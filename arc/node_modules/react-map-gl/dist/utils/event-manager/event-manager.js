'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _wheelInput = require('./wheel-input');

var _wheelInput2 = _interopRequireDefault(_wheelInput);

var _moveInput = require('./move-input');

var _moveInput2 = _interopRequireDefault(_moveInput);

var _isBrowser = require('../is-browser');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Hammer.js directly references `document` and `window`,
// which means that importing it in environments without
// those objects throws errors. Therefore, instead of
// directly `import`ing 'hammerjs' and './constants'
// (which imports Hammer.js) we conditionally require it
// depending on support for those globals, and provide mocks
// for environments without `document`/`window`.
function ManagerMock(m) {
  var instance = {};
  var chainedNoop = function chainedNoop() {
    return instance;
  };
  instance.on = chainedNoop;
  instance.off = chainedNoop;
  instance.destroy = chainedNoop;
  instance.emit = chainedNoop;
  instance.get = function () {
    return null;
  };
  instance.set = chainedNoop;
  return instance;
}

var Manager = _isBrowser.isBrowser ? require('hammerjs').Manager : ManagerMock;

var _ref = _isBrowser.isBrowser ? require('./constants') : {
  BASIC_EVENT_ALIASES: {},
  EVENT_RECOGNIZER_MAP: {},
  GESTURE_EVENT_ALIASES: {}
},
    BASIC_EVENT_ALIASES = _ref.BASIC_EVENT_ALIASES,
    EVENT_RECOGNIZER_MAP = _ref.EVENT_RECOGNIZER_MAP,
    RECOGNIZERS = _ref.RECOGNIZERS,
    GESTURE_EVENT_ALIASES = _ref.GESTURE_EVENT_ALIASES;

/**
 * Single API for subscribing to events about both
 * basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
 * and gestural input (e.g. 'click', 'tap', 'panstart').
 * Delegates event registration and handling to Hammer.js.
 * @param {DOM Element} element         DOM element on which event handlers will be registered.
 * @param {Object} options              Options for instantiation
 * @param {Object} options.events       Map of {event name: handler} to register on init.
 * @param {Object} options.recognizers  Gesture recognizers from Hammer.js to register,
 *                                      as an Array in Hammer.Recognizer format.
 *                                      (http://hammerjs.github.io/api/#hammermanager)
 */


var EventManager = function () {
  function EventManager(element) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, EventManager);

    this.element = element;
    this._onBasicInput = this._onBasicInput.bind(this);
    this.manager = new Manager(element, { recognizers: options.recognizers || RECOGNIZERS }).on('hammer.input', this._onBasicInput);

    this.eventHandlers = [];

    // Handle events not handled by Hammer.js:
    // - mouse wheel
    // - pointer/touch/mouse move
    this._onOtherEvent = this._onOtherEvent.bind(this);
    this.wheelInput = new _wheelInput2.default(element, this._onOtherEvent, { enable: false });
    this.moveInput = new _moveInput2.default(element, this._onOtherEvent, { enable: false });

    // Register all passed events.
    var events = options.events;

    if (events) {
      this.on(events);
    }
  }

  /**
   * Tear down internal event management implementations.
   */


  (0, _createClass3.default)(EventManager, [{
    key: 'destroy',
    value: function destroy() {
      this.wheelInput.destroy();
      this.moveInput.destroy();
      this.manager.destroy();
    }

    /**
     * Register an event handler function to be called on `event`.
     * @param {string|Object} event   An event name (String) or map of event names to handlers.
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: 'on',
    value: function on(event, handler) {
      if (typeof event === 'string') {
        this._addEventHandler(event, handler);
      } else {
        // If `event` is a map, call `on()` for each entry.
        for (var eventName in event) {
          this._addEventHandler(eventName, event[eventName]);
        }
      }
    }

    /**
     * Deregister a previously-registered event handler.
     * @param {string|Object} event   An event name (String) or map of event names to handlers
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: 'off',
    value: function off(event, handler) {
      if (typeof event === 'string') {
        this._removeEventHandler(event, handler);
      } else {
        // If `event` is a map, call `off()` for each entry.
        for (var eventName in event) {
          this._removeEventHandler(eventName, event[eventName]);
        }
      }
    }

    /*
     * Enable/disable recognizer for the given event
     */

  }, {
    key: '_toggleRecognizer',
    value: function _toggleRecognizer(name, enabled) {
      var recognizer = this.manager.get(name);
      if (recognizer) {
        recognizer.set({ enable: enabled });
      }
      this.wheelInput.toggleIfEventSupported(name, enabled);
      this.moveInput.toggleIfEventSupported(name, enabled);
    }

    /**
     * Process the event registration for a single event + handler.
     */

  }, {
    key: '_addEventHandler',
    value: function _addEventHandler(event, handler) {
      var wrappedHandler = this._wrapEventHandler(event, handler);
      // Alias to a recognized gesture as necessary.
      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;
      // Get recognizer for this event
      var recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
      // Enable recognizer for this event.
      this._toggleRecognizer(recognizerName, true);

      // Save wrapped handler
      this.eventHandlers.push({ event: event, eventAlias: eventAlias, recognizerName: recognizerName, handler: handler, wrappedHandler: wrappedHandler });

      this.manager.on(eventAlias, wrappedHandler);
    }

    /**
     * Process the event deregistration for a single event + handler.
     */

  }, {
    key: '_removeEventHandler',
    value: function _removeEventHandler(event, handler) {
      var success = false;

      // Find saved handler if any.
      for (var i = this.eventHandlers.length; i--;) {
        var entry = this.eventHandlers[i];
        if (entry.event === event && entry.handler === handler) {
          // Deregister event handler.
          this.manager.off(entry.eventAlias, entry.wrappedHandler);
          // Delete saved handler
          this.eventHandlers.splice(i, 1);
          success = true;
        }
      }

      if (success) {
        // Alias to a recognized gesture as necessary.
        var eventAlias = GESTURE_EVENT_ALIASES[event] || event;
        // Get recognizer for this event
        var recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
        // Disable recognizer if no more handlers are attached to its events
        var isRecognizerUsed = this.eventHandlers.find(function (entry) {
          return entry.recognizerName === recognizerName;
        });
        if (!isRecognizerUsed) {
          this._toggleRecognizer(recognizerName, false);
        }
      }
    }

    /**
     * Returns an event handler that aliases events and add props before passing
     * to the real handler.
     */

  }, {
    key: '_wrapEventHandler',
    value: function _wrapEventHandler(type, handler) {
      var _this = this;

      return function (event) {
        var element = _this.element;
        var srcEvent = event.srcEvent;


        var center = event.center || {
          x: srcEvent.clientX,
          y: srcEvent.clientY
        };

        var rect = element.getBoundingClientRect();
        // Fix scale for map affected by a CSS transform.
        // See https://stackoverflow.com/a/26893663/3528533
        var scaleX = rect.width / element.offsetWidth;
        var scaleY = rect.height / element.offsetHeight;
        // Calculate center relative to the root element
        var offsetCenter = {
          x: (center.x - rect.left - element.clientLeft) / scaleX,
          y: (center.y - rect.top - element.clientTop) / scaleY
        };

        handler((0, _assign2.default)({}, event, {
          type: type,
          center: center,
          offsetCenter: offsetCenter,
          rootElement: element
        }));
      };
    }

    /**
     * Handle basic events using the 'hammer.input' Hammer.js API:
     * Before running Recognizers, Hammer emits a 'hammer.input' event
     * with the basic event info. This function emits all basic events
     * aliased to the "class" of event received.
     * See constants.BASIC_EVENT_CLASSES basic event class definitions.
     */

  }, {
    key: '_onBasicInput',
    value: function _onBasicInput(event) {
      var srcEvent = event.srcEvent;

      var alias = BASIC_EVENT_ALIASES[srcEvent.type];
      if (alias) {
        // fire all events aliased to srcEvent.type
        var emitEvent = (0, _assign2.default)({}, event, { type: alias });
        this.manager.emit(alias, emitEvent);
      }
    }

    /**
     * Handle events not supported by Hammer.js,
     * and pipe back out through same (Hammer) channel used by other events.
     */

  }, {
    key: '_onOtherEvent',
    value: function _onOtherEvent(event) {
      this.manager.emit(event.type, event);
    }
  }]);
  return EventManager;
}();

exports.default = EventManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudC1tYW5hZ2VyL2V2ZW50LW1hbmFnZXIuanMiXSwibmFtZXMiOlsiTWFuYWdlck1vY2siLCJtIiwiaW5zdGFuY2UiLCJjaGFpbmVkTm9vcCIsIm9uIiwib2ZmIiwiZGVzdHJveSIsImVtaXQiLCJnZXQiLCJzZXQiLCJNYW5hZ2VyIiwicmVxdWlyZSIsIkJBU0lDX0VWRU5UX0FMSUFTRVMiLCJFVkVOVF9SRUNPR05JWkVSX01BUCIsIkdFU1RVUkVfRVZFTlRfQUxJQVNFUyIsIlJFQ09HTklaRVJTIiwiRXZlbnRNYW5hZ2VyIiwiZWxlbWVudCIsIm9wdGlvbnMiLCJfb25CYXNpY0lucHV0IiwiYmluZCIsIm1hbmFnZXIiLCJyZWNvZ25pemVycyIsImV2ZW50SGFuZGxlcnMiLCJfb25PdGhlckV2ZW50Iiwid2hlZWxJbnB1dCIsImVuYWJsZSIsIm1vdmVJbnB1dCIsImV2ZW50cyIsImV2ZW50IiwiaGFuZGxlciIsIl9hZGRFdmVudEhhbmRsZXIiLCJldmVudE5hbWUiLCJfcmVtb3ZlRXZlbnRIYW5kbGVyIiwibmFtZSIsImVuYWJsZWQiLCJyZWNvZ25pemVyIiwidG9nZ2xlSWZFdmVudFN1cHBvcnRlZCIsIndyYXBwZWRIYW5kbGVyIiwiX3dyYXBFdmVudEhhbmRsZXIiLCJldmVudEFsaWFzIiwicmVjb2duaXplck5hbWUiLCJfdG9nZ2xlUmVjb2duaXplciIsInB1c2giLCJzdWNjZXNzIiwiaSIsImxlbmd0aCIsImVudHJ5Iiwic3BsaWNlIiwiaXNSZWNvZ25pemVyVXNlZCIsImZpbmQiLCJ0eXBlIiwic3JjRXZlbnQiLCJjZW50ZXIiLCJ4IiwiY2xpZW50WCIsInkiLCJjbGllbnRZIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjYWxlWCIsIndpZHRoIiwib2Zmc2V0V2lkdGgiLCJzY2FsZVkiLCJoZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRDZW50ZXIiLCJsZWZ0IiwiY2xpZW50TGVmdCIs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QUE4QnRCLEtBQTlCO0FBQ0Q7Ozs7O2tCQXhMa0JiLFkiLCJmaWxlIjoiZXZlbnQtbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBXaGVlbElucHV0IGZyb20gJy4vd2hlZWwtaW5wdXQnO1xuaW1wb3J0IE1vdmVJbnB1dCBmcm9tICcuL21vdmUtaW5wdXQnO1xuaW1wb3J0IHtpc0Jyb3dzZXJ9IGZyb20gJy4uL2lzLWJyb3dzZXInO1xuXG4vLyBIYW1tZXIuanMgZGlyZWN0bHkgcmVmZXJlbmNlcyBgZG9jdW1lbnRgIGFuZCBgd2luZG93YCxcbi8vIHdoaWNoIG1lYW5zIHRoYXQgaW1wb3J0aW5nIGl0IGluIGVudmlyb25tZW50cyB3aXRob3V0XG4vLyB0aG9zZSBvYmplY3RzIHRocm93cyBlcnJvcnMuIFRoZXJlZm9yZSwgaW5zdGVhZCBvZlxuLy8gZGlyZWN0bHkgYGltcG9ydGBpbmcgJ2hhbW1lcmpzJyBhbmQgJy4vY29uc3RhbnRzJ1xuLy8gKHdoaWNoIGltcG9ydHMgSGFtbWVyLmpzKSB3ZSBjb25kaXRpb25hbGx5IHJlcXVpcmUgaXRcbi8vIGRlcGVuZGluZyBvbiBzdXBwb3J0IGZvciB0aG9zZSBnbG9iYWxzLCBhbmQgcHJvdmlkZSBtb2Nrc1xuLy8gZm9yIGVudmlyb25tZW50cyB3aXRob3V0IGBkb2N1bWVudGAvYHdpbmRvd2AuXG5mdW5jdGlvbiBNYW5hZ2VyTW9jayhtKSB7XG4gIGNvbnN0IGluc3RhbmNlID0ge307XG4gIGNvbnN0IGNoYWluZWROb29wID0gKCkgPT4gaW5zdGFuY2U7XG4gIGluc3RhbmNlLm9uID0gY2hhaW5lZE5vb3A7XG4gIGluc3RhbmNlLm9mZiA9IGNoYWluZWROb29wO1xuICBpbnN0YW5jZS5kZXN0cm95ID0gY2hhaW5lZE5vb3A7XG4gIGluc3RhbmNlLmVtaXQgPSBjaGFpbmVkTm9vcDtcbiAgaW5zdGFuY2UuZ2V0ID0gKCkgPT4gbnVsbDtcbiAgaW5zdGFuY2Uuc2V0ID0gY2hhaW5lZE5vb3A7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuY29uc3QgTWFuYWdlciA9IGlzQnJvd3NlciA/IHJlcXVpcmUoJ2hhbW1lcmpzJykuTWFuYWdlciA6IE1hbmFnZXJNb2NrO1xuY29uc3Qge1xuICBCQVNJQ19FVkVOVF9BTElBU0VTLFxuICBFVkVOVF9SRUNPR05JWkVSX01BUCxcbiAgUkVDT0dOSVpFUlMsXG4gIEdFU1RVUkVfRVZFTlRfQUxJQVNFU1xufSA9IGlzQnJvd3NlciA/IHJlcXVpcmUoJy4vY29uc3RhbnRzJykgOiB7XG4gIEJBU0lDX0VWRU5UX0FMSUFTRVM6IHt9LFxuICBFVkVOVF9SRUNPR05JWkVSX01BUDoge30sXG4gIEdFU1RVUkVfRVZFTlRfQUxJQVNFUzoge31cbn07XG5cbi8qKlxuICogU2luZ2xlIEFQSSBmb3Igc3Vic2NyaWJpbmcgdG8gZXZlbnRzIGFib3V0IGJvdGhcbiAqIGJhc2ljIGlucHV0IGV2ZW50cyAoZS5nLiAnbW91c2Vtb3ZlJywgJ3RvdWNoc3RhcnQnLCAnd2hlZWwnKVxuICogYW5kIGdlc3R1cmFsIGlucHV0IChlLmcuICdjbGljaycsICd0YXAnLCAncGFuc3RhcnQnKS5cbiAqIERlbGVnYXRlcyBldmVudCByZWdpc3RyYXRpb24gYW5kIGhhbmRsaW5nIHRvIEhhbW1lci5qcy5cbiAqIEBwYXJhbSB7RE9NIEVsZW1lbnR9IGVsZW1lbnQgICAgICAgICBET00gZWxlbWVudCBvbiB3aGljaCBldmVudCBoYW5kbGVycyB3aWxsIGJlIHJlZ2lzdGVyZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgT3B0aW9ucyBmb3IgaW5zdGFudGlhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZXZlbnRzICAgICAgIE1hcCBvZiB7ZXZlbnQgbmFtZTogaGFuZGxlcn0gdG8gcmVnaXN0ZXIgb24gaW5pdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnJlY29nbml6ZXJzICBHZXN0dXJlIHJlY29nbml6ZXJzIGZyb20gSGFtbWVyLmpzIHRvIHJlZ2lzdGVyLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIGFuIEFycmF5IGluIEhhbW1lci5SZWNvZ25pemVyIGZvcm1hdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9hcGkvI2hhbW1lcm1hbmFnZXIpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fb25CYXNpY0lucHV0ID0gdGhpcy5fb25CYXNpY0lucHV0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5tYW5hZ2VyID0gbmV3IE1hbmFnZXIoZWxlbWVudCwge3JlY29nbml6ZXJzOiBvcHRpb25zLnJlY29nbml6ZXJzIHx8IFJFQ09HTklaRVJTfSlcbiAgICAgIC5vbignaGFtbWVyLmlucHV0JywgdGhpcy5fb25CYXNpY0lucHV0KTtcblxuICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IFtdO1xuXG4gICAgLy8gSGFuZGxlIGV2ZW50cyBub3QgaGFuZGxlZCBieSBIYW1tZXIuanM6XG4gICAgLy8gLSBtb3VzZSB3aGVlbFxuICAgIC8vIC0gcG9pbnRlci90b3VjaC9tb3VzZSBtb3ZlXG4gICAgdGhpcy5fb25PdGhlckV2ZW50ID0gdGhpcy5fb25PdGhlckV2ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy53aGVlbElucHV0ID0gbmV3IFdoZWVsSW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7ZW5hYmxlOiBmYWxzZX0pO1xuICAgIHRoaXMubW92ZUlucHV0ID0gbmV3IE1vdmVJbnB1dChlbGVtZW50LCB0aGlzLl9vbk90aGVyRXZlbnQsIHtlbmFibGU6IGZhbHNlfSk7XG5cbiAgICAvLyBSZWdpc3RlciBhbGwgcGFzc2VkIGV2ZW50cy5cbiAgICBjb25zdCB7ZXZlbnRzfSA9IG9wdGlvbnM7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgdGhpcy5vbihldmVudHMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUZWFyIGRvd24gaW50ZXJuYWwgZXZlbnQgbWFuYWdlbWVudCBpbXBsZW1lbnRhdGlvbnMuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMud2hlZWxJbnB1dC5kZXN0cm95KCk7XG4gICAgdGhpcy5tb3ZlSW5wdXQuZGVzdHJveSgpO1xuICAgIHRoaXMubWFuYWdlci5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXZlbnQgaGFuZGxlciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYGV2ZW50YC5cbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBldmVudCAgIEFuIGV2ZW50IG5hbWUgKFN0cmluZykgb3IgbWFwIG9mIGV2ZW50IG5hbWVzIHRvIGhhbmRsZXJzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0gICAgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBgZXZlbnRgLlxuICAgKi9cbiAgb24oZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYGV2ZW50YCBpcyBhIG1hcCwgY2FsbCBgb24oKWAgZm9yIGVhY2ggZW50cnkuXG4gICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBpbiBldmVudCkge1xuICAgICAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoZXZlbnROYW1lLCBldmVudFtldmVudE5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHByZXZpb3VzbHktcmVnaXN0ZXJlZCBldmVudCBoYW5kbGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGV2ZW50ICAgQW4gZXZlbnQgbmFtZSAoU3RyaW5nKSBvciBtYXAgb2YgZXZlbnQgbmFtZXMgdG8gaGFuZGxlcnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdICAgIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYGV2ZW50YC5cbiAgICovXG4gIG9mZihldmVudCwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBgZXZlbnRgIGlzIGEgbWFwLCBjYWxsIGBvZmYoKWAgZm9yIGVhY2ggZW50cnkuXG4gICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBpbiBldmVudCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnROYW1lLCBldmVudFtldmVudE5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiBFbmFibGUvZGlzYWJsZSByZWNvZ25pemVyIGZvciB0aGUgZ2l2ZW4gZXZlbnRcbiAgICovXG4gIF90b2dnbGVSZWNvZ25pemVyKG5hbWUsIGVuYWJsZWQpIHtcbiAgICBjb25zdCByZWNvZ25pemVyID0gdGhpcy5tYW5hZ2VyLmdldChuYW1lKTtcbiAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgcmVjb2duaXplci5zZXQoe2VuYWJsZTogZW5hYmxlZH0pO1xuICAgIH1cbiAgICB0aGlzLndoZWVsSW5wdXQudG9nZ2xlSWZFdmVudFN1cHBvcnRlZChuYW1lLCBlbmFibGVkKTtcbiAgICB0aGlzLm1vdmVJbnB1dC50b2dnbGVJZkV2ZW50U3VwcG9ydGVkKG5hbWUsIGVuYWJsZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIGV2ZW50IHJlZ2lzdHJhdGlvbiBmb3IgYSBzaW5nbGUgZXZlbnQgKyBoYW5kbGVyLlxuICAgKi9cbiAgX2FkZEV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcikge1xuICAgIGNvbnN0IHdyYXBwZWRIYW5kbGVyID0gdGhpcy5fd3JhcEV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcik7XG4gICAgLy8gQWxpYXMgdG8gYSByZWNvZ25pemVkIGdlc3R1cmUgYXMgbmVjZXNzYXJ5LlxuICAgIGNvbnN0IGV2ZW50QWxpYXMgPSBHRVNUVVJFX0VWRU5UX0FMSUFTRVNbZXZlbnRdIHx8IGV2ZW50O1xuICAgIC8vIEdldCByZWNvZ25pemVyIGZvciB0aGlzIGV2ZW50XG4gICAgY29uc3QgcmVjb2duaXplck5hbWUgPSBFVkVOVF9SRUNPR05JWkVSX01BUFtldmVudEFsaWFzXSB8fCBldmVudEFsaWFzO1xuICAgIC8vIEVuYWJsZSByZWNvZ25pemVyIGZvciB0aGlzIGV2ZW50LlxuICAgIHRoaXMuX3RvZ2dsZVJlY29nbml6ZXIocmVjb2duaXplck5hbWUsIHRydWUpO1xuXG4gICAgLy8gU2F2ZSB3cmFwcGVkIGhhbmRsZXJcbiAgICB0aGlzLmV2ZW50SGFuZGxlcnMucHVzaCh7ZXZlbnQsIGV2ZW50QWxpYXMsIHJlY29nbml6ZXJOYW1lLCBoYW5kbGVyLCB3cmFwcGVkSGFuZGxlcn0pO1xuXG4gICAgdGhpcy5tYW5hZ2VyLm9uKGV2ZW50QWxpYXMsIHdyYXBwZWRIYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBldmVudCBkZXJlZ2lzdHJhdGlvbiBmb3IgYSBzaW5nbGUgZXZlbnQgKyBoYW5kbGVyLlxuICAgKi9cbiAgX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcikge1xuICAgIGxldCBzdWNjZXNzID0gZmFsc2U7XG5cbiAgICAvLyBGaW5kIHNhdmVkIGhhbmRsZXIgaWYgYW55LlxuICAgIGZvciAobGV0IGkgPSB0aGlzLmV2ZW50SGFuZGxlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZXZlbnRIYW5kbGVyc1tpXTtcbiAgICAgIGlmIChlbnRyeS5ldmVudCA9PT0gZXZlbnQgJiYgZW50cnkuaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgICAvLyBEZXJlZ2lzdGVyIGV2ZW50IGhhbmRsZXIuXG4gICAgICAgIHRoaXMubWFuYWdlci5vZmYoZW50cnkuZXZlbnRBbGlhcywgZW50cnkud3JhcHBlZEhhbmRsZXIpO1xuICAgICAgICAvLyBEZWxldGUgc2F2ZWQgaGFuZGxlclxuICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgLy8gQWxpYXMgdG8gYSByZWNvZ25pemVkIGdlc3R1cmUgYXMgbmVjZXNzYXJ5LlxuICAgICAgY29uc3QgZXZlbnRBbGlhcyA9IEdFU1RVUkVfRVZFTlRfQUxJQVNFU1tldmVudF0gfHwgZXZlbnQ7XG4gICAgICAvLyBHZXQgcmVjb2duaXplciBmb3IgdGhpcyBldmVudFxuICAgICAgY29uc3QgcmVjb2duaXplck5hbWUgPSBFVkVOVF9SRUNPR05JWkVSX01BUFtldmVudEFsaWFzXSB8fCBldmVudEFsaWFzO1xuICAgICAgLy8gRGlzYWJsZSByZWNvZ25pemVyIGlmIG5vIG1vcmUgaGFuZGxlcnMgYXJlIGF0dGFjaGVkIHRvIGl0cyBldmVudHNcbiAgICAgIGNvbnN0IGlzUmVjb2duaXplclVzZWQgPSB0aGlzLmV2ZW50SGFuZGxlcnMuZmluZChcbiAgICAgICAgZW50cnkgPT4gZW50cnkucmVjb2duaXplck5hbWUgPT09IHJlY29nbml6ZXJOYW1lXG4gICAgICApO1xuICAgICAgaWYgKCFpc1JlY29nbml6ZXJVc2VkKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVJlY29nbml6ZXIocmVjb2duaXplck5hbWUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBldmVudCBoYW5kbGVyIHRoYXQgYWxpYXNlcyBldmVudHMgYW5kIGFkZCBwcm9wcyBiZWZvcmUgcGFzc2luZ1xuICAgKiB0byB0aGUgcmVhbCBoYW5kbGVyLlxuICAgKi9cbiAgX3dyYXBFdmVudEhhbmRsZXIodHlwZSwgaGFuZGxlcikge1xuICAgIHJldHVybiBldmVudCA9PiB7XG4gICAgICBjb25zdCB7ZWxlbWVudH0gPSB0aGlzO1xuICAgICAgY29uc3Qge3NyY0V2ZW50fSA9IGV2ZW50O1xuXG4gICAgICBjb25zdCBjZW50ZXIgPSBldmVudC5jZW50ZXIgfHwge1xuICAgICAgICB4OiBzcmNFdmVudC5jbGllbnRYLFxuICAgICAgICB5OiBzcmNFdmVudC5jbGllbnRZXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIC8vIEZpeCBzY2FsZSBmb3IgbWFwIGFmZmVjdGVkIGJ5IGEgQ1NTIHRyYW5zZm9ybS5cbiAgICAgIC8vIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY4OTM2NjMvMzUyODUzM1xuICAgICAgY29uc3Qgc2NhbGVYID0gcmVjdC53aWR0aCAvIGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICBjb25zdCBzY2FsZVkgPSByZWN0LmhlaWdodCAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgLy8gQ2FsY3VsYXRlIGNlbnRlciByZWxhdGl2ZSB0byB0aGUgcm9vdCBlbGVtZW50XG4gICAgICBjb25zdCBvZmZzZXRDZW50ZXIgPSB7XG4gICAgICAgIHg6IChjZW50ZXIueCAtIHJlY3QubGVmdCAtIGVsZW1lbnQuY2xpZW50TGVmdCkgLyBzY2FsZVgsXG4gICAgICAgIHk6IChjZW50ZXIueSAtIHJlY3QudG9wIC0gZWxlbWVudC5jbGllbnRUb3ApIC8gc2NhbGVZXG4gICAgICB9O1xuXG4gICAgICBoYW5kbGVyKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50LCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNlbnRlcixcbiAgICAgICAgb2Zmc2V0Q2VudGVyLFxuICAgICAgICByb290RWxlbWVudDogZWxlbWVudFxuICAgICAgfSkpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGJhc2ljIGV2ZW50cyB1c2luZyB0aGUgJ2hhbW1lci5pbnB1dCcgSGFtbWVyLmpzIEFQSTpcbiAgICogQmVmb3JlIHJ1bm5pbmcgUmVjb2duaXplcnMsIEhhbW1lciBlbWl0cyBhICdoYW1tZXIuaW5wdXQnIGV2ZW50XG4gICAqIHdpdGggdGhlIGJhc2ljIGV2ZW50IGluZm8uIFRoaXMgZnVuY3Rpb24gZW1pdHMgYWxsIGJhc2ljIGV2ZW50c1xuICAgKiBhbGlhc2VkIHRvIHRoZSBcImNsYXNzXCIgb2YgZXZlbnQgcmVjZWl2ZWQuXG4gICAqIFNlZSBjb25zdGFudHMuQkFTSUNfRVZFTlRfQ0xBU1NFUyBiYXNpYyBldmVudCBjbGFzcyBkZWZpbml0aW9ucy5cbiAgICovXG4gIF9vbkJhc2ljSW5wdXQoZXZlbnQpIHtcbiAgICBjb25zdCB7c3JjRXZlbnR9ID0gZXZlbnQ7XG4gICAgY29uc3QgYWxpYXMgPSBCQVNJQ19FVkVOVF9BTElBU0VTW3NyY0V2ZW50LnR5cGVdO1xuICAgIGlmIChhbGlhcykge1xuICAgICAgLy8gZmlyZSBhbGwgZXZlbnRzIGFsaWFzZWQgdG8gc3JjRXZlbnQudHlwZVxuICAgICAgY29uc3QgZW1pdEV2ZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQsIHt0eXBlOiBhbGlhc30pO1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQoYWxpYXMsIGVtaXRFdmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBldmVudHMgbm90IHN1cHBvcnRlZCBieSBIYW1tZXIuanMsXG4gICAqIGFuZCBwaXBlIGJhY2sgb3V0IHRocm91Z2ggc2FtZSAoSGFtbWVyKSBjaGFubmVsIHVzZWQgYnkgb3RoZXIgZXZlbnRzLlxuICAgKi9cbiAgX29uT3RoZXJFdmVudChldmVudCkge1xuICAgIHRoaXMubWFuYWdlci5lbWl0KGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgfVxuXG59XG4iXX0=