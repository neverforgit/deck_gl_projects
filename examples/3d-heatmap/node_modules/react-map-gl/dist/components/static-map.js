'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _autobind = require('../utils/autobind');

var _autobind2 = _interopRequireDefault(_autobind);

var _accessToken = require('../utils/access-token');

var _styleUtils = require('../utils/style-utils');

var _diffStyles2 = require('../utils/diff-styles');

var _diffStyles3 = _interopRequireDefault(_diffStyles2);

var _immutable = require('immutable');

var _immutable2 = _interopRequireDefault(_immutable);

var _isBrowser = require('../utils/is-browser');

var _isBrowser2 = _interopRequireDefault(_isBrowser);

var _viewportMercatorProject = require('viewport-mercator-project');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mapboxgl = null; // Copyright (c) 2015 Uber Technologies, Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

if (_isBrowser2.default) {
  mapboxgl = require('mapbox-gl');
}

function noop() {}

var propTypes = {
  /** Mapbox API access token for mapbox-gl-js. Required when using Mapbox vector tiles/styles. */
  mapboxApiAccessToken: _propTypes2.default.string,
  /** Mapbox WebGL context creation option. Useful when you want to export the canvas as a PNG. */
  preserveDrawingBuffer: _propTypes2.default.bool,
  /** Show attribution control or not. */
  attributionControl: _propTypes2.default.bool,

  /** The Mapbox style. A string url or a MapboxGL style Immutable.Map object. */
  mapStyle: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.instanceOf(_immutable2.default.Map)]),
  /** There are known issues with style diffing. As stopgap, add option to prevent style diffing. */
  preventStyleDiffing: _propTypes2.default.bool,
  /** Whether the map is visible */
  visible: _propTypes2.default.bool,

  /** The width of the map. */
  width: _propTypes2.default.number.isRequired,
  /** The height of the map. */
  height: _propTypes2.default.number.isRequired,
  /** The longitude of the center of the map. */
  longitude: _propTypes2.default.number.isRequired,
  /** The latitude of the center of the map. */
  latitude: _propTypes2.default.number.isRequired,
  /** The tile zoom level of the map. */
  zoom: _propTypes2.default.number.isRequired,
  /** Specify the bearing of the viewport */
  bearing: _propTypes2.default.number,
  /** Specify the pitch of the viewport */
  pitch: _propTypes2.default.number,
  /** Altitude of the viewport camera. Default 1.5 "screen heights" */
  // Note: Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
  altitude: _propTypes2.default.number,
  /** The onLoad callback for the map */
  onLoad: _propTypes2.default.func
};

var defaultProps = {
  mapStyle: 'mapbox://styles/mapbox/light-v8',
  mapboxApiAccessToken: (0, _accessToken.getAccessToken)(),
  preserveDrawingBuffer: false,
  attributionControl: true,
  preventStyleDiffing: false,
  visible: true,
  bearing: 0,
  pitch: 0,
  altitude: 1.5,
  onLoad: noop
};

var childContextTypes = {
  viewport: _propTypes2.default.instanceOf(_viewportMercatorProject.PerspectiveMercatorViewport)
};

var StaticMap = function (_PureComponent) {
  (0, _inherits3.default)(StaticMap, _PureComponent);
  (0, _createClass3.default)(StaticMap, null, [{
    key: 'supported',
    value: function supported() {
      return mapboxgl && mapboxgl.supported();
    }
  }]);

  function StaticMap(props) {
    (0, _classCallCheck3.default)(this, StaticMap);

    var _this = (0, _possibleConstructorReturn3.default)(this, (StaticMap.__proto__ || (0, _getPrototypeOf2.default)(StaticMap)).call(this, props));

    _this._queryParams = {};
    if (mapboxgl) {
      mapboxgl.accessToken = props.mapboxApiAccessToken;
    }

    if (!StaticMap.supported()) {
      _this.componentDidMount = noop;
      _this.componentWillReceiveProps = noop;
      _this.componentDidUpdate = noop;
    }
    (0, _autobind2.default)(_this);
    return _this;
  }

  (0, _createClass3.default)(StaticMap, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        viewport: new _viewportMercatorProject.PerspectiveMercatorViewport(this.props)
      };
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (!mapboxgl) {
        return;
      }

      var mapStyle = _immutable2.default.Map.isMap(this.props.mapStyle) ? this.props.mapStyle.toJS() : this.props.mapStyle;
      var map = new mapboxgl.Map({
        container: this._mapboxMap,
        center: [this.props.longitude, this.props.latitude],
        zoom: this.props.zoom,
        pitch: this.props.pitch,
        bearing: this.props.bearing,
        style: mapStyle,
        interactive: false,
        attributionControl: this.props.attributionControl,
        preserveDrawingBuffer: this.props.preserveDrawingBuffer
      });

      // Disable outline style
      var canvas = map.getCanvas();
      if (canvas) {
        canvas.style.outline = 'none';
      }

      // Attach optional onLoad function
      map.once('load', this.props.onLoad);

      this._map = map;
      this._updateMapViewport({}, this.props);
      // this._callOnChangeViewport(map.transform);
      this._updateQueryParams(mapStyle);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(newProps) {
      if (!mapboxgl) {
        return;
      }

      this._updateStateFromProps(this.props, newProps);
      this._updateMapViewport(this.props, newProps);
      this._updateMapStyle(this.props, newProps);
      // Save width/height so that we can check them in componentDidUpdate
      this.setState({
        width: this.props.width,
        height: this.props.height
      });
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (!mapboxgl) {
        return;
      }

      // Since Mapbox's map.resize() reads size from DOM
      // we must wait to read size until after render (i.e. here in "didUpdate")
      this._updateMapSize(this.state, this.props);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (!mapboxgl) {
        return;
      }

      if (this._map) {
        this._map.remove();
      }
    }

    // External apps can access map this way

  }, {
    key: 'getMap',
    value: function getMap() {
      return this._map;
    }

    /** Uses Mapbox's
      * queryRenderedFeatures API to find features at point or in a bounding box.
      * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures
      * To query only some of the layers, set the `interactive` property in the
      * layer style to `true`.
      * @param {[Number, Number]|[[Number, Number], [Number, Number]]} geometry -
      *   Point or an array of two points defining the bounding box
      * @param {Object} parameters - query options
      */

  }, {
    key: 'queryRenderedFeatures',
    value: function queryRenderedFeatures(geometry, parameters) {
      var queryParams = parameters || this._queryParams;
      if (queryParams.layers && queryParams.layers.length === 0) {
        return [];
      }
      return this._map.queryRenderedFeatures(geometry, queryParams);
    }
  }, {
    key: '_updateStateFromProps',
    value: function _updateStateFromProps(oldProps, newProps) {
      if (mapboxgl) {
        mapboxgl.accessToken = newProps.mapboxApiAccessToken;
      }
    }

    // Hover and click only query layers whose interactive property is true

  }, {
    key: '_updateQueryParams',
    value: function _updateQueryParams(mapStyle) {
      var interactiveLayerIds = (0, _styleUtils.getInteractiveLayerIds)(mapStyle);
      this._queryParams = { layers: interactiveLayerIds };
    }

    // Update a source in the map style

  }, {
    key: '_updateSource',
    value: function _updateSource(map, update) {
      var newSource = update.source.toJS();
      if (newSource.type === 'geojson') {
        var oldSource = map.getSource(update.id);
        if (oldSource.type === 'geojson') {
          // update data if no other GeoJSONSource options were changed
          var oldOpts = oldSource.workerOptions;
          if ((newSource.maxzoom === undefined || newSource.maxzoom === oldOpts.geojsonVtOptions.maxZoom) && (newSource.buffer === undefined || newSource.buffer === oldOpts.geojsonVtOptions.buffer) && (newSource.tolerance === undefined || newSource.tolerance === oldOpts.geojsonVtOptions.tolerance) && (newSource.cluster === undefined || newSource.cluster === oldOpts.cluster) && (newSource.clusterRadius === undefined || newSource.clusterRadius === oldOpts.superclusterOptions.radius) && (newSource.clusterMaxZoom === undefined || newSource.clusterMaxZoom === oldOpts.superclusterOptions.maxZoom)) {
            oldSource.setData(newSource.data);
            return;
          }
        }
      }

      map.removeSource(update.id);
      map.addSource(update.id, newSource);
    }

    // Individually update the maps source and layers that have changed if all
    // other style props haven't changed. This prevents flicking of the map when
    // styles only change sources or layers.
    /* eslint-disable max-statements, complexity */

  }, {
    key: '_setDiffStyle',
    value: function _setDiffStyle(prevStyle, nextStyle) {
      var prevKeysMap = prevStyle && styleKeysMap(prevStyle) || {};
      var nextKeysMap = styleKeysMap(nextStyle);
      function styleKeysMap(style) {
        return style.map(function () {
          return true;
        }).delete('layers').delete('sources').toJS();
      }
      function propsOtherThanLayersOrSourcesDiffer() {
        var prevKeysList = (0, _keys2.default)(prevKeysMap);
        var nextKeysList = (0, _keys2.default)(nextKeysMap);
        if (prevKeysList.length !== nextKeysList.length) {
          return true;
        }
        // `nextStyle` and `prevStyle` should not have the same set of props.
        if (nextKeysList.some(function (key) {
          return prevStyle.get(key) !== nextStyle.get(key);
        }
        // But the value of one of those props is different.
        )) {
          return true;
        }
        return false;
      }

      var map = this._map;

      if (!prevStyle || propsOtherThanLayersOrSourcesDiffer()) {
        map.setStyle(nextStyle.toJS());
        return;
      }

      var _diffStyles = (0, _diffStyles3.default)(prevStyle, nextStyle),
          sourcesDiff = _diffStyles.sourcesDiff,
          layersDiff = _diffStyles.layersDiff;

      // TODO: It's rather difficult to determine style diffing in the presence
      // of refs. For now, if any style update has a ref, fallback to no diffing.
      // We can come back to this case if there's a solid usecase.


      if (layersDiff.updates.some(function (node) {
        return node.layer.get('ref');
      })) {
        map.setStyle(nextStyle.toJS());
        return;
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(sourcesDiff.enter), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var enter = _step.value;

          map.addSource(enter.id, enter.source.toJS());
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(sourcesDiff.update), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var update = _step2.value;

          this._updateSource(map, update);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator3.default)(sourcesDiff.exit), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var exit = _step3.value;

          map.removeSource(exit.id);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (0, _getIterator3.default)(layersDiff.exiting), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _exit = _step4.value;

          if (map.style.getLayer(_exit.id)) {
            map.removeLayer(_exit.id);
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = (0, _getIterator3.default)(layersDiff.updates), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _update = _step5.value;

          if (!_update.enter) {
            // This is an old layer that needs to be updated. Remove the old layer
            // with the same id and add it back again.
            map.removeLayer(_update.id);
          }
          map.addLayer(_update.layer.toJS(), _update.before);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
    /* eslint-enable max-statements, complexity */

  }, {
    key: '_updateMapStyle',
    value: function _updateMapStyle(oldProps, newProps) {
      var mapStyle = newProps.mapStyle;
      var oldMapStyle = oldProps.mapStyle;
      if (mapStyle !== oldMapStyle) {
        if (_immutable2.default.Map.isMap(mapStyle)) {
          if (this.props.preventStyleDiffing) {
            this._map.setStyle(mapStyle.toJS());
          } else {
            this._setDiffStyle(oldMapStyle, mapStyle);
          }
        } else {
          this._map.setStyle(mapStyle);
        }
        this._updateQueryParams(mapStyle);
      }
    }
  }, {
    key: '_updateMapViewport',
    value: function _updateMapViewport(oldProps, newProps) {
      var viewportChanged = newProps.latitude !== oldProps.latitude || newProps.longitude !== oldProps.longitude || newProps.zoom !== oldProps.zoom || newProps.pitch !== oldProps.pitch || newProps.bearing !== oldProps.bearing || newProps.altitude !== oldProps.altitude;

      if (viewportChanged) {
        this._map.jumpTo({
          center: [newProps.longitude, newProps.latitude],
          zoom: newProps.zoom,
          bearing: newProps.bearing,
          pitch: newProps.pitch
        });

        // TODO - jumpTo doesn't handle altitude
        if (newProps.altitude !== oldProps.altitude) {
          this._map.transform.altitude = newProps.altitude;
        }
      }
    }

    // Note: needs to be called after render (e.g. in componentDidUpdate)

  }, {
    key: '_updateMapSize',
    value: function _updateMapSize(oldProps, newProps) {
      var sizeChanged = oldProps.width !== newProps.width || oldProps.height !== newProps.height;

      if (sizeChanged) {
        this._map.resize();
        // this._callOnChangeViewport(this._map.transform);
      }
    }
  }, {
    key: '_mapboxMapLoaded',
    value: function _mapboxMapLoaded(ref) {
      this._mapboxMap = ref;
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          className = _props.className,
          width = _props.width,
          height = _props.height,
          style = _props.style,
          visible = _props.visible;

      var mapContainerStyle = (0, _assign2.default)({}, style, { width: width, height: height, position: 'relative' });
      var mapStyle = (0, _assign2.default)({}, style, {
        width: width,
        height: height,
        visibility: visible ? 'visible' : 'hidden'
      });
      var overlayContainerStyle = {
        position: 'absolute',
        left: 0,
        top: 0,
        width: width,
        height: height,
        overflow: 'hidden'
      };

      // Note: a static map still handles clicks and hover events
      return (0, _react.createElement)('div', {
        key: 'map-container',
        style: mapContainerStyle,
        children: [(0, _react.createElement)('div', {
          key: 'map-mapbox',
          ref: this._mapboxMapLoaded,
          style: mapStyle,
          className: className
        }), (0, _react.createElement)('div', {
          key: 'map-overlays',
          // Same as interactive map's overlay container
          className: 'overlays',
          style: overlayContainerStyle,
          children: this.props.children
        })]
      });
    }
  }]);
  return StaticMap;
}(_react.PureComponent);

exports.default = StaticMap;


StaticMap.displayName = 'StaticMap';
StaticMap.propTypes = propTypes;
StaticMap.defaultProps = defaultProps;
StaticMap.childContextTypes = childContextTypes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL3N0YXRpYy1tYXAuanMiXSwibmFtZXMiOlsibWFwYm94Z2wiLCJyZXF1aXJlIiwibm9vcCIsInByb3BUeXBlcyIsIm1hcGJveEFwaUFjY2Vzc1Rva2VuIiwic3RyaW5nIiwicHJlc2VydmVEcmF3aW5nQnVmZmVyIiwiYm9vbCIsImF0dHJpYnV0aW9uQ29udHJvbCIsIm1hcFN0eWxlIiwib25lT2ZUeXBlIiwiaW5zdGFuY2VPZiIsIk1hcCIsInByZXZlbnRTdHlsZURpZmZpbmciLCJ2aXNpYmxlIiwid2lkdGgiLCJudW1iZXIiLCJpc1JlcXVpcmVkIiwiaGVpZ2h0IiwibG9uZ2l0dWRlIiwibGF0aXR1ZGUiLCJ6b29tIiwiYmVhcmluZyIsInBpdGNoIiwiYWx0aXR1ZGUiLCJvbkxvYWQiLCJmdW5jIiwiZGVmYXVsdFByb3BzIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJ2aWV3cG9ydCIsIlN0YXRpY01hcCIsInN1cHBvcnRlZCIsInByb3BzIiwiX3F1ZXJ5UGFyYW1zIiwiYWNjZXNzVG9rZW4iLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJjb21wb25lbnREaWRVcGRhdGUiLCJpc01hcCIsInRvSlMiLCJtYXAiLCJjb250YWluZXIiLCJfbWFwYm94TWFwIiwiY2VudGVyIiwic3R5bGUiLCJpbnRlcmFjdGl2ZSIsImNhbnZhcyIsImdldENhbnZhcyIsIm91dGxpbmUiLCJvbmNlIiwiX21hcCIsIl91cGRhdGVNYXBWaWV3cG9ydCIsIl91cGRhdGVRdWVyeVBhcmFtcyIsIm5ld1Byb3BzIiwiX3VwZGF0ZVN0YXRlRnJvbVByb3BzIiwiX3VwZGF0ZU1hcFN0eWxlIiwic2V0U3RhdGUiLCJfdXBkYXRlTWFwU2l6ZSIsInN0YXRlIiwicmVtb3ZlIiwiZ2VvbWV0cnkiLCJwYXJhbWV0ZXJzIiwicXVlcnlQYXJhbXMiLCJsYXllcnMiLCJsZW5ndGgiLCJxdWVyeVJlbmRlcmVkRmVhdHVyZXMiLCJvbGRQcm9wcyIsImludGVyYWN0aXZlTGF5ZXJJZHMiLCJ1cGRhdGUiLCJuZXdTb3VyY2UiLCJzb3VyY2UiLCJ0eXBlIiwib2xkU291cmNlIiwiZ2V0U291cmNlIiwiaWQiLCJvbGRPcHRzIiwid29ya2VyT3B0aW9ucyIsIm1heHpvb20iLCJ1bmRlZmluZWQiLCJnZW9qc29uVnRPcHRpb25zIiwibWF4Wm9vbSIsImJ1ZmZlciIsInRvbGVyYW5jZSIsImNsdXN0ZXIiLCJjbHVzdGVyUmFkaXVzIiwic3VwZXJjbHVzdGVyT3B0aW9ucyIsInJhZGl1cyIsImNsdXN0ZXJNYXhab29tIiwic2V0RGF0YSIsImRhdGEiLCJyZW1vdmVTb3VyY2UiLCJhZGRTb3VyY2UiLCJwcmV2U3R5bGUiLCJuZXh0U3R5bGUiLCJwcmV2S2V5c01hcCIsInN0eWxlS2V5c01hcCIsIm5leHRLZXlzTWFwIiwiZGVsZXRlIiwicHJvcHNPdGhlclRoYW5MYXllcnNPclNvdXJjZXNEaWZmZXIiLCJwcmV2S2V5c0xpc3QiLCJuZXh0S2V5c0xpc3QiLCJzb21lIiwiZ2V0Iiwia2V5Iiwic2V0U3R5bGUiLCJzb3VyY2VzRGlmZiIsImxheWVyc0RpZmYiLCJ1cGRhdGVzIiwibm9kZSIsImxheWVyIiwiZW50ZXIiLCJfdXBkYXRlU291cmNlIiwiZXhpdCIsImV4aXRpbmciLCJnZXRMYXllciIsInJlbW92ZUxheWVyIiwiYWRkTGF5ZXIiLCJiZWZvcmUiLCJvbGRNYXBTdHlsZSIsIl9zZXREaWZmU3R5bGUiLCJ2aWV3cG9ydENoYW5nZWQiLCJqdW1wVG8iLCJ0cmFuc2Zvcm0iLCJzaXplQ2hhbmdlZCIsInJlc2l6ZSIsInJlZiIsImNsYXNzTmFtZSIsIm1hcENvbnRhaW5lclN0eWxlIiwicG9zaXRpb24iLCJ2aXNpYmlsaXR5Iiwib3ZlcmxheUNvbnRhaW5lclN0eWxlIiwibGVmdCIsInRvcCIsIm92ZXJmbG93IiwiY2hpbGRyZW4iLCJfbWFwYm94TWFwTG9hZGVkIiwiZGlzcGxheU5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7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RixpQkFBVixHQUE4QkEsaUJBQTlCIiwiZmlsZSI6InN0YXRpYy1tYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuaW1wb3J0IHtQdXJlQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGF1dG9iaW5kIGZyb20gJy4uL3V0aWxzL2F1dG9iaW5kJztcblxuaW1wb3J0IHtnZXRBY2Nlc3NUb2tlbn0gZnJvbSAnLi4vdXRpbHMvYWNjZXNzLXRva2VuJztcbmltcG9ydCB7Z2V0SW50ZXJhY3RpdmVMYXllcklkc30gZnJvbSAnLi4vdXRpbHMvc3R5bGUtdXRpbHMnO1xuaW1wb3J0IGRpZmZTdHlsZXMgZnJvbSAnLi4vdXRpbHMvZGlmZi1zdHlsZXMnO1xuXG5pbXBvcnQgSW1tdXRhYmxlIGZyb20gJ2ltbXV0YWJsZSc7XG5cbmltcG9ydCBpc0Jyb3dzZXIgZnJvbSAnLi4vdXRpbHMvaXMtYnJvd3Nlcic7XG5pbXBvcnQge1BlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydH0gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5cbmxldCBtYXBib3hnbCA9IG51bGw7XG5pZiAoaXNCcm93c2VyKSB7XG4gIG1hcGJveGdsID0gcmVxdWlyZSgnbWFwYm94LWdsJyk7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5jb25zdCBwcm9wVHlwZXMgPSB7XG4gIC8qKiBNYXBib3ggQVBJIGFjY2VzcyB0b2tlbiBmb3IgbWFwYm94LWdsLWpzLiBSZXF1aXJlZCB3aGVuIHVzaW5nIE1hcGJveCB2ZWN0b3IgdGlsZXMvc3R5bGVzLiAqL1xuICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqIE1hcGJveCBXZWJHTCBjb250ZXh0IGNyZWF0aW9uIG9wdGlvbi4gVXNlZnVsIHdoZW4geW91IHdhbnQgdG8gZXhwb3J0IHRoZSBjYW52YXMgYXMgYSBQTkcuICovXG4gIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKiBTaG93IGF0dHJpYnV0aW9uIGNvbnRyb2wgb3Igbm90LiAqL1xuICBhdHRyaWJ1dGlvbkNvbnRyb2w6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKiBUaGUgTWFwYm94IHN0eWxlLiBBIHN0cmluZyB1cmwgb3IgYSBNYXBib3hHTCBzdHlsZSBJbW11dGFibGUuTWFwIG9iamVjdC4gKi9cbiAgbWFwU3R5bGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgIFByb3BUeXBlcy5zdHJpbmcsXG4gICAgUHJvcFR5cGVzLmluc3RhbmNlT2YoSW1tdXRhYmxlLk1hcClcbiAgXSksXG4gIC8qKiBUaGVyZSBhcmUga25vd24gaXNzdWVzIHdpdGggc3R5bGUgZGlmZmluZy4gQXMgc3RvcGdhcCwgYWRkIG9wdGlvbiB0byBwcmV2ZW50IHN0eWxlIGRpZmZpbmcuICovXG4gIHByZXZlbnRTdHlsZURpZmZpbmc6IFByb3BUeXBlcy5ib29sLFxuICAvKiogV2hldGhlciB0aGUgbWFwIGlzIHZpc2libGUgKi9cbiAgdmlzaWJsZTogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgbWFwLiAqL1xuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgbWFwLiAqL1xuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFRoZSBsb25naXR1ZGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwLiAqL1xuICBsb25naXR1ZGU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFRoZSBsYXRpdHVkZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBtYXAuICovXG4gIGxhdGl0dWRlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBUaGUgdGlsZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuICovXG4gIHpvb206IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFNwZWNpZnkgdGhlIGJlYXJpbmcgb2YgdGhlIHZpZXdwb3J0ICovXG4gIGJlYXJpbmc6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8qKiBTcGVjaWZ5IHRoZSBwaXRjaCBvZiB0aGUgdmlld3BvcnQgKi9cbiAgcGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8qKiBBbHRpdHVkZSBvZiB0aGUgdmlld3BvcnQgY2FtZXJhLiBEZWZhdWx0IDEuNSBcInNjcmVlbiBoZWlnaHRzXCIgKi9cbiAgLy8gTm90ZTogTm9uLXB1YmxpYyBBUEksIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qcy9pc3N1ZXMvMTEzN1xuICBhbHRpdHVkZTogUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqIFRoZSBvbkxvYWQgY2FsbGJhY2sgZm9yIHRoZSBtYXAgKi9cbiAgb25Mb2FkOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBtYXBTdHlsZTogJ21hcGJveDovL3N0eWxlcy9tYXBib3gvbGlnaHQtdjgnLFxuICBtYXBib3hBcGlBY2Nlc3NUb2tlbjogZ2V0QWNjZXNzVG9rZW4oKSxcbiAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgYXR0cmlidXRpb25Db250cm9sOiB0cnVlLFxuICBwcmV2ZW50U3R5bGVEaWZmaW5nOiBmYWxzZSxcbiAgdmlzaWJsZTogdHJ1ZSxcbiAgYmVhcmluZzogMCxcbiAgcGl0Y2g6IDAsXG4gIGFsdGl0dWRlOiAxLjUsXG4gIG9uTG9hZDogbm9vcFxufTtcblxuY29uc3QgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHZpZXdwb3J0OiBQcm9wVHlwZXMuaW5zdGFuY2VPZihQZXJzcGVjdGl2ZU1lcmNhdG9yVmlld3BvcnQpXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0aWNNYXAgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIHN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gbWFwYm94Z2wgJiYgbWFwYm94Z2wuc3VwcG9ydGVkKCk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuX3F1ZXJ5UGFyYW1zID0ge307XG4gICAgaWYgKG1hcGJveGdsKSB7XG4gICAgICBtYXBib3hnbC5hY2Nlc3NUb2tlbiA9IHByb3BzLm1hcGJveEFwaUFjY2Vzc1Rva2VuO1xuICAgIH1cblxuICAgIGlmICghU3RhdGljTWFwLnN1cHBvcnRlZCgpKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudERpZE1vdW50ID0gbm9vcDtcbiAgICAgIHRoaXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IG5vb3A7XG4gICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSA9IG5vb3A7XG4gICAgfVxuICAgIGF1dG9iaW5kKHRoaXMpO1xuICB9XG5cbiAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2aWV3cG9ydDogbmV3IFBlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydCh0aGlzLnByb3BzKVxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAoIW1hcGJveGdsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWFwU3R5bGUgPSBJbW11dGFibGUuTWFwLmlzTWFwKHRoaXMucHJvcHMubWFwU3R5bGUpID9cbiAgICAgIHRoaXMucHJvcHMubWFwU3R5bGUudG9KUygpIDpcbiAgICAgIHRoaXMucHJvcHMubWFwU3R5bGU7XG4gICAgY29uc3QgbWFwID0gbmV3IG1hcGJveGdsLk1hcCh7XG4gICAgICBjb250YWluZXI6IHRoaXMuX21hcGJveE1hcCxcbiAgICAgIGNlbnRlcjogW3RoaXMucHJvcHMubG9uZ2l0dWRlLCB0aGlzLnByb3BzLmxhdGl0dWRlXSxcbiAgICAgIHpvb206IHRoaXMucHJvcHMuem9vbSxcbiAgICAgIHBpdGNoOiB0aGlzLnByb3BzLnBpdGNoLFxuICAgICAgYmVhcmluZzogdGhpcy5wcm9wcy5iZWFyaW5nLFxuICAgICAgc3R5bGU6IG1hcFN0eWxlLFxuICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgICAgYXR0cmlidXRpb25Db250cm9sOiB0aGlzLnByb3BzLmF0dHJpYnV0aW9uQ29udHJvbCxcbiAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdGhpcy5wcm9wcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXJcbiAgICB9KTtcblxuICAgIC8vIERpc2FibGUgb3V0bGluZSBzdHlsZVxuICAgIGNvbnN0IGNhbnZhcyA9IG1hcC5nZXRDYW52YXMoKTtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBjYW52YXMuc3R5bGUub3V0bGluZSA9ICdub25lJztcbiAgICB9XG5cbiAgICAvLyBBdHRhY2ggb3B0aW9uYWwgb25Mb2FkIGZ1bmN0aW9uXG4gICAgbWFwLm9uY2UoJ2xvYWQnLCB0aGlzLnByb3BzLm9uTG9hZCk7XG5cbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fdXBkYXRlTWFwVmlld3BvcnQoe30sIHRoaXMucHJvcHMpO1xuICAgIC8vIHRoaXMuX2NhbGxPbkNoYW5nZVZpZXdwb3J0KG1hcC50cmFuc2Zvcm0pO1xuICAgIHRoaXMuX3VwZGF0ZVF1ZXJ5UGFyYW1zKG1hcFN0eWxlKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMpIHtcbiAgICBpZiAoIW1hcGJveGdsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlU3RhdGVGcm9tUHJvcHModGhpcy5wcm9wcywgbmV3UHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZU1hcFZpZXdwb3J0KHRoaXMucHJvcHMsIG5ld1Byb3BzKTtcbiAgICB0aGlzLl91cGRhdGVNYXBTdHlsZSh0aGlzLnByb3BzLCBuZXdQcm9wcyk7XG4gICAgLy8gU2F2ZSB3aWR0aC9oZWlnaHQgc28gdGhhdCB3ZSBjYW4gY2hlY2sgdGhlbSBpbiBjb21wb25lbnREaWRVcGRhdGVcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHdpZHRoOiB0aGlzLnByb3BzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLnByb3BzLmhlaWdodFxuICAgIH0pO1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGlmICghbWFwYm94Z2wpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaW5jZSBNYXBib3gncyBtYXAucmVzaXplKCkgcmVhZHMgc2l6ZSBmcm9tIERPTVxuICAgIC8vIHdlIG11c3Qgd2FpdCB0byByZWFkIHNpemUgdW50aWwgYWZ0ZXIgcmVuZGVyIChpLmUuIGhlcmUgaW4gXCJkaWRVcGRhdGVcIilcbiAgICB0aGlzLl91cGRhdGVNYXBTaXplKHRoaXMuc3RhdGUsIHRoaXMucHJvcHMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKCFtYXBib3hnbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9tYXApIHtcbiAgICAgIHRoaXMuX21hcC5yZW1vdmUoKTtcbiAgICB9XG4gIH1cblxuICAvLyBFeHRlcm5hbCBhcHBzIGNhbiBhY2Nlc3MgbWFwIHRoaXMgd2F5XG4gIGdldE1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwO1xuICB9XG5cbiAgLyoqIFVzZXMgTWFwYm94J3NcbiAgICAqIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyBBUEkgdG8gZmluZCBmZWF0dXJlcyBhdCBwb2ludCBvciBpbiBhIGJvdW5kaW5nIGJveC5cbiAgICAqIGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vbWFwYm94LWdsLWpzL2FwaS8jTWFwI3F1ZXJ5UmVuZGVyZWRGZWF0dXJlc1xuICAgICogVG8gcXVlcnkgb25seSBzb21lIG9mIHRoZSBsYXllcnMsIHNldCB0aGUgYGludGVyYWN0aXZlYCBwcm9wZXJ0eSBpbiB0aGVcbiAgICAqIGxheWVyIHN0eWxlIHRvIGB0cnVlYC5cbiAgICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXXxbW051bWJlciwgTnVtYmVyXSwgW051bWJlciwgTnVtYmVyXV19IGdlb21ldHJ5IC1cbiAgICAqICAgUG9pbnQgb3IgYW4gYXJyYXkgb2YgdHdvIHBvaW50cyBkZWZpbmluZyB0aGUgYm91bmRpbmcgYm94XG4gICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVycyAtIHF1ZXJ5IG9wdGlvbnNcbiAgICAqL1xuICBxdWVyeVJlbmRlcmVkRmVhdHVyZXMoZ2VvbWV0cnksIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9IHBhcmFtZXRlcnMgfHwgdGhpcy5fcXVlcnlQYXJhbXM7XG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmxheWVycyAmJiBxdWVyeVBhcmFtcy5sYXllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9tYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGdlb21ldHJ5LCBxdWVyeVBhcmFtcyk7XG4gIH1cblxuICBfdXBkYXRlU3RhdGVGcm9tUHJvcHMob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgaWYgKG1hcGJveGdsKSB7XG4gICAgICBtYXBib3hnbC5hY2Nlc3NUb2tlbiA9IG5ld1Byb3BzLm1hcGJveEFwaUFjY2Vzc1Rva2VuO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhvdmVyIGFuZCBjbGljayBvbmx5IHF1ZXJ5IGxheWVycyB3aG9zZSBpbnRlcmFjdGl2ZSBwcm9wZXJ0eSBpcyB0cnVlXG4gIF91cGRhdGVRdWVyeVBhcmFtcyhtYXBTdHlsZSkge1xuICAgIGNvbnN0IGludGVyYWN0aXZlTGF5ZXJJZHMgPSBnZXRJbnRlcmFjdGl2ZUxheWVySWRzKG1hcFN0eWxlKTtcbiAgICB0aGlzLl9xdWVyeVBhcmFtcyA9IHtsYXllcnM6IGludGVyYWN0aXZlTGF5ZXJJZHN9O1xuICB9XG5cbiAgLy8gVXBkYXRlIGEgc291cmNlIGluIHRoZSBtYXAgc3R5bGVcbiAgX3VwZGF0ZVNvdXJjZShtYXAsIHVwZGF0ZSkge1xuICAgIGNvbnN0IG5ld1NvdXJjZSA9IHVwZGF0ZS5zb3VyY2UudG9KUygpO1xuICAgIGlmIChuZXdTb3VyY2UudHlwZSA9PT0gJ2dlb2pzb24nKSB7XG4gICAgICBjb25zdCBvbGRTb3VyY2UgPSBtYXAuZ2V0U291cmNlKHVwZGF0ZS5pZCk7XG4gICAgICBpZiAob2xkU291cmNlLnR5cGUgPT09ICdnZW9qc29uJykge1xuICAgICAgICAvLyB1cGRhdGUgZGF0YSBpZiBubyBvdGhlciBHZW9KU09OU291cmNlIG9wdGlvbnMgd2VyZSBjaGFuZ2VkXG4gICAgICAgIGNvbnN0IG9sZE9wdHMgPSBvbGRTb3VyY2Uud29ya2VyT3B0aW9ucztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChuZXdTb3VyY2UubWF4em9vbSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBuZXdTb3VyY2UubWF4em9vbSA9PT0gb2xkT3B0cy5nZW9qc29uVnRPcHRpb25zLm1heFpvb20pICYmXG4gICAgICAgICAgKG5ld1NvdXJjZS5idWZmZXIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgbmV3U291cmNlLmJ1ZmZlciA9PT0gb2xkT3B0cy5nZW9qc29uVnRPcHRpb25zLmJ1ZmZlcikgJiZcbiAgICAgICAgICAobmV3U291cmNlLnRvbGVyYW5jZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBuZXdTb3VyY2UudG9sZXJhbmNlID09PSBvbGRPcHRzLmdlb2pzb25WdE9wdGlvbnMudG9sZXJhbmNlKSAmJlxuICAgICAgICAgIChuZXdTb3VyY2UuY2x1c3RlciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBuZXdTb3VyY2UuY2x1c3RlciA9PT0gb2xkT3B0cy5jbHVzdGVyKSAmJlxuICAgICAgICAgIChuZXdTb3VyY2UuY2x1c3RlclJhZGl1cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBuZXdTb3VyY2UuY2x1c3RlclJhZGl1cyA9PT0gb2xkT3B0cy5zdXBlcmNsdXN0ZXJPcHRpb25zLnJhZGl1cykgJiZcbiAgICAgICAgICAobmV3U291cmNlLmNsdXN0ZXJNYXhab29tID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIG5ld1NvdXJjZS5jbHVzdGVyTWF4Wm9vbSA9PT0gb2xkT3B0cy5zdXBlcmNsdXN0ZXJPcHRpb25zLm1heFpvb20pXG4gICAgICAgICkge1xuICAgICAgICAgIG9sZFNvdXJjZS5zZXREYXRhKG5ld1NvdXJjZS5kYXRhKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBtYXAucmVtb3ZlU291cmNlKHVwZGF0ZS5pZCk7XG4gICAgbWFwLmFkZFNvdXJjZSh1cGRhdGUuaWQsIG5ld1NvdXJjZSk7XG4gIH1cblxuICAvLyBJbmRpdmlkdWFsbHkgdXBkYXRlIHRoZSBtYXBzIHNvdXJjZSBhbmQgbGF5ZXJzIHRoYXQgaGF2ZSBjaGFuZ2VkIGlmIGFsbFxuICAvLyBvdGhlciBzdHlsZSBwcm9wcyBoYXZlbid0IGNoYW5nZWQuIFRoaXMgcHJldmVudHMgZmxpY2tpbmcgb2YgdGhlIG1hcCB3aGVuXG4gIC8vIHN0eWxlcyBvbmx5IGNoYW5nZSBzb3VyY2VzIG9yIGxheWVycy5cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMsIGNvbXBsZXhpdHkgKi9cbiAgX3NldERpZmZTdHlsZShwcmV2U3R5bGUsIG5leHRTdHlsZSkge1xuICAgIGNvbnN0IHByZXZLZXlzTWFwID0gcHJldlN0eWxlICYmIHN0eWxlS2V5c01hcChwcmV2U3R5bGUpIHx8IHt9O1xuICAgIGNvbnN0IG5leHRLZXlzTWFwID0gc3R5bGVLZXlzTWFwKG5leHRTdHlsZSk7XG4gICAgZnVuY3Rpb24gc3R5bGVLZXlzTWFwKHN0eWxlKSB7XG4gICAgICByZXR1cm4gc3R5bGUubWFwKCgpID0+IHRydWUpLmRlbGV0ZSgnbGF5ZXJzJykuZGVsZXRlKCdzb3VyY2VzJykudG9KUygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wc090aGVyVGhhbkxheWVyc09yU291cmNlc0RpZmZlcigpIHtcbiAgICAgIGNvbnN0IHByZXZLZXlzTGlzdCA9IE9iamVjdC5rZXlzKHByZXZLZXlzTWFwKTtcbiAgICAgIGNvbnN0IG5leHRLZXlzTGlzdCA9IE9iamVjdC5rZXlzKG5leHRLZXlzTWFwKTtcbiAgICAgIGlmIChwcmV2S2V5c0xpc3QubGVuZ3RoICE9PSBuZXh0S2V5c0xpc3QubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gYG5leHRTdHlsZWAgYW5kIGBwcmV2U3R5bGVgIHNob3VsZCBub3QgaGF2ZSB0aGUgc2FtZSBzZXQgb2YgcHJvcHMuXG4gICAgICBpZiAobmV4dEtleXNMaXN0LnNvbWUoXG4gICAgICAgIGtleSA9PiBwcmV2U3R5bGUuZ2V0KGtleSkgIT09IG5leHRTdHlsZS5nZXQoa2V5KVxuICAgICAgICAvLyBCdXQgdGhlIHZhbHVlIG9mIG9uZSBvZiB0aG9zZSBwcm9wcyBpcyBkaWZmZXJlbnQuXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG1hcCA9IHRoaXMuX21hcDtcblxuICAgIGlmICghcHJldlN0eWxlIHx8IHByb3BzT3RoZXJUaGFuTGF5ZXJzT3JTb3VyY2VzRGlmZmVyKCkpIHtcbiAgICAgIG1hcC5zZXRTdHlsZShuZXh0U3R5bGUudG9KUygpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7c291cmNlc0RpZmYsIGxheWVyc0RpZmZ9ID0gZGlmZlN0eWxlcyhwcmV2U3R5bGUsIG5leHRTdHlsZSk7XG5cbiAgICAvLyBUT0RPOiBJdCdzIHJhdGhlciBkaWZmaWN1bHQgdG8gZGV0ZXJtaW5lIHN0eWxlIGRpZmZpbmcgaW4gdGhlIHByZXNlbmNlXG4gICAgLy8gb2YgcmVmcy4gRm9yIG5vdywgaWYgYW55IHN0eWxlIHVwZGF0ZSBoYXMgYSByZWYsIGZhbGxiYWNrIHRvIG5vIGRpZmZpbmcuXG4gICAgLy8gV2UgY2FuIGNvbWUgYmFjayB0byB0aGlzIGNhc2UgaWYgdGhlcmUncyBhIHNvbGlkIHVzZWNhc2UuXG4gICAgaWYgKGxheWVyc0RpZmYudXBkYXRlcy5zb21lKG5vZGUgPT4gbm9kZS5sYXllci5nZXQoJ3JlZicpKSkge1xuICAgICAgbWFwLnNldFN0eWxlKG5leHRTdHlsZS50b0pTKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZW50ZXIgb2Ygc291cmNlc0RpZmYuZW50ZXIpIHtcbiAgICAgIG1hcC5hZGRTb3VyY2UoZW50ZXIuaWQsIGVudGVyLnNvdXJjZS50b0pTKCkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiBzb3VyY2VzRGlmZi51cGRhdGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVNvdXJjZShtYXAsIHVwZGF0ZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXhpdCBvZiBzb3VyY2VzRGlmZi5leGl0KSB7XG4gICAgICBtYXAucmVtb3ZlU291cmNlKGV4aXQuaWQpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV4aXQgb2YgbGF5ZXJzRGlmZi5leGl0aW5nKSB7XG4gICAgICBpZiAobWFwLnN0eWxlLmdldExheWVyKGV4aXQuaWQpKSB7XG4gICAgICAgIG1hcC5yZW1vdmVMYXllcihleGl0LmlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB1cGRhdGUgb2YgbGF5ZXJzRGlmZi51cGRhdGVzKSB7XG4gICAgICBpZiAoIXVwZGF0ZS5lbnRlcikge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIG9sZCBsYXllciB0aGF0IG5lZWRzIHRvIGJlIHVwZGF0ZWQuIFJlbW92ZSB0aGUgb2xkIGxheWVyXG4gICAgICAgIC8vIHdpdGggdGhlIHNhbWUgaWQgYW5kIGFkZCBpdCBiYWNrIGFnYWluLlxuICAgICAgICBtYXAucmVtb3ZlTGF5ZXIodXBkYXRlLmlkKTtcbiAgICAgIH1cbiAgICAgIG1hcC5hZGRMYXllcih1cGRhdGUubGF5ZXIudG9KUygpLCB1cGRhdGUuYmVmb3JlKTtcbiAgICB9XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cywgY29tcGxleGl0eSAqL1xuXG4gIF91cGRhdGVNYXBTdHlsZShvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICBjb25zdCBtYXBTdHlsZSA9IG5ld1Byb3BzLm1hcFN0eWxlO1xuICAgIGNvbnN0IG9sZE1hcFN0eWxlID0gb2xkUHJvcHMubWFwU3R5bGU7XG4gICAgaWYgKG1hcFN0eWxlICE9PSBvbGRNYXBTdHlsZSkge1xuICAgICAgaWYgKEltbXV0YWJsZS5NYXAuaXNNYXAobWFwU3R5bGUpKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnByZXZlbnRTdHlsZURpZmZpbmcpIHtcbiAgICAgICAgICB0aGlzLl9tYXAuc2V0U3R5bGUobWFwU3R5bGUudG9KUygpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zZXREaWZmU3R5bGUob2xkTWFwU3R5bGUsIG1hcFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbWFwLnNldFN0eWxlKG1hcFN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZVF1ZXJ5UGFyYW1zKG1hcFN0eWxlKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlTWFwVmlld3BvcnQob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgY29uc3Qgdmlld3BvcnRDaGFuZ2VkID1cbiAgICAgIG5ld1Byb3BzLmxhdGl0dWRlICE9PSBvbGRQcm9wcy5sYXRpdHVkZSB8fFxuICAgICAgbmV3UHJvcHMubG9uZ2l0dWRlICE9PSBvbGRQcm9wcy5sb25naXR1ZGUgfHxcbiAgICAgIG5ld1Byb3BzLnpvb20gIT09IG9sZFByb3BzLnpvb20gfHxcbiAgICAgIG5ld1Byb3BzLnBpdGNoICE9PSBvbGRQcm9wcy5waXRjaCB8fFxuICAgICAgbmV3UHJvcHMuYmVhcmluZyAhPT0gb2xkUHJvcHMuYmVhcmluZyB8fFxuICAgICAgbmV3UHJvcHMuYWx0aXR1ZGUgIT09IG9sZFByb3BzLmFsdGl0dWRlO1xuXG4gICAgaWYgKHZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgdGhpcy5fbWFwLmp1bXBUbyh7XG4gICAgICAgIGNlbnRlcjogW25ld1Byb3BzLmxvbmdpdHVkZSwgbmV3UHJvcHMubGF0aXR1ZGVdLFxuICAgICAgICB6b29tOiBuZXdQcm9wcy56b29tLFxuICAgICAgICBiZWFyaW5nOiBuZXdQcm9wcy5iZWFyaW5nLFxuICAgICAgICBwaXRjaDogbmV3UHJvcHMucGl0Y2hcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUT0RPIC0ganVtcFRvIGRvZXNuJ3QgaGFuZGxlIGFsdGl0dWRlXG4gICAgICBpZiAobmV3UHJvcHMuYWx0aXR1ZGUgIT09IG9sZFByb3BzLmFsdGl0dWRlKSB7XG4gICAgICAgIHRoaXMuX21hcC50cmFuc2Zvcm0uYWx0aXR1ZGUgPSBuZXdQcm9wcy5hbHRpdHVkZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBOb3RlOiBuZWVkcyB0byBiZSBjYWxsZWQgYWZ0ZXIgcmVuZGVyIChlLmcuIGluIGNvbXBvbmVudERpZFVwZGF0ZSlcbiAgX3VwZGF0ZU1hcFNpemUob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgY29uc3Qgc2l6ZUNoYW5nZWQgPVxuICAgICAgb2xkUHJvcHMud2lkdGggIT09IG5ld1Byb3BzLndpZHRoIHx8IG9sZFByb3BzLmhlaWdodCAhPT0gbmV3UHJvcHMuaGVpZ2h0O1xuXG4gICAgaWYgKHNpemVDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9tYXAucmVzaXplKCk7XG4gICAgICAvLyB0aGlzLl9jYWxsT25DaGFuZ2VWaWV3cG9ydCh0aGlzLl9tYXAudHJhbnNmb3JtKTtcbiAgICB9XG4gIH1cblxuICBfbWFwYm94TWFwTG9hZGVkKHJlZikge1xuICAgIHRoaXMuX21hcGJveE1hcCA9IHJlZjtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7Y2xhc3NOYW1lLCB3aWR0aCwgaGVpZ2h0LCBzdHlsZSwgdmlzaWJsZX0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IG1hcENvbnRhaW5lclN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIHt3aWR0aCwgaGVpZ2h0LCBwb3NpdGlvbjogJ3JlbGF0aXZlJ30pO1xuICAgIGNvbnN0IG1hcFN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdmlzaWJpbGl0eTogdmlzaWJsZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nXG4gICAgfSk7XG4gICAgY29uc3Qgb3ZlcmxheUNvbnRhaW5lclN0eWxlID0ge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICB9O1xuXG4gICAgLy8gTm90ZTogYSBzdGF0aWMgbWFwIHN0aWxsIGhhbmRsZXMgY2xpY2tzIGFuZCBob3ZlciBldmVudHNcbiAgICByZXR1cm4gKFxuICAgICAgY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICBrZXk6ICdtYXAtY29udGFpbmVyJyxcbiAgICAgICAgc3R5bGU6IG1hcENvbnRhaW5lclN0eWxlLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgICAgIGtleTogJ21hcC1tYXBib3gnLFxuICAgICAgICAgICAgcmVmOiB0aGlzLl9tYXBib3hNYXBMb2FkZWQsXG4gICAgICAgICAgICBzdHlsZTogbWFwU3R5bGUsXG4gICAgICAgICAgICBjbGFzc05hbWVcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICBrZXk6ICdtYXAtb3ZlcmxheXMnLFxuICAgICAgICAgICAgLy8gU2FtZSBhcyBpbnRlcmFjdGl2ZSBtYXAncyBvdmVybGF5IGNvbnRhaW5lclxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnb3ZlcmxheXMnLFxuICAgICAgICAgICAgc3R5bGU6IG92ZXJsYXlDb250YWluZXJTdHlsZSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgfSlcbiAgICAgICAgXVxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5cblN0YXRpY01hcC5kaXNwbGF5TmFtZSA9ICdTdGF0aWNNYXAnO1xuU3RhdGljTWFwLnByb3BUeXBlcyA9IHByb3BUeXBlcztcblN0YXRpY01hcC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5TdGF0aWNNYXAuY2hpbGRDb250ZXh0VHlwZXMgPSBjaGlsZENvbnRleHRUeXBlcztcbiJdfQ==