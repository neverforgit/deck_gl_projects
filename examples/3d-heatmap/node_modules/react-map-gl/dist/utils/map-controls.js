'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _mapState = require('../utils/map-state');

var _mapState2 = _interopRequireDefault(_mapState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// EVENT HANDLING PARAMETERS
var PITCH_MOUSE_THRESHOLD = 5; // Copyright (c) 2015 Uber Technologies, Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var PITCH_ACCEL = 1.2;
var ZOOM_ACCEL = 0.01;

var EVENT_TYPES = {
  WHEEL: ['wheel'],
  PAN: ['panstart', 'panmove', 'panend'],
  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],
  DOUBLE_TAP: ['doubletap']
};

var MapControls = function () {
  /**
   * @classdesc
   * A class that handles events and updates mercator style viewport parameters
   */
  function MapControls() {
    (0, _classCallCheck3.default)(this, MapControls);

    this._state = {
      isDragging: false
    };
    this.handleEvent = this.handleEvent.bind(this);
  }

  /**
   * Callback for events
   * @param {hammer.Event} event
   */


  (0, _createClass3.default)(MapControls, [{
    key: 'handleEvent',
    value: function handleEvent(event) {
      this.mapState = new _mapState2.default((0, _assign2.default)({}, this.mapStateProps, this._state));

      switch (event.type) {
        case 'panstart':
          return this._onPanStart(event);
        case 'panmove':
          return this._onPan(event);
        case 'panend':
          return this._onPanEnd(event);
        case 'pinchstart':
          return this._onPinchStart(event);
        case 'pinchmove':
          return this._onPinch(event);
        case 'pinchend':
          return this._onPinchEnd(event);
        case 'doubletap':
          return this._onDoubleTap(event);
        case 'wheel':
          return this._onWheel(event);
        default:
          return false;
      }
    }

    /* Event utils */
    // Event object: http://hammerjs.github.io/api/#event-object

  }, {
    key: 'getCenter',
    value: function getCenter(event) {
      var _event$offsetCenter = event.offsetCenter,
          x = _event$offsetCenter.x,
          y = _event$offsetCenter.y;

      return [x, y];
    }
  }, {
    key: 'isFunctionKeyPressed',
    value: function isFunctionKeyPressed(event) {
      var srcEvent = event.srcEvent;

      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
  }, {
    key: 'setState',
    value: function setState(newState) {
      (0, _assign2.default)(this._state, newState);
      if (this.onStateChange) {
        this.onStateChange(this._state);
      }
    }

    /* Callback util */
    // formats map state and invokes callback function

  }, {
    key: 'updateViewport',
    value: function updateViewport(newMapState) {
      var extraState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var oldViewport = this.mapState.getViewportProps();
      var newViewport = newMapState.getViewportProps();

      if (this.onViewportChange && (0, _keys2.default)(newViewport).some(function (key) {
        return oldViewport[key] !== newViewport[key];
      })) {
        // Viewport has changed
        this.onViewportChange(newViewport);
      }

      this.setState((0, _assign2.default)({}, newMapState.getInteractiveState(), extraState));
    }

    /**
     * Extract interactivity options
     */

  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      var onChangeViewport = options.onChangeViewport,
          onViewportChange = options.onViewportChange,
          _options$onStateChang = options.onStateChange,
          onStateChange = _options$onStateChang === undefined ? this.onStateChange : _options$onStateChang,
          _options$eventManager = options.eventManager,
          eventManager = _options$eventManager === undefined ? this.eventManager : _options$eventManager,
          _options$scrollZoom = options.scrollZoom,
          scrollZoom = _options$scrollZoom === undefined ? true : _options$scrollZoom,
          _options$dragPan = options.dragPan,
          dragPan = _options$dragPan === undefined ? true : _options$dragPan,
          _options$dragRotate = options.dragRotate,
          dragRotate = _options$dragRotate === undefined ? true : _options$dragRotate,
          _options$doubleClickZ = options.doubleClickZoom,
          doubleClickZoom = _options$doubleClickZ === undefined ? true : _options$doubleClickZ,
          _options$touchZoomRot = options.touchZoomRotate,
          touchZoomRotate = _options$touchZoomRot === undefined ? true : _options$touchZoomRot;

      // TODO(deprecate): remove this check when `onChangeViewport` gets deprecated

      this.onViewportChange = onViewportChange || onChangeViewport;
      this.onStateChange = onStateChange;
      this.mapStateProps = options;
      if (this.eventManager !== eventManager) {
        // EventManager has changed
        this.eventManager = eventManager;
        this._events = {};
      }
      var isInteractive = Boolean(this.onViewportChange);

      // Register/unregister events
      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
      this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && touchZoomRotate);
      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);

      // Interaction toggles
      this.scrollZoom = scrollZoom;
      this.dragPan = dragPan;
      this.dragRotate = dragRotate;
      this.doubleClickZoom = doubleClickZoom;
      this.touchZoomRotate = touchZoomRotate;
    }
  }, {
    key: 'toggleEvents',
    value: function toggleEvents(eventNames, enabled) {
      var _this = this;

      if (this.eventManager) {
        eventNames.forEach(function (eventName) {
          if (_this._events[eventName] !== enabled) {
            _this._events[eventName] = enabled;
            if (enabled) {
              _this.eventManager.on(eventName, _this.handleEvent);
            } else {
              _this.eventManager.off(eventName, _this.handleEvent);
            }
          }
        });
      }
    }

    /* Event handlers */
    // Default handler for the `panstart` event.

  }, {
    key: '_onPanStart',
    value: function _onPanStart(event) {
      var pos = this.getCenter(event);
      var newMapState = this.mapState.panStart({ pos: pos }).rotateStart({ pos: pos });
      return this.updateViewport(newMapState, { isDragging: true });
    }

    // Default handler for the `panmove` event.

  }, {
    key: '_onPan',
    value: function _onPan(event) {
      return this.isFunctionKeyPressed(event) ? this._onPanRotate(event) : this._onPanMove(event);
    }

    // Default handler for the `panend` event.

  }, {
    key: '_onPanEnd',
    value: function _onPanEnd(event) {
      var newMapState = this.mapState.panEnd().rotateEnd();
      return this.updateViewport(newMapState, { isDragging: false });
    }

    // Default handler for panning to move.
    // Called by `_onPan` when panning without function key pressed.

  }, {
    key: '_onPanMove',
    value: function _onPanMove(event) {
      if (!this.dragPan) {
        return false;
      }
      var pos = this.getCenter(event);
      var newMapState = this.mapState.pan({ pos: pos });
      return this.updateViewport(newMapState);
    }

    // Default handler for panning to rotate.
    // Called by `_onPan` when panning with function key pressed.

  }, {
    key: '_onPanRotate',
    value: function _onPanRotate(event) {
      if (!this.dragRotate) {
        return false;
      }

      var deltaX = event.deltaX,
          deltaY = event.deltaY;

      var _getCenter = this.getCenter(event),
          _getCenter2 = (0, _slicedToArray3.default)(_getCenter, 2),
          centerY = _getCenter2[1];

      var startY = centerY - deltaY;

      var _mapState$getViewport = this.mapState.getViewportProps(),
          width = _mapState$getViewport.width,
          height = _mapState$getViewport.height;

      var deltaScaleX = deltaX / width;
      var deltaScaleY = 0;

      if (deltaY > 0) {
        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
          // Move from 0 to -1 as we drag upwards
          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
        }
      } else if (deltaY < 0) {
        if (startY > PITCH_MOUSE_THRESHOLD) {
          // Move from 0 to 1 as we drag upwards
          deltaScaleY = 1 - centerY / startY;
        }
      }
      deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));

      var newMapState = this.mapState.rotate({ deltaScaleX: deltaScaleX, deltaScaleY: deltaScaleY });
      return this.updateViewport(newMapState);
    }

    // Default handler for the `wheel` event.

  }, {
    key: '_onWheel',
    value: function _onWheel(event) {
      if (!this.scrollZoom) {
        return false;
      }

      var pos = this.getCenter(event);
      var delta = event.delta;

      // Map wheel delta to relative scale

      var scale = 2 / (1 + Math.exp(-Math.abs(delta * ZOOM_ACCEL)));
      if (delta < 0 && scale !== 0) {
        scale = 1 / scale;
      }

      var newMapState = this.mapState.zoom({ pos: pos, scale: scale });
      return this.updateViewport(newMapState);
    }

    // Default handler for the `pinchstart` event.

  }, {
    key: '_onPinchStart',
    value: function _onPinchStart(event) {
      var pos = this.getCenter(event);
      var newMapState = this.mapState.zoomStart({ pos: pos });
      return this.updateViewport(newMapState, { isDragging: true });
    }

    // Default handler for the `pinch` event.

  }, {
    key: '_onPinch',
    value: function _onPinch(event) {
      if (!this.touchZoomRotate) {
        return false;
      }
      var pos = this.getCenter(event);
      var scale = event.scale;

      var newMapState = this.mapState.zoom({ pos: pos, scale: scale });
      return this.updateViewport(newMapState);
    }

    // Default handler for the `pinchend` event.

  }, {
    key: '_onPinchEnd',
    value: function _onPinchEnd(event) {
      var newMapState = this.mapState.zoomEnd();
      return this.updateViewport(newMapState, { isDragging: false });
    }

    // Default handler for the `doubletap` event.

  }, {
    key: '_onDoubleTap',
    value: function _onDoubleTap(event) {
      if (!this.doubleClickZoom) {
        return false;
      }
      var pos = this.getCenter(event);
      var isZoomOut = this.isFunctionKeyPressed(event);

      var newMapState = this.mapState.zoom({ pos: pos, scale: isZoomOut ? 0.5 : 2 });
      return this.updateViewport(newMapState);
    }
  }]);
  return MapControls;
}();

exports.default = MapControls;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9tYXAtY29udHJvbHMuanMiXSwibmFtZXMiOlsiUElUQ0hfTU9VU0VfVEhSRVNIT0xEIiwiUElUQ0hfQUNDRUwiLCJaT09NX0FDQ0VMIiwiRVZFTlRfVFlQRVMiLCJXSEVFTCIsIlBBTiIsIlBJTkNIIiwiRE9VQkxFX1RBUCIsIk1hcENvbnRyb2xzIiwiX3N0YXRlIiwiaXNEcmFnZ2luZyIsImhhbmRsZUV2ZW50IiwiYmluZCIsImV2ZW50IiwibWFwU3RhdGUiLCJtYXBTdGF0ZVByb3BzIiwidHlwZSIsIl9vblBhblN0YXJ0IiwiX29uUGFuIiwiX29uUGFuRW5kIiwiX29uUGluY2hTdGFydCIsIl9vblBpbmNoIiwiX29uUGluY2hFbmQiLCJfb25Eb3VibGVUYXAiLCJfb25XaGVlbCIsIm9mZnNldENlbnRlciIsIngiLCJ5Iiwic3JjRXZlbnQiLCJCb29sZWFuIiwibWV0YUtleSIsImFsdEtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsIm5ld1N0YXRlIiwib25TdGF0ZUNoYW5nZSIsIm5ld01hcFN0YXRlIiwiZXh0cmFTdGF0ZSIsIm9sZFZpZXdwb3J0IiwiZ2V0Vmlld3BvcnRQcm9wcyIsIm5ld1ZpZXdwb3J0Iiwib25WaWV3cG9ydENoYW5nZSIsInNvbWUiLCJrZXkiLCJzZXRTdGF0ZSIsImdldEludGVyYWN0aXZlU3RhdGUiLCJvcHRpb25zIiwib25DaGFuZ2VWaWV3cG9ydCIsImV2ZW50TWFuYWdlciIsInNjcm9sbFpvb20iLCJkcmFnUGFuIiwiZHJhZ1JvdGF0ZSIsImRvdWJsZUNsaWNrWm9vbSIsInRvdWNoWm9vbVJvdGF0ZSIsIl9ldmVudHMiLCJpc0ludGVyYWN0aXZlIiwidG9nZ2xlRXZlbnRzIiwiZXZlbnROYW1lcyIsImVuYWJsZWQiLCJmb3JFYWNoIiwiZXZlbnROYW1lIiwib24iLCJvZmYiLCJwb3MiLCJnZXRDZW50ZXIiLCJwYW5TdGFydCIsInJvdGF0ZVN0YXJ0IiwidXBkYXRlVmlld3BvcnQiLCJpc0Z1bmN0aW9uS2V5UHJlc3NlZCIsIl9vblBhblJvdGF0ZSIsIl9vblBhbk1vdmUiLCJwYW5FbmQiLCJyb3RhdGVFbmQiLCJwYW4iLCJkZWx0YVgiLCJkZWx0YVkiLCJjZW50ZXJZIiwic3RhcnRZIiwid2lkdGgiLCJoZWlnaHQiLCJkZWx0YVNjYWxlWCIsImRlbHRhU2NhbGVZIiwiTWF0aCIsImFicyIsIm1pbiIsIm1heCIsInJvdGF0ZSIsImRlbHRhIiwic2NhbGUiLCJleHAiLCJ6b29tIiwiem9vbVN0YXJ0Iiwiem9vbUVuZCIsImlzWm9vbU91dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7OztBQUVBO0FBQ0EsSUFBTUEsd0JBQXdCLENBQTlCLEMsQ0F2QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTUEsSUFBTUMsY0FBYyxHQUFwQjtBQUNBLElBQU1DLGFBQWEsSUFBbkI7O0FBRUEsSUFBTUMsY0FBYztBQUNsQkMsU0FBTyxDQUFDLE9BQUQsQ0FEVztBQUVsQkMsT0FBSyxDQUFDLFVBQUQsRUFBYSxTQUFiLEVBQXdCLFFBQXhCLENBRmE7QUFHbEJDLFNBQU8sQ0FBQyxZQUFELEVBQWUsV0FBZixFQUE0QixVQUE1QixDQUhXO0FBSWxCQyxjQUFZLENBQUMsV0FBRDtBQUpNLENBQXBCOztJQU9xQkMsVztBQUNuQjs7OztBQUlBLHlCQUFjO0FBQUE7O0FBQ1osU0FBS0MsTUFBTCxHQUFjO0FBQ1pDLGtCQUFZO0FBREEsS0FBZDtBQUdBLFNBQUtDLFdBQUwsR0FBbUIsS0FBS0EsV0FBTCxDQUFpQkMsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBbkI7QUFDRDs7QUFFRDs7Ozs7Ozs7Z0NBSVlDLEssRUFBTztBQUNqQixXQUFLQyxRQUFMLEdBQWdCLHVCQUFhLHNCQUFjLEVBQWQsRUFBa0IsS0FBS0MsYUFBdkIsRUFBc0MsS0FBS04sTUFBM0MsQ0FBYixDQUFoQjs7QUFF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LEtBTEYsQ0FLUDJFLEtBTE87O0FBTWQsVUFBTXBELGNBQWMsS0FBS3RCLFFBQUwsQ0FBYzRFLElBQWQsQ0FBbUIsRUFBQzNCLFFBQUQsRUFBTXlCLFlBQU4sRUFBbkIsQ0FBcEI7QUFDQSxhQUFPLEtBQUtyQixjQUFMLENBQW9CL0IsV0FBcEIsQ0FBUDtBQUNEOztBQUVEOzs7O2dDQUNZdkIsSyxFQUFPO0FBQ2pCLFVBQU11QixjQUFjLEtBQUt0QixRQUFMLENBQWM4RSxPQUFkLEVBQXBCO0FBQ0EsYUFBTyxLQUFLekIsY0FBTCxDQUFvQi9CLFdBQXBCLEVBQWlDLEVBQUMxQixZQUFZLEtBQWIsRUFBakMsQ0FBUDtBQUNEOztBQUVEOzs7O2lDQUNhRyxLLEVBQU87QUFDbEIsVUFBSSxDQUFDLEtBQUt1QyxlQUFWLEVBQTJCO0FBQ3pCLGVBQU8sS0FBUDtBQUNEO0FBQ0QsVUFBTVcsTUFBTSxLQUFLQyxTQUFMLENBQWVuRCxLQUFmLENBQVo7QUFDQSxVQUFNZ0YsWUFBWSxLQUFLekIsb0JBQUwsQ0FBMEJ2RCxLQUExQixDQUFsQjs7QUFFQSxVQUFNdUIsY0FBYyxLQUFLdEIsUUFBTCxDQUFjNEUsSUFBZCxDQUFtQixFQUFDM0IsUUFBRCxFQUFNeUIsT0FBT0ssWUFBWSxHQUFaLEdBQWtCLENBQS9CLEVBQW5CLENBQXBCO0FBQ0EsYUFBTyxLQUFLMUIsY0FBTCxDQUFvQi9CLFdBQXBCLENBQVA7QUFDRDs7Ozs7a0JBeFBrQjVCLFciLCJmaWxlIjoibWFwLWNvbnRyb2xzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG5cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IE1hcFN0YXRlIGZyb20gJy4uL3V0aWxzL21hcC1zdGF0ZSc7XG5cbi8vIEVWRU5UIEhBTkRMSU5HIFBBUkFNRVRFUlNcbmNvbnN0IFBJVENIX01PVVNFX1RIUkVTSE9MRCA9IDU7XG5jb25zdCBQSVRDSF9BQ0NFTCA9IDEuMjtcbmNvbnN0IFpPT01fQUNDRUwgPSAwLjAxO1xuXG5jb25zdCBFVkVOVF9UWVBFUyA9IHtcbiAgV0hFRUw6IFsnd2hlZWwnXSxcbiAgUEFOOiBbJ3BhbnN0YXJ0JywgJ3Bhbm1vdmUnLCAncGFuZW5kJ10sXG4gIFBJTkNIOiBbJ3BpbmNoc3RhcnQnLCAncGluY2htb3ZlJywgJ3BpbmNoZW5kJ10sXG4gIERPVUJMRV9UQVA6IFsnZG91YmxldGFwJ11cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcENvbnRyb2xzIHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogQSBjbGFzcyB0aGF0IGhhbmRsZXMgZXZlbnRzIGFuZCB1cGRhdGVzIG1lcmNhdG9yIHN0eWxlIHZpZXdwb3J0IHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3N0YXRlID0ge1xuICAgICAgaXNEcmFnZ2luZzogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRXZlbnQgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIGV2ZW50c1xuICAgKiBAcGFyYW0ge2hhbW1lci5FdmVudH0gZXZlbnRcbiAgICovXG4gIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5tYXBTdGF0ZSA9IG5ldyBNYXBTdGF0ZShPYmplY3QuYXNzaWduKHt9LCB0aGlzLm1hcFN0YXRlUHJvcHMsIHRoaXMuX3N0YXRlKSk7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICBjYXNlICdwYW5zdGFydCc6XG4gICAgICByZXR1cm4gdGhpcy5fb25QYW5TdGFydChldmVudCk7XG4gICAgY2FzZSAncGFubW92ZSc6XG4gICAgICByZXR1cm4gdGhpcy5fb25QYW4oZXZlbnQpO1xuICAgIGNhc2UgJ3BhbmVuZCc6XG4gICAgICByZXR1cm4gdGhpcy5fb25QYW5FbmQoZXZlbnQpO1xuICAgIGNhc2UgJ3BpbmNoc3RhcnQnOlxuICAgICAgcmV0dXJuIHRoaXMuX29uUGluY2hTdGFydChldmVudCk7XG4gICAgY2FzZSAncGluY2htb3ZlJzpcbiAgICAgIHJldHVybiB0aGlzLl9vblBpbmNoKGV2ZW50KTtcbiAgICBjYXNlICdwaW5jaGVuZCc6XG4gICAgICByZXR1cm4gdGhpcy5fb25QaW5jaEVuZChldmVudCk7XG4gICAgY2FzZSAnZG91YmxldGFwJzpcbiAgICAgIHJldHVybiB0aGlzLl9vbkRvdWJsZVRhcChldmVudCk7XG4gICAgY2FzZSAnd2hlZWwnOlxuICAgICAgcmV0dXJuIHRoaXMuX29uV2hlZWwoZXZlbnQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyogRXZlbnQgdXRpbHMgKi9cbiAgLy8gRXZlbnQgb2JqZWN0OiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL2FwaS8jZXZlbnQtb2JqZWN0XG4gIGdldENlbnRlcihldmVudCkge1xuICAgIGNvbnN0IHtvZmZzZXRDZW50ZXI6IHt4LCB5fX0gPSBldmVudDtcbiAgICByZXR1cm4gW3gsIHldO1xuICB9XG5cbiAgaXNGdW5jdGlvbktleVByZXNzZWQoZXZlbnQpIHtcbiAgICBjb25zdCB7c3JjRXZlbnR9ID0gZXZlbnQ7XG4gICAgcmV0dXJuIEJvb2xlYW4oc3JjRXZlbnQubWV0YUtleSB8fCBzcmNFdmVudC5hbHRLZXkgfHxcbiAgICAgIHNyY0V2ZW50LmN0cmxLZXkgfHwgc3JjRXZlbnQuc2hpZnRLZXkpO1xuICB9XG5cbiAgc2V0U3RhdGUobmV3U3RhdGUpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX3N0YXRlLCBuZXdTdGF0ZSk7XG4gICAgaWYgKHRoaXMub25TdGF0ZUNoYW5nZSkge1xuICAgICAgdGhpcy5vblN0YXRlQ2hhbmdlKHRoaXMuX3N0YXRlKTtcbiAgICB9XG4gIH1cblxuICAvKiBDYWxsYmFjayB1dGlsICovXG4gIC8vIGZvcm1hdHMgbWFwIHN0YXRlIGFuZCBpbnZva2VzIGNhbGxiYWNrIGZ1bmN0aW9uXG4gIHVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCBleHRyYVN0YXRlID0ge30pIHtcbiAgICBjb25zdCBvbGRWaWV3cG9ydCA9IHRoaXMubWFwU3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpO1xuICAgIGNvbnN0IG5ld1ZpZXdwb3J0ID0gbmV3TWFwU3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpO1xuXG4gICAgaWYgKHRoaXMub25WaWV3cG9ydENoYW5nZSAmJlxuICAgICAgT2JqZWN0LmtleXMobmV3Vmlld3BvcnQpLnNvbWUoa2V5ID0+IG9sZFZpZXdwb3J0W2tleV0gIT09IG5ld1ZpZXdwb3J0W2tleV0pKSB7XG4gICAgICAvLyBWaWV3cG9ydCBoYXMgY2hhbmdlZFxuICAgICAgdGhpcy5vblZpZXdwb3J0Q2hhbmdlKG5ld1ZpZXdwb3J0KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKE9iamVjdC5hc3NpZ24oe30sIG5ld01hcFN0YXRlLmdldEludGVyYWN0aXZlU3RhdGUoKSwgZXh0cmFTdGF0ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgaW50ZXJhY3Rpdml0eSBvcHRpb25zXG4gICAqL1xuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICAvLyBUT0RPKGRlcHJlY2F0ZSk6IHJlbW92ZSB0aGlzIHdoZW4gYG9uQ2hhbmdlVmlld3BvcnRgIGdldHMgZGVwcmVjYXRlZFxuICAgICAgb25DaGFuZ2VWaWV3cG9ydCxcbiAgICAgIG9uVmlld3BvcnRDaGFuZ2UsXG4gICAgICBvblN0YXRlQ2hhbmdlID0gdGhpcy5vblN0YXRlQ2hhbmdlLFxuICAgICAgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXIsXG4gICAgICBzY3JvbGxab29tID0gdHJ1ZSxcbiAgICAgIGRyYWdQYW4gPSB0cnVlLFxuICAgICAgZHJhZ1JvdGF0ZSA9IHRydWUsXG4gICAgICBkb3VibGVDbGlja1pvb20gPSB0cnVlLFxuICAgICAgdG91Y2hab29tUm90YXRlID0gdHJ1ZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgLy8gVE9ETyhkZXByZWNhdGUpOiByZW1vdmUgdGhpcyBjaGVjayB3aGVuIGBvbkNoYW5nZVZpZXdwb3J0YCBnZXRzIGRlcHJlY2F0ZWRcbiAgICB0aGlzLm9uVmlld3BvcnRDaGFuZ2UgPSBvblZpZXdwb3J0Q2hhbmdlIHx8IG9uQ2hhbmdlVmlld3BvcnQ7XG4gICAgdGhpcy5vblN0YXRlQ2hhbmdlID0gb25TdGF0ZUNoYW5nZTtcbiAgICB0aGlzLm1hcFN0YXRlUHJvcHMgPSBvcHRpb25zO1xuICAgIGlmICh0aGlzLmV2ZW50TWFuYWdlciAhPT0gZXZlbnRNYW5hZ2VyKSB7XG4gICAgICAvLyBFdmVudE1hbmFnZXIgaGFzIGNoYW5nZWRcbiAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgfVxuICAgIGNvbnN0IGlzSW50ZXJhY3RpdmUgPSBCb29sZWFuKHRoaXMub25WaWV3cG9ydENoYW5nZSk7XG5cbiAgICAvLyBSZWdpc3Rlci91bnJlZ2lzdGVyIGV2ZW50c1xuICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLldIRUVMLCBpc0ludGVyYWN0aXZlICYmIHNjcm9sbFpvb20pO1xuICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLlBBTiwgaXNJbnRlcmFjdGl2ZSAmJiAoZHJhZ1BhbiB8fCBkcmFnUm90YXRlKSk7XG4gICAgdGhpcy50b2dnbGVFdmVudHMoRVZFTlRfVFlQRVMuUElOQ0gsIGlzSW50ZXJhY3RpdmUgJiYgdG91Y2hab29tUm90YXRlKTtcbiAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5ET1VCTEVfVEFQLCBpc0ludGVyYWN0aXZlICYmIGRvdWJsZUNsaWNrWm9vbSk7XG5cbiAgICAvLyBJbnRlcmFjdGlvbiB0b2dnbGVzXG4gICAgdGhpcy5zY3JvbGxab29tID0gc2Nyb2xsWm9vbTtcbiAgICB0aGlzLmRyYWdQYW4gPSBkcmFnUGFuO1xuICAgIHRoaXMuZHJhZ1JvdGF0ZSA9IGRyYWdSb3RhdGU7XG4gICAgdGhpcy5kb3VibGVDbGlja1pvb20gPSBkb3VibGVDbGlja1pvb207XG4gICAgdGhpcy50b3VjaFpvb21Sb3RhdGUgPSB0b3VjaFpvb21Sb3RhdGU7XG4gIH1cblxuICB0b2dnbGVFdmVudHMoZXZlbnROYW1lcywgZW5hYmxlZCkge1xuICAgIGlmICh0aGlzLmV2ZW50TWFuYWdlcikge1xuICAgICAgZXZlbnROYW1lcy5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudHNbZXZlbnROYW1lXSAhPT0gZW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50c1tldmVudE5hbWVdID0gZW5hYmxlZDtcbiAgICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIub24oZXZlbnROYW1lLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIub2ZmKGV2ZW50TmFtZSwgdGhpcy5oYW5kbGVFdmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiBFdmVudCBoYW5kbGVycyAqL1xuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHRoZSBgcGFuc3RhcnRgIGV2ZW50LlxuICBfb25QYW5TdGFydChldmVudCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuU3RhcnQoe3Bvc30pLnJvdGF0ZVN0YXJ0KHtwb3N9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwge2lzRHJhZ2dpbmc6IHRydWV9KTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBwYW5tb3ZlYCBldmVudC5cbiAgX29uUGFuKGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNGdW5jdGlvbktleVByZXNzZWQoZXZlbnQpID8gdGhpcy5fb25QYW5Sb3RhdGUoZXZlbnQpIDogdGhpcy5fb25QYW5Nb3ZlKGV2ZW50KTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBwYW5lbmRgIGV2ZW50LlxuICBfb25QYW5FbmQoZXZlbnQpIHtcbiAgICBjb25zdCBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuRW5kKCkucm90YXRlRW5kKCk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUsIHtpc0RyYWdnaW5nOiBmYWxzZX0pO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciBwYW5uaW5nIHRvIG1vdmUuXG4gIC8vIENhbGxlZCBieSBgX29uUGFuYCB3aGVuIHBhbm5pbmcgd2l0aG91dCBmdW5jdGlvbiBrZXkgcHJlc3NlZC5cbiAgX29uUGFuTW92ZShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnUGFuKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUucGFuKHtwb3N9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHBhbm5pbmcgdG8gcm90YXRlLlxuICAvLyBDYWxsZWQgYnkgYF9vblBhbmAgd2hlbiBwYW5uaW5nIHdpdGggZnVuY3Rpb24ga2V5IHByZXNzZWQuXG4gIF9vblBhblJvdGF0ZShldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnUm90YXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qge2RlbHRhWCwgZGVsdGFZfSA9IGV2ZW50O1xuICAgIGNvbnN0IFssIGNlbnRlclldID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgIGNvbnN0IHN0YXJ0WSA9IGNlbnRlclkgLSBkZWx0YVk7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy5tYXBTdGF0ZS5nZXRWaWV3cG9ydFByb3BzKCk7XG5cbiAgICBjb25zdCBkZWx0YVNjYWxlWCA9IGRlbHRhWCAvIHdpZHRoO1xuICAgIGxldCBkZWx0YVNjYWxlWSA9IDA7XG5cbiAgICBpZiAoZGVsdGFZID4gMCkge1xuICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCAtIHN0YXJ0WSkgPiBQSVRDSF9NT1VTRV9USFJFU0hPTEQpIHtcbiAgICAgICAgLy8gTW92ZSBmcm9tIDAgdG8gLTEgYXMgd2UgZHJhZyB1cHdhcmRzXG4gICAgICAgIGRlbHRhU2NhbGVZID0gZGVsdGFZIC8gKHN0YXJ0WSAtIGhlaWdodCkgKiBQSVRDSF9BQ0NFTDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRlbHRhWSA8IDApIHtcbiAgICAgIGlmIChzdGFydFkgPiBQSVRDSF9NT1VTRV9USFJFU0hPTEQpIHtcbiAgICAgICAgLy8gTW92ZSBmcm9tIDAgdG8gMSBhcyB3ZSBkcmFnIHVwd2FyZHNcbiAgICAgICAgZGVsdGFTY2FsZVkgPSAxIC0gY2VudGVyWSAvIHN0YXJ0WTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsdGFTY2FsZVkgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgtMSwgZGVsdGFTY2FsZVkpKTtcblxuICAgIGNvbnN0IG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS5yb3RhdGUoe2RlbHRhU2NhbGVYLCBkZWx0YVNjYWxlWX0pO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlKTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGB3aGVlbGAgZXZlbnQuXG4gIF9vbldoZWVsKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnNjcm9sbFpvb20pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgY29uc3Qge2RlbHRhfSA9IGV2ZW50O1xuXG4gICAgLy8gTWFwIHdoZWVsIGRlbHRhIHRvIHJlbGF0aXZlIHNjYWxlXG4gICAgbGV0IHNjYWxlID0gMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGRlbHRhICogWk9PTV9BQ0NFTCkpKTtcbiAgICBpZiAoZGVsdGEgPCAwICYmIHNjYWxlICE9PSAwKSB7XG4gICAgICBzY2FsZSA9IDEgLyBzY2FsZTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUuem9vbSh7cG9zLCBzY2FsZX0pO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlKTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBwaW5jaHN0YXJ0YCBldmVudC5cbiAgX29uUGluY2hTdGFydChldmVudCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUuem9vbVN0YXJ0KHtwb3N9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSwge2lzRHJhZ2dpbmc6IHRydWV9KTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBwaW5jaGAgZXZlbnQuXG4gIF9vblBpbmNoKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnRvdWNoWm9vbVJvdGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgY29uc3Qge3NjYWxlfSA9IGV2ZW50O1xuICAgIGNvbnN0IG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS56b29tKHtwb3MsIHNjYWxlfSk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUpO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciB0aGUgYHBpbmNoZW5kYCBldmVudC5cbiAgX29uUGluY2hFbmQoZXZlbnQpIHtcbiAgICBjb25zdCBuZXdNYXBTdGF0ZSA9IHRoaXMubWFwU3RhdGUuem9vbUVuZCgpO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld01hcFN0YXRlLCB7aXNEcmFnZ2luZzogZmFsc2V9KTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBkb3VibGV0YXBgIGV2ZW50LlxuICBfb25Eb3VibGVUYXAoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZG91YmxlQ2xpY2tab29tKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCBpc1pvb21PdXQgPSB0aGlzLmlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KTtcblxuICAgIGNvbnN0IG5ld01hcFN0YXRlID0gdGhpcy5tYXBTdGF0ZS56b29tKHtwb3MsIHNjYWxlOiBpc1pvb21PdXQgPyAwLjUgOiAyfSk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3TWFwU3RhdGUpO1xuICB9XG59XG4iXX0=