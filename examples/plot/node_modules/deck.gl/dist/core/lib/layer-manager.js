'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _luma = require('luma.gl');

var _seer = require('seer');

var _seer2 = _interopRequireDefault(_seer);

var _layer = require('./layer');

var _layer2 = _interopRequireDefault(_layer);

var _utils = require('./utils');

var _flatten = require('./utils/flatten');

var _drawLayers2 = require('./draw-layers');

var _pickLayers = require('./pick-layers');

var _constants = require('./constants');

var _viewport = require('../viewports/viewport');

var _viewport2 = _interopRequireDefault(_viewport);

var _seerIntegration = require('./seer-integration');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LOG_PRIORITY_LIFECYCLE = 2;
var LOG_PRIORITY_LIFECYCLE_MINOR = 4;

var layerName = function layerName(layer) {
  return layer instanceof _layer2.default ? '' + layer : !layer ? 'null layer' : 'invalid layer';
};

var LayerManager = function () {
  function LayerManager(_ref) {
    var gl = _ref.gl;

    _classCallCheck(this, LayerManager);

    // Currently deck.gl expects the DeckGL.layers array to be different
    // whenever React rerenders. If the same layers array is used, the
    // LayerManager's diffing algorithm will generate a fatal error and
    // break the rendering.

    // `this.lastRenderedLayers` stores the UNFILTERED layers sent
    // down to LayerManager, so that `layers` reference can be compared.
    // If it's the same across two React render calls, the diffing logic
    // will be skipped.
    this.lastRenderedLayers = [];

    this.prevLayers = [];
    this.layers = [];
    this.oldContext = {};
    this.screenCleared = false;
    this._needsRedraw = true;

    this._eventManager = null;
    this._pickingRadius = 0;
    this._onLayerClick = null;
    this._onLayerHover = null;
    this._onClick = this._onClick.bind(this);
    this._onPointerMove = this._onPointerMove.bind(this);
    this._onPointerLeave = this._onPointerLeave.bind(this);
    this._pickAndCallback = this._pickAndCallback.bind(this);

    this._initSeer = this._initSeer.bind(this);
    this._editSeer = this._editSeer.bind(this);

    this.context = {
      gl: gl,
      uniforms: {},
      viewports: [],
      viewport: null,
      viewportChanged: true,
      pickingFBO: null,
      useDevicePixelRatio: true,
      lastPickedInfo: {
        index: -1,
        layerId: null
      },
      shaderCache: new _luma.ShaderCache({ gl: gl })
    };

    (0, _seerIntegration.seerInitListener)(this._initSeer);
    (0, _seerIntegration.layerEditListener)(this._editSeer);

    Object.seal(this.context);
    Object.seal(this);
  }

  /**
   * Method to call when the layer manager is not needed anymore.
   *
   * Currently used in the <DeckGL> componentWillUnmount lifecycle to unbind Seer listeners.
   */


  _createClass(LayerManager, [{
    key: 'finalize',
    value: function finalize() {
      _seer2.default.removeListener(this._initSeer);
      _seer2.default.removeListener(this._editSeer);
    }

    // Gets an (optionally) filtered list of layers

  }, {
    key: 'getLayers',
    value: function getLayers() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === undefined ? null : _ref2$layerIds;

      // Filtering by layerId compares beginning of strings, so that sublayers will be included
      // Dependes on the convention of adding suffixes to the parent's layer name
      return layerIds ? this.layers.filter(function (layer) {
        return layerIds.find(function (layerId) {
          return layer.id.indexOf(layerId) === 0;
        });
      }) : this.layers;
    }
  }, {
    key: 'getViewports',
    value: function getViewports() {
      return this.context.viewports;
    }

    /**
     * Set parameters needed for layer rendering and picking.
     * Parameters are to be passed as a single object, with the following values:
     * @param {Boolean} useDevicePixelRatio
     */

  }, {
    key: 'setParameters',
    value: function setParameters(parameters) {
      if ('eventManager' in parameters) {
        this.initEventHandling(parameters.eventManager);
      }

      if ('pickingRadius' in parameters || 'onLayerClick' in parameters || 'onLayerHover' in parameters) {
        this.setEventHandlingParameters(parameters);
      }

      if ('viewports' in parameters) {
        this.setViewports(parameters.viewports);
      }

      if ('layers' in parameters) {
        this.updateLayers({ newLayers: parameters.layers });
      }

      this.context = Object.assign({}, this.context, parameters);
    }
  }, {
    key: 'setViewports',
    value: function setViewports(viewports) {
      viewports = (0, _flatten.flatten)(viewports, { filter: Boolean });

      // Viewports are "immutable", so we can shallow compare
      var oldViewports = this.context.viewports;
      var viewportsChanged = viewports.length !== oldViewports.length || viewports.some(function (_, i) {
        return viewports[i] !== oldViewports[i];
      });

      if (viewportsChanged) {
        this._needsRedraw = true;

        // Need to ensure one viewport is activated
        var viewport = viewports[0];
        (0, _assert2.default)(viewport instanceof _viewport2.default, 'Invalid viewport');

        this.context.viewports = viewports;
        this._activateViewport(viewport);
      }
    }

    /**
     * @param {Object} eventManager   A source of DOM input events
     */

  }, {
    key: 'initEventHandling',
    value: function initEventHandling(eventManager) {
      this._eventManager = eventManager;

      // TODO: add/remove handlers on demand at runtime, not all at once on init.
      // Consider both top-level handlers like onLayerClick/Hover
      // and per-layer handlers attached to individual layers.
      // https://github.com/uber/deck.gl/issues/634
      this._eventManager.on({
        click: this._onClick,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerLeave
      });
    }

    // Set parameters for input event handling.

  }, {
    key: 'setEventHandlingParameters',
    value: function setEventHandlingParameters(_ref3) {
      var pickingRadius = _ref3.pickingRadius,
          onLayerClick = _ref3.onLayerClick,
          onLayerHover = _ref3.onLayerHover;

      if (!isNaN(pickingRadius)) {
        this._pickingRadius = pickingRadius;
      }
      if (typeof onLayerClick !== 'undefined') {
        this._onLayerClick = onLayerClick;
      }
      if (typeof onLayerHover !== 'undefined') {
        this._onLayerHover = onLayerHover;
      }
      this._validateEventHandling();
    }
  }, {
    key: 'updateLayers',
    value: function updateLayers(_ref4) {
      var newLayers = _ref4.newLayers;

      // TODO - something is generating state updates that cause rerender of the same
      if (newLayers === this.lastRenderedLayers) {
        _utils.log.log(3, 'Ignoring layer update due to layer array not changed');
        return this;
      }
      this.lastRenderedLayers = newLayers;

      (0, _assert2.default)(this.context.viewport, 'LayerManager.updateLayers: viewport not set');

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return newLayer !== null;
      });

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = newLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;

          layer.context = this.context;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.prevLayers = this.layers;

      var _updateLayers2 = this._updateLayers({
        oldLayers: this.prevLayers,
        newLayers: newLayers
      }),
          error = _updateLayers2.error,
          generatedLayers = _updateLayers2.generatedLayers;

      this.layers = generatedLayers;
      // Throw first error found, if any
      if (error) {
        throw error;
      }
      return this;
    }
  }, {
    key: 'drawLayers',
    value: function drawLayers(_ref5) {
      var _ref5$pass = _ref5.pass,
          pass = _ref5$pass === undefined ? 'render to screen' : _ref5$pass;
      var _context = this.context,
          gl = _context.gl,
          useDevicePixelRatio = _context.useDevicePixelRatio,
          drawPickingColors = _context.drawPickingColors;

      // render this viewport

      (0, _drawLayers2.drawLayers)(gl, {
        pass: pass,
        layers: this.layers,
        viewports: this.context.viewports,
        onViewportActive: this._activateViewport.bind(this),
        useDevicePixelRatio: useDevicePixelRatio,
        drawPickingColors: drawPickingColors
      });

      return this;
    }

    // Pick the closest info at given coordinate

  }, {
    key: 'pickObject',
    value: function pickObject(_ref6) {
      var x = _ref6.x,
          y = _ref6.y,
          mode = _ref6.mode,
          _ref6$radius = _ref6.radius,
          radius = _ref6$radius === undefined ? 0 : _ref6$radius,
          layerIds = _ref6.layerIds;
      var _context2 = this.context,
          gl = _context2.gl,
          useDevicePixelRatio = _context2.useDevicePixelRatio;


      var layers = this.getLayers({ layerIds: layerIds });

      return (0, _pickLayers.pickObject)(gl, {
        x: x,
        y: y,
        radius: radius,
        layers: layers,
        mode: mode,
        viewports: this.context.viewports,
        onViewportActive: this._activateViewport.bind(this),
        pickingFBO: this._getPickingBuffer(),
        lastPickedInfo: this.context.lastPickedInfo,
        useDevicePixelRatio: useDevicePixelRatio
      });
    }

    // Get all unique infos within a bounding box

  }, {
    key: 'pickVisibleObjects',
    value: function pickVisibleObjects(_ref7) {
      var x = _ref7.x,
          y = _ref7.y,
          width = _ref7.width,
          height = _ref7.height,
          layerIds = _ref7.layerIds;
      var _context3 = this.context,
          gl = _context3.gl,
          useDevicePixelRatio = _context3.useDevicePixelRatio;


      var layers = this.getLayers({ layerIds: layerIds });

      return (0, _pickLayers.pickVisibleObjects)(gl, {
        x: x,
        y: y,
        width: width,
        height: height,
        layers: layers,
        mode: 'query',
        // TODO - how does this interact with multiple viewports?
        viewport: this.context.viewport,
        viewports: this.context.viewports,
        onViewportActive: this._activateViewport.bind(this),
        pickingFBO: this._getPickingBuffer(),
        useDevicePixelRatio: useDevicePixelRatio
      });
    }
  }, {
    key: 'needsRedraw',
    value: function needsRedraw() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref8$clearRedrawFlag = _ref8.clearRedrawFlags,
          clearRedrawFlags = _ref8$clearRedrawFlag === undefined ? false : _ref8$clearRedrawFlag;

      if (!this.context.viewport) {
        return false;
      }

      var redraw = this._needsRedraw;
      if (clearRedrawFlags) {
        this._needsRedraw = false;
      }

      // Make sure that buffer is cleared once when layer list becomes empty
      if (this.layers.length === 0) {
        if (this.screenCleared === false) {
          redraw = true;
          this.screenCleared = true;
          return true;
        }
      } else if (this.screenCleared === true) {
        this.screenCleared = false;
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var layer = _step2.value;

          redraw = redraw || layer.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return redraw;
    }

    //
    // DEPRECATED METHODS
    //

  }, {
    key: 'setViewport',
    value: function setViewport(viewport) {
      _utils.log.deprecated('setViewport', 'setViewports');
      this.setViewports([viewport]);
      return this;
    }

    //
    // PRIVATE METHODS
    //

    // Make a viewport "current" in layer context, primed for draw

  }, {
    key: '_activateViewport',
    value: function _activateViewport(viewport) {
      // TODO - viewport change detection breaks METER_OFFSETS mode
      // const oldViewport = this.context.viewport;
      // const viewportChanged = !oldViewport || !viewport.equals(oldViewport);
      var viewportChanged = true;

      if (viewportChanged) {
        Object.assign(this.oldContext, this.context);
        this.context.viewport = viewport;
        this.context.viewportChanged = true;
        this.context.uniforms = {};
        (0, _utils.log)(4, viewport);

        // Update layers states
        // Let screen space layers update their state based on viewport
        // TODO - reimplement viewport change detection (single viewport optimization)
        // TODO - don't set viewportChanged during setViewports?
        if (this.context.viewportChanged) {
          this._updateLayerStates({ viewportChanged: true });
        }
      }

      (0, _assert2.default)(this.context.viewport, 'LayerManager: viewport not set');

      return this;
    }

    // Walk the layers and update their states

  }, {
    key: '_updateLayerStates',
    value: function _updateLayerStates(changeFlags) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.layers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var layer = _step3.value;

          layer.updateLayer({ changeFlags: changeFlags });
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }

    // Get a viewport from a viewport descriptor (which can be a plain viewport)

  }, {
    key: '_getViewportFromDescriptor',
    value: function _getViewportFromDescriptor(viewportOrDescriptor) {
      return viewportOrDescriptor.viewport ? viewportOrDescriptor.viewport : viewportOrDescriptor;
    }
  }, {
    key: '_getPickingBuffer',
    value: function _getPickingBuffer() {
      var gl = this.context.gl;
      // Create a frame buffer if not already available

      this.context.pickingFBO = this.context.pickingFBO || new _luma.Framebuffer(gl);
      // Resize it to current canvas size (this is a noop if size hasn't changed)
      this.context.pickingFBO.resize({ width: gl.canvas.width, height: gl.canvas.height });
      return this.context.pickingFBO;
    }

    // Match all layers, checking for caught errors
    // To avoid having an exception in one layer disrupt other layers
    // TODO - mark layers with exceptions as bad and remove from rendering cycle?

  }, {
    key: '_updateLayers',
    value: function _updateLayers(_ref9) {
      var oldLayers = _ref9.oldLayers,
          newLayers = _ref9.newLayers;

      // Create old layer map
      var oldLayerMap = {};
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = oldLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var oldLayer = _step4.value;

          if (oldLayerMap[oldLayer.id]) {
            _utils.log.once(0, 'Multiple old layers with same id ' + layerName(oldLayer));
          } else {
            oldLayerMap[oldLayer.id] = oldLayer;
            oldLayer.lifecycle = _constants.LIFECYCLE.AWAITING_FINALIZATION;
          }
        }

        // Allocate array for generated layers
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      var generatedLayers = [];

      // Match sublayers
      var error = this._matchSublayers({
        newLayers: newLayers, oldLayerMap: oldLayerMap, generatedLayers: generatedLayers
      });

      var error2 = this._finalizeOldLayers(oldLayers);
      var firstError = error || error2;
      return { error: firstError, generatedLayers: generatedLayers };
    }

    /* eslint-disable max-statements */

  }, {
    key: '_matchSublayers',
    value: function _matchSublayers(_ref10) {
      var _this = this;

      var newLayers = _ref10.newLayers,
          oldLayerMap = _ref10.oldLayerMap,
          generatedLayers = _ref10.generatedLayers;

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return newLayer !== null;
      });

      var error = null;
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        var _loop = function _loop() {
          var newLayer = _step5.value;

          newLayer.context = _this.context;

          try {
            // 1. given a new coming layer, find its matching layer
            var oldLayer = oldLayerMap[newLayer.id];
            oldLayerMap[newLayer.id] = null;

            if (oldLayer === null) {
              _utils.log.once(0, 'Multiple new layers with same id ' + layerName(newLayer));
            }

            // Only transfer state at this stage. We must not generate exceptions
            // until all layers' state have been transferred
            if (oldLayer) {
              _this._transferLayerState(oldLayer, newLayer);
              _this._updateLayer(newLayer);

              (0, _seerIntegration.updateLayerInSeer)(newLayer); // Initializes layer in seer chrome extension (if connected)
            } else {
              _this._initializeNewLayer(newLayer);

              (0, _seerIntegration.initLayerInSeer)(newLayer); // Initializes layer in seer chrome extension (if connected)
            }
            generatedLayers.push(newLayer);

            // Call layer lifecycle method: render sublayers
            var props = newLayer.props,
                oldProps = newLayer.oldProps;

            var sublayers = newLayer.isComposite ? newLayer._renderLayers({
              oldProps: oldProps,
              props: props,
              context: _this.context,
              oldContext: _this.oldContext,
              changeFlags: newLayer.diffProps(oldProps, props, _this.context)
            }) : null;
            // End layer lifecycle method: render sublayers

            if (sublayers) {
              // Flatten the returned array, removing any null, undefined or false
              // this allows layers to render sublayers conditionally
              // (see CompositeLayer.renderLayers docs)
              sublayers = (0, _flatten.flatten)(sublayers, { filter: Boolean });

              // populate reference to parent layer
              sublayers.forEach(function (layer) {
                layer.parentLayer = newLayer;
              });

              _this._matchSublayers({
                newLayers: sublayers,
                oldLayerMap: oldLayerMap,
                generatedLayers: generatedLayers
              });
            }
          } catch (err) {
            _utils.log.once(0, 'error during matching of ' + layerName(newLayer), err);
            // Save first error
            error = error || err;
          }
        };

        for (var _iterator5 = newLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return error;
    }
  }, {
    key: '_transferLayerState',
    value: function _transferLayerState(oldLayer, newLayer) {
      var state = oldLayer.state,
          props = oldLayer.props;

      // sanity check

      (0, _assert2.default)(state, 'deck.gl sanity check - Matching layer has no state');
      if (newLayer !== oldLayer) {
        (0, _utils.log)(LOG_PRIORITY_LIFECYCLE_MINOR, 'matched ' + layerName(newLayer), oldLayer, '->', newLayer);

        // Move state
        state.layer = newLayer;
        newLayer.state = state;

        // Update model layer reference
        if (state.model) {
          state.model.userData.layer = newLayer;
        }
        // Keep a temporary ref to the old props, for prop comparison
        newLayer.oldProps = props;
        // oldLayer.state = null;

        newLayer.lifecycle = _constants.LIFECYCLE.MATCHED;
        oldLayer.lifecycle = _constants.LIFECYCLE.AWAITING_GC;
      } else {
        _utils.log.log(LOG_PRIORITY_LIFECYCLE_MINOR, 'Matching layer is unchanged ' + newLayer.id);
        newLayer.lifecycle = _constants.LIFECYCLE.MATCHED;
        newLayer.oldProps = newLayer.props;
        // TODO - we could avoid prop comparisons in this case
      }
    }

    // Update the old layers that were not matched

  }, {
    key: '_finalizeOldLayers',
    value: function _finalizeOldLayers(oldLayers) {
      var error = null;
      // Matched layers have lifecycle state "outdated"
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = oldLayers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var layer = _step6.value;

          if (layer.lifecycle === _constants.LIFECYCLE.AWAITING_FINALIZATION) {
            error = error || this._finalizeLayer(layer);
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return error;
    }

    // Initializes a single layer, calling layer methods

  }, {
    key: '_initializeNewLayer',
    value: function _initializeNewLayer(layer) {
      var error = null;
      // Check if new layer, and initialize it's state
      if (!layer.state) {
        (0, _utils.log)(LOG_PRIORITY_LIFECYCLE, 'initializing ' + layerName(layer));
        try {

          layer.initializeLayer({
            oldProps: {},
            props: layer.props,
            oldContext: this.oldContext,
            context: this.context,
            changeFlags: layer.diffProps({}, layer.props, this.context)
          });

          layer.lifecycle = _constants.LIFECYCLE.INITIALIZED;
        } catch (err) {
          _utils.log.once(0, 'error while initializing ' + layerName(layer) + '\n', err);
          // Save first error
          error = error || err;
        }
        // Set back pointer (used in picking)
        if (layer.state) {
          layer.state.layer = layer;
          // Save layer on model for picking purposes
          // TODO - store on model.userData rather than directly on model
        }
        if (layer.state && layer.state.model) {
          layer.state.model.userData.layer = layer;
        }
      }
      return error;
    }

    // Updates a single layer, calling layer methods

  }, {
    key: '_updateLayer',
    value: function _updateLayer(layer) {
      var oldProps = layer.oldProps,
          props = layer.props;

      var error = null;
      if (oldProps) {
        try {
          layer.updateLayer({
            oldProps: oldProps,
            props: props,
            context: this.context,
            oldContext: this.oldContext,
            changeFlags: layer.diffProps(oldProps, layer.props, this.context)
          });
        } catch (err) {
          _utils.log.once(0, 'error during update of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        (0, _utils.log)(LOG_PRIORITY_LIFECYCLE_MINOR, 'updating ' + layerName(layer));
      }
      return error;
    }

    // Finalizes a single layer

  }, {
    key: '_finalizeLayer',
    value: function _finalizeLayer(layer) {
      var error = null;
      var state = layer.state;

      if (state) {
        try {
          layer.finalizeLayer();
        } catch (err) {
          _utils.log.once(0, 'error during finalization of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        // layer.state = null;
        layer.lifecycle = _constants.LIFECYCLE.FINALIZED;
        (0, _utils.log)(LOG_PRIORITY_LIFECYCLE, 'finalizing ' + layerName(layer));
      }
      return error;
    }

    /**
     * Warn if a deck-level mouse event has been specified,
     * but no layers are `pickable`.
     */

  }, {
    key: '_validateEventHandling',
    value: function _validateEventHandling() {
      if (this.onLayerClick || this.onLayerHover) {
        if (this.layers.length && !this.layers.some(function (layer) {
          return layer.props.pickable;
        })) {
          _utils.log.warn(1, 'You have supplied a top-level input event handler (e.g. `onLayerClick`), ' + 'but none of your layers have set the `pickable` flag.');
        }
      }
    }

    /**
     * Route click events to layers.
     * `pickLayer` will call the `onClick` prop of any picked layer,
     * and `onLayerClick` is called directly from here
     * with any picking info generated by `pickLayer`.
     * @param {Object} event  An object encapsulating an input event,
     *                        with the following shape:
     *                        {Object: {x, y}} offsetCenter: center of the event
     *                        {Object} srcEvent:             native JS Event object
     */

  }, {
    key: '_onClick',
    value: function _onClick(event) {
      if (!event.offsetCenter) {
        // Do not trigger onHover callbacks when click position is invalid.
        return;
      }
      this._pickAndCallback({
        callback: this._onLayerClick,
        event: event,
        mode: 'click'
      });
    }

    /**
     * Route click events to layers.
     * `pickLayer` will call the `onHover` prop of any picked layer,
     * and `onLayerHover` is called directly from here
     * with any picking info generated by `pickLayer`.
     * @param {Object} event  An object encapsulating an input event,
     *                        with the following shape:
     *                        {Object: {x, y}} offsetCenter: center of the event
     *                        {Object} srcEvent:             native JS Event object
     */

  }, {
    key: '_onPointerMove',
    value: function _onPointerMove(event) {
      if (event.isDown) {
        // Do not trigger onHover callbacks if mouse button is down.
        return;
      }
      this._pickAndCallback({
        callback: this._onLayerHover,
        event: event,
        mode: 'hover'
      });
    }
  }, {
    key: '_onPointerLeave',
    value: function _onPointerLeave(event) {
      this.pickObject({
        x: -1,
        y: -1,
        radius: this._pickingRadius,
        mode: 'hover'
      });
    }
  }, {
    key: '_pickAndCallback',
    value: function _pickAndCallback(options) {
      var pos = options.event.offsetCenter;
      var radius = this._pickingRadius;
      var selectedInfos = this.pickObject({ x: pos.x, y: pos.y, radius: radius, mode: options.mode });
      if (options.callback) {
        var firstInfo = selectedInfos.find(function (info) {
          return info.index >= 0;
        }) || null;
        // As per documentation, send null value when no valid object is picked.
        options.callback(firstInfo, selectedInfos, options.event.srcEvent);
      }
    }

    // SEER INTEGRATION

    /**
     * Called upon Seer initialization, manually sends layers data.
     */

  }, {
    key: '_initSeer',
    value: function _initSeer() {
      this.layers.forEach(function (layer) {
        (0, _seerIntegration.initLayerInSeer)(layer);
        (0, _seerIntegration.updateLayerInSeer)(layer);
      });
    }

    /**
     * On Seer property edition, set override and update layers.
     */

  }, {
    key: '_editSeer',
    value: function _editSeer(payload) {
      if (payload.type !== 'edit' || payload.valuePath[0] !== 'props') {
        return;
      }

      (0, _seerIntegration.setPropOverrides)(payload.itemKey, payload.valuePath.slice(1), payload.value);
      var newLayers = this.layers.map(function (layer) {
        return new layer.constructor(layer.props);
      });
      this.updateLayers({ newLayers: newLayers });
    }
  }]);

  return LayerManager;
}();

exports.default = LayerManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9sYXllci1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbIkxPR19QUklPUklUWV9MSUZFQ1lDTEUiLCJMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SIiwibGF5ZXJOYW1lIiwibGF5ZXIiLCJMYXllck1hbmFnZXIiLCJnbCIsImxhc3RSZW5kZXJlZExheWVycyIsInByZXZMYXllcnMiLCJsYXllcnMiLCJvbGRDb250ZXh0Iiwic2NyZWVuQ2xlYXJlZCIsIl9uZWVkc1JlZHJhdyIsIl9ldmVudE1hbmFnZXIiLCJfcGlja2luZ1JhZGl1cyIsIl9vbkxheWVyQ2xpY2siLCJfb25MYXllckhvdmVyIiwiX29uQ2xpY2siLCJiaW5kIiwiX29uUG9pbnRlck1vdmUiLCJfb25Qb2ludGVyTGVhdmUiLCJfcGlja0FuZENhbGxiYWNrIiwiX2luaXRTZWVyIiwiX2VkaXRTZWVyIiwiY29udGV4dCIsInVuaWZvcm1zIiwidmlld3BvcnRzIiwidmlld3BvcnQiLCJ2aWV3cG9ydENoYW5nZWQiLCJwaWNraW5nRkJPIiwidXNlRGV2aWNlUGl4ZWxSYXRpbyIsImxhc3RQaWNrZWRJbmZvIiwiaW5kZXgiLCJsYXllcklkIiwic2hhZGVyQ2FjaGUiLCJPYmplY3QiLCJzZWFsIiwicmVtb3ZlTGlzdGVuZXIiLCJsYXllcklkcyIsImZpbHRlciIsImZpbmQiLCJpZCIsImluZGV4T2YiLCJwYXJhbWV0ZXJzIiwiaW5pdEV2ZW50SGFuZGxpbmciLCJldmVudE1hbmFnZXIiLCJzZXRFdmVudEhhbmRsaW5nUGFyYW1ldGVycyIsInNldFZpZXdwb3J0cyIsInVwZGF0ZUxheWVycyIsIm5ld0xheWVycyIsImFzc2lnbiIsIkJvb2xlYW4iLCJvbGRWaWV3cG9ydHMiLCJ2aWV3cG9ydHNDaGFuZ2VkIiwibGVuZ3RoIiwic29tZSIsIl8iLCJpIiwiX2FjdGl2YXRlVmlld3BvcnQiLCJvbiIsImNsaWNrIiwicG9pbnRlcm1vdmUiLCJwb2ludGVybGVhdmUiLCJwaWNraW5nUmFkaXVzIiwib25MYXllckNsaWNrIiwib25MYXllckhvdmVyIiwiaXNOYU4iLCJfdmFsaWRhdGVFdmVudEhhbmRsaW5nIiwibG9nIiwibmV3TGF5ZXIiLCJfdXBkYXRlTGF5ZXJzIiwib2xkTGF5ZXJzIiwiZXJyb3IiLCJnZW5lcmF0ZWRMYXllcnMiLCJwYXNzIiwiZHJhd1BpY2tpbmdDb2xvcnMiLCJvblZpZXdwb3J0QWN0aXZlIiwieCIsInkiLCJtb2RlIiwicmFkaXVzIiwiZ2V0TGF5ZXJzIiwiX2dldFBpY2tpbmdCdWZmZXIiLCJ3aWR0aCIsImhlaWdodCIsImNsZWFyUmVkcmF3RmxhZ3MiLCJyZWRyYXciLCJnZXROZWVkc1JlZHJhdyIsImRlcHJlY2F0ZWQiLCJfdXBkYXRlTGF5ZXJTdGF0ZXMiLCJjaGFuZ2VGbGFncyIsInVwZGF0ZUxheWVyIiwidmlld3BvcnRPckRlc2NyaXB0b3IiLCJyZXNpemUiLCJjYW52YXMiLCJvbGRMYXllck1hcCIsIm9sZExheWVyIiwib25jZSIsImxpZmVjeWNsZSIsIkFXQUlUSU5HX0ZJTkFMSVpBVElPTiIsIl9tYXRjaFN1YmxheWVycyIsImVycm9yMiIsIl9maW5hbGl6ZU9sZExheWVycyIsImZpcnN0RXJyb3IiLCJfdHJhbnNmZXJMYXllclN0YXRlIiwiX3VwZGF0ZUxheWVyIiwiX2luaXRpYWxpemVOZXdMYXllciIsInB1c2giLCJwcm9wcyIsIm9sZFByb3BzIiwic3VibGF5ZXJzIiwiaXNDb21wb3NpdGUiLCJfcmVuZGVyTGF5ZXJzIiwiZGlmZlByb3BzIiwiZm9yRWFjaCIsInBhcmVudExheWVyIiwiZXJyIiwic3RhdGUiLCJtb2RlbCIsInVzZXJEYXRhIiwiTUFUQ0hFRCIsIkFXQUlUSU5HX0dDIiwiX2ZpbmFsaXplTGF5ZXIiLCJpbml0aWFsaXplTGF5ZXIiLCJJTklUSUFMSVpFRCIsImZpbmFsaXplTGF5ZXIiLCJGSU5BTElaRUQiLCJwaWNrYWJsZSIsIndhcm4iLCJldmVudCIsIm9mZnNldENlbnRlciIsImNhbGxiYWNrIiwiaXNEb3duIiwicGlja09iamVjdCIsIm9wdGlvbnMiLCJwb3MiLCJzZWxlY3RlZEluZm9zIiwiZmlyc3RJbmZvIiwiaW5mbyIsInNyY0V2ZW50IiwicGF5bG9hZCIsInR5cGUiLCJ2YWx1ZVBhdGgiLCJpdGVtS2V5Iiwic2xpY2UiLCJ2YWx1ZSIsIm1hcCIsImNvbnN0cnVjdG9yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7cWpCQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7OztBQVFBLElBQU1BLHlCQUF5QixDQUEvQjtBQUNBLElBQU1DLCtCQUErQixDQUFyQzs7QUFFQSxJQUFNQyxZQUFZLFNBQVpBLFNBQVk7QUFBQSxTQUFTQyx3Q0FDdEJBLEtBRHNCLEdBRXhCLENBQUNBLEtBQUQsR0FBUyxZQUFULEdBQXdCLGVBRlQ7QUFBQSxDQUFsQjs7SUFJcUJDLFk7QUFDbkIsOEJBQWtCO0FBQUEsUUFBTEMsRUFBSyxRQUFMQSxFQUFLOztBQUFBOztBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0QsU0FBS0Msa0JBQUwsR0FBMEIsRUFBMUI7O0FBRUEsU0FBS0MsVUFBTCxHQUFrQixFQUFsQjtBQUNBLFNBQUtDLE1BQUwsR0FBYyxFQUFkO0FBQ0EsU0FBS0MsVUFBTCxHQUFrQixFQUFsQjtBQUNBLFNBQUtDLGFBQUwsR0FBcUIsS0FBckI7QUFDQSxTQUFLQyxZQUFMLEdBQW9CLElBQXBCOztBQUVBLFNBQUtDLGFBQUwsR0FBcUIsSUFBckI7QUFDQSxTQUFLQyxjQUFMLEdBQXNCLENBQXRCO0FBQ0EsU0FBS0MsYUFBTCxHQUFxQixJQUFyQjtBQUNBLFNBQUtDLGFBQUwsR0FBcUIsSUFBckI7QUFDQSxTQUFLQyxRQUFMLEdBQWdCLEtBQUtBLFFBQUwsQ0FBY0MsSUFBZCxDQUFtQixJQUFuQixDQUFoQjtBQUNBLFNBQUtDLGNBQUwsR0FBc0IsS0FBS0EsY0FBTCxDQUFvQkQsSUFBcEIsQ0FBeUIsSUFBekIsQ0FBdEI7QUFDQSxTQUFLRSxlQUFMLEdBQXVCLEtBQUtBLGVBQUwsQ0FBcUJGLElBQXJCLENBQTBCLElBQTFCLENBQXZCO0FBQ0EsU0FBS0csZ0JBQUwsR0FBd0IsS0FBS0EsZ0JBQUwsQ0FBc0JILElBQXRCLENBQTJCLElBQTNCLENBQXhCOztBQUVBLFNBQUtJLFNBQUwsR0FBaUIsS0FBS0EsU0FBTCxDQUFlSixJQUFmLENBQW9CLElBQXBCLENBQWpCO0FBQ0EsU0FBS0ssU0FBTCxHQUFpQixLQUFLQSxTQUFMLENBQWVMLElBQWYsQ0FBb0IsSUFBcEIsQ0FBakI7O0FBRUEsU0FBS00sT0FBTCxHQUFlO0FBQ2JsQixZQURhO0FBRWJtQixnQkFBVSxFQUZHO0FBR2JDLGlCQUFXLEVBSEU7QUFJYkMsZ0JBQVUsSUFKRztBQUtiQyx1QkFBaUIsSUFMSjtBQU1iQyxrQkFBWSxJQU5DO0FBT2JDLDJCQUFxQixJQVBSO0FBUWJDLHNCQUFnQjtBQUNkQyxlQUFPLENBQUMsQ0FETTtBQUVkQyxpQkFBUztBQUZLLE9BUkg7QUFZYkMsbUJBQWEsc0JBQWdCLEVBQUM1QixNQUFELEVBQWhCO0FBWkEsS0FBZjs7QUFlQSwyQ0FBaUIsS0FBS2dCLFNBQXRCO0FBQ0EsNENBQWtCLEtBQUtDLFNBQXZCOztBQUVBWSxXQUFPQyxJQUFQLENBQVksS0FBS1osT0FBakI7QUFDQVcsV0FBT0MsSUFBUCxDQUFZLElBQVo7QUFDRDs7QUFFRDs7Ozs7Ozs7OytCQUtXO0FBQ1QscUJBQUtDLGNBQUwsQ0FBb0IsS0FBS2YsU0FBekI7QUFDQSxxQkFBS2UsY0FBTCxDQUFvQixLQUFLZCxTQUF6QjtBQUNEOztBQUVEOzs7O2dDQUNrQztBQUFBLHNGQUFKLEVBQUk7QUFBQSxpQ0FBdkJlLFFBQXVCO0FBQUEsVUFBdkJBLFFBQXVCLGtDQUFaLElBQVk7O0FBQ2hDO0FBQ0E7QUFDQSxhQUFPQSxXQUNMLEtBQUs3QixNQUFMLENBQVk4QixNQUFaLENBQW1CO0FBQUEsZUFBU0QsU0FBU0UsSUFBVCxDQUFjO0FBQUEsaUJBQVdwQyxNQUFNcUMsRUFBTixDQUFTQyxPQUFULENBQWlCVCxPQUFqQixNQUE4QixDQUF6QztBQUFBLFNBQWQsQ0FBVDtBQUFBLE9BQW5CLENBREssR0FFTCxLQUFLeEIsTUFGUDtBQUdEOzs7bUNBRWM7QUFDYixhQUFPLEtBQUtlLE9BQUwsQ0FBYUUsU0FBcEI7QUFDRDs7QUFFRDs7Ozs7Ozs7a0NBS2NpQixVLEVBQVk7QUFDeEIsVUFBSSxrQkFBa0JBLFVBQXRCLEVBQWtDO0FBQ2hDLGFBQUtDLGlCQUFMLENBQXVCRCxXQUFXRSxZQUFsQztBQUNEOztBQUVELFVBQUksbUJBQW1CRixVQUFuQixJQUNGLGtCQUFrQkEsVUFEaEIsSUFFRixrQkFBa0JBLFVBRnBCLEVBRWdDO0FBQzlCLGFBQUtHLDBCQUFMLENBQWdDSCxVQUFoQztBQUNEOztBQUVELFVBQUksZUFBZUEsVUFBbkIsRUFBK0I7QUFDN0IsYUFBS0ksWUFBTCxDQUFrQkosV0FBV2pCLFNBQTdCO0FBQ0Q7O0FBRUQsVUFBSSxZQUFZaUIsVUFBaEIsRUFBNEI7QUFDMUIsYUFBS0ssWUFBTCxDQUFrQixFQUFDQyxXQUFXTixXQUFXbEMsTUFBdkIsRUFBbEI7QUFDRDs7QUFFRCxXQUFLZSxPQUFMLEdBQWVXLE9BQU9lLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLEtBQUsxQixPQUF2QixFQUFnQ21CLFVBQWhDLENBQWY7QUFDRDs7O2lDQUVZakIsUyxFQUFXO0FBQ3RCQSxrQkFBWSxzQkFBUUEsU0FBUixFQUFtQixFQUFDYSxRQUFRWSxPQUFULEVBQW5CLENBQVo7O0FBRUE7QUFDQSxVQUFNQyxlQUFlLEtBQUs1QixPQUFMLENBQWFFLFNBQWxDO0FBQ0EsVUFBTTJCLG1CQUFtQjNCLFVBQVU0QixNQUFWLEtBQXFCRixhQUFhRSxNQUFsQyxJQUN2QjVCLFVBQVU2QixJQUFWLENBQWUsVUFBQ0MsQ0FBRCxFQUFJQyxDQUFKO0FBQUEsZUFBVS9CLFVBQVUrQixDQUFWLE1BQWlCTCxhQUFhSyxDQUFiLENBQTNCO0FBQUEsT0FBZixDQURGOztBQUdBLFVBQUlKLGdCQUFKLEVBQXNCO0FBQ3BCLGFBQUt6QyxZQUFMLEdBQW9CLElBQXBCOztBQUVBO0FBQ0EsWUFBTWUsV0FBV0QsVUFBVSxDQUFWLENBQWpCO0FBQ0EsOEJBQU9DLHNDQUFQLEVBQXFDLGtCQUFyQzs7QUFFQSxhQUFLSCxPQUFMLENBQWFFLFNBQWIsR0FBeUJBLFNBQXpCO0FBQ0EsYUFBS2dDLGlCQUFMLENBQXVCL0IsUUFBdkI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7c0NBR2tCa0IsWSxFQUFjO0FBQzlCLFdBQUtoQyxhQUFMLEdBQXFCZ0MsWUFBckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFLaEMsYUFBTCxDQUFtQjhDLEVBQW5CLENBQXNCO0FBQ3BCQyxlQUFPLEtBQUszQyxRQURRO0FBRXBCNEMscUJBQWEsS0FBSzFDLGNBRkU7QUFHcEIyQyxzQkFBYyxLQUFLMUM7QUFIQyxPQUF0QjtBQUtEOztBQUVEOzs7O3NEQUtHO0FBQUEsVUFIRDJDLGFBR0MsU0FIREEsYUFHQztBQUFBLFVBRkRDLFlBRUMsU0FGREEsWUFFQztBQUFBLFVBRERDLFlBQ0MsU0FEREEsWUFDQzs7QUFDRCxVQUFJLENBQUNDLE1BQU1ILGFBQU4sQ0FBTCxFQUEyQjtBQUN6QixhQUFLakQsY0FBTCxHQUFzQmlELGFBQXRCO0FBQ0Q7QUFDRCxVQUFJLE9BQU9DLFlBQVAsS0FBd0IsV0FBNUIsRUFBeUM7QUFDdkMsYUFBS2pELGFBQUwsR0FBcUJpRCxZQUFyQjtBQUNEO0FBQ0QsVUFBSSxPQUFPQyxZQUFQLEtBQXdCLFdBQTVCLEVBQXlDO0FBQ3ZDLGFBQUtqRCxhQUFMLEdBQXFCaUQsWUFBckI7QUFDRDtBQUNELFdBQUtFLHNCQUFMO0FBQ0Q7Ozt3Q0FFeUI7QUFBQSxVQUFabEIsU0FBWSxTQUFaQSxTQUFZOztBQUN4QjtBQUNBLFVBQUlBLGNBQWMsS0FBSzFDLGtCQUF2QixFQUEyQztBQUN6QyxtQkFBSTZELEdBQUosQ0FBUSxDQUFSLEVBQVcsc0RBQVg7QUFDQSxlQUFPLElBQVA7QUFDRDtBQUNELFdBQUs3RCxrQkFBTCxHQUEwQjBDLFNBQTFCOztBQUVBLDRCQUFPLEtBQUt6QixPQUFMLENBQWFHLFFBQXBCLEVBQThCLDZDQUE5Qjs7QUFFQTtBQUNBc0Isa0JBQVlBLFVBQVVWLE1BQVYsQ0FBaUI7QUFBQSxlQUFZOEIsYUFBYSxJQUF6QjtBQUFBLE9BQWpCLENBQVo7O0FBWHdCO0FBQUE7QUFBQTs7QUFBQTtBQWF4Qiw2QkFBb0JwQixTQUFwQiw4SEFBK0I7QUFBQSxjQUFwQjdDLEtBQW9COztBQUM3QkEsZ0JBQU1vQixPQUFOLEdBQWdCLEtBQUtBLE9BQXJCO0FBQ0Q7QUFmdUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFpQnhCLFdBQUtoQixVQUFMLEdBQWtCLEtBQUtDLE1BQXZCOztBQWpCd0IsMkJBa0JTLEtBQUs2RCxhQUFMLENBQW1CO0FBQ2xEQyxtQkFBVyxLQUFLL0QsVUFEa0M7QUFFbER5QztBQUZrRCxPQUFuQixDQWxCVDtBQUFBLFVBa0JqQnVCLEtBbEJpQixrQkFrQmpCQSxLQWxCaUI7QUFBQSxVQWtCVkMsZUFsQlUsa0JBa0JWQSxlQWxCVTs7QUF1QnhCLFdBQUtoRSxNQUFMLEdBQWNnRSxlQUFkO0FBQ0E7QUFDQSxVQUFJRCxLQUFKLEVBQVc7QUFDVCxjQUFNQSxLQUFOO0FBQ0Q7QUFDRCxhQUFPLElBQVA7QUFDRDs7O3NDQUV1QztBQUFBLDZCQUE1QkUsSUFBNEI7QUFBQSxVQUE1QkEsSUFBNEIsOEJBQXJCLGtCQUFxQjtBQUFBLHFCQUNlLEtBQUtsRCxPQURwQjtBQUFBLFVBQy9CbEIsRUFEK0IsWUFDL0JBLEVBRCtCO0FBQUEsVUFDM0J3QixtQkFEMkIsWUFDM0JBLG1CQUQyQjtBQUFBLFVBQ042QyxpQkFETSxZQUNOQSxpQkFETTs7QUFHdEM7O0FBQ0EsbUNBQVdyRSxFQUFYLEVBQWU7QUFDYm9FLGtCQURhO0FBRWJqRSxnQkFBUSxLQUFLQSxNQUZBO0FBR2JpQixtQkFBVyxLQUFLRixPQUFMLENBQWFFLFNBSFg7QUFJYmtELDBCQUFrQixLQUFLbEIsaUJBQUwsQ0FBdUJ4QyxJQUF2QixDQUE0QixJQUE1QixDQUpMO0FBS2JZLGdEQUxhO0FBTWI2QztBQU5hLE9BQWY7O0FBU0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7c0NBQytDO0FBQUEsVUFBbkNFLENBQW1DLFNBQW5DQSxDQUFtQztBQUFBLFVBQWhDQyxDQUFnQyxTQUFoQ0EsQ0FBZ0M7QUFBQSxVQUE3QkMsSUFBNkIsU0FBN0JBLElBQTZCO0FBQUEsK0JBQXZCQyxNQUF1QjtBQUFBLFVBQXZCQSxNQUF1QixnQ0FBZCxDQUFjO0FBQUEsVUFBWDFDLFFBQVcsU0FBWEEsUUFBVztBQUFBLHNCQUNYLEtBQUtkLE9BRE07QUFBQSxVQUN0Q2xCLEVBRHNDLGFBQ3RDQSxFQURzQztBQUFBLFVBQ2xDd0IsbUJBRGtDLGFBQ2xDQSxtQkFEa0M7OztBQUc3QyxVQUFNckIsU0FBUyxLQUFLd0UsU0FBTCxDQUFlLEVBQUMzQyxrQkFBRCxFQUFmLENBQWY7O0FBRUEsYUFBTyw0QkFBV2hDLEVBQVgsRUFBZTtBQUNwQnVFLFlBRG9CO0FBRXBCQyxZQUZvQjtBQUdwQkUsc0JBSG9CO0FBSXBCdkUsc0JBSm9CO0FBS3BCc0Usa0JBTG9CO0FBTXBCckQsbUJBQVcsS0FBS0YsT0FBTCxDQUFhRSxTQU5KO0FBT3BCa0QsMEJBQWtCLEtBQUtsQixpQkFBTCxDQUF1QnhDLElBQXZCLENBQTRCLElBQTVCLENBUEU7QUFRcEJXLG9CQUFZLEtBQUtxRCxpQkFBTCxFQVJRO0FBU3BCbkQsd0JBQWdCLEtBQUtQLE9BQUwsQ0FBYU8sY0FUVDtBQVVwQkQ7QUFWb0IsT0FBZixDQUFQO0FBWUQ7O0FBRUQ7Ozs7OENBQ29EO0FBQUEsVUFBaEMrQyxDQUFnQyxTQUFoQ0EsQ0FBZ0M7QUFBQSxVQUE3QkMsQ0FBNkIsU0FBN0JBLENBQTZCO0FBQUEsVUFBMUJLLEtBQTBCLFNBQTFCQSxLQUEwQjtBQUFBLFVBQW5CQyxNQUFtQixTQUFuQkEsTUFBbUI7QUFBQSxVQUFYOUMsUUFBVyxTQUFYQSxRQUFXO0FBQUEsc0JBQ2hCLEtBQUtkLE9BRFc7QUFBQSxVQUMzQ2xCLEVBRDJDLGFBQzNDQSxFQUQyQztBQUFBLFVBQ3ZDd0IsbUJBRHVDLGFBQ3ZDQSxtQkFEdUM7OztBQUdsRCxVQUFNckIsU0FBUyxLQUFLd0UsU0FBTCxDQUFlLEVBQUMzQyxrQkFBRCxFQUFmLENBQWY7O0FBRUEsYUFBTyxvQ0FBbUJoQyxFQUFuQixFQUF1QjtBQUM1QnVFLFlBRDRCO0FBRTVCQyxZQUY0QjtBQUc1Qkssb0JBSDRCO0FBSTVCQyxzQkFKNEI7QUFLNUIzRSxzQkFMNEI7QUFNNUJzRSxjQUFNLE9BTnNCO0FBTzVCO0FBQ0FwRCxrQkFBVSxLQUFLSCxPQUFMLENBQWFHLFFBUks7QUFTNUJELG1CQUFXLEtBQUtGLE9BQUwsQ0FBYUUsU0FUSTtBQVU1QmtELDBCQUFrQixLQUFLbEIsaUJBQUwsQ0FBdUJ4QyxJQUF2QixDQUE0QixJQUE1QixDQVZVO0FBVzVCVyxvQkFBWSxLQUFLcUQsaUJBQUwsRUFYZ0I7QUFZNUJwRDtBQVo0QixPQUF2QixDQUFQO0FBY0Q7OztrQ0FFNEM7QUFBQSxzRkFBSixFQUFJO0FBQUEsd0NBQWhDdUQsZ0JBQWdDO0FBQUEsVUFBaENBLGdCQUFnQyx5Q0FBYixLQUFhOztBQUMzQyxVQUFJLENBQUMsS0FBSzdELE9BQUwsQ0FBYUcsUUFBbEIsRUFBNEI7QUFDMUIsZUFBTyxLQUFQO0FBQ0Q7O0FBRUQsVUFBSTJELFNBQVMsS0FBSzFFLFlBQWxCO0FBQ0EsVUFBSXlFLGdCQUFKLEVBQXNCO0FBQ3BCLGFBQUt6RSxZQUFMLEdBQW9CLEtBQXBCO0FBQ0Q7O0FBRUQ7QUFDQSxVQUFJLEtBQUtILE1BQUwsQ0FBWTZDLE1BQVosS0FBdUIsQ0FBM0IsRUFBOEI7QUFDNUIsWUFBSSxLQUFLM0MsYUFBTCxLQUF1QixLQUEzQixFQUFrQztBQUNoQzJFLG1CQUFTLElBQVQ7QUFDQSxlQUFLM0UsYUFBTCxHQUFxQixJQUFyQjtBQUNBLGlCQUFPLElBQVA7QUFDRDtBQUNGLE9BTkQsTUFNTyxJQUFJLEtBQUtBLGFBQUwsS0FBdUIsSUFBM0IsRUFBaUM7QUFDdEMsYUFBS0EsYUFBTCxHQUFxQixLQUFyQjtBQUNEOztBQW5CMEM7QUFBQTtBQUFBOztBQUFBO0FBcUIzQyw4QkFBb0IsS0FBS0YsTUFBekIsbUlBQWlDO0FBQUEsY0FBdEJMLEtBQXNCOztBQUMvQmtGLG1CQUFTQSxVQUFVbEYsTUFBTW1GLGNBQU4sQ0FBcUIsRUFBQ0Ysa0NBQUQsRUFBckIsQ0FBbkI7QUFDRDtBQXZCMEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUF5QjNDLGFBQU9DLE1BQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7Ozs7Z0NBRVkzRCxRLEVBQVU7QUFDcEIsaUJBQUk2RCxVQUFKLENBQWUsYUFBZixFQUE4QixjQUE5QjtBQUNBLFdBQUt6QyxZQUFMLENBQWtCLENBQUNwQixRQUFELENBQWxCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOzs7O3NDQUNrQkEsUSxFQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFVBQU1DLGtCQUFrQixJQUF4Qjs7QUFFQSxVQUFJQSxlQUFKLEVBQXFCO0FBQ25CTyxlQUFPZSxNQUFQLENBQWMsS0FBS3hDLFVBQW5CLEVBQStCLEtBQUtjLE9BQXBDO0FBQ0EsYUFBS0EsT0FBTCxDQUFhRyxRQUFiLEdBQXdCQSxRQUF4QjtBQUNBLGFBQUtILE9BQUwsQ0FBYUksZUFBYixHQUErQixJQUEvQjtBQUNBLGFBQUtKLE9BQUwsQ0FBYUMsUUFBYixHQUF3QixFQUF4QjtBQUNBLHdCQUFJLENBQUosRUFBT0UsUUFBUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUksS0FBS0gsT0FBTCxDQUFhSSxlQUFqQixFQUFrQztBQUNoQyxlQUFLNkQsa0JBQUwsQ0FBd0IsRUFBQzdELGlCQUFpQixJQUFsQixFQUF4QjtBQUNEO0FBQ0Y7O0FBRUQsNEJBQU8sS0FBS0osT0FBTCxDQUFhRyxRQUFwQixFQUE4QixnQ0FBOUI7O0FBRUEsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7dUNBQ21CK0QsVyxFQUFhO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQzlCLDhCQUFvQixLQUFLakYsTUFBekIsbUlBQWlDO0FBQUEsY0FBdEJMLEtBQXNCOztBQUMvQkEsZ0JBQU11RixXQUFOLENBQWtCLEVBQUNELHdCQUFELEVBQWxCO0FBQ0Q7QUFINkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUkvQjs7QUFFRDs7OzsrQ0FDMkJFLG9CLEVBQXNCO0FBQy9DLGFBQU9BLHFCQUFxQmpFLFFBQXJCLEdBQWdDaUUscUJBQXFCakUsUUFBckQsR0FBZ0VpRSxvQkFBdkU7QUFDRDs7O3dDQUVtQjtBQUFBLFVBQ1h0RixFQURXLEdBQ0wsS0FBS2tCLE9BREEsQ0FDWGxCLEVBRFc7QUFFbEI7O0FBQ0EsV0FBS2tCLE9BQUwsQ0FBYUssVUFBYixHQUEwQixLQUFLTCxPQUFMLENBQWFLLFVBQWIsSUFBMkIsc0JBQWdCdkIsRUFBaEIsQ0FBckQ7QUFDQTtBQUNBLFdBQUtrQixPQUFMLENBQWFLLFVBQWIsQ0FBd0JnRSxNQUF4QixDQUErQixFQUFDVixPQUFPN0UsR0FBR3dGLE1BQUgsQ0FBVVgsS0FBbEIsRUFBeUJDLFFBQVE5RSxHQUFHd0YsTUFBSCxDQUFVVixNQUEzQyxFQUEvQjtBQUNBLGFBQU8sS0FBSzVELE9BQUwsQ0FBYUssVUFBcEI7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7Ozs7eUNBQ3NDO0FBQUEsVUFBdkIwQyxTQUF1QixTQUF2QkEsU0FBdUI7QUFBQSxVQUFadEIsU0FBWSxTQUFaQSxTQUFZOztBQUNwQztBQUNBLFVBQU04QyxjQUFjLEVBQXBCO0FBRm9DO0FBQUE7QUFBQTs7QUFBQTtBQUdwQyw4QkFBdUJ4QixTQUF2QixtSUFBa0M7QUFBQSxjQUF2QnlCLFFBQXVCOztBQUNoQyxjQUFJRCxZQUFZQyxTQUFTdkQsRUFBckIsQ0FBSixFQUE4QjtBQUM1Qix1QkFBSXdELElBQUosQ0FBUyxDQUFULHdDQUFnRDlGLFVBQVU2RixRQUFWLENBQWhEO0FBQ0QsV0FGRCxNQUVPO0FBQ0xELHdCQUFZQyxTQUFTdkQsRUFBckIsSUFBMkJ1RCxRQUEzQjtBQUNBQSxxQkFBU0UsU0FBVCxHQUFxQixxQkFBVUMscUJBQS9CO0FBQ0Q7QUFDRjs7QUFFRDtBQVpvQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWFwQyxVQUFNMUIsa0JBQWtCLEVBQXhCOztBQUVBO0FBQ0EsVUFBTUQsUUFBUSxLQUFLNEIsZUFBTCxDQUFxQjtBQUNqQ25ELDRCQURpQyxFQUN0QjhDLHdCQURzQixFQUNUdEI7QUFEUyxPQUFyQixDQUFkOztBQUlBLFVBQU00QixTQUFTLEtBQUtDLGtCQUFMLENBQXdCL0IsU0FBeEIsQ0FBZjtBQUNBLFVBQU1nQyxhQUFhL0IsU0FBUzZCLE1BQTVCO0FBQ0EsYUFBTyxFQUFDN0IsT0FBTytCLFVBQVIsRUFBb0I5QixnQ0FBcEIsRUFBUDtBQUNEOztBQUVEOzs7OzRDQUUyRDtBQUFBOztBQUFBLFVBQTFDeEIsU0FBMEMsVUFBMUNBLFNBQTBDO0FBQUEsVUFBL0I4QyxXQUErQixVQUEvQkEsV0FBK0I7QUFBQSxVQUFsQnRCLGVBQWtCLFVBQWxCQSxlQUFrQjs7QUFDekQ7QUFDQXhCLGtCQUFZQSxVQUFVVixNQUFWLENBQWlCO0FBQUEsZUFBWThCLGFBQWEsSUFBekI7QUFBQSxPQUFqQixDQUFaOztBQUVBLFVBQUlHLFFBQVEsSUFBWjtBQUp5RDtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLGNBSzlDSCxRQUw4Qzs7QUFNdkRBLG1CQUFTN0MsT0FBVCxHQUFtQixNQUFLQSxPQUF4Qjs7QUFFQSxjQUFJO0FBQ0Y7QUFDQSxnQkFBTXdFLFdBQVdELFlBQVkxQixTQUFTNUIsRUFBckIsQ0FBakI7QUFDQXNELHdCQUFZMUIsU0FBUzVCLEVBQXJCLElBQTJCLElBQTNCOztBQUVBLGdCQUFJdUQsYUFBYSxJQUFqQixFQUF1QjtBQUNyQix5QkFBSUMsSUFBSixDQUFTLENBQVQsd0NBQWdEOUYsVUFBVWtFLFFBQVYsQ0FBaEQ7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsZ0JBQUkyQixRQUFKLEVBQWM7QUFDWixvQkFBS1EsbUJBQUwsQ0FBeUJSLFFBQXpCLEVBQW1DM0IsUUFBbkM7QUFDQSxvQkFBS29DLFlBQUwsQ0FBa0JwQyxRQUFsQjs7QUFFQSxzREFBa0JBLFFBQWxCLEVBSlksQ0FJaUI7QUFDOUIsYUFMRCxNQUtPO0FBQ0wsb0JBQUtxQyxtQkFBTCxDQUF5QnJDLFFBQXpCOztBQUVBLG9EQUFnQkEsUUFBaEIsRUFISyxDQUdzQjtBQUM1QjtBQUNESSw0QkFBZ0JrQyxJQUFoQixDQUFxQnRDLFFBQXJCOztBQUVBO0FBdkJFLGdCQXdCS3VDLEtBeEJMLEdBd0J3QnZDLFFBeEJ4QixDQXdCS3VDLEtBeEJMO0FBQUEsZ0JBd0JZQyxRQXhCWixHQXdCd0J4QyxRQXhCeEIsQ0F3Qll3QyxRQXhCWjs7QUF5QkYsZ0JBQUlDLFlBQVl6QyxTQUFTMEMsV0FBVCxHQUF1QjFDLFNBQVMyQyxhQUFULENBQXVCO0FBQzVESCxnQ0FENEQ7QUFFNURELDBCQUY0RDtBQUc1RHBGLHVCQUFTLE1BQUtBLE9BSDhDO0FBSTVEZCwwQkFBWSxNQUFLQSxVQUoyQztBQUs1RGdGLDJCQUFhckIsU0FBUzRDLFNBQVQsQ0FBbUJKLFFBQW5CLEVBQTZCRCxLQUE3QixFQUFvQyxNQUFLcEYsT0FBekM7QUFMK0MsYUFBdkIsQ0FBdkIsR0FNWCxJQU5MO0FBT0E7O0FBRUEsZ0JBQUlzRixTQUFKLEVBQWU7QUFDYjtBQUNBO0FBQ0E7QUFDQUEsMEJBQVksc0JBQVFBLFNBQVIsRUFBbUIsRUFBQ3ZFLFFBQVFZLE9BQVQsRUFBbkIsQ0FBWjs7QUFFQTtBQUNBMkQsd0JBQVVJLE9BQVYsQ0FBa0IsaUJBQVM7QUFDekI5RyxzQkFBTStHLFdBQU4sR0FBb0I5QyxRQUFwQjtBQUNELGVBRkQ7O0FBSUEsb0JBQUsrQixlQUFMLENBQXFCO0FBQ25CbkQsMkJBQVc2RCxTQURRO0FBRW5CZix3Q0FGbUI7QUFHbkJ0QjtBQUhtQixlQUFyQjtBQUtEO0FBQ0YsV0FuREQsQ0FtREUsT0FBTzJDLEdBQVAsRUFBWTtBQUNaLHVCQUFJbkIsSUFBSixDQUFTLENBQVQsZ0NBQXdDOUYsVUFBVWtFLFFBQVYsQ0FBeEMsRUFBK0QrQyxHQUEvRDtBQUNBO0FBQ0E1QyxvQkFBUUEsU0FBUzRDLEdBQWpCO0FBQ0Q7QUEvRHNEOztBQUt6RCw4QkFBdUJuRSxTQUF2QixtSUFBa0M7QUFBQTtBQTJEakM7QUFoRXdEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBaUV6RCxhQUFPdUIsS0FBUDtBQUNEOzs7d0NBRW1Cd0IsUSxFQUFVM0IsUSxFQUFVO0FBQUEsVUFDL0JnRCxLQUQrQixHQUNmckIsUUFEZSxDQUMvQnFCLEtBRCtCO0FBQUEsVUFDeEJULEtBRHdCLEdBQ2ZaLFFBRGUsQ0FDeEJZLEtBRHdCOztBQUd0Qzs7QUFDQSw0QkFBT1MsS0FBUCxFQUFjLG9EQUFkO0FBQ0EsVUFBSWhELGFBQWEyQixRQUFqQixFQUEyQjtBQUN6Qix3QkFBSTlGLDRCQUFKLGVBQ2FDLFVBQVVrRSxRQUFWLENBRGIsRUFDb0MyQixRQURwQyxFQUM4QyxJQUQ5QyxFQUNvRDNCLFFBRHBEOztBQUdBO0FBQ0FnRCxjQUFNakgsS0FBTixHQUFjaUUsUUFBZDtBQUNBQSxpQkFBU2dELEtBQVQsR0FBaUJBLEtBQWpCOztBQUVBO0FBQ0EsWUFBSUEsTUFBTUMsS0FBVixFQUFpQjtBQUNmRCxnQkFBTUMsS0FBTixDQUFZQyxRQUFaLENBQXFCbkgsS0FBckIsR0FBNkJpRSxRQUE3QjtBQUNEO0FBQ0Q7QUFDQUEsaUJBQVN3QyxRQUFULEdBQW9CRCxLQUFwQjtBQUNBOztBQUVBdkMsaUJBQVM2QixTQUFULEdBQXFCLHFCQUFVc0IsT0FBL0I7QUFDQXhCLGlCQUFTRSxTQUFULEdBQXFCLHFCQUFVdUIsV0FBL0I7QUFDRCxPQWxCRCxNQWtCTztBQUNMLG1CQUFJckQsR0FBSixDQUFRbEUsNEJBQVIsbUNBQXFFbUUsU0FBUzVCLEVBQTlFO0FBQ0E0QixpQkFBUzZCLFNBQVQsR0FBcUIscUJBQVVzQixPQUEvQjtBQUNBbkQsaUJBQVN3QyxRQUFULEdBQW9CeEMsU0FBU3VDLEtBQTdCO0FBQ0E7QUFDRDtBQUNGOztBQUVEOzs7O3VDQUNtQnJDLFMsRUFBVztBQUM1QixVQUFJQyxRQUFRLElBQVo7QUFDQTtBQUY0QjtBQUFBO0FBQUE7O0FBQUE7QUFHNUIsOEJBQW9CRCxTQUFwQixtSUFBK0I7QUFBQSxjQUFwQm5FLEtBQW9COztBQUM3QixjQUFJQSxNQUFNOEYsU0FBTixLQUFvQixxQkFBVUMscUJBQWxDLEVBQXlEO0FBQ3ZEM0Isb0JBQVFBLFNBQVMsS0FBS2tELGNBQUwsQ0FBb0J0SCxLQUFwQixDQUFqQjtBQUNEO0FBQ0Y7QUFQMkI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFRNUIsYUFBT29FLEtBQVA7QUFDRDs7QUFFRDs7Ozt3Q0FDb0JwRSxLLEVBQU87QUFDekIsVUFBSW9FLFFBQVEsSUFBWjtBQUNBO0FBQ0EsVUFBSSxDQUFDcEUsTUFBTWlILEtBQVgsRUFBa0I7QUFDaEIsd0JBQUlwSCxzQkFBSixvQkFBNENFLFVBQVVDLEtBQVYsQ0FBNUM7QUFDQSxZQUFJOztBQUVGQSxnQkFBTXVILGVBQU4sQ0FBc0I7QUFDcEJkLHNCQUFVLEVBRFU7QUFFcEJELG1CQUFPeEcsTUFBTXdHLEtBRk87QUFHcEJsRyx3QkFBWSxLQUFLQSxVQUhHO0FBSXBCYyxxQkFBUyxLQUFLQSxPQUpNO0FBS3BCa0UseUJBQWF0RixNQUFNNkcsU0FBTixDQUFnQixFQUFoQixFQUFvQjdHLE1BQU13RyxLQUExQixFQUFpQyxLQUFLcEYsT0FBdEM7QUFMTyxXQUF0Qjs7QUFRQXBCLGdCQUFNOEYsU0FBTixHQUFrQixxQkFBVTBCLFdBQTVCO0FBRUQsU0FaRCxDQVlFLE9BQU9SLEdBQVAsRUFBWTtBQUNaLHFCQUFJbkIsSUFBSixDQUFTLENBQVQsZ0NBQXdDOUYsVUFBVUMsS0FBVixDQUF4QyxTQUE4RGdILEdBQTlEO0FBQ0E7QUFDQTVDLGtCQUFRQSxTQUFTNEMsR0FBakI7QUFDRDtBQUNEO0FBQ0EsWUFBSWhILE1BQU1pSCxLQUFWLEVBQWlCO0FBQ2ZqSCxnQkFBTWlILEtBQU4sQ0FBWWpILEtBQVosR0FBb0JBLEtBQXBCO0FBQ0E7QUFDQTtBQUNEO0FBQ0QsWUFBSUEsTUFBTWlILEtBQU4sSUFBZWpILE1BQU1pSCxLQUFOLENBQVlDLEtBQS9CLEVBQXNDO0FBQ3BDbEgsZ0JBQU1pSCxLQUFOLENBQVlDLEtBQVosQ0FBa0JDLFFBQWxCLENBQTJCbkgsS0FBM0IsR0FBbUNBLEtBQW5DO0FBQ0Q7QUFDRjtBQUNELGFBQU9vRSxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7aUNBQ2FwRSxLLEVBQU87QUFBQSxVQUNYeUcsUUFEVyxHQUNRekcsS0FEUixDQUNYeUcsUUFEVztBQUFBLFVBQ0RELEtBREMsR0FDUXhHLEtBRFIsQ0FDRHdHLEtBREM7O0FBRWxCLFVBQUlwQyxRQUFRLElBQVo7QUFDQSxVQUFJcUMsUUFBSixFQUFjO0FBQ1osWUFBSTtBQUNGekcsZ0JBQU11RixXQUFOLENBQWtCO0FBQ2hCa0IsOEJBRGdCO0FBRWhCRCx3QkFGZ0I7QUFHaEJwRixxQkFBUyxLQUFLQSxPQUhFO0FBSWhCZCx3QkFBWSxLQUFLQSxVQUpEO0FBS2hCZ0YseUJBQWF0RixNQUFNNkcsU0FBTixDQUFnQkosUUFBaEIsRUFBMEJ6RyxNQUFNd0csS0FBaEMsRUFBdUMsS0FBS3BGLE9BQTVDO0FBTEcsV0FBbEI7QUFPRCxTQVJELENBUUUsT0FBTzRGLEdBQVAsRUFBWTtBQUNaLHFCQUFJbkIsSUFBSixDQUFTLENBQVQsOEJBQXNDOUYsVUFBVUMsS0FBVixDQUF0QyxFQUEwRGdILEdBQTFEO0FBQ0E7QUFDQTVDLGtCQUFRNEMsR0FBUjtBQUNEO0FBQ0Qsd0JBQUlsSCw0QkFBSixnQkFBOENDLFVBQVVDLEtBQVYsQ0FBOUM7QUFDRDtBQUNELGFBQU9vRSxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7bUNBQ2VwRSxLLEVBQU87QUFDcEIsVUFBSW9FLFFBQVEsSUFBWjtBQURvQixVQUViNkMsS0FGYSxHQUVKakgsS0FGSSxDQUViaUgsS0FGYTs7QUFHcEIsVUFBSUEsS0FBSixFQUFXO0FBQ1QsWUFBSTtBQUNGakgsZ0JBQU15SCxhQUFOO0FBQ0QsU0FGRCxDQUVFLE9BQU9ULEdBQVAsRUFBWTtBQUNaLHFCQUFJbkIsSUFBSixDQUFTLENBQVQsb0NBQ2tDOUYsVUFBVUMsS0FBVixDQURsQyxFQUNzRGdILEdBRHREO0FBRUE7QUFDQTVDLGtCQUFRNEMsR0FBUjtBQUNEO0FBQ0Q7QUFDQWhILGNBQU04RixTQUFOLEdBQWtCLHFCQUFVNEIsU0FBNUI7QUFDQSx3QkFBSTdILHNCQUFKLGtCQUEwQ0UsVUFBVUMsS0FBVixDQUExQztBQUNEO0FBQ0QsYUFBT29FLEtBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs2Q0FJeUI7QUFDdkIsVUFBSSxLQUFLUixZQUFMLElBQXFCLEtBQUtDLFlBQTlCLEVBQTRDO0FBQzFDLFlBQUksS0FBS3hELE1BQUwsQ0FBWTZDLE1BQVosSUFBc0IsQ0FBQyxLQUFLN0MsTUFBTCxDQUFZOEMsSUFBWixDQUFpQjtBQUFBLGlCQUFTbkQsTUFBTXdHLEtBQU4sQ0FBWW1CLFFBQXJCO0FBQUEsU0FBakIsQ0FBM0IsRUFBNEU7QUFDMUUscUJBQUlDLElBQUosQ0FBUyxDQUFULEVBQ0UsOEVBQ0EsdURBRkY7QUFJRDtBQUNGO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7NkJBVVNDLEssRUFBTztBQUNkLFVBQUksQ0FBQ0EsTUFBTUMsWUFBWCxFQUF5QjtBQUN2QjtBQUNBO0FBQ0Q7QUFDRCxXQUFLN0csZ0JBQUwsQ0FBc0I7QUFDcEI4RyxrQkFBVSxLQUFLcEgsYUFESztBQUVwQmtILG9CQUZvQjtBQUdwQmxELGNBQU07QUFIYyxPQUF0QjtBQUtEOztBQUVEOzs7Ozs7Ozs7Ozs7O21DQVVla0QsSyxFQUFPO0FBQ3BCLFVBQUlBLE1BQU1HLE1BQVYsRUFBa0I7QUFDaEI7QUFDQTtBQUNEO0FBQ0QsV0FBSy9HLGdCQUFMLENBQXNCO0FBQ3BCOEcsa0JBQVUsS0FBS25ILGFBREs7QUFFcEJpSCxvQkFGb0I7QUFHcEJsRCxjQUFNO0FBSGMsT0FBdEI7QUFLRDs7O29DQUVla0QsSyxFQUFPO0FBQ3JCLFdBQUtJLFVBQUwsQ0FBZ0I7QUFDZHhELFdBQUcsQ0FBQyxDQURVO0FBRWRDLFdBQUcsQ0FBQyxDQUZVO0FBR2RFLGdCQUFRLEtBQUtsRSxjQUhDO0FBSWRpRSxjQUFNO0FBSlEsT0FBaEI7QUFNRDs7O3FDQUVnQnVELE8sRUFBUztBQUN4QixVQUFNQyxNQUFNRCxRQUFRTCxLQUFSLENBQWNDLFlBQTFCO0FBQ0EsVUFBTWxELFNBQVMsS0FBS2xFLGNBQXBCO0FBQ0EsVUFBTTBILGdCQUFnQixLQUFLSCxVQUFMLENBQWdCLEVBQUN4RCxHQUFHMEQsSUFBSTFELENBQVIsRUFBV0MsR0FBR3lELElBQUl6RCxDQUFsQixFQUFxQkUsY0FBckIsRUFBNkJELE1BQU11RCxRQUFRdkQsSUFBM0MsRUFBaEIsQ0FBdEI7QUFDQSxVQUFJdUQsUUFBUUgsUUFBWixFQUFzQjtBQUNwQixZQUFNTSxZQUFZRCxjQUFjaEcsSUFBZCxDQUFtQjtBQUFBLGlCQUFRa0csS0FBSzFHLEtBQUwsSUFBYyxDQUF0QjtBQUFBLFNBQW5CLEtBQStDLElBQWpFO0FBQ0E7QUFDQXNHLGdCQUFRSCxRQUFSLENBQWlCTSxTQUFqQixFQUE0QkQsYUFBNUIsRUFBMkNGLFFBQVFMLEtBQVIsQ0FBY1UsUUFBekQ7QUFDRDtBQUNGOztBQUVEOztBQUVBOzs7Ozs7Z0NBR1k7QUFDVixXQUFLbEksTUFBTCxDQUFZeUcsT0FBWixDQUFvQixpQkFBUztBQUMzQiw4Q0FBZ0I5RyxLQUFoQjtBQUNBLGdEQUFrQkEsS0FBbEI7QUFDRCxPQUhEO0FBSUQ7O0FBRUQ7Ozs7Ozs4QkFHVXdJLE8sRUFBUztBQUNqQixVQUFJQSxRQUFRQyxJQUFSLEtBQWlCLE1BQWpCLElBQTJCRCxRQUFRRSxTQUFSLENBQWtCLENBQWxCLE1BQXlCLE9BQXhELEVBQWlFO0FBQy9EO0FBQ0Q7O0FBRUQsNkNBQWlCRixRQUFRRyxPQUF6QixFQUFrQ0gsUUFBUUUsU0FBUixDQUFrQkUsS0FBbEIsQ0FBd0IsQ0FBeEIsQ0FBbEMsRUFBOERKLFFBQVFLLEtBQXRFO0FBQ0EsVUFBTWhHLFlBQVksS0FBS3hDLE1BQUwsQ0FBWXlJLEdBQVosQ0FBZ0I7QUFBQSxlQUFTLElBQUk5SSxNQUFNK0ksV0FBVixDQUFzQi9JLE1BQU13RyxLQUE1QixDQUFUO0FBQUEsT0FBaEIsQ0FBbEI7QUFDQSxXQUFLNUQsWUFBTCxDQUFrQixFQUFDQyxvQkFBRCxFQUFsQjtBQUNEOzs7Ozs7a0JBcHBCa0I1QyxZIiwiZmlsZSI6ImxheWVyLW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHtGcmFtZWJ1ZmZlciwgU2hhZGVyQ2FjaGV9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHNlZXIgZnJvbSAnc2Vlcic7XG5pbXBvcnQgTGF5ZXIgZnJvbSAnLi9sYXllcic7XG5pbXBvcnQge2xvZ30gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge2ZsYXR0ZW59IGZyb20gJy4vdXRpbHMvZmxhdHRlbic7XG5pbXBvcnQge2RyYXdMYXllcnN9IGZyb20gJy4vZHJhdy1sYXllcnMnO1xuaW1wb3J0IHtwaWNrT2JqZWN0LCBwaWNrVmlzaWJsZU9iamVjdHN9IGZyb20gJy4vcGljay1sYXllcnMnO1xuaW1wb3J0IHtMSUZFQ1lDTEV9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBWaWV3cG9ydCBmcm9tICcuLi92aWV3cG9ydHMvdmlld3BvcnQnO1xuaW1wb3J0IHtcbiAgc2V0UHJvcE92ZXJyaWRlcyxcbiAgbGF5ZXJFZGl0TGlzdGVuZXIsXG4gIHNlZXJJbml0TGlzdGVuZXIsXG4gIGluaXRMYXllckluU2VlcixcbiAgdXBkYXRlTGF5ZXJJblNlZXJcbn0gZnJvbSAnLi9zZWVyLWludGVncmF0aW9uJztcblxuY29uc3QgTE9HX1BSSU9SSVRZX0xJRkVDWUNMRSA9IDI7XG5jb25zdCBMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SID0gNDtcblxuY29uc3QgbGF5ZXJOYW1lID0gbGF5ZXIgPT4gbGF5ZXIgaW5zdGFuY2VvZiBMYXllciA/XG4gIGAke2xheWVyfWAgOlxuICAoIWxheWVyID8gJ251bGwgbGF5ZXInIDogJ2ludmFsaWQgbGF5ZXInKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXJNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Ioe2dsfSkge1xuICAgICAvLyBDdXJyZW50bHkgZGVjay5nbCBleHBlY3RzIHRoZSBEZWNrR0wubGF5ZXJzIGFycmF5IHRvIGJlIGRpZmZlcmVudFxuICAgICAvLyB3aGVuZXZlciBSZWFjdCByZXJlbmRlcnMuIElmIHRoZSBzYW1lIGxheWVycyBhcnJheSBpcyB1c2VkLCB0aGVcbiAgICAgLy8gTGF5ZXJNYW5hZ2VyJ3MgZGlmZmluZyBhbGdvcml0aG0gd2lsbCBnZW5lcmF0ZSBhIGZhdGFsIGVycm9yIGFuZFxuICAgICAvLyBicmVhayB0aGUgcmVuZGVyaW5nLlxuXG4gICAgIC8vIGB0aGlzLmxhc3RSZW5kZXJlZExheWVyc2Agc3RvcmVzIHRoZSBVTkZJTFRFUkVEIGxheWVycyBzZW50XG4gICAgIC8vIGRvd24gdG8gTGF5ZXJNYW5hZ2VyLCBzbyB0aGF0IGBsYXllcnNgIHJlZmVyZW5jZSBjYW4gYmUgY29tcGFyZWQuXG4gICAgIC8vIElmIGl0J3MgdGhlIHNhbWUgYWNyb3NzIHR3byBSZWFjdCByZW5kZXIgY2FsbHMsIHRoZSBkaWZmaW5nIGxvZ2ljXG4gICAgIC8vIHdpbGwgYmUgc2tpcHBlZC5cbiAgICB0aGlzLmxhc3RSZW5kZXJlZExheWVycyA9IFtdO1xuXG4gICAgdGhpcy5wcmV2TGF5ZXJzID0gW107XG4gICAgdGhpcy5sYXllcnMgPSBbXTtcbiAgICB0aGlzLm9sZENvbnRleHQgPSB7fTtcbiAgICB0aGlzLnNjcmVlbkNsZWFyZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9uZWVkc1JlZHJhdyA9IHRydWU7XG5cbiAgICB0aGlzLl9ldmVudE1hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMuX3BpY2tpbmdSYWRpdXMgPSAwO1xuICAgIHRoaXMuX29uTGF5ZXJDbGljayA9IG51bGw7XG4gICAgdGhpcy5fb25MYXllckhvdmVyID0gbnVsbDtcbiAgICB0aGlzLl9vbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uUG9pbnRlck1vdmUgPSB0aGlzLl9vblBvaW50ZXJNb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Qb2ludGVyTGVhdmUgPSB0aGlzLl9vblBvaW50ZXJMZWF2ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3BpY2tBbmRDYWxsYmFjayA9IHRoaXMuX3BpY2tBbmRDYWxsYmFjay5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5faW5pdFNlZXIgPSB0aGlzLl9pbml0U2Vlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2VkaXRTZWVyID0gdGhpcy5fZWRpdFNlZXIuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuY29udGV4dCA9IHtcbiAgICAgIGdsLFxuICAgICAgdW5pZm9ybXM6IHt9LFxuICAgICAgdmlld3BvcnRzOiBbXSxcbiAgICAgIHZpZXdwb3J0OiBudWxsLFxuICAgICAgdmlld3BvcnRDaGFuZ2VkOiB0cnVlLFxuICAgICAgcGlja2luZ0ZCTzogbnVsbCxcbiAgICAgIHVzZURldmljZVBpeGVsUmF0aW86IHRydWUsXG4gICAgICBsYXN0UGlja2VkSW5mbzoge1xuICAgICAgICBpbmRleDogLTEsXG4gICAgICAgIGxheWVySWQ6IG51bGxcbiAgICAgIH0sXG4gICAgICBzaGFkZXJDYWNoZTogbmV3IFNoYWRlckNhY2hlKHtnbH0pXG4gICAgfTtcblxuICAgIHNlZXJJbml0TGlzdGVuZXIodGhpcy5faW5pdFNlZXIpO1xuICAgIGxheWVyRWRpdExpc3RlbmVyKHRoaXMuX2VkaXRTZWVyKTtcblxuICAgIE9iamVjdC5zZWFsKHRoaXMuY29udGV4dCk7XG4gICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHRvIGNhbGwgd2hlbiB0aGUgbGF5ZXIgbWFuYWdlciBpcyBub3QgbmVlZGVkIGFueW1vcmUuXG4gICAqXG4gICAqIEN1cnJlbnRseSB1c2VkIGluIHRoZSA8RGVja0dMPiBjb21wb25lbnRXaWxsVW5tb3VudCBsaWZlY3ljbGUgdG8gdW5iaW5kIFNlZXIgbGlzdGVuZXJzLlxuICAgKi9cbiAgZmluYWxpemUoKSB7XG4gICAgc2Vlci5yZW1vdmVMaXN0ZW5lcih0aGlzLl9pbml0U2Vlcik7XG4gICAgc2Vlci5yZW1vdmVMaXN0ZW5lcih0aGlzLl9lZGl0U2Vlcik7XG4gIH1cblxuICAvLyBHZXRzIGFuIChvcHRpb25hbGx5KSBmaWx0ZXJlZCBsaXN0IG9mIGxheWVyc1xuICBnZXRMYXllcnMoe2xheWVySWRzID0gbnVsbH0gPSB7fSkge1xuICAgIC8vIEZpbHRlcmluZyBieSBsYXllcklkIGNvbXBhcmVzIGJlZ2lubmluZyBvZiBzdHJpbmdzLCBzbyB0aGF0IHN1YmxheWVycyB3aWxsIGJlIGluY2x1ZGVkXG4gICAgLy8gRGVwZW5kZXMgb24gdGhlIGNvbnZlbnRpb24gb2YgYWRkaW5nIHN1ZmZpeGVzIHRvIHRoZSBwYXJlbnQncyBsYXllciBuYW1lXG4gICAgcmV0dXJuIGxheWVySWRzID9cbiAgICAgIHRoaXMubGF5ZXJzLmZpbHRlcihsYXllciA9PiBsYXllcklkcy5maW5kKGxheWVySWQgPT4gbGF5ZXIuaWQuaW5kZXhPZihsYXllcklkKSA9PT0gMCkpIDpcbiAgICAgIHRoaXMubGF5ZXJzO1xuICB9XG5cbiAgZ2V0Vmlld3BvcnRzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQudmlld3BvcnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBwYXJhbWV0ZXJzIG5lZWRlZCBmb3IgbGF5ZXIgcmVuZGVyaW5nIGFuZCBwaWNraW5nLlxuICAgKiBQYXJhbWV0ZXJzIGFyZSB0byBiZSBwYXNzZWQgYXMgYSBzaW5nbGUgb2JqZWN0LCB3aXRoIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZURldmljZVBpeGVsUmF0aW9cbiAgICovXG4gIHNldFBhcmFtZXRlcnMocGFyYW1ldGVycykge1xuICAgIGlmICgnZXZlbnRNYW5hZ2VyJyBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgICB0aGlzLmluaXRFdmVudEhhbmRsaW5nKHBhcmFtZXRlcnMuZXZlbnRNYW5hZ2VyKTtcbiAgICB9XG5cbiAgICBpZiAoJ3BpY2tpbmdSYWRpdXMnIGluIHBhcmFtZXRlcnMgfHxcbiAgICAgICdvbkxheWVyQ2xpY2snIGluIHBhcmFtZXRlcnMgfHxcbiAgICAgICdvbkxheWVySG92ZXInIGluIHBhcmFtZXRlcnMpIHtcbiAgICAgIHRoaXMuc2V0RXZlbnRIYW5kbGluZ1BhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgfVxuXG4gICAgaWYgKCd2aWV3cG9ydHMnIGluIHBhcmFtZXRlcnMpIHtcbiAgICAgIHRoaXMuc2V0Vmlld3BvcnRzKHBhcmFtZXRlcnMudmlld3BvcnRzKTtcbiAgICB9XG5cbiAgICBpZiAoJ2xheWVycycgaW4gcGFyYW1ldGVycykge1xuICAgICAgdGhpcy51cGRhdGVMYXllcnMoe25ld0xheWVyczogcGFyYW1ldGVycy5sYXllcnN9KTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRleHQgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbnRleHQsIHBhcmFtZXRlcnMpO1xuICB9XG5cbiAgc2V0Vmlld3BvcnRzKHZpZXdwb3J0cykge1xuICAgIHZpZXdwb3J0cyA9IGZsYXR0ZW4odmlld3BvcnRzLCB7ZmlsdGVyOiBCb29sZWFufSk7XG5cbiAgICAvLyBWaWV3cG9ydHMgYXJlIFwiaW1tdXRhYmxlXCIsIHNvIHdlIGNhbiBzaGFsbG93IGNvbXBhcmVcbiAgICBjb25zdCBvbGRWaWV3cG9ydHMgPSB0aGlzLmNvbnRleHQudmlld3BvcnRzO1xuICAgIGNvbnN0IHZpZXdwb3J0c0NoYW5nZWQgPSB2aWV3cG9ydHMubGVuZ3RoICE9PSBvbGRWaWV3cG9ydHMubGVuZ3RoIHx8XG4gICAgICB2aWV3cG9ydHMuc29tZSgoXywgaSkgPT4gdmlld3BvcnRzW2ldICE9PSBvbGRWaWV3cG9ydHNbaV0pO1xuXG4gICAgaWYgKHZpZXdwb3J0c0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuX25lZWRzUmVkcmF3ID0gdHJ1ZTtcblxuICAgICAgLy8gTmVlZCB0byBlbnN1cmUgb25lIHZpZXdwb3J0IGlzIGFjdGl2YXRlZFxuICAgICAgY29uc3Qgdmlld3BvcnQgPSB2aWV3cG9ydHNbMF07XG4gICAgICBhc3NlcnQodmlld3BvcnQgaW5zdGFuY2VvZiBWaWV3cG9ydCwgJ0ludmFsaWQgdmlld3BvcnQnKTtcblxuICAgICAgdGhpcy5jb250ZXh0LnZpZXdwb3J0cyA9IHZpZXdwb3J0cztcbiAgICAgIHRoaXMuX2FjdGl2YXRlVmlld3BvcnQodmlld3BvcnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRNYW5hZ2VyICAgQSBzb3VyY2Ugb2YgRE9NIGlucHV0IGV2ZW50c1xuICAgKi9cbiAgaW5pdEV2ZW50SGFuZGxpbmcoZXZlbnRNYW5hZ2VyKSB7XG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuXG4gICAgLy8gVE9ETzogYWRkL3JlbW92ZSBoYW5kbGVycyBvbiBkZW1hbmQgYXQgcnVudGltZSwgbm90IGFsbCBhdCBvbmNlIG9uIGluaXQuXG4gICAgLy8gQ29uc2lkZXIgYm90aCB0b3AtbGV2ZWwgaGFuZGxlcnMgbGlrZSBvbkxheWVyQ2xpY2svSG92ZXJcbiAgICAvLyBhbmQgcGVyLWxheWVyIGhhbmRsZXJzIGF0dGFjaGVkIHRvIGluZGl2aWR1YWwgbGF5ZXJzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91YmVyL2RlY2suZ2wvaXNzdWVzLzYzNFxuICAgIHRoaXMuX2V2ZW50TWFuYWdlci5vbih7XG4gICAgICBjbGljazogdGhpcy5fb25DbGljayxcbiAgICAgIHBvaW50ZXJtb3ZlOiB0aGlzLl9vblBvaW50ZXJNb3ZlLFxuICAgICAgcG9pbnRlcmxlYXZlOiB0aGlzLl9vblBvaW50ZXJMZWF2ZVxuICAgIH0pO1xuICB9XG5cbiAgLy8gU2V0IHBhcmFtZXRlcnMgZm9yIGlucHV0IGV2ZW50IGhhbmRsaW5nLlxuICBzZXRFdmVudEhhbmRsaW5nUGFyYW1ldGVycyh7XG4gICAgcGlja2luZ1JhZGl1cyxcbiAgICBvbkxheWVyQ2xpY2ssXG4gICAgb25MYXllckhvdmVyXG4gIH0pIHtcbiAgICBpZiAoIWlzTmFOKHBpY2tpbmdSYWRpdXMpKSB7XG4gICAgICB0aGlzLl9waWNraW5nUmFkaXVzID0gcGlja2luZ1JhZGl1cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvbkxheWVyQ2xpY2sgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9vbkxheWVyQ2xpY2sgPSBvbkxheWVyQ2xpY2s7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb25MYXllckhvdmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5fb25MYXllckhvdmVyID0gb25MYXllckhvdmVyO1xuICAgIH1cbiAgICB0aGlzLl92YWxpZGF0ZUV2ZW50SGFuZGxpbmcoKTtcbiAgfVxuXG4gIHVwZGF0ZUxheWVycyh7bmV3TGF5ZXJzfSkge1xuICAgIC8vIFRPRE8gLSBzb21ldGhpbmcgaXMgZ2VuZXJhdGluZyBzdGF0ZSB1cGRhdGVzIHRoYXQgY2F1c2UgcmVyZW5kZXIgb2YgdGhlIHNhbWVcbiAgICBpZiAobmV3TGF5ZXJzID09PSB0aGlzLmxhc3RSZW5kZXJlZExheWVycykge1xuICAgICAgbG9nLmxvZygzLCAnSWdub3JpbmcgbGF5ZXIgdXBkYXRlIGR1ZSB0byBsYXllciBhcnJheSBub3QgY2hhbmdlZCcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMubGFzdFJlbmRlcmVkTGF5ZXJzID0gbmV3TGF5ZXJzO1xuXG4gICAgYXNzZXJ0KHRoaXMuY29udGV4dC52aWV3cG9ydCwgJ0xheWVyTWFuYWdlci51cGRhdGVMYXllcnM6IHZpZXdwb3J0IG5vdCBzZXQnKTtcblxuICAgIC8vIEZpbHRlciBvdXQgYW55IG51bGwgbGF5ZXJzXG4gICAgbmV3TGF5ZXJzID0gbmV3TGF5ZXJzLmZpbHRlcihuZXdMYXllciA9PiBuZXdMYXllciAhPT0gbnVsbCk7XG5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIG5ld0xheWVycykge1xuICAgICAgbGF5ZXIuY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZMYXllcnMgPSB0aGlzLmxheWVycztcbiAgICBjb25zdCB7ZXJyb3IsIGdlbmVyYXRlZExheWVyc30gPSB0aGlzLl91cGRhdGVMYXllcnMoe1xuICAgICAgb2xkTGF5ZXJzOiB0aGlzLnByZXZMYXllcnMsXG4gICAgICBuZXdMYXllcnNcbiAgICB9KTtcblxuICAgIHRoaXMubGF5ZXJzID0gZ2VuZXJhdGVkTGF5ZXJzO1xuICAgIC8vIFRocm93IGZpcnN0IGVycm9yIGZvdW5kLCBpZiBhbnlcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRyYXdMYXllcnMoe3Bhc3MgPSAncmVuZGVyIHRvIHNjcmVlbid9KSB7XG4gICAgY29uc3Qge2dsLCB1c2VEZXZpY2VQaXhlbFJhdGlvLCBkcmF3UGlja2luZ0NvbG9yc30gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAvLyByZW5kZXIgdGhpcyB2aWV3cG9ydFxuICAgIGRyYXdMYXllcnMoZ2wsIHtcbiAgICAgIHBhc3MsXG4gICAgICBsYXllcnM6IHRoaXMubGF5ZXJzLFxuICAgICAgdmlld3BvcnRzOiB0aGlzLmNvbnRleHQudmlld3BvcnRzLFxuICAgICAgb25WaWV3cG9ydEFjdGl2ZTogdGhpcy5fYWN0aXZhdGVWaWV3cG9ydC5iaW5kKHRoaXMpLFxuICAgICAgdXNlRGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgIGRyYXdQaWNraW5nQ29sb3JzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFBpY2sgdGhlIGNsb3Nlc3QgaW5mbyBhdCBnaXZlbiBjb29yZGluYXRlXG4gIHBpY2tPYmplY3Qoe3gsIHksIG1vZGUsIHJhZGl1cyA9IDAsIGxheWVySWRzfSkge1xuICAgIGNvbnN0IHtnbCwgdXNlRGV2aWNlUGl4ZWxSYXRpb30gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLmdldExheWVycyh7bGF5ZXJJZHN9KTtcblxuICAgIHJldHVybiBwaWNrT2JqZWN0KGdsLCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHJhZGl1cyxcbiAgICAgIGxheWVycyxcbiAgICAgIG1vZGUsXG4gICAgICB2aWV3cG9ydHM6IHRoaXMuY29udGV4dC52aWV3cG9ydHMsXG4gICAgICBvblZpZXdwb3J0QWN0aXZlOiB0aGlzLl9hY3RpdmF0ZVZpZXdwb3J0LmJpbmQodGhpcyksXG4gICAgICBwaWNraW5nRkJPOiB0aGlzLl9nZXRQaWNraW5nQnVmZmVyKCksXG4gICAgICBsYXN0UGlja2VkSW5mbzogdGhpcy5jb250ZXh0Lmxhc3RQaWNrZWRJbmZvLFxuICAgICAgdXNlRGV2aWNlUGl4ZWxSYXRpb1xuICAgIH0pO1xuICB9XG5cbiAgLy8gR2V0IGFsbCB1bmlxdWUgaW5mb3Mgd2l0aGluIGEgYm91bmRpbmcgYm94XG4gIHBpY2tWaXNpYmxlT2JqZWN0cyh7eCwgeSwgd2lkdGgsIGhlaWdodCwgbGF5ZXJJZHN9KSB7XG4gICAgY29uc3Qge2dsLCB1c2VEZXZpY2VQaXhlbFJhdGlvfSA9IHRoaXMuY29udGV4dDtcblxuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKHtsYXllcklkc30pO1xuXG4gICAgcmV0dXJuIHBpY2tWaXNpYmxlT2JqZWN0cyhnbCwge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxheWVycyxcbiAgICAgIG1vZGU6ICdxdWVyeScsXG4gICAgICAvLyBUT0RPIC0gaG93IGRvZXMgdGhpcyBpbnRlcmFjdCB3aXRoIG11bHRpcGxlIHZpZXdwb3J0cz9cbiAgICAgIHZpZXdwb3J0OiB0aGlzLmNvbnRleHQudmlld3BvcnQsXG4gICAgICB2aWV3cG9ydHM6IHRoaXMuY29udGV4dC52aWV3cG9ydHMsXG4gICAgICBvblZpZXdwb3J0QWN0aXZlOiB0aGlzLl9hY3RpdmF0ZVZpZXdwb3J0LmJpbmQodGhpcyksXG4gICAgICBwaWNraW5nRkJPOiB0aGlzLl9nZXRQaWNraW5nQnVmZmVyKCksXG4gICAgICB1c2VEZXZpY2VQaXhlbFJhdGlvXG4gICAgfSk7XG4gIH1cblxuICBuZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFncyA9IGZhbHNlfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRleHQudmlld3BvcnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgcmVkcmF3ID0gdGhpcy5fbmVlZHNSZWRyYXc7XG4gICAgaWYgKGNsZWFyUmVkcmF3RmxhZ3MpIHtcbiAgICAgIHRoaXMuX25lZWRzUmVkcmF3ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzIGNsZWFyZWQgb25jZSB3aGVuIGxheWVyIGxpc3QgYmVjb21lcyBlbXB0eVxuICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLnNjcmVlbkNsZWFyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJlZHJhdyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2NyZWVuQ2xlYXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zY3JlZW5DbGVhcmVkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLnNjcmVlbkNsZWFyZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzKSB7XG4gICAgICByZWRyYXcgPSByZWRyYXcgfHwgbGF5ZXIuZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3N9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVkcmF3O1xuICB9XG5cbiAgLy9cbiAgLy8gREVQUkVDQVRFRCBNRVRIT0RTXG4gIC8vXG5cbiAgc2V0Vmlld3BvcnQodmlld3BvcnQpIHtcbiAgICBsb2cuZGVwcmVjYXRlZCgnc2V0Vmlld3BvcnQnLCAnc2V0Vmlld3BvcnRzJyk7XG4gICAgdGhpcy5zZXRWaWV3cG9ydHMoW3ZpZXdwb3J0XSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvL1xuICAvLyBQUklWQVRFIE1FVEhPRFNcbiAgLy9cblxuICAvLyBNYWtlIGEgdmlld3BvcnQgXCJjdXJyZW50XCIgaW4gbGF5ZXIgY29udGV4dCwgcHJpbWVkIGZvciBkcmF3XG4gIF9hY3RpdmF0ZVZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgLy8gVE9ETyAtIHZpZXdwb3J0IGNoYW5nZSBkZXRlY3Rpb24gYnJlYWtzIE1FVEVSX09GRlNFVFMgbW9kZVxuICAgIC8vIGNvbnN0IG9sZFZpZXdwb3J0ID0gdGhpcy5jb250ZXh0LnZpZXdwb3J0O1xuICAgIC8vIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9ICFvbGRWaWV3cG9ydCB8fCAhdmlld3BvcnQuZXF1YWxzKG9sZFZpZXdwb3J0KTtcbiAgICBjb25zdCB2aWV3cG9ydENoYW5nZWQgPSB0cnVlO1xuXG4gICAgaWYgKHZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLm9sZENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAgICB0aGlzLmNvbnRleHQudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgIHRoaXMuY29udGV4dC52aWV3cG9ydENoYW5nZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jb250ZXh0LnVuaWZvcm1zID0ge307XG4gICAgICBsb2coNCwgdmlld3BvcnQpO1xuXG4gICAgICAvLyBVcGRhdGUgbGF5ZXJzIHN0YXRlc1xuICAgICAgLy8gTGV0IHNjcmVlbiBzcGFjZSBsYXllcnMgdXBkYXRlIHRoZWlyIHN0YXRlIGJhc2VkIG9uIHZpZXdwb3J0XG4gICAgICAvLyBUT0RPIC0gcmVpbXBsZW1lbnQgdmlld3BvcnQgY2hhbmdlIGRldGVjdGlvbiAoc2luZ2xlIHZpZXdwb3J0IG9wdGltaXphdGlvbilcbiAgICAgIC8vIFRPRE8gLSBkb24ndCBzZXQgdmlld3BvcnRDaGFuZ2VkIGR1cmluZyBzZXRWaWV3cG9ydHM/XG4gICAgICBpZiAodGhpcy5jb250ZXh0LnZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgICB0aGlzLl91cGRhdGVMYXllclN0YXRlcyh7dmlld3BvcnRDaGFuZ2VkOiB0cnVlfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXNzZXJ0KHRoaXMuY29udGV4dC52aWV3cG9ydCwgJ0xheWVyTWFuYWdlcjogdmlld3BvcnQgbm90IHNldCcpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBXYWxrIHRoZSBsYXllcnMgYW5kIHVwZGF0ZSB0aGVpciBzdGF0ZXNcbiAgX3VwZGF0ZUxheWVyU3RhdGVzKGNoYW5nZUZsYWdzKSB7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgbGF5ZXIudXBkYXRlTGF5ZXIoe2NoYW5nZUZsYWdzfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGEgdmlld3BvcnQgZnJvbSBhIHZpZXdwb3J0IGRlc2NyaXB0b3IgKHdoaWNoIGNhbiBiZSBhIHBsYWluIHZpZXdwb3J0KVxuICBfZ2V0Vmlld3BvcnRGcm9tRGVzY3JpcHRvcih2aWV3cG9ydE9yRGVzY3JpcHRvcikge1xuICAgIHJldHVybiB2aWV3cG9ydE9yRGVzY3JpcHRvci52aWV3cG9ydCA/IHZpZXdwb3J0T3JEZXNjcmlwdG9yLnZpZXdwb3J0IDogdmlld3BvcnRPckRlc2NyaXB0b3I7XG4gIH1cblxuICBfZ2V0UGlja2luZ0J1ZmZlcigpIHtcbiAgICBjb25zdCB7Z2x9ID0gdGhpcy5jb250ZXh0O1xuICAgIC8vIENyZWF0ZSBhIGZyYW1lIGJ1ZmZlciBpZiBub3QgYWxyZWFkeSBhdmFpbGFibGVcbiAgICB0aGlzLmNvbnRleHQucGlja2luZ0ZCTyA9IHRoaXMuY29udGV4dC5waWNraW5nRkJPIHx8IG5ldyBGcmFtZWJ1ZmZlcihnbCk7XG4gICAgLy8gUmVzaXplIGl0IHRvIGN1cnJlbnQgY2FudmFzIHNpemUgKHRoaXMgaXMgYSBub29wIGlmIHNpemUgaGFzbid0IGNoYW5nZWQpXG4gICAgdGhpcy5jb250ZXh0LnBpY2tpbmdGQk8ucmVzaXplKHt3aWR0aDogZ2wuY2FudmFzLndpZHRoLCBoZWlnaHQ6IGdsLmNhbnZhcy5oZWlnaHR9KTtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnBpY2tpbmdGQk87XG4gIH1cblxuICAvLyBNYXRjaCBhbGwgbGF5ZXJzLCBjaGVja2luZyBmb3IgY2F1Z2h0IGVycm9yc1xuICAvLyBUbyBhdm9pZCBoYXZpbmcgYW4gZXhjZXB0aW9uIGluIG9uZSBsYXllciBkaXNydXB0IG90aGVyIGxheWVyc1xuICAvLyBUT0RPIC0gbWFyayBsYXllcnMgd2l0aCBleGNlcHRpb25zIGFzIGJhZCBhbmQgcmVtb3ZlIGZyb20gcmVuZGVyaW5nIGN5Y2xlP1xuICBfdXBkYXRlTGF5ZXJzKHtvbGRMYXllcnMsIG5ld0xheWVyc30pIHtcbiAgICAvLyBDcmVhdGUgb2xkIGxheWVyIG1hcFxuICAgIGNvbnN0IG9sZExheWVyTWFwID0ge307XG4gICAgZm9yIChjb25zdCBvbGRMYXllciBvZiBvbGRMYXllcnMpIHtcbiAgICAgIGlmIChvbGRMYXllck1hcFtvbGRMYXllci5pZF0pIHtcbiAgICAgICAgbG9nLm9uY2UoMCwgYE11bHRpcGxlIG9sZCBsYXllcnMgd2l0aCBzYW1lIGlkICR7bGF5ZXJOYW1lKG9sZExheWVyKX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9sZExheWVyTWFwW29sZExheWVyLmlkXSA9IG9sZExheWVyO1xuICAgICAgICBvbGRMYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuQVdBSVRJTkdfRklOQUxJWkFUSU9OO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsbG9jYXRlIGFycmF5IGZvciBnZW5lcmF0ZWQgbGF5ZXJzXG4gICAgY29uc3QgZ2VuZXJhdGVkTGF5ZXJzID0gW107XG5cbiAgICAvLyBNYXRjaCBzdWJsYXllcnNcbiAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoU3VibGF5ZXJzKHtcbiAgICAgIG5ld0xheWVycywgb2xkTGF5ZXJNYXAsIGdlbmVyYXRlZExheWVyc1xuICAgIH0pO1xuXG4gICAgY29uc3QgZXJyb3IyID0gdGhpcy5fZmluYWxpemVPbGRMYXllcnMob2xkTGF5ZXJzKTtcbiAgICBjb25zdCBmaXJzdEVycm9yID0gZXJyb3IgfHwgZXJyb3IyO1xuICAgIHJldHVybiB7ZXJyb3I6IGZpcnN0RXJyb3IsIGdlbmVyYXRlZExheWVyc307XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIF9tYXRjaFN1YmxheWVycyh7bmV3TGF5ZXJzLCBvbGRMYXllck1hcCwgZ2VuZXJhdGVkTGF5ZXJzfSkge1xuICAgIC8vIEZpbHRlciBvdXQgYW55IG51bGwgbGF5ZXJzXG4gICAgbmV3TGF5ZXJzID0gbmV3TGF5ZXJzLmZpbHRlcihuZXdMYXllciA9PiBuZXdMYXllciAhPT0gbnVsbCk7XG5cbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIGZvciAoY29uc3QgbmV3TGF5ZXIgb2YgbmV3TGF5ZXJzKSB7XG4gICAgICBuZXdMYXllci5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyAxLiBnaXZlbiBhIG5ldyBjb21pbmcgbGF5ZXIsIGZpbmQgaXRzIG1hdGNoaW5nIGxheWVyXG4gICAgICAgIGNvbnN0IG9sZExheWVyID0gb2xkTGF5ZXJNYXBbbmV3TGF5ZXIuaWRdO1xuICAgICAgICBvbGRMYXllck1hcFtuZXdMYXllci5pZF0gPSBudWxsO1xuXG4gICAgICAgIGlmIChvbGRMYXllciA9PT0gbnVsbCkge1xuICAgICAgICAgIGxvZy5vbmNlKDAsIGBNdWx0aXBsZSBuZXcgbGF5ZXJzIHdpdGggc2FtZSBpZCAke2xheWVyTmFtZShuZXdMYXllcil9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IHRyYW5zZmVyIHN0YXRlIGF0IHRoaXMgc3RhZ2UuIFdlIG11c3Qgbm90IGdlbmVyYXRlIGV4Y2VwdGlvbnNcbiAgICAgICAgLy8gdW50aWwgYWxsIGxheWVycycgc3RhdGUgaGF2ZSBiZWVuIHRyYW5zZmVycmVkXG4gICAgICAgIGlmIChvbGRMYXllcikge1xuICAgICAgICAgIHRoaXMuX3RyYW5zZmVyTGF5ZXJTdGF0ZShvbGRMYXllciwgbmV3TGF5ZXIpO1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyKG5ld0xheWVyKTtcblxuICAgICAgICAgIHVwZGF0ZUxheWVySW5TZWVyKG5ld0xheWVyKTsgLy8gSW5pdGlhbGl6ZXMgbGF5ZXIgaW4gc2VlciBjaHJvbWUgZXh0ZW5zaW9uIChpZiBjb25uZWN0ZWQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZU5ld0xheWVyKG5ld0xheWVyKTtcblxuICAgICAgICAgIGluaXRMYXllckluU2VlcihuZXdMYXllcik7IC8vIEluaXRpYWxpemVzIGxheWVyIGluIHNlZXIgY2hyb21lIGV4dGVuc2lvbiAoaWYgY29ubmVjdGVkKVxuICAgICAgICB9XG4gICAgICAgIGdlbmVyYXRlZExheWVycy5wdXNoKG5ld0xheWVyKTtcblxuICAgICAgICAvLyBDYWxsIGxheWVyIGxpZmVjeWNsZSBtZXRob2Q6IHJlbmRlciBzdWJsYXllcnNcbiAgICAgICAgY29uc3Qge3Byb3BzLCBvbGRQcm9wc30gPSBuZXdMYXllcjtcbiAgICAgICAgbGV0IHN1YmxheWVycyA9IG5ld0xheWVyLmlzQ29tcG9zaXRlID8gbmV3TGF5ZXIuX3JlbmRlckxheWVycyh7XG4gICAgICAgICAgb2xkUHJvcHMsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgIG9sZENvbnRleHQ6IHRoaXMub2xkQ29udGV4dCxcbiAgICAgICAgICBjaGFuZ2VGbGFnczogbmV3TGF5ZXIuZGlmZlByb3BzKG9sZFByb3BzLCBwcm9wcywgdGhpcy5jb250ZXh0KVxuICAgICAgICB9KSA6IG51bGw7XG4gICAgICAgIC8vIEVuZCBsYXllciBsaWZlY3ljbGUgbWV0aG9kOiByZW5kZXIgc3VibGF5ZXJzXG5cbiAgICAgICAgaWYgKHN1YmxheWVycykge1xuICAgICAgICAgIC8vIEZsYXR0ZW4gdGhlIHJldHVybmVkIGFycmF5LCByZW1vdmluZyBhbnkgbnVsbCwgdW5kZWZpbmVkIG9yIGZhbHNlXG4gICAgICAgICAgLy8gdGhpcyBhbGxvd3MgbGF5ZXJzIHRvIHJlbmRlciBzdWJsYXllcnMgY29uZGl0aW9uYWxseVxuICAgICAgICAgIC8vIChzZWUgQ29tcG9zaXRlTGF5ZXIucmVuZGVyTGF5ZXJzIGRvY3MpXG4gICAgICAgICAgc3VibGF5ZXJzID0gZmxhdHRlbihzdWJsYXllcnMsIHtmaWx0ZXI6IEJvb2xlYW59KTtcblxuICAgICAgICAgIC8vIHBvcHVsYXRlIHJlZmVyZW5jZSB0byBwYXJlbnQgbGF5ZXJcbiAgICAgICAgICBzdWJsYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICAgICAgICBsYXllci5wYXJlbnRMYXllciA9IG5ld0xheWVyO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5fbWF0Y2hTdWJsYXllcnMoe1xuICAgICAgICAgICAgbmV3TGF5ZXJzOiBzdWJsYXllcnMsXG4gICAgICAgICAgICBvbGRMYXllck1hcCxcbiAgICAgICAgICAgIGdlbmVyYXRlZExheWVyc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLm9uY2UoMCwgYGVycm9yIGR1cmluZyBtYXRjaGluZyBvZiAke2xheWVyTmFtZShuZXdMYXllcil9YCwgZXJyKTtcbiAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICBlcnJvciA9IGVycm9yIHx8IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgX3RyYW5zZmVyTGF5ZXJTdGF0ZShvbGRMYXllciwgbmV3TGF5ZXIpIHtcbiAgICBjb25zdCB7c3RhdGUsIHByb3BzfSA9IG9sZExheWVyO1xuXG4gICAgLy8gc2FuaXR5IGNoZWNrXG4gICAgYXNzZXJ0KHN0YXRlLCAnZGVjay5nbCBzYW5pdHkgY2hlY2sgLSBNYXRjaGluZyBsYXllciBoYXMgbm8gc3RhdGUnKTtcbiAgICBpZiAobmV3TGF5ZXIgIT09IG9sZExheWVyKSB7XG4gICAgICBsb2coTE9HX1BSSU9SSVRZX0xJRkVDWUNMRV9NSU5PUixcbiAgICAgICAgYG1hdGNoZWQgJHtsYXllck5hbWUobmV3TGF5ZXIpfWAsIG9sZExheWVyLCAnLT4nLCBuZXdMYXllcik7XG5cbiAgICAgIC8vIE1vdmUgc3RhdGVcbiAgICAgIHN0YXRlLmxheWVyID0gbmV3TGF5ZXI7XG4gICAgICBuZXdMYXllci5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgICAvLyBVcGRhdGUgbW9kZWwgbGF5ZXIgcmVmZXJlbmNlXG4gICAgICBpZiAoc3RhdGUubW9kZWwpIHtcbiAgICAgICAgc3RhdGUubW9kZWwudXNlckRhdGEubGF5ZXIgPSBuZXdMYXllcjtcbiAgICAgIH1cbiAgICAgIC8vIEtlZXAgYSB0ZW1wb3JhcnkgcmVmIHRvIHRoZSBvbGQgcHJvcHMsIGZvciBwcm9wIGNvbXBhcmlzb25cbiAgICAgIG5ld0xheWVyLm9sZFByb3BzID0gcHJvcHM7XG4gICAgICAvLyBvbGRMYXllci5zdGF0ZSA9IG51bGw7XG5cbiAgICAgIG5ld0xheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5NQVRDSEVEO1xuICAgICAgb2xkTGF5ZXIubGlmZWN5Y2xlID0gTElGRUNZQ0xFLkFXQUlUSU5HX0dDO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cubG9nKExPR19QUklPUklUWV9MSUZFQ1lDTEVfTUlOT1IsIGBNYXRjaGluZyBsYXllciBpcyB1bmNoYW5nZWQgJHtuZXdMYXllci5pZH1gKTtcbiAgICAgIG5ld0xheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5NQVRDSEVEO1xuICAgICAgbmV3TGF5ZXIub2xkUHJvcHMgPSBuZXdMYXllci5wcm9wcztcbiAgICAgIC8vIFRPRE8gLSB3ZSBjb3VsZCBhdm9pZCBwcm9wIGNvbXBhcmlzb25zIGluIHRoaXMgY2FzZVxuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgb2xkIGxheWVycyB0aGF0IHdlcmUgbm90IG1hdGNoZWRcbiAgX2ZpbmFsaXplT2xkTGF5ZXJzKG9sZExheWVycykge1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgLy8gTWF0Y2hlZCBsYXllcnMgaGF2ZSBsaWZlY3ljbGUgc3RhdGUgXCJvdXRkYXRlZFwiXG4gICAgZm9yIChjb25zdCBsYXllciBvZiBvbGRMYXllcnMpIHtcbiAgICAgIGlmIChsYXllci5saWZlY3ljbGUgPT09IExJRkVDWUNMRS5BV0FJVElOR19GSU5BTElaQVRJT04pIHtcbiAgICAgICAgZXJyb3IgPSBlcnJvciB8fCB0aGlzLl9maW5hbGl6ZUxheWVyKGxheWVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZXMgYSBzaW5nbGUgbGF5ZXIsIGNhbGxpbmcgbGF5ZXIgbWV0aG9kc1xuICBfaW5pdGlhbGl6ZU5ld0xheWVyKGxheWVyKSB7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAvLyBDaGVjayBpZiBuZXcgbGF5ZXIsIGFuZCBpbml0aWFsaXplIGl0J3Mgc3RhdGVcbiAgICBpZiAoIWxheWVyLnN0YXRlKSB7XG4gICAgICBsb2coTE9HX1BSSU9SSVRZX0xJRkVDWUNMRSwgYGluaXRpYWxpemluZyAke2xheWVyTmFtZShsYXllcil9YCk7XG4gICAgICB0cnkge1xuXG4gICAgICAgIGxheWVyLmluaXRpYWxpemVMYXllcih7XG4gICAgICAgICAgb2xkUHJvcHM6IHt9LFxuICAgICAgICAgIHByb3BzOiBsYXllci5wcm9wcyxcbiAgICAgICAgICBvbGRDb250ZXh0OiB0aGlzLm9sZENvbnRleHQsXG4gICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgIGNoYW5nZUZsYWdzOiBsYXllci5kaWZmUHJvcHMoe30sIGxheWVyLnByb3BzLCB0aGlzLmNvbnRleHQpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5JTklUSUFMSVpFRDtcblxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxvZy5vbmNlKDAsIGBlcnJvciB3aGlsZSBpbml0aWFsaXppbmcgJHtsYXllck5hbWUobGF5ZXIpfVxcbmAsIGVycik7XG4gICAgICAgIC8vIFNhdmUgZmlyc3QgZXJyb3JcbiAgICAgICAgZXJyb3IgPSBlcnJvciB8fCBlcnI7XG4gICAgICB9XG4gICAgICAvLyBTZXQgYmFjayBwb2ludGVyICh1c2VkIGluIHBpY2tpbmcpXG4gICAgICBpZiAobGF5ZXIuc3RhdGUpIHtcbiAgICAgICAgbGF5ZXIuc3RhdGUubGF5ZXIgPSBsYXllcjtcbiAgICAgICAgLy8gU2F2ZSBsYXllciBvbiBtb2RlbCBmb3IgcGlja2luZyBwdXJwb3Nlc1xuICAgICAgICAvLyBUT0RPIC0gc3RvcmUgb24gbW9kZWwudXNlckRhdGEgcmF0aGVyIHRoYW4gZGlyZWN0bHkgb24gbW9kZWxcbiAgICAgIH1cbiAgICAgIGlmIChsYXllci5zdGF0ZSAmJiBsYXllci5zdGF0ZS5tb2RlbCkge1xuICAgICAgICBsYXllci5zdGF0ZS5tb2RlbC51c2VyRGF0YS5sYXllciA9IGxheWVyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvLyBVcGRhdGVzIGEgc2luZ2xlIGxheWVyLCBjYWxsaW5nIGxheWVyIG1ldGhvZHNcbiAgX3VwZGF0ZUxheWVyKGxheWVyKSB7XG4gICAgY29uc3Qge29sZFByb3BzLCBwcm9wc30gPSBsYXllcjtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIGlmIChvbGRQcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGF5ZXIudXBkYXRlTGF5ZXIoe1xuICAgICAgICAgIG9sZFByb3BzLFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgICAgICBvbGRDb250ZXh0OiB0aGlzLm9sZENvbnRleHQsXG4gICAgICAgICAgY2hhbmdlRmxhZ3M6IGxheWVyLmRpZmZQcm9wcyhvbGRQcm9wcywgbGF5ZXIucHJvcHMsIHRoaXMuY29udGV4dClcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLm9uY2UoMCwgYGVycm9yIGR1cmluZyB1cGRhdGUgb2YgJHtsYXllck5hbWUobGF5ZXIpfWAsIGVycik7XG4gICAgICAgIC8vIFNhdmUgZmlyc3QgZXJyb3JcbiAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICB9XG4gICAgICBsb2coTE9HX1BSSU9SSVRZX0xJRkVDWUNMRV9NSU5PUiwgYHVwZGF0aW5nICR7bGF5ZXJOYW1lKGxheWVyKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gRmluYWxpemVzIGEgc2luZ2xlIGxheWVyXG4gIF9maW5hbGl6ZUxheWVyKGxheWVyKSB7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICBjb25zdCB7c3RhdGV9ID0gbGF5ZXI7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsYXllci5maW5hbGl6ZUxheWVyKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLm9uY2UoMCxcbiAgICAgICAgICBgZXJyb3IgZHVyaW5nIGZpbmFsaXphdGlvbiBvZiAke2xheWVyTmFtZShsYXllcil9YCwgZXJyKTtcbiAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgIH1cbiAgICAgIC8vIGxheWVyLnN0YXRlID0gbnVsbDtcbiAgICAgIGxheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5GSU5BTElaRUQ7XG4gICAgICBsb2coTE9HX1BSSU9SSVRZX0xJRkVDWUNMRSwgYGZpbmFsaXppbmcgJHtsYXllck5hbWUobGF5ZXIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvKipcbiAgICogV2FybiBpZiBhIGRlY2stbGV2ZWwgbW91c2UgZXZlbnQgaGFzIGJlZW4gc3BlY2lmaWVkLFxuICAgKiBidXQgbm8gbGF5ZXJzIGFyZSBgcGlja2FibGVgLlxuICAgKi9cbiAgX3ZhbGlkYXRlRXZlbnRIYW5kbGluZygpIHtcbiAgICBpZiAodGhpcy5vbkxheWVyQ2xpY2sgfHwgdGhpcy5vbkxheWVySG92ZXIpIHtcbiAgICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggJiYgIXRoaXMubGF5ZXJzLnNvbWUobGF5ZXIgPT4gbGF5ZXIucHJvcHMucGlja2FibGUpKSB7XG4gICAgICAgIGxvZy53YXJuKDEsXG4gICAgICAgICAgJ1lvdSBoYXZlIHN1cHBsaWVkIGEgdG9wLWxldmVsIGlucHV0IGV2ZW50IGhhbmRsZXIgKGUuZy4gYG9uTGF5ZXJDbGlja2ApLCAnICtcbiAgICAgICAgICAnYnV0IG5vbmUgb2YgeW91ciBsYXllcnMgaGF2ZSBzZXQgdGhlIGBwaWNrYWJsZWAgZmxhZy4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJvdXRlIGNsaWNrIGV2ZW50cyB0byBsYXllcnMuXG4gICAqIGBwaWNrTGF5ZXJgIHdpbGwgY2FsbCB0aGUgYG9uQ2xpY2tgIHByb3Agb2YgYW55IHBpY2tlZCBsYXllcixcbiAgICogYW5kIGBvbkxheWVyQ2xpY2tgIGlzIGNhbGxlZCBkaXJlY3RseSBmcm9tIGhlcmVcbiAgICogd2l0aCBhbnkgcGlja2luZyBpbmZvIGdlbmVyYXRlZCBieSBgcGlja0xheWVyYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50ICBBbiBvYmplY3QgZW5jYXBzdWxhdGluZyBhbiBpbnB1dCBldmVudCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSBmb2xsb3dpbmcgc2hhcGU6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdDoge3gsIHl9fSBvZmZzZXRDZW50ZXI6IGNlbnRlciBvZiB0aGUgZXZlbnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBzcmNFdmVudDogICAgICAgICAgICAgbmF0aXZlIEpTIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgX29uQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50Lm9mZnNldENlbnRlcikge1xuICAgICAgLy8gRG8gbm90IHRyaWdnZXIgb25Ib3ZlciBjYWxsYmFja3Mgd2hlbiBjbGljayBwb3NpdGlvbiBpcyBpbnZhbGlkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9waWNrQW5kQ2FsbGJhY2soe1xuICAgICAgY2FsbGJhY2s6IHRoaXMuX29uTGF5ZXJDbGljayxcbiAgICAgIGV2ZW50LFxuICAgICAgbW9kZTogJ2NsaWNrJ1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvdXRlIGNsaWNrIGV2ZW50cyB0byBsYXllcnMuXG4gICAqIGBwaWNrTGF5ZXJgIHdpbGwgY2FsbCB0aGUgYG9uSG92ZXJgIHByb3Agb2YgYW55IHBpY2tlZCBsYXllcixcbiAgICogYW5kIGBvbkxheWVySG92ZXJgIGlzIGNhbGxlZCBkaXJlY3RseSBmcm9tIGhlcmVcbiAgICogd2l0aCBhbnkgcGlja2luZyBpbmZvIGdlbmVyYXRlZCBieSBgcGlja0xheWVyYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50ICBBbiBvYmplY3QgZW5jYXBzdWxhdGluZyBhbiBpbnB1dCBldmVudCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHRoZSBmb2xsb3dpbmcgc2hhcGU6XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAge09iamVjdDoge3gsIHl9fSBvZmZzZXRDZW50ZXI6IGNlbnRlciBvZiB0aGUgZXZlbnRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0fSBzcmNFdmVudDogICAgICAgICAgICAgbmF0aXZlIEpTIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgX29uUG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuaXNEb3duKSB7XG4gICAgICAvLyBEbyBub3QgdHJpZ2dlciBvbkhvdmVyIGNhbGxiYWNrcyBpZiBtb3VzZSBidXR0b24gaXMgZG93bi5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcGlja0FuZENhbGxiYWNrKHtcbiAgICAgIGNhbGxiYWNrOiB0aGlzLl9vbkxheWVySG92ZXIsXG4gICAgICBldmVudCxcbiAgICAgIG1vZGU6ICdob3ZlcidcbiAgICB9KTtcbiAgfVxuXG4gIF9vblBvaW50ZXJMZWF2ZShldmVudCkge1xuICAgIHRoaXMucGlja09iamVjdCh7XG4gICAgICB4OiAtMSxcbiAgICAgIHk6IC0xLFxuICAgICAgcmFkaXVzOiB0aGlzLl9waWNraW5nUmFkaXVzLFxuICAgICAgbW9kZTogJ2hvdmVyJ1xuICAgIH0pO1xuICB9XG5cbiAgX3BpY2tBbmRDYWxsYmFjayhvcHRpb25zKSB7XG4gICAgY29uc3QgcG9zID0gb3B0aW9ucy5ldmVudC5vZmZzZXRDZW50ZXI7XG4gICAgY29uc3QgcmFkaXVzID0gdGhpcy5fcGlja2luZ1JhZGl1cztcbiAgICBjb25zdCBzZWxlY3RlZEluZm9zID0gdGhpcy5waWNrT2JqZWN0KHt4OiBwb3MueCwgeTogcG9zLnksIHJhZGl1cywgbW9kZTogb3B0aW9ucy5tb2RlfSk7XG4gICAgaWYgKG9wdGlvbnMuY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGZpcnN0SW5mbyA9IHNlbGVjdGVkSW5mb3MuZmluZChpbmZvID0+IGluZm8uaW5kZXggPj0gMCkgfHwgbnVsbDtcbiAgICAgIC8vIEFzIHBlciBkb2N1bWVudGF0aW9uLCBzZW5kIG51bGwgdmFsdWUgd2hlbiBubyB2YWxpZCBvYmplY3QgaXMgcGlja2VkLlxuICAgICAgb3B0aW9ucy5jYWxsYmFjayhmaXJzdEluZm8sIHNlbGVjdGVkSW5mb3MsIG9wdGlvbnMuZXZlbnQuc3JjRXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNFRVIgSU5URUdSQVRJT05cblxuICAvKipcbiAgICogQ2FsbGVkIHVwb24gU2VlciBpbml0aWFsaXphdGlvbiwgbWFudWFsbHkgc2VuZHMgbGF5ZXJzIGRhdGEuXG4gICAqL1xuICBfaW5pdFNlZXIoKSB7XG4gICAgdGhpcy5sYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICBpbml0TGF5ZXJJblNlZXIobGF5ZXIpO1xuICAgICAgdXBkYXRlTGF5ZXJJblNlZXIobGF5ZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE9uIFNlZXIgcHJvcGVydHkgZWRpdGlvbiwgc2V0IG92ZXJyaWRlIGFuZCB1cGRhdGUgbGF5ZXJzLlxuICAgKi9cbiAgX2VkaXRTZWVyKHBheWxvYWQpIHtcbiAgICBpZiAocGF5bG9hZC50eXBlICE9PSAnZWRpdCcgfHwgcGF5bG9hZC52YWx1ZVBhdGhbMF0gIT09ICdwcm9wcycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRQcm9wT3ZlcnJpZGVzKHBheWxvYWQuaXRlbUtleSwgcGF5bG9hZC52YWx1ZVBhdGguc2xpY2UoMSksIHBheWxvYWQudmFsdWUpO1xuICAgIGNvbnN0IG5ld0xheWVycyA9IHRoaXMubGF5ZXJzLm1hcChsYXllciA9PiBuZXcgbGF5ZXIuY29uc3RydWN0b3IobGF5ZXIucHJvcHMpKTtcbiAgICB0aGlzLnVwZGF0ZUxheWVycyh7bmV3TGF5ZXJzfSk7XG4gIH1cbn1cbiJdfQ==