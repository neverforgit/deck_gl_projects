'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPixelRatio = undefined;
exports.drawLayers = drawLayers;
exports.drawPickingBuffer = drawPickingBuffer;

var _luma = require('luma.gl');

var _utils = require('./utils');

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */
var renderCount = 0;

// TODO - Exported for pick-layers.js - Move to util?
var getPixelRatio = exports.getPixelRatio = function getPixelRatio(_ref) {
  var useDevicePixelRatio = _ref.useDevicePixelRatio;
  return useDevicePixelRatio && typeof window !== 'undefined' ? window.devicePixelRatio : 1;
};

// Convert viewport top-left CSS coordinates to bottom up WebGL coordinates
var getGLViewport = function getGLViewport(gl, _ref2) {
  var viewport = _ref2.viewport,
      pixelRatio = _ref2.pixelRatio;

  var width = gl.canvas.clientWidth;
  var height = gl.canvas.clientHeight;
  // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates
  var dimensions = viewport.getDimensions({ width: width, height: height });
  return [dimensions.x * pixelRatio, (height - dimensions.y - dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
};

// Helper functions

function clearCanvas(gl, _ref3) {
  var useDevicePixelRatio = _ref3.useDevicePixelRatio;

  // const pixelRatio = getPixelRatio({useDevicePixelRatio});
  var width = gl.drawingBufferWidth;
  var height = gl.drawingBufferHeight;
  // clear depth and color buffers, restoring transparency
  (0, _luma.withParameters)(gl, { viewport: [0, 0, width, height] }, function () {
    gl.clear(_luma.GL.COLOR_BUFFER_BIT | _luma.GL.DEPTH_BUFFER_BIT);
  });
}

// Draw a list of layers in a list of viewports
function drawLayers(gl, _ref4) {
  var layers = _ref4.layers,
      viewports = _ref4.viewports,
      onViewportActive = _ref4.onViewportActive,
      useDevicePixelRatio = _ref4.useDevicePixelRatio,
      _ref4$drawPickingColo = _ref4.drawPickingColors,
      drawPickingColors = _ref4$drawPickingColo === undefined ? false : _ref4$drawPickingColo,
      _ref4$deviceRect = _ref4.deviceRect,
      deviceRect = _ref4$deviceRect === undefined ? null : _ref4$deviceRect,
      _ref4$parameters = _ref4.parameters,
      parameters = _ref4$parameters === undefined ? {} : _ref4$parameters,
      _ref4$pass = _ref4.pass,
      pass = _ref4$pass === undefined ? 'draw' : _ref4$pass;

  clearCanvas(gl, { useDevicePixelRatio: useDevicePixelRatio });

  // effectManager.preDraw();

  viewports.forEach(function (viewportOrDescriptor, i) {
    var viewport = getViewportFromDescriptor(viewportOrDescriptor);

    // Update context to point to this viewport
    onViewportActive(viewport);

    // render this viewport
    drawLayersInViewport(gl, {
      layers: layers,
      viewport: viewport,
      useDevicePixelRatio: useDevicePixelRatio,
      drawPickingColors: drawPickingColors,
      deviceRect: deviceRect,
      parameters: parameters,
      pass: pass
    });
  });

  // effectManager.draw();
}

// Draws list of layers and viewports into the picking buffer
// Note: does not sample the buffer, that has to be done by the caller
function drawPickingBuffer(gl, _ref5) {
  var layers = _ref5.layers,
      viewports = _ref5.viewports,
      onViewportActive = _ref5.onViewportActive,
      useDevicePixelRatio = _ref5.useDevicePixelRatio,
      pickingFBO = _ref5.pickingFBO,
      _ref5$deviceRect = _ref5.deviceRect,
      x = _ref5$deviceRect.x,
      y = _ref5$deviceRect.y,
      width = _ref5$deviceRect.width,
      height = _ref5$deviceRect.height;

  // Make sure we clear scissor test and fbo bindings in case of exceptions
  // We are only interested in one pixel, no need to render anything else
  // Note that the callback here is called synchronously.
  // Set blend mode for picking
  // always overwrite existing pixel with [r,g,b,layerIndex]
  return (0, _luma.withParameters)(gl, {
    framebuffer: pickingFBO,
    scissorTest: true,
    scissor: [x, y, width, height],
    clearColor: [0, 0, 0, 0]
  }, function () {

    drawLayers(gl, {
      layers: layers,
      viewports: viewports,
      onViewportActive: onViewportActive,
      useDevicePixelRatio: useDevicePixelRatio,
      drawPickingColors: true,
      pass: 'picking',
      parameters: {
        blend: true,
        blendFunc: [gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO],
        blendEquation: gl.FUNC_ADD,
        blendColor: [0, 0, 0, 0]
      }
    });
  });
}

// Draws a list of layers in one viewport
// TODO - when picking we could completely skip rendering viewports that dont
// intersect with the picking rect
function drawLayersInViewport(gl, _ref6) {
  var layers = _ref6.layers,
      viewport = _ref6.viewport,
      useDevicePixelRatio = _ref6.useDevicePixelRatio,
      _ref6$drawPickingColo = _ref6.drawPickingColors,
      drawPickingColors = _ref6$drawPickingColo === undefined ? false : _ref6$drawPickingColo,
      _ref6$deviceRect = _ref6.deviceRect,
      deviceRect = _ref6$deviceRect === undefined ? null : _ref6$deviceRect,
      _ref6$parameters = _ref6.parameters,
      parameters = _ref6$parameters === undefined ? {} : _ref6$parameters,
      _ref6$pass = _ref6.pass,
      pass = _ref6$pass === undefined ? 'draw' : _ref6$pass;

  var pixelRatio = getPixelRatio({ useDevicePixelRatio: useDevicePixelRatio });
  var glViewport = getGLViewport(gl, { viewport: viewport, pixelRatio: pixelRatio });

  // render layers in normal colors
  var visibleCount = 0;
  var compositeCount = 0;
  var pickableCount = 0;

  // const {x, y, width, height} = deviceRect || [];

  // TODO: Update all layers to use 'picking_uActive' (picking shader module)
  // and then remove 'renderPickingBuffer' and 'pickingEnabled'.
  var pickingUniforms = {
    picking_uActive: drawPickingColors ? 1 : 0,
    renderPickingBuffer: drawPickingColors ? 1 : 0,
    pickingEnabled: drawPickingColors ? 1 : 0
  };

  (0, _luma.setParameters)(gl, parameters || {});

  // render layers in normal colors
  layers.forEach(function (layer, layerIndex) {
    if (layer.isComposite) {
      compositeCount++;
    }

    if (layer.props.pickable) {
      pickableCount++;
    }

    if (layer.props.visible && (layer.props.pickable || !drawPickingColors)) {

      visibleCount++;

      if (!drawPickingColors) {
        updateLayerHighlightColor(layer);
        // TODO - Disable during picking
      }

      if (layer.state.model) {
        // Update project module parameters
        layer.state.model.updateModuleSettings(Object.assign({}, layer.props, {
          viewport: layer.context.viewport
        }));
      }

      var uniforms = Object.assign(pickingUniforms, layer.context.uniforms, { layerIndex: layerIndex });

      // Blend parameters must not be overriden
      var layerParameters = Object.assign({ viewport: glViewport }, layer.props.parameters || {});

      if (drawPickingColors) {
        Object.assign(layerParameters, {
          blendColor: [0, 0, 0, (layerIndex + 1) / 255]
        });
      }

      (0, _luma.withParameters)(gl, parameters, function () {
        layer.drawLayer({
          uniforms: uniforms,
          parameters: layerParameters
        });
      });
    }
  });

  var totalCount = layers.length;
  var primitiveCount = totalCount - compositeCount;
  var hiddenCount = primitiveCount - visibleCount;

  var message = '#' + renderCount++ + ': Rendering ' + pass + ' : ' + visibleCount + ' of ' + totalCount + ' layers (' + hiddenCount + ' hidden, ' + compositeCount + ' composite ' + pickableCount + ' unpickable) DPR={pixelRatio} pick={$drawPickingColors}';

  _utils.log.log(2, message);
}

// Get a viewport from a viewport descriptor (which can be a plain viewport)
function getViewportFromDescriptor(viewportOrDescriptor) {
  return viewportOrDescriptor.viewport ? viewportOrDescriptor.viewport : viewportOrDescriptor;
}

/**
 * Returns the picking color of currenlty selected object of the given 'layer'.
 * @return {Array} - the picking color or null if layers selected object is invalid.
 */
function updateLayerHighlightColor(layer) {
  // TODO - inefficient to update settings every render?
  // TODO: Add warning if 'highlightedObjectIndex' is > numberOfInstances of the model.

  // Update picking module settings if highlightedObjectIndex is set.
  // This will overwrite any settings from auto highlighting.
  var pickingSelectedColorValid = layer.props.highlightedObjectIndex >= 0;
  if (layer.state.model && pickingSelectedColorValid) {
    var pickingSelectedColor = layer.encodePickingColor(layer.props.highlightedObjectIndex);

    // TODO - handle multimodel layers?
    layer.state.model.updateModuleSettings({
      pickingSelectedColor: pickingSelectedColor,
      pickingSelectedColorValid: pickingSelectedColorValid
    });
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9kcmF3LWxheWVycy5qcyJdLCJuYW1lcyI6WyJkcmF3TGF5ZXJzIiwiZHJhd1BpY2tpbmdCdWZmZXIiLCJyZW5kZXJDb3VudCIsImdldFBpeGVsUmF0aW8iLCJ1c2VEZXZpY2VQaXhlbFJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImdldEdMVmlld3BvcnQiLCJnbCIsInZpZXdwb3J0IiwicGl4ZWxSYXRpbyIsIndpZHRoIiwiY2FudmFzIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJkaW1lbnNpb25zIiwiZ2V0RGltZW5zaW9ucyIsIngiLCJ5IiwiY2xlYXJDYW52YXMiLCJkcmF3aW5nQnVmZmVyV2lkdGgiLCJkcmF3aW5nQnVmZmVySGVpZ2h0IiwiY2xlYXIiLCJDT0xPUl9CVUZGRVJfQklUIiwiREVQVEhfQlVGRkVSX0JJVCIsImxheWVycyIsInZpZXdwb3J0cyIsIm9uVmlld3BvcnRBY3RpdmUiLCJkcmF3UGlja2luZ0NvbG9ycyIsImRldmljZVJlY3QiLCJwYXJhbWV0ZXJzIiwicGFzcyIsImZvckVhY2giLCJ2aWV3cG9ydE9yRGVzY3JpcHRvciIsImkiLCJnZXRWaWV3cG9ydEZyb21EZXNjcmlwdG9yIiwiZHJhd0xheWVyc0luVmlld3BvcnQiLCJwaWNraW5nRkJPIiwiZnJhbWVidWZmZXIiLCJzY2lzc29yVGVzdCIsInNjaXNzb3IiLCJjbGVhckNvbG9yIiwiYmxlbmQiLCJibGVuZEZ1bmMiLCJPTkUiLCJaRVJPIiwiQ09OU1RBTlRfQUxQSEEiLCJibGVuZEVxdWF0aW9uIiwiRlVOQ19BREQiLCJibGVuZENvbG9yIiwiZ2xWaWV3cG9ydCIsInZpc2libGVDb3VudCIsImNvbXBvc2l0ZUNvdW50IiwicGlja2FibGVDb3VudCIsInBpY2tpbmdVbmlmb3JtcyIsInBpY2tpbmdfdUFjdGl2ZSIsInJlbmRlclBpY2tpbmdCdWZmZXIiLCJwaWNraW5nRW5hYmxlZCIsImxheWVyIiwibGF5ZXJJbmRleCIsImlzQ29tcG9zaXRlIiwicHJvcHMiLCJwaWNrYWJsZSIsInZpc2libGUiLCJ1cGRhdGVMYXllckhpZ2hsaWdodENvbG9yIiwic3RhdGUiLCJtb2RlbCIsInVwZGF0ZU1vZHVsZVNldHRpbmdzIiwiT2JqZWN0IiwiYXNzaWduIiwiY29udGV4dCIsInVuaWZvcm1zIiwibGF5ZXJQYXJhbWV0ZXJzIiwiZHJhd0xheWVyIiwidG90YWxDb3VudCIsImxlbmd0aCIsInByaW1pdGl2ZUNvdW50IiwiaGlkZGVuQ291bnQiLCJtZXNzYWdlIiwibG9nIiwicGlja2luZ1NlbGVjdGVkQ29sb3JWYWxpZCIsImhpZ2hsaWdodGVkT2JqZWN0SW5kZXgiLCJwaWNraW5nU2VsZWN0ZWRDb2xvciIsImVuY29kZVBpY2tpbmdDb2xvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7O1FBeURnQkEsVSxHQUFBQSxVO1FBcUNBQyxpQixHQUFBQSxpQjs7QUF6RWhCOztBQUNBOztBQXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBLElBQUlDLGNBQWMsQ0FBbEI7O0FBRUE7QUFDTyxJQUFNQyx3Q0FBZ0IsU0FBaEJBLGFBQWdCO0FBQUEsTUFBRUMsbUJBQUYsUUFBRUEsbUJBQUY7QUFBQSxTQUMzQkEsdUJBQXVCLE9BQU9DLE1BQVAsS0FBa0IsV0FBekMsR0FBdURBLE9BQU9DLGdCQUE5RCxHQUFpRixDQUR0RDtBQUFBLENBQXRCOztBQUdQO0FBQ0EsSUFBTUMsZ0JBQWdCLFNBQWhCQSxhQUFnQixDQUFDQyxFQUFELFNBQWdDO0FBQUEsTUFBMUJDLFFBQTBCLFNBQTFCQSxRQUEwQjtBQUFBLE1BQWhCQyxVQUFnQixTQUFoQkEsVUFBZ0I7O0FBQ3BELE1BQU1DLFFBQVFILEdBQUdJLE1BQUgsQ0FBVUMsV0FBeEI7QUFDQSxNQUFNQyxTQUFTTixHQUFHSSxNQUFILENBQVVH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Q0F2QixVQUFNTyxLQUFOLENBQVlDLEtBQVosQ0FBa0JDLG9CQUFsQixDQUF1QztBQUNyQ2UsZ0RBRHFDO0FBRXJDRjtBQUZxQyxLQUF2QztBQUlEO0FBQ0YiLCJmaWxlIjoiZHJhdy1sYXllcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuaW1wb3J0IHtHTCwgd2l0aFBhcmFtZXRlcnMsIHNldFBhcmFtZXRlcnN9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IHtsb2d9IGZyb20gJy4vdXRpbHMnO1xuXG5sZXQgcmVuZGVyQ291bnQgPSAwO1xuXG4vLyBUT0RPIC0gRXhwb3J0ZWQgZm9yIHBpY2stbGF5ZXJzLmpzIC0gTW92ZSB0byB1dGlsP1xuZXhwb3J0IGNvbnN0IGdldFBpeGVsUmF0aW8gPSAoe3VzZURldmljZVBpeGVsUmF0aW99KSA9PlxuICB1c2VEZXZpY2VQaXhlbFJhdGlvICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xuXG4vLyBDb252ZXJ0IHZpZXdwb3J0IHRvcC1sZWZ0IENTUyBjb29yZGluYXRlcyB0byBib3R0b20gdXAgV2ViR0wgY29vcmRpbmF0ZXNcbmNvbnN0IGdldEdMVmlld3BvcnQgPSAoZ2wsIHt2aWV3cG9ydCwgcGl4ZWxSYXRpb30pID0+IHtcbiAgY29uc3Qgd2lkdGggPSBnbC5jYW52YXMuY2xpZW50V2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IGdsLmNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gIC8vIENvbnZlcnQgdmlld3BvcnQgdG9wLWxlZnQgQ1NTIGNvb3JkaW5hdGVzIHRvIGJvdHRvbSB1cCBXZWJHTCBjb29yZGluYXRlc1xuICBjb25zdCBkaW1lbnNpb25zID0gdmlld3BvcnQuZ2V0RGltZW5zaW9ucyh7d2lkdGgsIGhlaWdodH0pO1xuICByZXR1cm4gW1xuICAgIGRpbWVuc2lvbnMueCAqIHBpeGVsUmF0aW8sXG4gICAgKGhlaWdodCAtIGRpbWVuc2lvbnMueSAtIGRpbWVuc2lvbnMuaGVpZ2h0KSAqIHBpeGVsUmF0aW8sXG4gICAgZGltZW5zaW9ucy53aWR0aCAqIHBpeGVsUmF0aW8sXG4gICAgZGltZW5zaW9ucy5oZWlnaHQgKiBwaXhlbFJhdGlvXG4gIF07XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zXG5cbmZ1bmN0aW9uIGNsZWFyQ2FudmFzKGdsLCB7dXNlRGV2aWNlUGl4ZWxSYXRpb30pIHtcbiAgLy8gY29uc3QgcGl4ZWxSYXRpbyA9IGdldFBpeGVsUmF0aW8oe3VzZURldmljZVBpeGVsUmF0aW99KTtcbiAgY29uc3Qgd2lkdGggPSBnbC5kcmF3aW5nQnVmZmVyV2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQ7XG4gIC8vIGNsZWFyIGRlcHRoIGFuZCBjb2xvciBidWZmZXJzLCByZXN0b3JpbmcgdHJhbnNwYXJlbmN5XG4gIHdpdGhQYXJhbWV0ZXJzKGdsLCB7dmlld3BvcnQ6IFswLCAwLCB3aWR0aCwgaGVpZ2h0XX0sICgpID0+IHtcbiAgICBnbC5jbGVhcihHTC5DT0xPUl9CVUZGRVJfQklUIHwgR0wuREVQVEhfQlVGRkVSX0JJVCk7XG4gIH0pO1xufVxuXG4vLyBEcmF3IGEgbGlzdCBvZiBsYXllcnMgaW4gYSBsaXN0IG9mIHZpZXdwb3J0c1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXdMYXllcnMoZ2wsIHtcbiAgbGF5ZXJzLFxuICB2aWV3cG9ydHMsXG4gIG9uVmlld3BvcnRBY3RpdmUsXG4gIHVzZURldmljZVBpeGVsUmF0aW8sXG4gIGRyYXdQaWNraW5nQ29sb3JzID0gZmFsc2UsXG4gIGRldmljZVJlY3QgPSBudWxsLFxuICBwYXJhbWV0ZXJzID0ge30sXG4gIHBhc3MgPSAnZHJhdydcbn0pIHtcbiAgY2xlYXJDYW52YXMoZ2wsIHt1c2VEZXZpY2VQaXhlbFJhdGlvfSk7XG5cbiAgLy8gZWZmZWN0TWFuYWdlci5wcmVEcmF3KCk7XG5cbiAgdmlld3BvcnRzLmZvckVhY2goKHZpZXdwb3J0T3JEZXNjcmlwdG9yLCBpKSA9PiB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3cG9ydEZyb21EZXNjcmlwdG9yKHZpZXdwb3J0T3JEZXNjcmlwdG9yKTtcblxuICAgIC8vIFVwZGF0ZSBjb250ZXh0IHRvIHBvaW50IHRvIHRoaXMgdmlld3BvcnRcbiAgICBvblZpZXdwb3J0QWN0aXZlKHZpZXdwb3J0KTtcblxuICAgIC8vIHJlbmRlciB0aGlzIHZpZXdwb3J0XG4gICAgZHJhd0xheWVyc0luVmlld3BvcnQoZ2wsIHtcbiAgICAgIGxheWVycyxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdXNlRGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgIGRyYXdQaWNraW5nQ29sb3JzLFxuICAgICAgZGV2aWNlUmVjdCxcbiAgICAgIHBhcmFtZXRlcnMsXG4gICAgICBwYXNzXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGVmZmVjdE1hbmFnZXIuZHJhdygpO1xufVxuXG4vLyBEcmF3cyBsaXN0IG9mIGxheWVycyBhbmQgdmlld3BvcnRzIGludG8gdGhlIHBpY2tpbmcgYnVmZmVyXG4vLyBOb3RlOiBkb2VzIG5vdCBzYW1wbGUgdGhlIGJ1ZmZlciwgdGhhdCBoYXMgdG8gYmUgZG9uZSBieSB0aGUgY2FsbGVyXG5leHBvcnQgZnVuY3Rpb24gZHJhd1BpY2tpbmdCdWZmZXIoZ2wsIHtcbiAgbGF5ZXJzLFxuICB2aWV3cG9ydHMsXG4gIG9uVmlld3BvcnRBY3RpdmUsXG4gIHVzZURldmljZVBpeGVsUmF0aW8sXG4gIHBpY2tpbmdGQk8sXG4gIGRldmljZVJlY3Q6IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxufSkge1xuICAvLyBNYWtlIHN1cmUgd2UgY2xlYXIgc2Npc3NvciB0ZXN0IGFuZCBmYm8gYmluZGluZ3MgaW4gY2FzZSBvZiBleGNlcHRpb25zXG4gIC8vIFdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gb25lIHBpeGVsLCBubyBuZWVkIHRvIHJlbmRlciBhbnl0aGluZyBlbHNlXG4gIC8vIE5vdGUgdGhhdCB0aGUgY2FsbGJhY2sgaGVyZSBpcyBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAgLy8gU2V0IGJsZW5kIG1vZGUgZm9yIHBpY2tpbmdcbiAgLy8gYWx3YXlzIG92ZXJ3cml0ZSBleGlzdGluZyBwaXhlbCB3aXRoIFtyLGcsYixsYXllckluZGV4XVxuICByZXR1cm4gd2l0aFBhcmFtZXRlcnMoZ2wsIHtcbiAgICBmcmFtZWJ1ZmZlcjogcGlja2luZ0ZCTyxcbiAgICBzY2lzc29yVGVzdDogdHJ1ZSxcbiAgICBzY2lzc29yOiBbeCwgeSwgd2lkdGgsIGhlaWdodF0sXG4gICAgY2xlYXJDb2xvcjogWzAsIDAsIDAsIDBdXG4gIH0sICgpID0+IHtcblxuICAgIGRyYXdMYXllcnMoZ2wsIHtcbiAgICAgIGxheWVycyxcbiAgICAgIHZpZXdwb3J0cyxcbiAgICAgIG9uVmlld3BvcnRBY3RpdmUsXG4gICAgICB1c2VEZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgZHJhd1BpY2tpbmdDb2xvcnM6IHRydWUsXG4gICAgICBwYXNzOiAncGlja2luZycsXG4gICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgIGJsZW5kOiB0cnVlLFxuICAgICAgICBibGVuZEZ1bmM6IFtnbC5PTkUsIGdsLlpFUk8sIGdsLkNPTlNUQU5UX0FMUEhBLCBnbC5aRVJPXSxcbiAgICAgICAgYmxlbmRFcXVhdGlvbjogZ2wuRlVOQ19BREQsXG4gICAgICAgIGJsZW5kQ29sb3I6IFswLCAwLCAwLCAwXVxuICAgICAgfVxuICAgIH0pO1xuXG4gIH0pO1xufVxuXG4vLyBEcmF3cyBhIGxpc3Qgb2YgbGF5ZXJzIGluIG9uZSB2aWV3cG9ydFxuLy8gVE9ETyAtIHdoZW4gcGlja2luZyB3ZSBjb3VsZCBjb21wbGV0ZWx5IHNraXAgcmVuZGVyaW5nIHZpZXdwb3J0cyB0aGF0IGRvbnRcbi8vIGludGVyc2VjdCB3aXRoIHRoZSBwaWNraW5nIHJlY3RcbmZ1bmN0aW9uIGRyYXdMYXllcnNJblZpZXdwb3J0KGdsLCB7XG4gIGxheWVycyxcbiAgdmlld3BvcnQsXG4gIHVzZURldmljZVBpeGVsUmF0aW8sXG4gIGRyYXdQaWNraW5nQ29sb3JzID0gZmFsc2UsXG4gIGRldmljZVJlY3QgPSBudWxsLFxuICBwYXJhbWV0ZXJzID0ge30sXG4gIHBhc3MgPSAnZHJhdydcbn0pIHtcbiAgY29uc3QgcGl4ZWxSYXRpbyA9IGdldFBpeGVsUmF0aW8oe3VzZURldmljZVBpeGVsUmF0aW99KTtcbiAgY29uc3QgZ2xWaWV3cG9ydCA9IGdldEdMVmlld3BvcnQoZ2wsIHt2aWV3cG9ydCwgcGl4ZWxSYXRpb30pO1xuXG4gIC8vIHJlbmRlciBsYXllcnMgaW4gbm9ybWFsIGNvbG9yc1xuICBsZXQgdmlzaWJsZUNvdW50ID0gMDtcbiAgbGV0IGNvbXBvc2l0ZUNvdW50ID0gMDtcbiAgbGV0IHBpY2thYmxlQ291bnQgPSAwO1xuXG4gIC8vIGNvbnN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSA9IGRldmljZVJlY3QgfHwgW107XG5cbiAgLy8gVE9ETzogVXBkYXRlIGFsbCBsYXllcnMgdG8gdXNlICdwaWNraW5nX3VBY3RpdmUnIChwaWNraW5nIHNoYWRlciBtb2R1bGUpXG4gIC8vIGFuZCB0aGVuIHJlbW92ZSAncmVuZGVyUGlja2luZ0J1ZmZlcicgYW5kICdwaWNraW5nRW5hYmxlZCcuXG4gIGNvbnN0IHBpY2tpbmdVbmlmb3JtcyA9IHtcbiAgICBwaWNraW5nX3VBY3RpdmU6IGRyYXdQaWNraW5nQ29sb3JzID8gMSA6IDAsXG4gICAgcmVuZGVyUGlja2luZ0J1ZmZlcjogZHJhd1BpY2tpbmdDb2xvcnMgPyAxIDogMCxcbiAgICBwaWNraW5nRW5hYmxlZDogZHJhd1BpY2tpbmdDb2xvcnMgPyAxIDogMFxuICB9O1xuXG4gIHNldFBhcmFtZXRlcnMoZ2wsIHBhcmFtZXRlcnMgfHwge30pO1xuXG4gIC8vIHJlbmRlciBsYXllcnMgaW4gbm9ybWFsIGNvbG9yc1xuICBsYXllcnMuZm9yRWFjaCgobGF5ZXIsIGxheWVySW5kZXgpID0+IHtcbiAgICBpZiAobGF5ZXIuaXNDb21wb3NpdGUpIHtcbiAgICAgIGNvbXBvc2l0ZUNvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKGxheWVyLnByb3BzLnBpY2thYmxlKSB7XG4gICAgICBwaWNrYWJsZUNvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKGxheWVyLnByb3BzLnZpc2libGUgJiYgKGxheWVyLnByb3BzLnBpY2thYmxlIHx8ICFkcmF3UGlja2luZ0NvbG9ycykpIHtcblxuICAgICAgdmlzaWJsZUNvdW50Kys7XG5cbiAgICAgIGlmICghZHJhd1BpY2tpbmdDb2xvcnMpIHtcbiAgICAgICAgdXBkYXRlTGF5ZXJIaWdobGlnaHRDb2xvcihsYXllcik7XG4gICAgICAgIC8vIFRPRE8gLSBEaXNhYmxlIGR1cmluZyBwaWNraW5nXG4gICAgICB9XG5cbiAgICAgIGlmIChsYXllci5zdGF0ZS5tb2RlbCkge1xuICAgICAgICAvLyBVcGRhdGUgcHJvamVjdCBtb2R1bGUgcGFyYW1ldGVyc1xuICAgICAgICBsYXllci5zdGF0ZS5tb2RlbC51cGRhdGVNb2R1bGVTZXR0aW5ncyhcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBsYXllci5wcm9wcywge1xuICAgICAgICAgICAgdmlld3BvcnQ6IGxheWVyLmNvbnRleHQudmlld3BvcnRcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1bmlmb3JtcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHBpY2tpbmdVbmlmb3JtcyxcbiAgICAgICAgbGF5ZXIuY29udGV4dC51bmlmb3JtcyxcbiAgICAgICAge2xheWVySW5kZXh9XG4gICAgICApO1xuXG4gICAgICAvLyBCbGVuZCBwYXJhbWV0ZXJzIG11c3Qgbm90IGJlIG92ZXJyaWRlblxuICAgICAgY29uc3QgbGF5ZXJQYXJhbWV0ZXJzID0gT2JqZWN0LmFzc2lnbih7dmlld3BvcnQ6IGdsVmlld3BvcnR9LCBsYXllci5wcm9wcy5wYXJhbWV0ZXJzIHx8IHt9KTtcblxuICAgICAgaWYgKGRyYXdQaWNraW5nQ29sb3JzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24obGF5ZXJQYXJhbWV0ZXJzLCB7XG4gICAgICAgICAgYmxlbmRDb2xvcjogWzAsIDAsIDAsIChsYXllckluZGV4ICsgMSkgLyAyNTVdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB3aXRoUGFyYW1ldGVycyhnbCwgcGFyYW1ldGVycywgKCkgPT4ge1xuICAgICAgICBsYXllci5kcmF3TGF5ZXIoe1xuICAgICAgICAgIHVuaWZvcm1zLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IGxheWVyUGFyYW1ldGVyc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgdG90YWxDb3VudCA9IGxheWVycy5sZW5ndGg7XG4gIGNvbnN0IHByaW1pdGl2ZUNvdW50ID0gdG90YWxDb3VudCAtIGNvbXBvc2l0ZUNvdW50O1xuICBjb25zdCBoaWRkZW5Db3VudCA9IHByaW1pdGl2ZUNvdW50IC0gdmlzaWJsZUNvdW50O1xuXG4gIGNvbnN0IG1lc3NhZ2UgPSBgXFxcbiMke3JlbmRlckNvdW50Kyt9OiBSZW5kZXJpbmcgJHtwYXNzfSA6ICR7dmlzaWJsZUNvdW50fSBvZiAke3RvdGFsQ291bnR9IGxheWVycyBcXFxuKCR7aGlkZGVuQ291bnR9IGhpZGRlbiwgJHtjb21wb3NpdGVDb3VudH0gY29tcG9zaXRlICR7cGlja2FibGVDb3VudH0gdW5waWNrYWJsZSkgXFxcbkRQUj17cGl4ZWxSYXRpb30gcGljaz17JGRyYXdQaWNraW5nQ29sb3JzfWA7XG5cbiAgbG9nLmxvZygyLCBtZXNzYWdlKTtcbn1cblxuLy8gR2V0IGEgdmlld3BvcnQgZnJvbSBhIHZpZXdwb3J0IGRlc2NyaXB0b3IgKHdoaWNoIGNhbiBiZSBhIHBsYWluIHZpZXdwb3J0KVxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRGcm9tRGVzY3JpcHRvcih2aWV3cG9ydE9yRGVzY3JpcHRvcikge1xuICByZXR1cm4gdmlld3BvcnRPckRlc2NyaXB0b3Iudmlld3BvcnQgPyB2aWV3cG9ydE9yRGVzY3JpcHRvci52aWV3cG9ydCA6IHZpZXdwb3J0T3JEZXNjcmlwdG9yO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBpY2tpbmcgY29sb3Igb2YgY3VycmVubHR5IHNlbGVjdGVkIG9iamVjdCBvZiB0aGUgZ2l2ZW4gJ2xheWVyJy5cbiAqIEByZXR1cm4ge0FycmF5fSAtIHRoZSBwaWNraW5nIGNvbG9yIG9yIG51bGwgaWYgbGF5ZXJzIHNlbGVjdGVkIG9iamVjdCBpcyBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB1cGRhdGVMYXllckhpZ2hsaWdodENvbG9yKGxheWVyKSB7XG4gIC8vIFRPRE8gLSBpbmVmZmljaWVudCB0byB1cGRhdGUgc2V0dGluZ3MgZXZlcnkgcmVuZGVyP1xuICAvLyBUT0RPOiBBZGQgd2FybmluZyBpZiAnaGlnaGxpZ2h0ZWRPYmplY3RJbmRleCcgaXMgPiBudW1iZXJPZkluc3RhbmNlcyBvZiB0aGUgbW9kZWwuXG5cbiAgLy8gVXBkYXRlIHBpY2tpbmcgbW9kdWxlIHNldHRpbmdzIGlmIGhpZ2hsaWdodGVkT2JqZWN0SW5kZXggaXMgc2V0LlxuICAvLyBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBzZXR0aW5ncyBmcm9tIGF1dG8gaGlnaGxpZ2h0aW5nLlxuICBjb25zdCBwaWNraW5nU2VsZWN0ZWRDb2xvclZhbGlkID0gbGF5ZXIucHJvcHMuaGlnaGxpZ2h0ZWRPYmplY3RJbmRleCA+PSAwO1xuICBpZiAobGF5ZXIuc3RhdGUubW9kZWwgJiYgcGlja2luZ1NlbGVjdGVkQ29sb3JWYWxpZCkge1xuICAgIGNvbnN0IHBpY2tpbmdTZWxlY3RlZENvbG9yID0gbGF5ZXIuZW5jb2RlUGlja2luZ0NvbG9yKGxheWVyLnByb3BzLmhpZ2hsaWdodGVkT2JqZWN0SW5kZXgpO1xuXG4gICAgLy8gVE9ETyAtIGhhbmRsZSBtdWx0aW1vZGVsIGxheWVycz9cbiAgICBsYXllci5zdGF0ZS5tb2RlbC51cGRhdGVNb2R1bGVTZXR0aW5ncyh7XG4gICAgICBwaWNraW5nU2VsZWN0ZWRDb2xvcixcbiAgICAgIHBpY2tpbmdTZWxlY3RlZENvbG9yVmFsaWRcbiAgICB9KTtcbiAgfVxufVxuIl19