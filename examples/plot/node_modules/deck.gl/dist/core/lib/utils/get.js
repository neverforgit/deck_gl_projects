'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.get = get;
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/**
 * Access properties of nested containers using dot-path notation
 * - Supports plain objects and arrays, as well as classes with `get` methods
 *   such as ES6 Maps, Immutable.js objects etc
 * - Returns undefined if any container is not valid, instead of throwing
 *
 * @param {Object} container - container that supports get
 * @param {String|*} compositeKey - key to access, can be '.'-separated string
 * @return {*} - value in the final key of the nested container
 */
function get(container, compositeKey) {
  // Split the key into subkeys
  var keyList = getKeys(compositeKey);
  // Recursively get the value of each key;
  var value = container;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = keyList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      // If any intermediate subfield is not a container, return undefined
      if (!isObject(value)) {
        return undefined;
      }
      // Get the `getter` for this container
      var getter = getGetter(value);
      // Use the getter to get the value for the key
      value = getter(value, key);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return value;
}

/**
 * Checks if argument is an indexable object (not a primitive value, nor null)
 * @param {*} value - JavaScript value to be tested
 * @return {Boolean} - true if argument is a JavaScript object
 */
function isObject(value) {
  return value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
}

// Default getter is container indexing
var squareBracketGetter = function squareBracketGetter(container, key) {
  return container[key];
};
var getMethodGetter = function getMethodGetter(obj, key) {
  return obj.get(key);
};
// Cache key to key arrays for speed
var keyMap = {};

// Looks for a `get` function on the prototype
// TODO - follow prototype chain?
// @private
// @return {Function} - get function: (container, key) => value
function getGetter(container) {
  // Check if container has a special get method
  var prototype = Object.getPrototypeOf(container);
  return prototype.get ? getMethodGetter : squareBracketGetter;
}

// Takes a string of '.' separated keys and returns an array of keys
// E.g. 'feature.geometry.type' => 'feature', 'geometry', 'type'
// @private
function getKeys(compositeKey) {
  if (typeof compositeKey === 'string') {
    // else assume string and split around dots
    var keyList = keyMap[compositeKey];
    if (!keyList) {
      keyList = compositeKey.split('.');
      keyMap[compositeKey] = keyList;
    }
    return keyList;
  }
  // Wrap in array if needed
  return Array.isArray(compositeKey) ? compositeKey : [compositeKey];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb3JlL2xpYi91dGlscy9nZXQuanMiXSwibmFtZXMiOlsiZ2V0IiwiY29udGFpbmVyIiwiY29tcG9zaXRlS2V5Iiwia2V5TGlzdCIsImdldEtleXMiLCJ2YWx1ZSIsImtleSIsImlzT2JqZWN0IiwidW5kZWZpbmVkIiwiZ2V0dGVyIiwiZ2V0R2V0dGVyIiwic3F1YXJlQnJhY2tldEdldHRlciIsImdldE1ldGhvZEdldHRlciIsIm9iaiIsImtleU1hcCIsInByb3RvdHlwZSIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwic3BsaXQiLCJBcnJheSIsImlzQXJyYXkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O1FBOEJnQkEsRyxHQUFBQSxHO0FBOUJoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7OztBQVVPLFNBQVNBLEdBQVQsQ0FBYUMsU0FBYixFQUF3QkMsWUFBeEIsRUFBc0M7QUFDM0M7QUFDQSxNQUFNQyxVQUFVQyxRQUFRRixZQUFSLENBQWhCO0FBQ0E7QUFDQSxNQUFJRyxRQUFRSixTQUFaO0FBSjJDO0FBQUE7QUFBQTs7QUFBQTtBQUszQyx5QkFBa0JFLE9BQWxCLDhIQUEyQjtBQUFBLFVBQWhCRyxHQUFnQjs7QUFDekI7QUFDQSxVQUFJLENBQUNDLFNBQVNGLEtBQVQsQ0FBTCxFQUFzQjtBQUNwQixlQUFPRyxTQUFQO0FBQ0Q7QUFDRDtBQUNBLFVBQU1DLFNBQVNDLFVBQVVMLEtBQVYsQ0FBZjtBQUNBO0FBQ0FBLGNBQVFJLE9BQU9KLEtBQVAsRUFBY0MsR0FBZCxDQUFSO0FBQ0Q7QUFkMEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFlM0MsU0FBT0QsS0FBUDtBQUNEOztBQUVEOzs7OztBQUtBLFNBQVNFLFFBQVQsQ0FBa0JGLEtBQWxCLEVBQXlCO0FBQ3ZCLFNBQU9BLFVBQVUsSUFBVixJQUFrQixRQUFPQSxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBQTFDO0FBQ0Q7O0FBRUQ7QUFDQSxJQUFNTSxzQkFBc0IsU0FBdEJBLG1CQUFzQixDQUFDVixTQUFELEVBQVlLLEdBQVo7QUFBQSxTQUFvQkwsVUFBVUssR0FBVixDQUFwQjtBQUFBLENBQTVCO0FBQ0EsSUFBTU0sa0JBQWtCLFNBQWxCQSxlQUFrQixDQUFDQyxHQUFELEVBQU1QLEdBQU47QUFBQSxTQUFjTyxJQUFJYixHQUFKLENBQVFNLEdBQVIsQ0FBZDtBQUFBLENBQXhCO0FBQ0E7QUFDQSxJQUFNUSxTQUFTLEVBQWY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTSixTQUFULENBQW1CVCxTQUFuQixFQUE4QjtBQUM1QjtBQUNBLE1BQU1jLFlBQVlDLE9BQU9DLGNBQVAsQ0FBc0JoQixTQUF0QixDQUFsQjtBQUNBLFNBQU9jLFVBQVVmLEdBQVYsR0FBZ0JZLGVBQWhCLEdBQWtDRCxtQkFBekM7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxTQUFTUCxPQUFULENBQWlCRixZQUFqQixFQUErQjtBQUM3QixNQUFJLE9BQU9BLFlBQVAsS0FBd0IsUUFBNUIsRUFBc0M7QUFDcEM7QUFDQSxRQUFJQyxVQUFVVyxPQUFPWixZQUFQLENBQWQ7QUFDQSxRQUFJLENBQUNDLE9BQUwsRUFBYztBQUNaQSxnQkFBVUQsYUFBYWdCLEtBQWIsQ0FBbUIsR0FBbkIsQ0FBVjtBQUNBSixhQUFPWixZQUFQLElBQXVCQyxPQUF2QjtBQUNEO0FBQ0QsV0FBT0EsT0FBUDtBQUNEO0FBQ0Q7QUFDQSxTQUFPZ0IsTUFBTUMsT0FBTixDQUFjbEIsWUFBZCxJQUE4QkEsWUFBOUIsR0FBNkMsQ0FBQ0EsWUFBRCxDQUFwRDtBQUNEIiwiZmlsZSI6ImdldC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKipcbiAqIEFjY2VzcyBwcm9wZXJ0aWVzIG9mIG5lc3RlZCBjb250YWluZXJzIHVzaW5nIGRvdC1wYXRoIG5vdGF0aW9uXG4gKiAtIFN1cHBvcnRzIHBsYWluIG9iamVjdHMgYW5kIGFycmF5cywgYXMgd2VsbCBhcyBjbGFzc2VzIHdpdGggYGdldGAgbWV0aG9kc1xuICogICBzdWNoIGFzIEVTNiBNYXBzLCBJbW11dGFibGUuanMgb2JqZWN0cyBldGNcbiAqIC0gUmV0dXJucyB1bmRlZmluZWQgaWYgYW55IGNvbnRhaW5lciBpcyBub3QgdmFsaWQsIGluc3RlYWQgb2YgdGhyb3dpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyIC0gY29udGFpbmVyIHRoYXQgc3VwcG9ydHMgZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ3wqfSBjb21wb3NpdGVLZXkgLSBrZXkgdG8gYWNjZXNzLCBjYW4gYmUgJy4nLXNlcGFyYXRlZCBzdHJpbmdcbiAqIEByZXR1cm4geyp9IC0gdmFsdWUgaW4gdGhlIGZpbmFsIGtleSBvZiB0aGUgbmVzdGVkIGNvbnRhaW5lclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGNvbnRhaW5lciwgY29tcG9zaXRlS2V5KSB7XG4gIC8vIFNwbGl0IHRoZSBrZXkgaW50byBzdWJrZXlzXG4gIGNvbnN0IGtleUxpc3QgPSBnZXRLZXlzKGNvbXBvc2l0ZUtleSk7XG4gIC8vIFJlY3Vyc2l2ZWx5IGdldCB0aGUgdmFsdWUgb2YgZWFjaCBrZXk7XG4gIGxldCB2YWx1ZSA9IGNvbnRhaW5lcjtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5TGlzdCkge1xuICAgIC8vIElmIGFueSBpbnRlcm1lZGlhdGUgc3ViZmllbGQgaXMgbm90IGEgY29udGFpbmVyLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgYGdldHRlcmAgZm9yIHRoaXMgY29udGFpbmVyXG4gICAgY29uc3QgZ2V0dGVyID0gZ2V0R2V0dGVyKHZhbHVlKTtcbiAgICAvLyBVc2UgdGhlIGdldHRlciB0byBnZXQgdGhlIHZhbHVlIGZvciB0aGUga2V5XG4gICAgdmFsdWUgPSBnZXR0ZXIodmFsdWUsIGtleSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhcmd1bWVudCBpcyBhbiBpbmRleGFibGUgb2JqZWN0IChub3QgYSBwcmltaXRpdmUgdmFsdWUsIG5vciBudWxsKVxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIEphdmFTY3JpcHQgdmFsdWUgdG8gYmUgdGVzdGVkXG4gKiBAcmV0dXJuIHtCb29sZWFufSAtIHRydWUgaWYgYXJndW1lbnQgaXMgYSBKYXZhU2NyaXB0IG9iamVjdFxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jztcbn1cblxuLy8gRGVmYXVsdCBnZXR0ZXIgaXMgY29udGFpbmVyIGluZGV4aW5nXG5jb25zdCBzcXVhcmVCcmFja2V0R2V0dGVyID0gKGNvbnRhaW5lciwga2V5KSA9PiBjb250YWluZXJba2V5XTtcbmNvbnN0IGdldE1ldGhvZEdldHRlciA9IChvYmosIGtleSkgPT4gb2JqLmdldChrZXkpO1xuLy8gQ2FjaGUga2V5IHRvIGtleSBhcnJheXMgZm9yIHNwZWVkXG5jb25zdCBrZXlNYXAgPSB7fTtcblxuLy8gTG9va3MgZm9yIGEgYGdldGAgZnVuY3Rpb24gb24gdGhlIHByb3RvdHlwZVxuLy8gVE9ETyAtIGZvbGxvdyBwcm90b3R5cGUgY2hhaW4/XG4vLyBAcHJpdmF0ZVxuLy8gQHJldHVybiB7RnVuY3Rpb259IC0gZ2V0IGZ1bmN0aW9uOiAoY29udGFpbmVyLCBrZXkpID0+IHZhbHVlXG5mdW5jdGlvbiBnZXRHZXR0ZXIoY29udGFpbmVyKSB7XG4gIC8vIENoZWNrIGlmIGNvbnRhaW5lciBoYXMgYSBzcGVjaWFsIGdldCBtZXRob2RcbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbnRhaW5lcik7XG4gIHJldHVybiBwcm90b3R5cGUuZ2V0ID8gZ2V0TWV0aG9kR2V0dGVyIDogc3F1YXJlQnJhY2tldEdldHRlcjtcbn1cblxuLy8gVGFrZXMgYSBzdHJpbmcgb2YgJy4nIHNlcGFyYXRlZCBrZXlzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGtleXNcbi8vIEUuZy4gJ2ZlYXR1cmUuZ2VvbWV0cnkudHlwZScgPT4gJ2ZlYXR1cmUnLCAnZ2VvbWV0cnknLCAndHlwZSdcbi8vIEBwcml2YXRlXG5mdW5jdGlvbiBnZXRLZXlzKGNvbXBvc2l0ZUtleSkge1xuICBpZiAodHlwZW9mIGNvbXBvc2l0ZUtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBlbHNlIGFzc3VtZSBzdHJpbmcgYW5kIHNwbGl0IGFyb3VuZCBkb3RzXG4gICAgbGV0IGtleUxpc3QgPSBrZXlNYXBbY29tcG9zaXRlS2V5XTtcbiAgICBpZiAoIWtleUxpc3QpIHtcbiAgICAgIGtleUxpc3QgPSBjb21wb3NpdGVLZXkuc3BsaXQoJy4nKTtcbiAgICAgIGtleU1hcFtjb21wb3NpdGVLZXldID0ga2V5TGlzdDtcbiAgICB9XG4gICAgcmV0dXJuIGtleUxpc3Q7XG4gIH1cbiAgLy8gV3JhcCBpbiBhcnJheSBpZiBuZWVkZWRcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY29tcG9zaXRlS2V5KSA/IGNvbXBvc2l0ZUtleSA6IFtjb21wb3NpdGVLZXldO1xufVxuIl19