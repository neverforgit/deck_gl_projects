'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */


var _constants = require('./constants');

var _attributeManager = require('./attribute-manager');

var _attributeManager2 = _interopRequireDefault(_attributeManager);

var _stats = require('./stats');

var _stats2 = _interopRequireDefault(_stats);

var _props2 = require('./props');

var _utils = require('./utils');

var _seerIntegration = require('./seer-integration');

var _luma = require('luma.gl');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LOG_PRIORITY_UPDATE = 1;

var EMPTY_ARRAY = [];
var noop = function noop() {};

/*
 * @param {string} props.id - layer name
 * @param {array}  props.data - array of data instances
 * @param {bool} props.opacity - opacity of the layer
 */
var defaultProps = {
  // data: Special handling for null, see below
  dataComparator: null,
  updateTriggers: {}, // Update triggers: a core change detection mechanism in deck.gl
  numInstances: undefined,

  visible: true,
  pickable: false,
  opacity: 0.8,

  onHover: noop,
  onClick: noop,

  coordinateSystem: _constants.COORDINATE_SYSTEM.LNGLAT,
  coordinateOrigin: [0, 0, 0],

  parameters: {},
  uniforms: {},
  framebuffer: null,

  animation: null, // Passed prop animation functions to evaluate props

  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: function getPolygonOffset(_ref) {
    var layerIndex = _ref.layerIndex;
    return [0, -layerIndex * 100];
  },

  // Selection/Highlighting
  highlightedObjectIndex: -1,
  autoHighlight: false,
  highlightColor: [0, 0, 128, 128]
};

var counter = 0;

var Layer = function () {
  /**
   * @class
   * @param {object} props - See docs and defaults above
   */
  function Layer(props) {
    _classCallCheck(this, Layer);

    // If sublayer has static defaultProps member, getDefaultProps will return it
    var mergedDefaultProps = (0, _props2.getDefaultProps)(this);
    // Merge supplied props with pre-merged default props
    props = Object.assign({}, mergedDefaultProps, props);
    // Accept null as data - otherwise apps and layers need to add ugly checks
    // Use constant fallback so that data change is not triggered
    props.data = props.data || EMPTY_ARRAY;
    // Apply any overrides from the seer debug extension if it is active
    (0, _seerIntegration.applyPropOverrides)(props);
    // Props are immutable
    Object.freeze(props);

    // Define all members
    this.id = props.id; // The layer's id, used for matching with layers' from last render cyckle
    this.props = props; // Current props, a frozen object
    this.animatedProps = null; // Computing animated props requires layer manager state
    this.oldProps = null; // Props from last render used for change detection
    this.state = null; // Will be set to the shared layer state object during layer matching
    this.context = null; // Will reference layer manager's context, contains state shared by layers
    this.count = counter++; // Keep track of how many layer instances you are generating
    this.lifecycle = _constants.LIFECYCLE.NO_STATE; // Helps track and debug the life cycle of the layers
    // CompositeLayer members, need to be defined here because of the `Object.seal`
    this.parentLayer = null; // reference to the composite layer parent that rendered this layer
    this.oldSubLayers = []; // reference to sublayers rendered in the previous cycle
    // Seal the layer
    Object.seal(this);
  }

  _createClass(Layer, [{
    key: 'toString',
    value: function toString() {
      var className = this.constructor.layerName || this.constructor.name;
      return className + '({id: \'' + this.props.id + '\'})';
    }
  }, {
    key: 'initializeState',


    // //////////////////////////////////////////////////
    // LIFECYCLE METHODS, overridden by the layer subclasses

    // Called once to set up the initial state
    // App can create WebGL resources
    value: function initializeState() {
      throw new Error('Layer ' + this + ' has not defined initializeState');
    }

    // Let's layer control if updateState should be called

  }, {
    key: 'shouldUpdateState',
    value: function shouldUpdateState(_ref2) {
      var oldProps = _ref2.oldProps,
          props = _ref2.props,
          oldContext = _ref2.oldContext,
          context = _ref2.context,
          changeFlags = _ref2.changeFlags;

      return changeFlags.propsOrDataChanged;
    }

    // Default implementation, all attributes will be invalidated and updated
    // when data changes

  }, {
    key: 'updateState',
    value: function updateState(_ref3) {
      var oldProps = _ref3.oldProps,
          props = _ref3.props,
          oldContext = _ref3.oldContext,
          context = _ref3.context,
          changeFlags = _ref3.changeFlags;

      if (changeFlags.dataChanged) {
        this.invalidateAttribute('all');
      }
    }

    // Called once when layer is no longer matched and state will be discarded
    // App can destroy WebGL resources here

  }, {
    key: 'finalizeState',
    value: function finalizeState() {}

    // If state has a model, draw it with supplied uniforms

  }, {
    key: 'draw',
    value: function draw(_ref4) {
      var _ref4$uniforms = _ref4.uniforms,
          uniforms = _ref4$uniforms === undefined ? {} : _ref4$uniforms;

      if (this.state.model) {
        this.state.model.render(uniforms);
      }
    }

    // called to populate the info object that is passed to the event handler
    // @return null to cancel event

  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref5) {
      var info = _ref5.info,
          mode = _ref5.mode;
      var index = info.index;


      if (index >= 0) {
        // If props.data is an indexable array, get the object
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index];
        }
      }

      return info;
    }

    // END LIFECYCLE METHODS
    // //////////////////////////////////////////////////

    // Default implementation of attribute invalidation, can be redefine

  }, {
    key: 'invalidateAttribute',
    value: function invalidateAttribute() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';

      if (name === 'all') {
        this.state.attributeManager.invalidateAll();
      } else {
        this.state.attributeManager.invalidate(name);
      }
    }

    // Calls attribute manager to update any WebGL attributes, can be redefined

  }, {
    key: 'updateAttributes',
    value: function updateAttributes(props) {
      var _state = this.state,
          attributeManager = _state.attributeManager,
          model = _state.model;

      if (!attributeManager) {
        return;
      }

      // Figure out data length
      var numInstances = this.getNumInstances(props);

      attributeManager.update({
        data: props.data,
        numInstances: numInstances,
        props: props,
        buffers: props,
        context: this,
        // Don't worry about non-attribute props
        ignoreUnknownAttributes: true
      });

      if (model) {
        var changedAttributes = attributeManager.getChangedAttributes({ clearChangedFlags: true });
        model.setAttributes(changedAttributes);
      }
    }

    // Public API

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setState',
    value: function setState(updateObject) {
      Object.assign(this.state, updateObject);
      this.state.needsRedraw = true;
    }
  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (this.state) {
        this.state.needsRedraw = redraw;
      }
    }

    // PROJECTION METHODS

    /**
     * Projects a point with current map state (lat, lon, zoom, pitch, bearing)
     *
     * Note: Position conversion is done in shader, so in many cases there is no need
     * for this function
     * @param {Array|TypedArray} lngLat - long and lat values
     * @return {Array|TypedArray} - x, y coordinates
     */

  }, {
    key: 'project',
    value: function project(lngLat) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.project(lngLat);
    }
  }, {
    key: 'unproject',
    value: function unproject(xy) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unproject(xy);
    }
  }, {
    key: 'projectFlat',
    value: function projectFlat(lngLat) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');
      return viewport.projectFlat(lngLat);
    }
  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xy) {
      var viewport = this.context.viewport;

      (0, _assert2.default)(Array.isArray(xy), 'Layer.unproject needs [x,y]');
      return viewport.unprojectFlat(xy);
    }
  }, {
    key: 'screenToDevicePixels',
    value: function screenToDevicePixels(screenPixels) {
      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
      return screenPixels * devicePixelRatio;
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @return {Array} - a black color
     */

  }, {
    key: 'nullPickingColor',
    value: function nullPickingColor() {
      return [0, 0, 0];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {int} i - index to be decoded
     * @return {Array} - the decoded color
     */

  }, {
    key: 'encodePickingColor',
    value: function encodePickingColor(i) {
      (0, _assert2.default)((i + 1 >> 24 & 255) === 0, 'index out of picking color range');
      return [i + 1 & 255, i + 1 >> 8 & 255, i + 1 >> 8 >> 8 & 255];
    }

    /**
     * Returns the picking color that doesn't match any subfeature
     * Use if some graphics do not belong to any pickable subfeature
     * @param {Uint8Array} color - color array to be decoded
     * @return {Array} - the decoded picking color
     */

  }, {
    key: 'decodePickingColor',
    value: function decodePickingColor(color) {
      (0, _assert2.default)(color instanceof Uint8Array);

      var _color = _slicedToArray(color, 3),
          i1 = _color[0],
          i2 = _color[1],
          i3 = _color[2];
      // 1 was added to seperate from no selection


      var index = i1 + i2 * 256 + i3 * 65536 - 1;
      return index;
    }
  }, {
    key: 'calculateInstancePickingColors',
    value: function calculateInstancePickingColors(attribute, _ref6) {
      var numInstances = _ref6.numInstances;
      var value = attribute.value,
          size = attribute.size;
      // add 1 to index to seperate from no selection

      for (var i = 0; i < numInstances; i++) {
        var pickingColor = this.encodePickingColor(i);
        value[i * size + 0] = pickingColor[0];
        value[i * size + 1] = pickingColor[1];
        value[i * size + 2] = pickingColor[2];
      }
    }

    // DATA ACCESS API
    // Data can use iterators and may not be random access

    // Use iteration (the only required capability on data) to get first element

  }, {
    key: 'getFirstObject',
    value: function getFirstObject() {
      var data = this.props.data;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          return object;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    }

    // INTERNAL METHODS

    // Deduces numer of instances. Intention is to support:
    // - Explicit setting of numInstances
    // - Auto-deduction for ES6 containers that define a size member
    // - Auto-deduction for Classic Arrays via the built-in length attribute
    // - Auto-deduction via arrays

  }, {
    key: 'getNumInstances',
    value: function getNumInstances(props) {
      props = props || this.props;

      // First check if the layer has set its own value
      if (this.state && this.state.numInstances !== undefined) {
        return this.state.numInstances;
      }

      // Check if app has provided an explicit value
      if (props.numInstances !== undefined) {
        return props.numInstances;
      }

      // Use container library to get a count for any ES6 container or object
      var _props = props,
          data = _props.data;

      return (0, _utils.count)(data);
    }

    // LAYER MANAGER API
    // Should only be called by the deck.gl LayerManager class

    // Called by layer manager when a new layer is found
    /* eslint-disable max-statements */

  }, {
    key: 'initializeLayer',
    value: function initializeLayer(updateParams) {
      (0, _assert2.default)(this.context.gl, 'Layer context missing gl');
      (0, _assert2.default)(!this.state, 'Layer missing state');

      this.state = {};
      this.state.stats = new _stats2.default({ id: 'draw' });

      // Initialize state only once
      this.setState({
        attributeManager: new _attributeManager2.default({ id: this.props.id }),
        model: null,
        needsRedraw: true,
        dataChanged: true
      });

      var attributeManager = this.state.attributeManager;
      // All instanced layers get instancePickingColors attribute by default
      // Their shaders can use it to render a picking scene
      // TODO - this slows down non instanced layers

      attributeManager.addInstanced({
        instancePickingColors: {
          type: _luma.GL.UNSIGNED_BYTE,
          size: 3,
          update: this.calculateInstancePickingColors
        }
      });

      // Call subclass lifecycle methods
      this.initializeState(this.context);
      this.updateState(updateParams);
      // End subclass lifecycle methods

      // Add any subclass attributes
      this.updateAttributes(this.props);
      this._updateBaseUniforms();
      this._updateModuleSettings();

      var model = this.state.model;

      if (model) {
        model.setInstanceCount(this.getNumInstances());
        model.id = this.props.id;
        model.program.id = this.props.id + '-program';
        model.geometry.id = this.props.id + '-geometry';
        model.setAttributes(attributeManager.getAttributes());
      }
    }

    // Called by layer manager when existing layer is getting new props

  }, {
    key: 'updateLayer',
    value: function updateLayer(updateParams) {
      // Check for deprecated method
      if (this.shouldUpdate) {
        _utils.log.deprecated('shouldUpdate', 'shouldUpdateState');
      }

      // Ensure context is available
      updateParams = Object.assign({}, this.context, updateParams);

      // Call subclass lifecycle method
      var stateNeedsUpdate = this.shouldUpdateState(updateParams);
      // End lifecycle method

      if (stateNeedsUpdate) {
        // Call subclass lifecycle method
        this.updateState(updateParams);
        // End lifecycle method

        // Run the attribute updaters
        this.updateAttributes(updateParams.props);
        this._updateBaseUniforms();
        this._updateModuleSettings();

        if (this.state.model) {
          this.state.model.setInstanceCount(this.getNumInstances());
        }
      }
    }
    /* eslint-enable max-statements */

    // Called by manager when layer is about to be disposed
    // Note: not guaranteed to be called on application shutdown

  }, {
    key: 'finalizeLayer',
    value: function finalizeLayer() {
      // Call subclass lifecycle method
      this.finalizeState(this.context);
      // End lifecycle method
      (0, _seerIntegration.removeLayerInSeer)(this.id);
    }

    // Calculates uniforms

  }, {
    key: 'drawLayer',
    value: function drawLayer(_ref7) {
      var _this = this;

      var _ref7$moduleParameter = _ref7.moduleParameters,
          moduleParameters = _ref7$moduleParameter === undefined ? null : _ref7$moduleParameter,
          _ref7$uniforms = _ref7.uniforms,
          uniforms = _ref7$uniforms === undefined ? {} : _ref7$uniforms,
          _ref7$parameters = _ref7.parameters,
          parameters = _ref7$parameters === undefined ? {} : _ref7$parameters;


      // TODO/ib - hack move to luma Model.draw
      if (moduleParameters && this.state.model) {
        this.state.model.updateModuleSettings(moduleParameters);
      }

      // Apply polygon offset to avoid z-fighting
      var getPolygonOffset = this.props.getPolygonOffset;

      var offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      parameters.polygonOffset = offsets;

      // Call subclass lifecycle method
      (0, _luma.withParameters)(this.context.gl, parameters, function () {
        _this.draw({ moduleParameters: moduleParameters, uniforms: uniforms, parameters: parameters, context: _this.context });
      });
      // End lifecycle method
    }

    // {uniforms = {}, ...opts}

  }, {
    key: 'pickLayer',
    value: function pickLayer(opts) {
      // Call subclass lifecycle method
      return this.getPickingInfo(opts);
      // End lifecycle method
    }

    // Checks state of attributes and model
    // TODO - is attribute manager needed? - Model should be enough.

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref8$clearRedrawFlag = _ref8.clearRedrawFlags,
          clearRedrawFlags = _ref8$clearRedrawFlag === undefined ? false : _ref8$clearRedrawFlag;

      // this method may be called by the render loop as soon a the layer
      // has been created, so guard against uninitialized state
      if (!this.state) {
        return false;
      }

      var redraw = false;
      redraw = redraw || this.state.needsRedraw;
      this.state.needsRedraw = this.state.needsRedraw && !clearRedrawFlags;

      var _state2 = this.state,
          attributeManager = _state2.attributeManager,
          model = _state2.model;

      redraw = redraw || attributeManager && attributeManager.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
      redraw = redraw || model && model.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });

      return redraw;
    }
  }, {
    key: 'diffProps',
    value: function diffProps(oldProps, newProps, context) {
      // First check if any props have changed (ignore props that will be examined separately)
      var propsChangedReason = (0, _props2.compareProps)({
        newProps: newProps,
        oldProps: oldProps,
        ignoreProps: { data: null, updateTriggers: null }
      });

      // Now check if any data related props have changed
      var dataChangedReason = this._diffDataProps(oldProps, newProps);

      var propsChanged = Boolean(propsChangedReason);
      var dataChanged = Boolean(dataChangedReason);
      var viewportChanged = context.viewportChanged;

      var updateTriggersChanged = false;
      // Check update triggers to determine if any attributes need regeneration
      // Note - if data has changed, all attributes will need regeneration, so skip this step
      if (!dataChanged) {
        updateTriggersChanged = this._diffUpdateTriggers(oldProps, newProps);
      }

      var propsOrDataChanged = propsChanged || dataChanged || updateTriggersChanged;
      var somethingChanged = propsOrDataChanged || viewportChanged;

      // Trace what happened
      if (dataChanged) {
        _utils.log.log(LOG_PRIORITY_UPDATE, 'dataChanged: ' + dataChangedReason + ' in ' + this.id);
      } else if (propsChanged) {
        _utils.log.log(LOG_PRIORITY_UPDATE, 'propsChanged: ' + propsChangedReason + ' in ' + this.id);
      }

      return {
        propsChanged: propsChanged,
        dataChanged: dataChanged,
        updateTriggersChanged: updateTriggersChanged,
        propsOrDataChanged: propsOrDataChanged,
        viewportChanged: viewportChanged,
        somethingChanged: somethingChanged,
        reason: dataChangedReason || propsChangedReason || 'Viewport changed'
      };
    }

    // PRIVATE METHODS

    // The comparison of the data prop requires special handling
    // the dataComparator should be used if supplied

  }, {
    key: '_diffDataProps',
    value: function _diffDataProps(oldProps, newProps) {
      if (oldProps === null) {
        return 'oldProps is null, initial diff';
      }

      // Support optional app defined comparison of data
      var dataComparator = newProps.dataComparator;

      if (dataComparator) {
        if (!dataComparator(newProps.data, oldProps.data)) {
          return 'Data comparator detected a change';
        }
        // Otherwise, do a shallow equal on props
      } else if (newProps.data !== oldProps.data) {
        return 'A new data container was supplied';
      }

      return null;
    }

    // Checks if any update triggers have changed, and invalidate
    // attributes accordingly.
    /* eslint-disable max-statements */

  }, {
    key: '_diffUpdateTriggers',
    value: function _diffUpdateTriggers(oldProps, newProps) {
      // const {attributeManager} = this.state;
      // const updateTriggerMap = attributeManager.getUpdateTriggerMap();
      if (oldProps === null) {
        return true; // oldProps is null, initial diff
      }

      var change = false;

      for (var propName in newProps.updateTriggers) {
        var oldTriggers = oldProps.updateTriggers[propName] || {};
        var newTriggers = newProps.updateTriggers[propName] || {};
        var diffReason = (0, _props2.compareProps)({
          oldProps: oldTriggers,
          newProps: newTriggers,
          triggerName: propName
        });
        if (diffReason) {
          if (propName === 'all') {
            _utils.log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating all attributes: ' + diffReason);
            this.invalidateAttribute('all');
            change = true;
          } else {
            _utils.log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating attribute ' + propName + ': ' + diffReason);
            this.invalidateAttribute(propName);
            change = true;
          }
        }
      }

      return change;
    }
    /* eslint-enable max-statements */

  }, {
    key: '_checkRequiredProp',
    value: function _checkRequiredProp(propertyName, condition) {
      var value = this.props[propertyName];
      if (value === undefined) {
        throw new Error('Property ' + propertyName + ' undefined in layer ' + this);
      }
      if (condition && !condition(value)) {
        throw new Error('Bad property ' + propertyName + ' in layer ' + this);
      }
    }

    // Emits a warning if an old prop is used, optionally suggesting a replacement

  }, {
    key: '_checkRemovedProp',
    value: function _checkRemovedProp(oldProp) {
      var newProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this.props[oldProp] !== undefined) {
        var layerName = this.constructor;
        var message = layerName + ' no longer accepts props.' + oldProp + ' in this version of deck.gl.';
        if (newProp) {
          message += '\nPlease use props.' + newProp + ' instead.';
        }
        _utils.log.once(0, message);
      }
    }
  }, {
    key: '_updateBaseUniforms',
    value: function _updateBaseUniforms() {
      this.setUniforms({
        // apply gamma to opacity to make it visually "linear"
        opacity: Math.pow(this.props.opacity, 1 / 2.2),
        ONE: 1.0
      });
    }
  }, {
    key: '_updateModuleSettings',
    value: function _updateModuleSettings() {
      if (this.state.model) {
        this.state.model.updateModuleSettings({
          pickingHighlightColor: this.props.highlightColor
        });
      }
    }

    // DEPRECATED METHODS

    // Updates selected state members and marks the object for redraw

  }, {
    key: 'setUniforms',
    value: function setUniforms(uniformMap) {
      if (this.state.model) {
        this.state.model.setUniforms(uniformMap);
      }
      // TODO - set needsRedraw on the model?
      this.state.needsRedraw = true;
      (0, _utils.log)(3, 'layer.setUniforms', uniformMap);
    }
  }, {
    key: 'stats',
    get: function get() {
      return this.state.stats;
    }
  }]);

  return Layer;
}();

exports.default = Layer;


Layer.layerName = 'Layer';
Layer.propTypes = defaultProps;
Layer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9sYXllci5qcyJdLCJuYW1lcyI6WyJMT0dfUFJJT1JJVFlfVVBEQVRFIiwiRU1QVFlfQVJSQVkiLCJub29wIiwiZGVmYXVsdFByb3BzIiwiZGF0YUNvbXBhcmF0b3IiLCJ1cGRhdGVUcmlnZ2VycyIsIm51bUluc3RhbmNlcyIsInVuZGVmaW5lZCIsInZpc2libGUiLCJwaWNrYWJsZSIsIm9wYWNpdHkiLCJvbkhvdmVyIiwib25DbGljayIsImNvb3JkaW5hdGVTeXN0ZW0iLCJMTkdMQVQiLCJjb29yZGluYXRlT3JpZ2luIiwicGFyYW1ldGVycyIsInVuaWZvcm1zIiwiZnJhbWVidWZmZXIiLCJhbmltYXRpb24iLCJnZXRQb2x5Z29uT2Zmc2V0IiwibGF5ZXJJbmRleCIsImhpZ2hsaWdodGVkT2JqZWN0SW5kZXgiLCJhdXRvSGlnaGxpZ2h0IiwiaGlnaGxpZ2h0Q29sb3IiLCJjb3VudGVyIiwiTGF5ZXIiLCJwcm9wcyIsIm1lcmdlZERlZmF1bHRQcm9wcyIsIk9iamVjdCIsImFzc2lnbiIsImRhdGEiLCJmcmVlemUiLCJpZCIsImFuaW1hdGVkUHJvcHMiLCJvbGRQcm9wcyIsInN0YXRlIiwiY29udGV4dCIsImNvdW50IiwibGlmZWN5Y2xlIiwiTk9fU1RBVEUiLCJwYXJlbnRMYXllciIsIm9sZFN1YkxheWVycyIsInNlYWwiLCJjbGFzc05hbWUiLCJjb25zdHJ1Y3RvciIsImxheWVyTmFtZSIsIm5hbWUiLCJFcnJvciIsIm9sZENvbnRleHQiLCJjaGFuZ2VGbGFncyIsInByb3BzT3JEYXRhQ2hhbmdlZCIsImRhdGFDaGFuZ2VkIiwiaW52YWxpZGF0ZUF0dHJpYnV0ZSIsIm1vZGVsIiwicmVuZGVyIiwiaW5mbyIsIm1vZGUiLCJpbmRleCIsIkFycmF5IiwiaXNBcnJheSIsIm9iamVjdCIsImF0dHJpYnV0ZU1hbmFnZXIiLCJpbnZhbGlkYXRlQWxsIiwiaW52YWxpZGF0ZSIsImdldE51bUluc3RhbmNlcyIsInVwZGF0ZSIsImJ1ZmZlcnMiLCJpZ25vcmVVbmtub3duQXR0cmlidXRlcyIsImNoYW5nZWRBdHRyaWJ1dGVzIiwiZ2V0Q2hhbmdlZEF0dHJpYnV0ZXMiLCJjbGVhckNoYW5nZWRGbGFncyIsInNldEF0dHJpYnV0ZXMiLCJ1cGRhdGVPYmplY3QiLCJuZWVkc1JlZHJhdyIsInJlZHJhdyIsImxuZ0xhdCIsInZpZXdwb3J0IiwicHJvamVjdCIsInh5IiwidW5wcm9qZWN0IiwicHJvamVjdEZsYXQiLCJ1bnByb2plY3RGbGF0Iiwic2NyZWVuUGl4ZWxzIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIndpbmRvdyIsImkiLCJjb2xvciIsIlVpbnQ4QXJyYXkiLCJpMSIsImkyIiwiaTMiLCJhdHRyaWJ1dGUiLCJ2YWx1ZSIsInNpemUiLCJwaWNraW5nQ29sb3IiLCJlbmNvZGVQaWNraW5nQ29sb3IiLCJ1cGRhdGVQYXJhbXMiLCJnbCIsInN0YXRzIiwic2V0U3RhdGUiLCJhZGRJbnN0YW5jZWQiLCJpbnN0YW5jZVBpY2tpbmdDb2xvcnMiLCJ0eXBlIiwiVU5TSUdORURfQllURSIsImNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9ycyIsImluaXRpYWxpemVTdGF0ZSIsInVwZGF0ZVN0YXRlIiwidXBkYXRlQXR0cmlidXRlcyIsIl91cGRhdGVCYXNlVW5pZm9ybXMiLCJfdXBkYXRlTW9kdWxlU2V0dGluZ3MiLCJzZXRJbnN0YW5jZUNvdW50IiwicHJvZ3JhbSIsImdlb21ldHJ5IiwiZ2V0QXR0cmlidXRlcyIsInNob3VsZFVwZGF0ZSIsImRlcHJlY2F0ZWQiLCJzdGF0ZU5lZWRzVXBkYXRlIiwic2hvdWxkVXBkYXRlU3RhdGUiLCJmaW5hbGl6ZVN0YXRlIiwibW9kdWxlUGFyYW1ldGVycyIsInVwZGF0ZU1vZHVsZVNldHRpbmdzIiwib2Zmc2V0cyIsInBvbHlnb25PZmZzZXQiLCJkcmF3Iiwib3B0cyIsImdldFBpY2tpbmdJbmZvIiwiY2xlYXJSZWRyYXdGbGFncyIsImdldE5lZWRzUmVkcmF3IiwibmV3UHJvcHMiLCJwcm9wc0NoYW5nZWRSZWFzb24iLCJpZ25vcmVQcm9wcyIsImRhdGFDaGFuZ2VkUmVhc29uIiwiX2RpZmZEYXRhUHJvcHMiLCJwcm9wc0NoYW5nZWQiLCJCb29sZWFuIiwidmlld3BvcnRDaGFuZ2VkIiwidXBkYXRlVHJpZ2dlcnNDaGFuZ2VkIiwiX2RpZmZVcGRhdGVUcmlnZ2VycyIsInNvbWV0aGluZ0NoYW5nZWQiLCJsb2ciLCJyZWFzb24iLCJjaGFuZ2UiLCJwcm9wTmFtZSIsIm9sZFRyaWdnZXJzIiwibmV3VHJpZ2dlcnMiLCJkaWZmUmVhc29uIiwidHJpZ2dlck5hbWUiLCJwcm9wZXJ0eU5hbWUiLCJjb25kaXRpb24iLCJvbGRQcm9wIiwibmV3UHJvcCIsIm1lc3NhZ2UiLCJvbmNlIiwic2V0VW5pZm9ybXMiLCJNYXRoIiwicG93IiwiT05FIiwicGlja2luZ0hpZ2hsaWdodENvbG9yIiwidW5pZm9ybU1hcCIsInByb3BUeXBlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7cWpCQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBRUEsSUFBTUEsc0JBQXNCLENBQTVCOztBQUVBLElBQU1DLGNBQWMsRUFBcEI7QUFDQSxJQUFNQyxPQUFPLFNBQVBBLElBQU8sR0FBTSxDQUFFLENBQXJCOztBQUVBOzs7OztBQUtBLElBQU1DLGVBQWU7QUFDbkI7QUFDQUMsa0JBQWdCLElBRkc7QUFHbkJDLGtCQUFnQixFQUhHLEVBR0M7QUFDcEJDLGdCQUFjQyxTQUpLOztBQU1uQkMsV0FBUyxJQU5VO0FBT25CQyxZQUFVLEtBUFM7QUFRbkJDLFdBQVMsR0FSVTs7QUFVbkJDLFdBQVNULElBVlU7QUFXbkJVLFdBQVNWLElBWFU7O0FBYW5CVyxvQkFBa0IsNkJBQWtCQyxNQWJqQjtBQWNuQkMs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LFNBQU4sR0FBa0IsT0FBbEI7QUFDQXBCLE1BQU1zSSxTQUFOLEdBQWtCN0osWUFBbEI7QUFDQXVCLE1BQU12QixZQUFOLEdBQXFCQSxZQUFyQiIsImZpbGUiOiJsYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNLCBMSUZFQ1lDTEV9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBBdHRyaWJ1dGVNYW5hZ2VyIGZyb20gJy4vYXR0cmlidXRlLW1hbmFnZXInO1xuaW1wb3J0IFN0YXRzIGZyb20gJy4vc3RhdHMnO1xuaW1wb3J0IHtnZXREZWZhdWx0UHJvcHMsIGNvbXBhcmVQcm9wc30gZnJvbSAnLi9wcm9wcyc7XG5pbXBvcnQge2xvZywgY291bnR9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHthcHBseVByb3BPdmVycmlkZXMsIHJlbW92ZUxheWVySW5TZWVyfSBmcm9tICcuL3NlZXItaW50ZWdyYXRpb24nO1xuaW1wb3J0IHtHTCwgd2l0aFBhcmFtZXRlcnN9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBMT0dfUFJJT1JJVFlfVVBEQVRFID0gMTtcblxuY29uc3QgRU1QVFlfQVJSQVkgPSBbXTtcbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuLypcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5pZCAtIGxheWVyIG5hbWVcbiAqIEBwYXJhbSB7YXJyYXl9ICBwcm9wcy5kYXRhIC0gYXJyYXkgb2YgZGF0YSBpbnN0YW5jZXNcbiAqIEBwYXJhbSB7Ym9vbH0gcHJvcHMub3BhY2l0eSAtIG9wYWNpdHkgb2YgdGhlIGxheWVyXG4gKi9cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgLy8gZGF0YTogU3BlY2lhbCBoYW5kbGluZyBmb3IgbnVsbCwgc2VlIGJlbG93XG4gIGRhdGFDb21wYXJhdG9yOiBudWxsLFxuICB1cGRhdGVUcmlnZ2Vyczoge30sIC8vIFVwZGF0ZSB0cmlnZ2VyczogYSBjb3JlIGNoYW5nZSBkZXRlY3Rpb24gbWVjaGFuaXNtIGluIGRlY2suZ2xcbiAgbnVtSW5zdGFuY2VzOiB1bmRlZmluZWQsXG5cbiAgdmlzaWJsZTogdHJ1ZSxcbiAgcGlja2FibGU6IGZhbHNlLFxuICBvcGFjaXR5OiAwLjgsXG5cbiAgb25Ib3Zlcjogbm9vcCxcbiAgb25DbGljazogbm9vcCxcblxuICBjb29yZGluYXRlU3lzdGVtOiBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQsXG4gIGNvb3JkaW5hdGVPcmlnaW46IFswLCAwLCAwXSxcblxuICBwYXJhbWV0ZXJzOiB7fSxcbiAgdW5pZm9ybXM6IHt9LFxuICBmcmFtZWJ1ZmZlcjogbnVsbCxcblxuICBhbmltYXRpb246IG51bGwsIC8vIFBhc3NlZCBwcm9wIGFuaW1hdGlvbiBmdW5jdGlvbnMgdG8gZXZhbHVhdGUgcHJvcHNcblxuICAvLyBPZmZzZXQgZGVwdGggYmFzZWQgb24gbGF5ZXIgaW5kZXggdG8gYXZvaWQgei1maWdodGluZy5cbiAgLy8gTmVnYXRpdmUgdmFsdWVzIHB1bGwgbGF5ZXIgdG93YXJkcyB0aGUgY2FtZXJhXG4gIC8vIGh0dHBzOi8vd3d3Lm9wZW5nbC5vcmcvYXJjaGl2ZXMvcmVzb3VyY2VzL2ZhcS90ZWNobmljYWwvcG9seWdvbm9mZnNldC5odG1cbiAgZ2V0UG9seWdvbk9mZnNldDogKHtsYXllckluZGV4fSkgPT4gWzAsIC1sYXllckluZGV4ICogMTAwXSxcblxuICAvLyBTZWxlY3Rpb24vSGlnaGxpZ2h0aW5nXG4gIGhpZ2hsaWdodGVkT2JqZWN0SW5kZXg6IC0xLFxuICBhdXRvSGlnaGxpZ2h0OiBmYWxzZSxcbiAgaGlnaGxpZ2h0Q29sb3I6IFswLCAwLCAxMjgsIDEyOF1cbn07XG5cbmxldCBjb3VudGVyID0gMDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIge1xuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyAtIFNlZSBkb2NzIGFuZCBkZWZhdWx0cyBhYm92ZVxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAvLyBJZiBzdWJsYXllciBoYXMgc3RhdGljIGRlZmF1bHRQcm9wcyBtZW1iZXIsIGdldERlZmF1bHRQcm9wcyB3aWxsIHJldHVybiBpdFxuICAgIGNvbnN0IG1lcmdlZERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcyh0aGlzKTtcbiAgICAvLyBNZXJnZSBzdXBwbGllZCBwcm9wcyB3aXRoIHByZS1tZXJnZWQgZGVmYXVsdCBwcm9wc1xuICAgIHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgbWVyZ2VkRGVmYXVsdFByb3BzLCBwcm9wcyk7XG4gICAgLy8gQWNjZXB0IG51bGwgYXMgZGF0YSAtIG90aGVyd2lzZSBhcHBzIGFuZCBsYXllcnMgbmVlZCB0byBhZGQgdWdseSBjaGVja3NcbiAgICAvLyBVc2UgY29uc3RhbnQgZmFsbGJhY2sgc28gdGhhdCBkYXRhIGNoYW5nZSBpcyBub3QgdHJpZ2dlcmVkXG4gICAgcHJvcHMuZGF0YSA9IHByb3BzLmRhdGEgfHwgRU1QVFlfQVJSQVk7XG4gICAgLy8gQXBwbHkgYW55IG92ZXJyaWRlcyBmcm9tIHRoZSBzZWVyIGRlYnVnIGV4dGVuc2lvbiBpZiBpdCBpcyBhY3RpdmVcbiAgICBhcHBseVByb3BPdmVycmlkZXMocHJvcHMpO1xuICAgIC8vIFByb3BzIGFyZSBpbW11dGFibGVcbiAgICBPYmplY3QuZnJlZXplKHByb3BzKTtcblxuICAgIC8vIERlZmluZSBhbGwgbWVtYmVyc1xuICAgIHRoaXMuaWQgPSBwcm9wcy5pZDsgLy8gVGhlIGxheWVyJ3MgaWQsIHVzZWQgZm9yIG1hdGNoaW5nIHdpdGggbGF5ZXJzJyBmcm9tIGxhc3QgcmVuZGVyIGN5Y2tsZVxuICAgIHRoaXMucHJvcHMgPSBwcm9wczsgLy8gQ3VycmVudCBwcm9wcywgYSBmcm96ZW4gb2JqZWN0XG4gICAgdGhpcy5hbmltYXRlZFByb3BzID0gbnVsbDsgLy8gQ29tcHV0aW5nIGFuaW1hdGVkIHByb3BzIHJlcXVpcmVzIGxheWVyIG1hbmFnZXIgc3RhdGVcbiAgICB0aGlzLm9sZFByb3BzID0gbnVsbDsgLy8gUHJvcHMgZnJvbSBsYXN0IHJlbmRlciB1c2VkIGZvciBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7IC8vIFdpbGwgYmUgc2V0IHRvIHRoZSBzaGFyZWQgbGF5ZXIgc3RhdGUgb2JqZWN0IGR1cmluZyBsYXllciBtYXRjaGluZ1xuICAgIHRoaXMuY29udGV4dCA9IG51bGw7IC8vIFdpbGwgcmVmZXJlbmNlIGxheWVyIG1hbmFnZXIncyBjb250ZXh0LCBjb250YWlucyBzdGF0ZSBzaGFyZWQgYnkgbGF5ZXJzXG4gICAgdGhpcy5jb3VudCA9IGNvdW50ZXIrKzsgLy8gS2VlcCB0cmFjayBvZiBob3cgbWFueSBsYXllciBpbnN0YW5jZXMgeW91IGFyZSBnZW5lcmF0aW5nXG4gICAgdGhpcy5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuTk9fU1RBVEU7IC8vIEhlbHBzIHRyYWNrIGFuZCBkZWJ1ZyB0aGUgbGlmZSBjeWNsZSBvZiB0aGUgbGF5ZXJzXG4gICAgLy8gQ29tcG9zaXRlTGF5ZXIgbWVtYmVycywgbmVlZCB0byBiZSBkZWZpbmVkIGhlcmUgYmVjYXVzZSBvZiB0aGUgYE9iamVjdC5zZWFsYFxuICAgIHRoaXMucGFyZW50TGF5ZXIgPSBudWxsOyAvLyByZWZlcmVuY2UgdG8gdGhlIGNvbXBvc2l0ZSBsYXllciBwYXJlbnQgdGhhdCByZW5kZXJlZCB0aGlzIGxheWVyXG4gICAgdGhpcy5vbGRTdWJMYXllcnMgPSBbXTsgLy8gcmVmZXJlbmNlIHRvIHN1YmxheWVycyByZW5kZXJlZCBpbiB0aGUgcHJldmlvdXMgY3ljbGVcbiAgICAvLyBTZWFsIHRoZSBsYXllclxuICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5sYXllck5hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHJldHVybiBgJHtjbGFzc05hbWV9KHtpZDogJyR7dGhpcy5wcm9wcy5pZH0nfSlgO1xuICB9XG5cbiAgZ2V0IHN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnN0YXRzO1xuICB9XG5cbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gTElGRUNZQ0xFIE1FVEhPRFMsIG92ZXJyaWRkZW4gYnkgdGhlIGxheWVyIHN1YmNsYXNzZXNcblxuICAvLyBDYWxsZWQgb25jZSB0byBzZXQgdXAgdGhlIGluaXRpYWwgc3RhdGVcbiAgLy8gQXBwIGNhbiBjcmVhdGUgV2ViR0wgcmVzb3VyY2VzXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYExheWVyICR7dGhpc30gaGFzIG5vdCBkZWZpbmVkIGluaXRpYWxpemVTdGF0ZWApO1xuICB9XG5cbiAgLy8gTGV0J3MgbGF5ZXIgY29udHJvbCBpZiB1cGRhdGVTdGF0ZSBzaG91bGQgYmUgY2FsbGVkXG4gIHNob3VsZFVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIG9sZENvbnRleHQsIGNvbnRleHQsIGNoYW5nZUZsYWdzfSkge1xuICAgIHJldHVybiBjaGFuZ2VGbGFncy5wcm9wc09yRGF0YUNoYW5nZWQ7XG4gIH1cblxuICAvLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uLCBhbGwgYXR0cmlidXRlcyB3aWxsIGJlIGludmFsaWRhdGVkIGFuZCB1cGRhdGVkXG4gIC8vIHdoZW4gZGF0YSBjaGFuZ2VzXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIG9sZENvbnRleHQsIGNvbnRleHQsIGNoYW5nZUZsYWdzfSkge1xuICAgIGlmIChjaGFuZ2VGbGFncy5kYXRhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlQXR0cmlidXRlKCdhbGwnKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgb25jZSB3aGVuIGxheWVyIGlzIG5vIGxvbmdlciBtYXRjaGVkIGFuZCBzdGF0ZSB3aWxsIGJlIGRpc2NhcmRlZFxuICAvLyBBcHAgY2FuIGRlc3Ryb3kgV2ViR0wgcmVzb3VyY2VzIGhlcmVcbiAgZmluYWxpemVTdGF0ZSgpIHtcbiAgfVxuXG4gIC8vIElmIHN0YXRlIGhhcyBhIG1vZGVsLCBkcmF3IGl0IHdpdGggc3VwcGxpZWQgdW5pZm9ybXNcbiAgZHJhdyh7dW5pZm9ybXMgPSB7fX0pIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbCkge1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5yZW5kZXIodW5pZm9ybXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNhbGxlZCB0byBwb3B1bGF0ZSB0aGUgaW5mbyBvYmplY3QgdGhhdCBpcyBwYXNzZWQgdG8gdGhlIGV2ZW50IGhhbmRsZXJcbiAgLy8gQHJldHVybiBudWxsIHRvIGNhbmNlbCBldmVudFxuICBnZXRQaWNraW5nSW5mbyh7aW5mbywgbW9kZX0pIHtcbiAgICBjb25zdCB7aW5kZXh9ID0gaW5mbztcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAvLyBJZiBwcm9wcy5kYXRhIGlzIGFuIGluZGV4YWJsZSBhcnJheSwgZ2V0IHRoZSBvYmplY3RcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMucHJvcHMuZGF0YSkpIHtcbiAgICAgICAgaW5mby5vYmplY3QgPSB0aGlzLnByb3BzLmRhdGFbaW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG5cbiAgLy8gRU5EIExJRkVDWUNMRSBNRVRIT0RTXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBhdHRyaWJ1dGUgaW52YWxpZGF0aW9uLCBjYW4gYmUgcmVkZWZpbmVcbiAgaW52YWxpZGF0ZUF0dHJpYnV0ZShuYW1lID0gJ2FsbCcpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2FsbCcpIHtcbiAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlKG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxzIGF0dHJpYnV0ZSBtYW5hZ2VyIHRvIHVwZGF0ZSBhbnkgV2ViR0wgYXR0cmlidXRlcywgY2FuIGJlIHJlZGVmaW5lZFxuICB1cGRhdGVBdHRyaWJ1dGVzKHByb3BzKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXIsIG1vZGVsfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFhdHRyaWJ1dGVNYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRmlndXJlIG91dCBkYXRhIGxlbmd0aFxuICAgIGNvbnN0IG51bUluc3RhbmNlcyA9IHRoaXMuZ2V0TnVtSW5zdGFuY2VzKHByb3BzKTtcblxuICAgIGF0dHJpYnV0ZU1hbmFnZXIudXBkYXRlKHtcbiAgICAgIGRhdGE6IHByb3BzLmRhdGEsXG4gICAgICBudW1JbnN0YW5jZXMsXG4gICAgICBwcm9wcyxcbiAgICAgIGJ1ZmZlcnM6IHByb3BzLFxuICAgICAgY29udGV4dDogdGhpcyxcbiAgICAgIC8vIERvbid0IHdvcnJ5IGFib3V0IG5vbi1hdHRyaWJ1dGUgcHJvcHNcbiAgICAgIGlnbm9yZVVua25vd25BdHRyaWJ1dGVzOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIGNvbnN0IGNoYW5nZWRBdHRyaWJ1dGVzID0gYXR0cmlidXRlTWFuYWdlci5nZXRDaGFuZ2VkQXR0cmlidXRlcyh7Y2xlYXJDaGFuZ2VkRmxhZ3M6IHRydWV9KTtcbiAgICAgIG1vZGVsLnNldEF0dHJpYnV0ZXMoY2hhbmdlZEF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1YmxpYyBBUElcblxuICAvLyBVcGRhdGVzIHNlbGVjdGVkIHN0YXRlIG1lbWJlcnMgYW5kIG1hcmtzIHRoZSBvYmplY3QgZm9yIHJlZHJhd1xuICBzZXRTdGF0ZSh1cGRhdGVPYmplY3QpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuc3RhdGUsIHVwZGF0ZU9iamVjdCk7XG4gICAgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gIH1cblxuICBzZXROZWVkc1JlZHJhdyhyZWRyYXcgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUpIHtcbiAgICAgIHRoaXMuc3RhdGUubmVlZHNSZWRyYXcgPSByZWRyYXc7XG4gICAgfVxuICB9XG5cbiAgLy8gUFJPSkVDVElPTiBNRVRIT0RTXG5cbiAgLyoqXG4gICAqIFByb2plY3RzIGEgcG9pbnQgd2l0aCBjdXJyZW50IG1hcCBzdGF0ZSAobGF0LCBsb24sIHpvb20sIHBpdGNoLCBiZWFyaW5nKVxuICAgKlxuICAgKiBOb3RlOiBQb3NpdGlvbiBjb252ZXJzaW9uIGlzIGRvbmUgaW4gc2hhZGVyLCBzbyBpbiBtYW55IGNhc2VzIHRoZXJlIGlzIG5vIG5lZWRcbiAgICogZm9yIHRoaXMgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBsbmdMYXQgLSBsb25nIGFuZCBsYXQgdmFsdWVzXG4gICAqIEByZXR1cm4ge0FycmF5fFR5cGVkQXJyYXl9IC0geCwgeSBjb29yZGluYXRlc1xuICAgKi9cbiAgcHJvamVjdChsbmdMYXQpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KGxuZ0xhdCksICdMYXllci5wcm9qZWN0IG5lZWRzIFtsbmcsbGF0XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC5wcm9qZWN0KGxuZ0xhdCk7XG4gIH1cblxuICB1bnByb2plY3QoeHkpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHh5KSwgJ0xheWVyLnVucHJvamVjdCBuZWVkcyBbeCx5XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC51bnByb2plY3QoeHkpO1xuICB9XG5cbiAgcHJvamVjdEZsYXQobG5nTGF0KSB7XG4gICAgY29uc3Qge3ZpZXdwb3J0fSA9IHRoaXMuY29udGV4dDtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShsbmdMYXQpLCAnTGF5ZXIucHJvamVjdCBuZWVkcyBbbG5nLGxhdF0nKTtcbiAgICByZXR1cm4gdmlld3BvcnQucHJvamVjdEZsYXQobG5nTGF0KTtcbiAgfVxuXG4gIHVucHJvamVjdEZsYXQoeHkpIHtcbiAgICBjb25zdCB7dmlld3BvcnR9ID0gdGhpcy5jb250ZXh0O1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHh5KSwgJ0xheWVyLnVucHJvamVjdCBuZWVkcyBbeCx5XScpO1xuICAgIHJldHVybiB2aWV3cG9ydC51bnByb2plY3RGbGF0KHh5KTtcbiAgfVxuXG4gIHNjcmVlblRvRGV2aWNlUGl4ZWxzKHNjcmVlblBpeGVscykge1xuICAgIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gICAgcmV0dXJuIHNjcmVlblBpeGVscyAqIGRldmljZVBpeGVsUmF0aW87XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBhIGJsYWNrIGNvbG9yXG4gICAqL1xuICBudWxsUGlja2luZ0NvbG9yKCkge1xuICAgIHJldHVybiBbMCwgMCwgMF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGlja2luZyBjb2xvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggYW55IHN1YmZlYXR1cmVcbiAgICogVXNlIGlmIHNvbWUgZ3JhcGhpY3MgZG8gbm90IGJlbG9uZyB0byBhbnkgcGlja2FibGUgc3ViZmVhdHVyZVxuICAgKiBAcGFyYW0ge2ludH0gaSAtIGluZGV4IHRvIGJlIGRlY29kZWRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gdGhlIGRlY29kZWQgY29sb3JcbiAgICovXG4gIGVuY29kZVBpY2tpbmdDb2xvcihpKSB7XG4gICAgYXNzZXJ0KCgoKChpICsgMSkgPj4gMjQpICYgMjU1KSA9PT0gMCksICdpbmRleCBvdXQgb2YgcGlja2luZyBjb2xvciByYW5nZScpO1xuICAgIHJldHVybiBbXG4gICAgICAoaSArIDEpICYgMjU1LFxuICAgICAgKChpICsgMSkgPj4gOCkgJiAyNTUsXG4gICAgICAoKChpICsgMSkgPj4gOCkgPj4gOCkgJiAyNTVcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBpY2tpbmcgY29sb3IgdGhhdCBkb2Vzbid0IG1hdGNoIGFueSBzdWJmZWF0dXJlXG4gICAqIFVzZSBpZiBzb21lIGdyYXBoaWNzIGRvIG5vdCBiZWxvbmcgdG8gYW55IHBpY2thYmxlIHN1YmZlYXR1cmVcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBjb2xvciAtIGNvbG9yIGFycmF5IHRvIGJlIGRlY29kZWRcbiAgICogQHJldHVybiB7QXJyYXl9IC0gdGhlIGRlY29kZWQgcGlja2luZyBjb2xvclxuICAgKi9cbiAgZGVjb2RlUGlja2luZ0NvbG9yKGNvbG9yKSB7XG4gICAgYXNzZXJ0KGNvbG9yIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG4gICAgY29uc3QgW2kxLCBpMiwgaTNdID0gY29sb3I7XG4gICAgLy8gMSB3YXMgYWRkZWQgdG8gc2VwZXJhdGUgZnJvbSBubyBzZWxlY3Rpb25cbiAgICBjb25zdCBpbmRleCA9IGkxICsgaTIgKiAyNTYgKyBpMyAqIDY1NTM2IC0gMTtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBjYWxjdWxhdGVJbnN0YW5jZVBpY2tpbmdDb2xvcnMoYXR0cmlidXRlLCB7bnVtSW5zdGFuY2VzfSkge1xuICAgIGNvbnN0IHt2YWx1ZSwgc2l6ZX0gPSBhdHRyaWJ1dGU7XG4gICAgLy8gYWRkIDEgdG8gaW5kZXggdG8gc2VwZXJhdGUgZnJvbSBubyBzZWxlY3Rpb25cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUluc3RhbmNlczsgaSsrKSB7XG4gICAgICBjb25zdCBwaWNraW5nQ29sb3IgPSB0aGlzLmVuY29kZVBpY2tpbmdDb2xvcihpKTtcbiAgICAgIHZhbHVlW2kgKiBzaXplICsgMF0gPSBwaWNraW5nQ29sb3JbMF07XG4gICAgICB2YWx1ZVtpICogc2l6ZSArIDFdID0gcGlja2luZ0NvbG9yWzFdO1xuICAgICAgdmFsdWVbaSAqIHNpemUgKyAyXSA9IHBpY2tpbmdDb2xvclsyXTtcbiAgICB9XG4gIH1cblxuICAvLyBEQVRBIEFDQ0VTUyBBUElcbiAgLy8gRGF0YSBjYW4gdXNlIGl0ZXJhdG9ycyBhbmQgbWF5IG5vdCBiZSByYW5kb20gYWNjZXNzXG5cbiAgLy8gVXNlIGl0ZXJhdGlvbiAodGhlIG9ubHkgcmVxdWlyZWQgY2FwYWJpbGl0eSBvbiBkYXRhKSB0byBnZXQgZmlyc3QgZWxlbWVudFxuICBnZXRGaXJzdE9iamVjdCgpIHtcbiAgICBjb25zdCB7ZGF0YX0gPSB0aGlzLnByb3BzO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIGRhdGEpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSU5URVJOQUwgTUVUSE9EU1xuXG4gIC8vIERlZHVjZXMgbnVtZXIgb2YgaW5zdGFuY2VzLiBJbnRlbnRpb24gaXMgdG8gc3VwcG9ydDpcbiAgLy8gLSBFeHBsaWNpdCBzZXR0aW5nIG9mIG51bUluc3RhbmNlc1xuICAvLyAtIEF1dG8tZGVkdWN0aW9uIGZvciBFUzYgY29udGFpbmVycyB0aGF0IGRlZmluZSBhIHNpemUgbWVtYmVyXG4gIC8vIC0gQXV0by1kZWR1Y3Rpb24gZm9yIENsYXNzaWMgQXJyYXlzIHZpYSB0aGUgYnVpbHQtaW4gbGVuZ3RoIGF0dHJpYnV0ZVxuICAvLyAtIEF1dG8tZGVkdWN0aW9uIHZpYSBhcnJheXNcbiAgZ2V0TnVtSW5zdGFuY2VzKHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB0aGlzLnByb3BzO1xuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIGxheWVyIGhhcyBzZXQgaXRzIG93biB2YWx1ZVxuICAgIGlmICh0aGlzLnN0YXRlICYmIHRoaXMuc3RhdGUubnVtSW5zdGFuY2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLm51bUluc3RhbmNlcztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhcHAgaGFzIHByb3ZpZGVkIGFuIGV4cGxpY2l0IHZhbHVlXG4gICAgaWYgKHByb3BzLm51bUluc3RhbmNlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJvcHMubnVtSW5zdGFuY2VzO1xuICAgIH1cblxuICAgIC8vIFVzZSBjb250YWluZXIgbGlicmFyeSB0byBnZXQgYSBjb3VudCBmb3IgYW55IEVTNiBjb250YWluZXIgb3Igb2JqZWN0XG4gICAgY29uc3Qge2RhdGF9ID0gcHJvcHM7XG4gICAgcmV0dXJuIGNvdW50KGRhdGEpO1xuICB9XG5cbiAgLy8gTEFZRVIgTUFOQUdFUiBBUElcbiAgLy8gU2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJ5IHRoZSBkZWNrLmdsIExheWVyTWFuYWdlciBjbGFzc1xuXG4gIC8vIENhbGxlZCBieSBsYXllciBtYW5hZ2VyIHdoZW4gYSBuZXcgbGF5ZXIgaXMgZm91bmRcbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMgKi9cbiAgaW5pdGlhbGl6ZUxheWVyKHVwZGF0ZVBhcmFtcykge1xuICAgIGFzc2VydCh0aGlzLmNvbnRleHQuZ2wsICdMYXllciBjb250ZXh0IG1pc3NpbmcgZ2wnKTtcbiAgICBhc3NlcnQoIXRoaXMuc3RhdGUsICdMYXllciBtaXNzaW5nIHN0YXRlJyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5zdGF0ZS5zdGF0cyA9IG5ldyBTdGF0cyh7aWQ6ICdkcmF3J30pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBzdGF0ZSBvbmx5IG9uY2VcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGF0dHJpYnV0ZU1hbmFnZXI6IG5ldyBBdHRyaWJ1dGVNYW5hZ2VyKHtpZDogdGhpcy5wcm9wcy5pZH0pLFxuICAgICAgbW9kZWw6IG51bGwsXG4gICAgICBuZWVkc1JlZHJhdzogdHJ1ZSxcbiAgICAgIGRhdGFDaGFuZ2VkOiB0cnVlXG4gICAgfSk7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIC8vIEFsbCBpbnN0YW5jZWQgbGF5ZXJzIGdldCBpbnN0YW5jZVBpY2tpbmdDb2xvcnMgYXR0cmlidXRlIGJ5IGRlZmF1bHRcbiAgICAvLyBUaGVpciBzaGFkZXJzIGNhbiB1c2UgaXQgdG8gcmVuZGVyIGEgcGlja2luZyBzY2VuZVxuICAgIC8vIFRPRE8gLSB0aGlzIHNsb3dzIGRvd24gbm9uIGluc3RhbmNlZCBsYXllcnNcbiAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICBpbnN0YW5jZVBpY2tpbmdDb2xvcnM6IHtcbiAgICAgICAgdHlwZTogR0wuVU5TSUdORURfQllURSxcbiAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUluc3RhbmNlUGlja2luZ0NvbG9yc1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kc1xuICAgIHRoaXMuaW5pdGlhbGl6ZVN0YXRlKHRoaXMuY29udGV4dCk7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSh1cGRhdGVQYXJhbXMpO1xuICAgIC8vIEVuZCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kc1xuXG4gICAgLy8gQWRkIGFueSBzdWJjbGFzcyBhdHRyaWJ1dGVzXG4gICAgdGhpcy51cGRhdGVBdHRyaWJ1dGVzKHRoaXMucHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZUJhc2VVbmlmb3JtcygpO1xuICAgIHRoaXMuX3VwZGF0ZU1vZHVsZVNldHRpbmdzKCk7XG5cbiAgICBjb25zdCB7bW9kZWx9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIG1vZGVsLnNldEluc3RhbmNlQ291bnQodGhpcy5nZXROdW1JbnN0YW5jZXMoKSk7XG4gICAgICBtb2RlbC5pZCA9IHRoaXMucHJvcHMuaWQ7XG4gICAgICBtb2RlbC5wcm9ncmFtLmlkID0gYCR7dGhpcy5wcm9wcy5pZH0tcHJvZ3JhbWA7XG4gICAgICBtb2RlbC5nZW9tZXRyeS5pZCA9IGAke3RoaXMucHJvcHMuaWR9LWdlb21ldHJ5YDtcbiAgICAgIG1vZGVsLnNldEF0dHJpYnV0ZXMoYXR0cmlidXRlTWFuYWdlci5nZXRBdHRyaWJ1dGVzKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCBieSBsYXllciBtYW5hZ2VyIHdoZW4gZXhpc3RpbmcgbGF5ZXIgaXMgZ2V0dGluZyBuZXcgcHJvcHNcbiAgdXBkYXRlTGF5ZXIodXBkYXRlUGFyYW1zKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGRlcHJlY2F0ZWQgbWV0aG9kXG4gICAgaWYgKHRoaXMuc2hvdWxkVXBkYXRlKSB7XG4gICAgICBsb2cuZGVwcmVjYXRlZCgnc2hvdWxkVXBkYXRlJywgJ3Nob3VsZFVwZGF0ZVN0YXRlJyk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGNvbnRleHQgaXMgYXZhaWxhYmxlXG4gICAgdXBkYXRlUGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb250ZXh0LCB1cGRhdGVQYXJhbXMpO1xuXG4gICAgLy8gQ2FsbCBzdWJjbGFzcyBsaWZlY3ljbGUgbWV0aG9kXG4gICAgY29uc3Qgc3RhdGVOZWVkc1VwZGF0ZSA9IHRoaXMuc2hvdWxkVXBkYXRlU3RhdGUodXBkYXRlUGFyYW1zKTtcbiAgICAvLyBFbmQgbGlmZWN5Y2xlIG1ldGhvZFxuXG4gICAgaWYgKHN0YXRlTmVlZHNVcGRhdGUpIHtcbiAgICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgICAgdGhpcy51cGRhdGVTdGF0ZSh1cGRhdGVQYXJhbXMpO1xuICAgICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcblxuICAgICAgLy8gUnVuIHRoZSBhdHRyaWJ1dGUgdXBkYXRlcnNcbiAgICAgIHRoaXMudXBkYXRlQXR0cmlidXRlcyh1cGRhdGVQYXJhbXMucHJvcHMpO1xuICAgICAgdGhpcy5fdXBkYXRlQmFzZVVuaWZvcm1zKCk7XG4gICAgICB0aGlzLl91cGRhdGVNb2R1bGVTZXR0aW5ncygpO1xuXG4gICAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbCkge1xuICAgICAgICB0aGlzLnN0YXRlLm1vZGVsLnNldEluc3RhbmNlQ291bnQodGhpcy5nZXROdW1JbnN0YW5jZXMoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICAvLyBDYWxsZWQgYnkgbWFuYWdlciB3aGVuIGxheWVyIGlzIGFib3V0IHRvIGJlIGRpc3Bvc2VkXG4gIC8vIE5vdGU6IG5vdCBndWFyYW50ZWVkIHRvIGJlIGNhbGxlZCBvbiBhcHBsaWNhdGlvbiBzaHV0ZG93blxuICBmaW5hbGl6ZUxheWVyKCkge1xuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHRoaXMuZmluYWxpemVTdGF0ZSh0aGlzLmNvbnRleHQpO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG4gICAgcmVtb3ZlTGF5ZXJJblNlZXIodGhpcy5pZCk7XG4gIH1cblxuICAvLyBDYWxjdWxhdGVzIHVuaWZvcm1zXG4gIGRyYXdMYXllcih7bW9kdWxlUGFyYW1ldGVycyA9IG51bGwsIHVuaWZvcm1zID0ge30sIHBhcmFtZXRlcnMgPSB7fX0pIHtcblxuICAgIC8vIFRPRE8vaWIgLSBoYWNrIG1vdmUgdG8gbHVtYSBNb2RlbC5kcmF3XG4gICAgaWYgKG1vZHVsZVBhcmFtZXRlcnMgJiYgdGhpcy5zdGF0ZS5tb2RlbCkge1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC51cGRhdGVNb2R1bGVTZXR0aW5ncyhtb2R1bGVQYXJhbWV0ZXJzKTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBwb2x5Z29uIG9mZnNldCB0byBhdm9pZCB6LWZpZ2h0aW5nXG4gICAgY29uc3Qge2dldFBvbHlnb25PZmZzZXR9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBvZmZzZXRzID0gZ2V0UG9seWdvbk9mZnNldCAmJiBnZXRQb2x5Z29uT2Zmc2V0KHVuaWZvcm1zKSB8fCBbMCwgMF07XG4gICAgcGFyYW1ldGVycy5wb2x5Z29uT2Zmc2V0ID0gb2Zmc2V0cztcblxuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHdpdGhQYXJhbWV0ZXJzKHRoaXMuY29udGV4dC5nbCwgcGFyYW1ldGVycywgKCkgPT4ge1xuICAgICAgdGhpcy5kcmF3KHttb2R1bGVQYXJhbWV0ZXJzLCB1bmlmb3JtcywgcGFyYW1ldGVycywgY29udGV4dDogdGhpcy5jb250ZXh0fSk7XG4gICAgfSk7XG4gICAgLy8gRW5kIGxpZmVjeWNsZSBtZXRob2RcbiAgfVxuXG4gIC8vIHt1bmlmb3JtcyA9IHt9LCAuLi5vcHRzfVxuICBwaWNrTGF5ZXIob3B0cykge1xuICAgIC8vIENhbGwgc3ViY2xhc3MgbGlmZWN5Y2xlIG1ldGhvZFxuICAgIHJldHVybiB0aGlzLmdldFBpY2tpbmdJbmZvKG9wdHMpO1xuICAgIC8vIEVuZCBsaWZlY3ljbGUgbWV0aG9kXG4gIH1cblxuICAvLyBDaGVja3Mgc3RhdGUgb2YgYXR0cmlidXRlcyBhbmQgbW9kZWxcbiAgLy8gVE9ETyAtIGlzIGF0dHJpYnV0ZSBtYW5hZ2VyIG5lZWRlZD8gLSBNb2RlbCBzaG91bGQgYmUgZW5vdWdoLlxuICBnZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFncyA9IGZhbHNlfSA9IHt9KSB7XG4gICAgLy8gdGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBieSB0aGUgcmVuZGVyIGxvb3AgYXMgc29vbiBhIHRoZSBsYXllclxuICAgIC8vIGhhcyBiZWVuIGNyZWF0ZWQsIHNvIGd1YXJkIGFnYWluc3QgdW5pbml0aWFsaXplZCBzdGF0ZVxuICAgIGlmICghdGhpcy5zdGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCByZWRyYXcgPSBmYWxzZTtcbiAgICByZWRyYXcgPSByZWRyYXcgfHwgdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdztcbiAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gdGhpcy5zdGF0ZS5uZWVkc1JlZHJhdyAmJiAhY2xlYXJSZWRyYXdGbGFncztcblxuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyLCBtb2RlbH0gPSB0aGlzLnN0YXRlO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCAoYXR0cmlidXRlTWFuYWdlciAmJiBhdHRyaWJ1dGVNYW5hZ2VyLmdldE5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzfSkpO1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCAobW9kZWwgJiYgbW9kZWwuZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3N9KSk7XG5cbiAgICByZXR1cm4gcmVkcmF3O1xuICB9XG5cbiAgZGlmZlByb3BzKG9sZFByb3BzLCBuZXdQcm9wcywgY29udGV4dCkge1xuICAgIC8vIEZpcnN0IGNoZWNrIGlmIGFueSBwcm9wcyBoYXZlIGNoYW5nZWQgKGlnbm9yZSBwcm9wcyB0aGF0IHdpbGwgYmUgZXhhbWluZWQgc2VwYXJhdGVseSlcbiAgICBjb25zdCBwcm9wc0NoYW5nZWRSZWFzb24gPSBjb21wYXJlUHJvcHMoe1xuICAgICAgbmV3UHJvcHMsXG4gICAgICBvbGRQcm9wcyxcbiAgICAgIGlnbm9yZVByb3BzOiB7ZGF0YTogbnVsbCwgdXBkYXRlVHJpZ2dlcnM6IG51bGx9XG4gICAgfSk7XG5cbiAgICAvLyBOb3cgY2hlY2sgaWYgYW55IGRhdGEgcmVsYXRlZCBwcm9wcyBoYXZlIGNoYW5nZWRcbiAgICBjb25zdCBkYXRhQ2hhbmdlZFJlYXNvbiA9IHRoaXMuX2RpZmZEYXRhUHJvcHMob2xkUHJvcHMsIG5ld1Byb3BzKTtcblxuICAgIGNvbnN0IHByb3BzQ2hhbmdlZCA9IEJvb2xlYW4ocHJvcHNDaGFuZ2VkUmVhc29uKTtcbiAgICBjb25zdCBkYXRhQ2hhbmdlZCA9IEJvb2xlYW4oZGF0YUNoYW5nZWRSZWFzb24pO1xuICAgIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9IGNvbnRleHQudmlld3BvcnRDaGFuZ2VkO1xuXG4gICAgbGV0IHVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIC8vIENoZWNrIHVwZGF0ZSB0cmlnZ2VycyB0byBkZXRlcm1pbmUgaWYgYW55IGF0dHJpYnV0ZXMgbmVlZCByZWdlbmVyYXRpb25cbiAgICAvLyBOb3RlIC0gaWYgZGF0YSBoYXMgY2hhbmdlZCwgYWxsIGF0dHJpYnV0ZXMgd2lsbCBuZWVkIHJlZ2VuZXJhdGlvbiwgc28gc2tpcCB0aGlzIHN0ZXBcbiAgICBpZiAoIWRhdGFDaGFuZ2VkKSB7XG4gICAgICB1cGRhdGVUcmlnZ2Vyc0NoYW5nZWQgPSB0aGlzLl9kaWZmVXBkYXRlVHJpZ2dlcnMob2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9wc09yRGF0YUNoYW5nZWQgPSBwcm9wc0NoYW5nZWQgfHwgZGF0YUNoYW5nZWQgfHwgdXBkYXRlVHJpZ2dlcnNDaGFuZ2VkO1xuICAgIGNvbnN0IHNvbWV0aGluZ0NoYW5nZWQgPSBwcm9wc09yRGF0YUNoYW5nZWQgfHwgdmlld3BvcnRDaGFuZ2VkO1xuXG4gICAgLy8gVHJhY2Ugd2hhdCBoYXBwZW5lZFxuICAgIGlmIChkYXRhQ2hhbmdlZCkge1xuICAgICAgbG9nLmxvZyhMT0dfUFJJT1JJVFlfVVBEQVRFLCBgZGF0YUNoYW5nZWQ6ICR7ZGF0YUNoYW5nZWRSZWFzb259IGluICR7dGhpcy5pZH1gKTtcbiAgICB9IGVsc2UgaWYgKHByb3BzQ2hhbmdlZCkge1xuICAgICAgbG9nLmxvZyhMT0dfUFJJT1JJVFlfVVBEQVRFLCBgcHJvcHNDaGFuZ2VkOiAke3Byb3BzQ2hhbmdlZFJlYXNvbn0gaW4gJHt0aGlzLmlkfWApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwcm9wc0NoYW5nZWQsXG4gICAgICBkYXRhQ2hhbmdlZCxcbiAgICAgIHVwZGF0ZVRyaWdnZXJzQ2hhbmdlZCxcbiAgICAgIHByb3BzT3JEYXRhQ2hhbmdlZCxcbiAgICAgIHZpZXdwb3J0Q2hhbmdlZCxcbiAgICAgIHNvbWV0aGluZ0NoYW5nZWQsXG4gICAgICByZWFzb246IGRhdGFDaGFuZ2VkUmVhc29uIHx8IHByb3BzQ2hhbmdlZFJlYXNvbiB8fCAnVmlld3BvcnQgY2hhbmdlZCdcbiAgICB9O1xuICB9XG5cbiAgLy8gUFJJVkFURSBNRVRIT0RTXG5cbiAgLy8gVGhlIGNvbXBhcmlzb24gb2YgdGhlIGRhdGEgcHJvcCByZXF1aXJlcyBzcGVjaWFsIGhhbmRsaW5nXG4gIC8vIHRoZSBkYXRhQ29tcGFyYXRvciBzaG91bGQgYmUgdXNlZCBpZiBzdXBwbGllZFxuICBfZGlmZkRhdGFQcm9wcyhvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnb2xkUHJvcHMgaXMgbnVsbCwgaW5pdGlhbCBkaWZmJztcbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0IG9wdGlvbmFsIGFwcCBkZWZpbmVkIGNvbXBhcmlzb24gb2YgZGF0YVxuICAgIGNvbnN0IHtkYXRhQ29tcGFyYXRvcn0gPSBuZXdQcm9wcztcbiAgICBpZiAoZGF0YUNvbXBhcmF0b3IpIHtcbiAgICAgIGlmICghZGF0YUNvbXBhcmF0b3IobmV3UHJvcHMuZGF0YSwgb2xkUHJvcHMuZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuICdEYXRhIGNvbXBhcmF0b3IgZGV0ZWN0ZWQgYSBjaGFuZ2UnO1xuICAgICAgfVxuICAgIC8vIE90aGVyd2lzZSwgZG8gYSBzaGFsbG93IGVxdWFsIG9uIHByb3BzXG4gICAgfSBlbHNlIGlmIChuZXdQcm9wcy5kYXRhICE9PSBvbGRQcm9wcy5kYXRhKSB7XG4gICAgICByZXR1cm4gJ0EgbmV3IGRhdGEgY29udGFpbmVyIHdhcyBzdXBwbGllZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBDaGVja3MgaWYgYW55IHVwZGF0ZSB0cmlnZ2VycyBoYXZlIGNoYW5nZWQsIGFuZCBpbnZhbGlkYXRlXG4gIC8vIGF0dHJpYnV0ZXMgYWNjb3JkaW5nbHkuXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG4gIF9kaWZmVXBkYXRlVHJpZ2dlcnMob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgLy8gY29uc3Qge2F0dHJpYnV0ZU1hbmFnZXJ9ID0gdGhpcy5zdGF0ZTtcbiAgICAvLyBjb25zdCB1cGRhdGVUcmlnZ2VyTWFwID0gYXR0cmlidXRlTWFuYWdlci5nZXRVcGRhdGVUcmlnZ2VyTWFwKCk7XG4gICAgaWYgKG9sZFByb3BzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gb2xkUHJvcHMgaXMgbnVsbCwgaW5pdGlhbCBkaWZmXG4gICAgfVxuXG4gICAgbGV0IGNoYW5nZSA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBwcm9wTmFtZSBpbiBuZXdQcm9wcy51cGRhdGVUcmlnZ2Vycykge1xuICAgICAgY29uc3Qgb2xkVHJpZ2dlcnMgPSBvbGRQcm9wcy51cGRhdGVUcmlnZ2Vyc1twcm9wTmFtZV0gfHwge307XG4gICAgICBjb25zdCBuZXdUcmlnZ2VycyA9IG5ld1Byb3BzLnVwZGF0ZVRyaWdnZXJzW3Byb3BOYW1lXSB8fCB7fTtcbiAgICAgIGNvbnN0IGRpZmZSZWFzb24gPSBjb21wYXJlUHJvcHMoe1xuICAgICAgICBvbGRQcm9wczogb2xkVHJpZ2dlcnMsXG4gICAgICAgIG5ld1Byb3BzOiBuZXdUcmlnZ2VycyxcbiAgICAgICAgdHJpZ2dlck5hbWU6IHByb3BOYW1lXG4gICAgICB9KTtcbiAgICAgIGlmIChkaWZmUmVhc29uKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICBsb2cubG9nKExPR19QUklPUklUWV9VUERBVEUsXG4gICAgICAgICAgICBgdXBkYXRlVHJpZ2dlcnMgaW52YWxpZGF0aW5nIGFsbCBhdHRyaWJ1dGVzOiAke2RpZmZSZWFzb259YCk7XG4gICAgICAgICAgdGhpcy5pbnZhbGlkYXRlQXR0cmlidXRlKCdhbGwnKTtcbiAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZy5sb2coTE9HX1BSSU9SSVRZX1VQREFURSxcbiAgICAgICAgICAgIGB1cGRhdGVUcmlnZ2VycyBpbnZhbGlkYXRpbmcgYXR0cmlidXRlICR7cHJvcE5hbWV9OiAke2RpZmZSZWFzb259YCk7XG4gICAgICAgICAgdGhpcy5pbnZhbGlkYXRlQXR0cmlidXRlKHByb3BOYW1lKTtcbiAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgX2NoZWNrUmVxdWlyZWRQcm9wKHByb3BlcnR5TmFtZSwgY29uZGl0aW9uKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnByb3BzW3Byb3BlcnR5TmFtZV07XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvcGVydHkgJHtwcm9wZXJ0eU5hbWV9IHVuZGVmaW5lZCBpbiBsYXllciAke3RoaXN9YCk7XG4gICAgfVxuICAgIGlmIChjb25kaXRpb24gJiYgIWNvbmRpdGlvbih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIHByb3BlcnR5ICR7cHJvcGVydHlOYW1lfSBpbiBsYXllciAke3RoaXN9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRW1pdHMgYSB3YXJuaW5nIGlmIGFuIG9sZCBwcm9wIGlzIHVzZWQsIG9wdGlvbmFsbHkgc3VnZ2VzdGluZyBhIHJlcGxhY2VtZW50XG4gIF9jaGVja1JlbW92ZWRQcm9wKG9sZFByb3AsIG5ld1Byb3AgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMucHJvcHNbb2xkUHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbGF5ZXJOYW1lID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgIGxldCBtZXNzYWdlID0gYCR7bGF5ZXJOYW1lfSBubyBsb25nZXIgYWNjZXB0cyBwcm9wcy4ke29sZFByb3B9IGluIHRoaXMgdmVyc2lvbiBvZiBkZWNrLmdsLmA7XG4gICAgICBpZiAobmV3UHJvcCkge1xuICAgICAgICBtZXNzYWdlICs9IGBcXG5QbGVhc2UgdXNlIHByb3BzLiR7bmV3UHJvcH0gaW5zdGVhZC5gO1xuICAgICAgfVxuICAgICAgbG9nLm9uY2UoMCwgbWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUJhc2VVbmlmb3JtcygpIHtcbiAgICB0aGlzLnNldFVuaWZvcm1zKHtcbiAgICAgIC8vIGFwcGx5IGdhbW1hIHRvIG9wYWNpdHkgdG8gbWFrZSBpdCB2aXN1YWxseSBcImxpbmVhclwiXG4gICAgICBvcGFjaXR5OiBNYXRoLnBvdyh0aGlzLnByb3BzLm9wYWNpdHksIDEgLyAyLjIpLFxuICAgICAgT05FOiAxLjBcbiAgICB9KTtcbiAgfVxuXG4gIF91cGRhdGVNb2R1bGVTZXR0aW5ncygpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbCkge1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC51cGRhdGVNb2R1bGVTZXR0aW5ncyh7XG4gICAgICAgIHBpY2tpbmdIaWdobGlnaHRDb2xvcjogdGhpcy5wcm9wcy5oaWdobGlnaHRDb2xvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gREVQUkVDQVRFRCBNRVRIT0RTXG5cbiAgLy8gVXBkYXRlcyBzZWxlY3RlZCBzdGF0ZSBtZW1iZXJzIGFuZCBtYXJrcyB0aGUgb2JqZWN0IGZvciByZWRyYXdcbiAgc2V0VW5pZm9ybXModW5pZm9ybU1hcCkge1xuICAgIGlmICh0aGlzLnN0YXRlLm1vZGVsKSB7XG4gICAgICB0aGlzLnN0YXRlLm1vZGVsLnNldFVuaWZvcm1zKHVuaWZvcm1NYXApO1xuICAgIH1cbiAgICAvLyBUT0RPIC0gc2V0IG5lZWRzUmVkcmF3IG9uIHRoZSBtb2RlbD9cbiAgICB0aGlzLnN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICBsb2coMywgJ2xheWVyLnNldFVuaWZvcm1zJywgdW5pZm9ybU1hcCk7XG4gIH1cbn1cblxuTGF5ZXIubGF5ZXJOYW1lID0gJ0xheWVyJztcbkxheWVyLnByb3BUeXBlcyA9IGRlZmF1bHRQcm9wcztcbkxheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==