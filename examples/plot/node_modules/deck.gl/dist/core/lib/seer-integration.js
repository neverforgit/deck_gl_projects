'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeLayerInSeer = exports.updateLayerInSeer = exports.initLayerInSeer = exports.seerInitListener = exports.layerEditListener = exports.applyPropOverrides = exports.setPropOverrides = undefined;

var _seer = require('seer');

var _seer2 = _interopRequireDefault(_seer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Recursively set a nested property of an object given a properties array and a value
 */
var recursiveSet = function recursiveSet(obj, path, value) {
  if (!obj) {
    return;
  }

  if (path.length > 1) {
    recursiveSet(obj[path[0]], path.slice(1), value);
  } else {
    obj[path[0]] = value;
  }
};

var overrides = new Map();

/**
 * Create an override on the specify layer, indexed by a valuePath array.
 * Do nothing in case Seer as not been initialized to prevent any preformance drawback.
 */
var setPropOverrides = exports.setPropOverrides = function setPropOverrides(id, valuePath, value) {
  if (!_seer2.default.isReady()) {
    return;
  }

  if (!overrides.has(id)) {
    overrides.set(id, new Map());
  }

  var props = overrides.get(id);
  props.set(valuePath, value);
};

/**
 * Get the props overrides of a specific layer if Seer as been initialized
 * Invalidates the data to be sure new ones are always picked up.
 */
var applyPropOverrides = exports.applyPropOverrides = function applyPropOverrides(props) {
  if (!_seer2.default.isReady() || !props.id) {
    return;
  }

  var overs = overrides.get(props.id);
  if (!overs) {
    return;
  }

  overs.forEach(function (value, valuePath) {
    recursiveSet(props, valuePath, value);
    // Invalidate data array if we have a data override
    if (valuePath[0] === 'data') {
      props.data = [].concat(_toConsumableArray(props.data));
    }
  });
};

/**
 * Listen for deck.gl edit events
 */
var layerEditListener = exports.layerEditListener = function layerEditListener(cb) {
  if (!_seer2.default.isReady()) {
    return;
  }

  _seer2.default.listenFor('deck.gl', cb);
};

/**
 * Listen for seer init events to resend data
 */
var seerInitListener = exports.seerInitListener = function seerInitListener(cb) {
  if (!_seer2.default.isReady()) {
    return;
  }

  _seer2.default.listenFor('init', cb);
};

var initLayerInSeer = exports.initLayerInSeer = function initLayerInSeer(layer) {
  if (!_seer2.default.isReady() || !layer) {
    return;
  }

  var badges = [layer.constructor.layerName];

  _seer2.default.listItem('deck.gl', layer.id, {
    badges: badges,
    links: layer.state && layer.state.model ? ['luma.gl:' + layer.state.model.id] : undefined,
    parent: layer.parentLayer ? layer.parentLayer.id : undefined
  });
};

/**
 * Log layer's properties to Seer
 */
var updateLayerInSeer = exports.updateLayerInSeer = function updateLayerInSeer(layer) {
  if (!_seer2.default.isReady() || _seer2.default.throttle('deck.gl:' + layer.id, 1E3)) {
    return;
  }

  var data = logPayload(layer);
  _seer2.default.multiUpdate('deck.gl', layer.id, data);
};

/**
 * On finalize of a specify layer, remove it from seer
 */
var removeLayerInSeer = exports.removeLayerInSeer = function removeLayerInSeer(id) {
  if (!_seer2.default.isReady() || !id) {
    return;
  }

  _seer2.default.deleteItem('deck.gl', id);
};

function logPayload(layer) {
  var data = [{ path: 'objects.props', data: layer.props }];

  var badges = [layer.constructor.layerName];

  if (layer.state) {
    if (layer.state.attributeManager) {
      var attrs = layer.state.attributeManager.getAttributes();
      data.push({ path: 'objects.attributes', data: attrs });
      badges.push(layer.state.attributeManager.stats.getTimeString());
    }
    if (layer.state.model) {
      layer.state.model.timerQueryEnabled = true;
      var lastFrameTime = layer.state.model.stats.lastFrameTime;

      if (lastFrameTime) {
        badges.push((lastFrameTime * 1000).toFixed(0) + '\u03BCs');
      }
    }
  }

  data.push({ path: 'badges', data: badges });

  return data;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9zZWVyLWludGVncmF0aW9uLmpzIl0sIm5hbWVzIjpbInJlY3Vyc2l2ZVNldCIsIm9iaiIsInBhdGgiLCJ2YWx1ZSIsImxlbmd0aCIsInNsaWNlIiwib3ZlcnJpZGVzIiwiTWFwIiwic2V0UHJvcE92ZXJyaWRlcyIsImlkIiwidmFsdWVQYXRoIiwiaXNSZWFkeSIsImhhcyIsInNldCIsInByb3BzIiwiZ2V0IiwiYXBwbHlQcm9wT3ZlcnJpZGVzIiwib3ZlcnMiLCJmb3JFYWNoIiwiZGF0YSIsImxheWVyRWRpdExpc3RlbmVyIiwibGlzdGVuRm9yIiwiY2IiLCJzZWVySW5pdExpc3RlbmVyIiwiaW5pdExheWVySW5TZWVyIiwibGF5ZXIiLCJiYWRnZXMiLCJjb25zdHJ1Y3RvciIsImxheWVyTmFtZSIsImxpc3RJdGVtIiwibGlua3MiLCJzdGF0ZSIsIm1vZGVsIiwidW5kZWZpbmVkIiwicGFyZW50IiwicGFyZW50TGF5ZXIiLCJ1cGRhdGVMYXllckluU2VlciIsInRocm90dGxlIiwibG9nUGF5bG9hZCIsIm11bHRpVXBkYXRlIiwicmVtb3ZlTGF5ZXJJblNlZXIiLCJkZWxldGVJdGVtIiwiYXR0cmlidXRlTWFuYWdlciIsImF0dHJzIiwiZ2V0QXR0cmlidXRlcyIsInB1c2giLCJzdGF0cyIsImdldFRpbWVTdHJpbmciLCJ0aW1lclF1ZXJ5RW5hYmxlZCIsImxhc3RGcmFtZVRpbWUiLCJ0b0ZpeGVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7O0FBRUE7OztBQUdBLElBQU1BLGVBQWUsU0FBZkEsWUFBZSxDQUFDQyxHQUFELEVBQU1DLElBQU4sRUFBWUMsS0FBWixFQUFzQjtBQUN6QyxNQUFJLENBQUNGLEdBQUwsRUFBVTtBQUNSO0FBQ0Q7O0FBRUQsTUFBSUMsS0FBS0UsTUFBTCxHQUFjLENBQWxCLEVBQXFCO0FBQ25CSixpQkFBYUMsSUFBSUMsS0FBSyxDQUFMLENBQUosQ0FBYixFQUEyQkEsS0FBS0cs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Z0JBQWdCLElBQWpCLEVBQXVCQyxPQUF2QixDQUErQixDQUEvQixDQUFmO0FBQ0Q7QUFDRjtBQUNGOztBQUVEL0IsT0FBSzBCLElBQUwsQ0FBVSxFQUFDM0MsTUFBTSxRQUFQLEVBQWlCaUIsTUFBTU8sTUFBdkIsRUFBVjs7QUFFQSxTQUFPUCxJQUFQO0FBQ0QiLCJmaWxlIjoic2Vlci1pbnRlZ3JhdGlvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzZWVyIGZyb20gJ3NlZXInO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNldCBhIG5lc3RlZCBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgZ2l2ZW4gYSBwcm9wZXJ0aWVzIGFycmF5IGFuZCBhIHZhbHVlXG4gKi9cbmNvbnN0IHJlY3Vyc2l2ZVNldCA9IChvYmosIHBhdGgsIHZhbHVlKSA9PiB7XG4gIGlmICghb2JqKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHBhdGgubGVuZ3RoID4gMSkge1xuICAgIHJlY3Vyc2l2ZVNldChvYmpbcGF0aFswXV0sIHBhdGguc2xpY2UoMSksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBvYmpbcGF0aFswXV0gPSB2YWx1ZTtcbiAgfVxufTtcblxuY29uc3Qgb3ZlcnJpZGVzID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBvdmVycmlkZSBvbiB0aGUgc3BlY2lmeSBsYXllciwgaW5kZXhlZCBieSBhIHZhbHVlUGF0aCBhcnJheS5cbiAqIERvIG5vdGhpbmcgaW4gY2FzZSBTZWVyIGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHRvIHByZXZlbnQgYW55IHByZWZvcm1hbmNlIGRyYXdiYWNrLlxuICovXG5leHBvcnQgY29uc3Qgc2V0UHJvcE92ZXJyaWRlcyA9IChpZCwgdmFsdWVQYXRoLCB2YWx1ZSkgPT4ge1xuICBpZiAoIXNlZXIuaXNSZWFkeSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFvdmVycmlkZXMuaGFzKGlkKSkge1xuICAgIG92ZXJyaWRlcy5zZXQoaWQsIG5ldyBNYXAoKSk7XG4gIH1cblxuICBjb25zdCBwcm9wcyA9IG92ZXJyaWRlcy5nZXQoaWQpO1xuICBwcm9wcy5zZXQodmFsdWVQYXRoLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcHJvcHMgb3ZlcnJpZGVzIG9mIGEgc3BlY2lmaWMgbGF5ZXIgaWYgU2VlciBhcyBiZWVuIGluaXRpYWxpemVkXG4gKiBJbnZhbGlkYXRlcyB0aGUgZGF0YSB0byBiZSBzdXJlIG5ldyBvbmVzIGFyZSBhbHdheXMgcGlja2VkIHVwLlxuICovXG5leHBvcnQgY29uc3QgYXBwbHlQcm9wT3ZlcnJpZGVzID0gcHJvcHMgPT4ge1xuICBpZiAoIXNlZXIuaXNSZWFkeSgpIHx8ICFwcm9wcy5pZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG92ZXJzID0gb3ZlcnJpZGVzLmdldChwcm9wcy5pZCk7XG4gIGlmICghb3ZlcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvdmVycy5mb3JFYWNoKCh2YWx1ZSwgdmFsdWVQYXRoKSA9PiB7XG4gICAgcmVjdXJzaXZlU2V0KHByb3BzLCB2YWx1ZVBhdGgsIHZhbHVlKTtcbiAgICAvLyBJbnZhbGlkYXRlIGRhdGEgYXJyYXkgaWYgd2UgaGF2ZSBhIGRhdGEgb3ZlcnJpZGVcbiAgICBpZiAodmFsdWVQYXRoWzBdID09PSAnZGF0YScpIHtcbiAgICAgIHByb3BzLmRhdGEgPSBbLi4ucHJvcHMuZGF0YV07XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogTGlzdGVuIGZvciBkZWNrLmdsIGVkaXQgZXZlbnRzXG4gKi9cbmV4cG9ydCBjb25zdCBsYXllckVkaXRMaXN0ZW5lciA9IGNiID0+IHtcbiAgaWYgKCFzZWVyLmlzUmVhZHkoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNlZXIubGlzdGVuRm9yKCdkZWNrLmdsJywgY2IpO1xufTtcblxuLyoqXG4gKiBMaXN0ZW4gZm9yIHNlZXIgaW5pdCBldmVudHMgdG8gcmVzZW5kIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IHNlZXJJbml0TGlzdGVuZXIgPSBjYiA9PiB7XG4gIGlmICghc2Vlci5pc1JlYWR5KCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzZWVyLmxpc3RlbkZvcignaW5pdCcsIGNiKTtcbn07XG5cbmV4cG9ydCBjb25zdCBpbml0TGF5ZXJJblNlZXIgPSBsYXllciA9PiB7XG4gIGlmICghc2Vlci5pc1JlYWR5KCkgfHwgIWxheWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYmFkZ2VzID0gW2xheWVyLmNvbnN0cnVjdG9yLmxheWVyTmFtZV07XG5cbiAgc2Vlci5saXN0SXRlbSgnZGVjay5nbCcsIGxheWVyLmlkLCB7XG4gICAgYmFkZ2VzLFxuICAgIGxpbmtzOiBsYXllci5zdGF0ZSAmJiBsYXllci5zdGF0ZS5tb2RlbCA/IFtgbHVtYS5nbDoke2xheWVyLnN0YXRlLm1vZGVsLmlkfWBdIDogdW5kZWZpbmVkLFxuICAgIHBhcmVudDogbGF5ZXIucGFyZW50TGF5ZXIgPyBsYXllci5wYXJlbnRMYXllci5pZCA6IHVuZGVmaW5lZFxuICB9KTtcbn07XG5cbi8qKlxuICogTG9nIGxheWVyJ3MgcHJvcGVydGllcyB0byBTZWVyXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVMYXllckluU2VlciA9IGxheWVyID0+IHtcbiAgaWYgKCFzZWVyLmlzUmVhZHkoKSB8fCBzZWVyLnRocm90dGxlKGBkZWNrLmdsOiR7bGF5ZXIuaWR9YCwgMUUzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSBsb2dQYXlsb2FkKGxheWVyKTtcbiAgc2Vlci5tdWx0aVVwZGF0ZSgnZGVjay5nbCcsIGxheWVyLmlkLCBkYXRhKTtcbn07XG5cbi8qKlxuICogT24gZmluYWxpemUgb2YgYSBzcGVjaWZ5IGxheWVyLCByZW1vdmUgaXQgZnJvbSBzZWVyXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVMYXllckluU2VlciA9IGlkID0+IHtcbiAgaWYgKCFzZWVyLmlzUmVhZHkoKSB8fCAhaWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzZWVyLmRlbGV0ZUl0ZW0oJ2RlY2suZ2wnLCBpZCk7XG59O1xuXG5mdW5jdGlvbiBsb2dQYXlsb2FkKGxheWVyKSB7XG4gIGNvbnN0IGRhdGEgPSBbXG4gICAge3BhdGg6ICdvYmplY3RzLnByb3BzJywgZGF0YTogbGF5ZXIucHJvcHN9XG4gIF07XG5cbiAgY29uc3QgYmFkZ2VzID0gW2xheWVyLmNvbnN0cnVjdG9yLmxheWVyTmFtZV07XG5cbiAgaWYgKGxheWVyLnN0YXRlKSB7XG4gICAgaWYgKGxheWVyLnN0YXRlLmF0dHJpYnV0ZU1hbmFnZXIpIHtcbiAgICAgIGNvbnN0IGF0dHJzID0gbGF5ZXIuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5nZXRBdHRyaWJ1dGVzKCk7XG4gICAgICBkYXRhLnB1c2goe3BhdGg6ICdvYmplY3RzLmF0dHJpYnV0ZXMnLCBkYXRhOiBhdHRyc30pO1xuICAgICAgYmFkZ2VzLnB1c2gobGF5ZXIuc3RhdGUuYXR0cmlidXRlTWFuYWdlci5zdGF0cy5nZXRUaW1lU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAobGF5ZXIuc3RhdGUubW9kZWwpIHtcbiAgICAgIGxheWVyLnN0YXRlLm1vZGVsLnRpbWVyUXVlcnlFbmFibGVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHtsYXN0RnJhbWVUaW1lfSA9IGxheWVyLnN0YXRlLm1vZGVsLnN0YXRzO1xuICAgICAgaWYgKGxhc3RGcmFtZVRpbWUpIHtcbiAgICAgICAgYmFkZ2VzLnB1c2goYCR7KGxhc3RGcmFtZVRpbWUgKiAxMDAwKS50b0ZpeGVkKDApfc68c2ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRhdGEucHVzaCh7cGF0aDogJ2JhZGdlcycsIGRhdGE6IGJhZGdlc30pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuIl19