'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fitBounds = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _viewport = require('./viewport');

var _viewport2 = _interopRequireDefault(_viewport);

var _viewportMercatorProject = require('viewport-mercator-project');

var _add = require('gl-vec2/add');

var _add2 = _interopRequireDefault(_add);

var _negate = require('gl-vec2/negate');

var _negate2 = _interopRequireDefault(_negate);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// View and Projection Matrix calculations for mapbox-js style
// map view properties


// TODO - import from viewport-mercator-project
// import {fitBounds} from '../viewport-mercator-project/fit-bounds';

// TODO - import from math.gl
/* eslint-disable camelcase */


var DEFAULT_MAP_STATE = {
  latitude: 37,
  longitude: -122,
  zoom: 11,
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

var ERR_ARGUMENT = 'Illegal argument to WebMercatorViewport';

var WebMercatorViewport = function (_Viewport) {
  _inherits(WebMercatorViewport, _Viewport);

  /**
   * @classdesc
   * Creates view/projection matrices from mercator params
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   */
  /* eslint-disable complexity, max-statements */
  function WebMercatorViewport() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, WebMercatorViewport);

    var width = opts.width,
        height = opts.height,
        latitude = opts.latitude,
        longitude = opts.longitude,
        zoom = opts.zoom,
        pitch = opts.pitch,
        bearing = opts.bearing,
        altitude = opts.altitude;
    var _opts$farZMultiplier = opts.farZMultiplier,
        farZMultiplier = _opts$farZMultiplier === undefined ? 10 : _opts$farZMultiplier;

    // Viewport - support undefined arguments

    width = width !== undefined ? width : DEFAULT_MAP_STATE.width;
    height = height !== undefined ? height : DEFAULT_MAP_STATE.height;
    zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;
    latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;
    longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;
    bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;
    pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;
    altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;

    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc
    width = width || 1;
    height = height || 1;

    // Altitude - prevent division by 0
    // TODO - just throw an Error instead?
    altitude = Math.max(0.75, altitude);

    var projectionMatrix = (0, _viewportMercatorProject.makeProjectionMatrixFromMercatorParams)({
      width: width,
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      farZMultiplier: farZMultiplier
    });

    // The uncentered matrix allows us two move the center addition to the
    // shader (cheap) which gives a coordinate system that has its center in
    // the layer's center position. This makes rotations and other modelMatrx
    // transforms much more useful.
    var viewMatrixUncentered = (0, _viewportMercatorProject.makeUncenteredViewMatrixFromMercatorParams)({
      width: width,
      height: height,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude
    });

    // Save parameters
    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, Object.assign({}, opts, {
      // x, y, position, ...
      // TODO / hack - prevent vertical offsets if not FirstPersonViewport
      position: opts.position && [opts.position[0], opts.position[1], 0],
      width: width, height: height,
      viewMatrix: viewMatrixUncentered,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      projectionMatrix: projectionMatrix,
      focalDistance: 1 // Viewport is already carefully set up to "focus" on ground
    })));

    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;

    // Bind methods
    _this.metersToLngLatDelta = _this.metersToLngLatDelta.bind(_this);
    _this.lngLatDeltaToMeters = _this.lngLatDeltaToMeters.bind(_this);
    _this.addMetersToLngLat = _this.addMetersToLngLat.bind(_this);

    Object.freeze(_this);
    return _this;
  }
  /* eslint-enable complexity, max-statements */

  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   *
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */


  _createClass(WebMercatorViewport, [{
    key: '_projectFlat',
    value: function _projectFlat(lngLat) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return (0, _viewportMercatorProject.projectFlat)(lngLat, scale);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xy) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return (0, _viewportMercatorProject.unprojectFlat)(xy, scale);
    }

    /**
     * Converts a meter offset to a lnglat offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas
     */

  }, {
    key: 'metersToLngLatDelta',
    value: function metersToLngLatDelta(xyz) {
      var _xyz = _slicedToArray(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          _xyz$ = _xyz[2],
          z = _xyz$ === undefined ? 0 : _xyz$;

      (0, _assert2.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _distanceScales = this.distanceScales,
          pixelsPerMeter = _distanceScales.pixelsPerMeter,
          degreesPerPixel = _distanceScales.degreesPerPixel;

      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }

    /**
     * Converts a lnglat offset to a meter offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas
     */

  }, {
    key: 'lngLatDeltaToMeters',
    value: function lngLatDeltaToMeters(deltaLngLatZ) {
      var _deltaLngLatZ = _slicedToArray(deltaLngLatZ, 3),
          deltaLng = _deltaLngLatZ[0],
          deltaLat = _deltaLngLatZ[1],
          _deltaLngLatZ$ = _deltaLngLatZ[2],
          deltaZ = _deltaLngLatZ$ === undefined ? 0 : _deltaLngLatZ$;

      (0, _assert2.default)(Number.isFinite(deltaLng) && Number.isFinite(deltaLat) && Number.isFinite(deltaZ), ERR_ARGUMENT);
      var _distanceScales2 = this.distanceScales,
          pixelsPerDegree = _distanceScales2.pixelsPerDegree,
          metersPerPixel = _distanceScales2.metersPerPixel;

      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];
      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];
      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];
    }

    /**
     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
     */

  }, {
    key: 'addMetersToLngLat',
    value: function addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = _slicedToArray(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;

      var _metersToLngLatDelta = this.metersToLngLatDelta(lngLatZ, xyz),
          _metersToLngLatDelta2 = _slicedToArray(_metersToLngLatDelta, 3),
          deltaLng = _metersToLngLatDelta2[0],
          deltaLat = _metersToLngLatDelta2[1],
          _metersToLngLatDelta3 = _metersToLngLatDelta2[2],
          deltaZ = _metersToLngLatDelta3 === undefined ? 0 : _metersToLngLatDelta3;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }

    /**
     * Get the map center that place a given [lng, lat] coordinate at screen
     * point [x, y]
     *
     * @param {Array} lngLat - [lng,lat] coordinates
     *   Specifies a point on the sphere.
     * @param {Array} pos - [x,y] coordinates
     *   Specifies a point on the screen.
     * @return {Array} [lng,lat] new map center.
     */

  }, {
    key: 'getLocationAtPoint',
    value: function getLocationAtPoint(_ref) {
      var lngLat = _ref.lngLat,
          pos = _ref.pos;

      var fromLocation = this.projectFlat(this.unproject(pos));
      var toLocation = this.projectFlat(lngLat);

      var center = this.projectFlat([this.longitude, this.latitude]);

      var translate = (0, _add2.default)([], toLocation, (0, _negate2.default)([], fromLocation));
      var newCenter = (0, _add2.default)([], center, translate);
      return this.unprojectFlat(newCenter);
    }

    /**
     * Returns a new viewport that fit around the given rectangle.
     * Only supports non-perspective mode.
     * @param {Array} bounds - [[lon, lat], [lon, lat]]
     * @param {Number} [options.padding] - The amount of padding in pixels to add to the given bounds.
     * @param {Array} [options.offset] - The center of the given bounds relative to the map's center,
     *    [x, y] measured in pixels.
     * @returns {WebMercatorViewport}
     */

  }, {
    key: 'fitBounds',
    value: function fitBounds(bounds) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var width = this.width,
          height = this.height;

      var _fitBounds2 = _fitBounds(Object.assign({ width: width, height: height, bounds: bounds }, options)),
          longitude = _fitBounds2.longitude,
          latitude = _fitBounds2.latitude,
          zoom = _fitBounds2.zoom;

      return new WebMercatorViewport({ width: width, height: height, longitude: longitude, latitude: latitude, zoom: zoom });
    }

    // TODO - should support user supplied constraints

  }, {
    key: 'isMapSynched',
    value: function isMapSynched() {
      var MAPBOX_LIMITS = {
        pitch: 60,
        zoom: 40
      };

      var pitch = this.pitch,
          zoom = this.zoom;


      return pitch <= MAPBOX_LIMITS.pitch && zoom <= MAPBOX_LIMITS.zoom;
    }
  }]);

  return WebMercatorViewport;
}(_viewport2.default);

// TODO - investigate if we can move this viewport-mercator-project

/**
 * Returns map settings {latitude, longitude, zoom}
 * that will contain the provided corners within the provided width.
 * Only supports non-perspective mode.
 * @param {Number} width - viewport width
 * @param {Number} height - viewport height
 * @param {Array} bounds - [[lon, lat], [lon, lat]]
 * @param {Number} [padding] - The amount of padding in pixels to add to the given bounds.
 * @param {Array} [offset] - The center of the given bounds relative to the map's center,
 *    [x, y] measured in pixels.
 * @returns {Object} - latitude, longitude and zoom
 */


exports.default = WebMercatorViewport;
function _fitBounds(_ref2) {
  var width = _ref2.width,
      height = _ref2.height,
      bounds = _ref2.bounds,
      _ref2$padding = _ref2.padding,
      padding = _ref2$padding === undefined ? 0 : _ref2$padding,
      _ref2$offset = _ref2.offset,
      offset = _ref2$offset === undefined ? [0, 0] : _ref2$offset;

  var _bounds = _slicedToArray(bounds, 2),
      _bounds$ = _slicedToArray(_bounds[0], 2),
      west = _bounds$[0],
      south = _bounds$[1],
      _bounds$2 = _slicedToArray(_bounds[1], 2),
      east = _bounds$2[0],
      north = _bounds$2[1];

  var viewport = new WebMercatorViewport({
    width: width,
    height: height,
    longitude: 0,
    latitude: 0,
    zoom: 0
  });

  var nw = viewport.project([west, north]);
  var se = viewport.project([east, south]);
  var size = [Math.abs(se[0] - nw[0]), Math.abs(se[1] - nw[1])];
  var center = [(se[0] + nw[0]) / 2, (se[1] + nw[1]) / 2];

  var scaleX = (width - padding * 2 - Math.abs(offset[0]) * 2) / size[0];
  var scaleY = (height - padding * 2 - Math.abs(offset[1]) * 2) / size[1];

  var centerLngLat = viewport.unproject(center);
  var zoom = viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY)));

  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom: zoom
  };
}

exports.fitBounds = _fitBounds;
WebMercatorViewport.displayName = 'WebMercatorViewport';
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL3ZpZXdwb3J0cy93ZWItbWVyY2F0b3Itdmlld3BvcnQuanMiXSwibmFtZXMiOlsiREVGQVVMVF9NQVBfU1RBVEUiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInpvb20iLCJwaXRjaCIsImJlYXJpbmciLCJhbHRpdHVkZSIsIkVSUl9BUkdVTUVOVCIsIldlYk1lcmNhdG9yVmlld3BvcnQiLCJvcHRzIiwid2lkdGgiLCJoZWlnaHQiLCJmYXJaTXVsdGlwbGllciIsInVuZGVmaW5lZCIsIk1hdGgiLCJtYXgiLCJwcm9qZWN0aW9uTWF0cml4Iiwidmlld01hdHJpeFVuY2VudGVyZWQiLCJPYmplY3QiLCJhc3NpZ24iLCJwb3NpdGlvbiIsInZpZXdNYXRyaXgiLCJmb2NhbERpc3RhbmNlIiwibWV0ZXJzVG9MbmdMYXREZWx0YSIsImJpbmQiLCJsbmdMYXREZWx0YVRvTWV0ZXJzIiwiYWRkTWV0ZXJzVG9MbmdMYXQiLCJmcmVlemUiLCJsbmdMYXQiLCJzY2FsZSIsInh5IiwieHl6IiwieCIsInkiLCJ6IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJkaXN0YW5jZVNjYWxlcyIsInBpeGVsc1Blck1ldGVyIiwiZGVncmVlc1BlclBpeGVsIiwiZGVsdGFMbmciLCJkZWx0YUxhdCIsImxlbmd0aCIsImRlbHRhTG5nTGF0WiIsImRlbHRhWiIsInBpeGVsc1BlckRlZ3JlZSIsIm1ldGVyc1BlclBpeGVsIiwiZGVsdGFYIiwiZGVsdGFZIiwibG5nTGF0WiIsImxuZyIsImxhdCIsIloiLCJwb3MiLCJmcm9tTG9jYXRpb24iLCJwcm9qZWN0RmxhdCIsInVucHJvamVjdCIsInRvTG9jYXRpb24iLCJjZW50ZXIiLCJ0cmFuc2xhdGUiLCJuZXdDZW50ZXIiLCJ1bnByb2plY3RGbGF0IiwiYm91bmRzIiwib3B0aW9ucyIsImZpdEJvdW5kcyIsIk1BUEJPWF9MSU1JVFMiLCJwYWRkaW5nIiwib2Zmc2V0Iiwid2VzdCIsInNvdXRoIiwiZWFzdCIsIm5vcnRoIiwidmlld3BvcnQiLCJudyIsInByb2plY3QiLCJzZSIsInNpemUiLCJhYnMiLCJzY2FsZVgiLCJzY2FsZVkiLCJjZW50ZXJMbmdMYXQiLCJsb2cyIiwibWluIiwiZGlzcGxheU5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBc0JBOzs7O0FBRUE7O0FBWUE7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7Ozs7OytlQXZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFVQTtBQUNBOztBQUVBO0FBQ0E7OztBQU1BLElBQU1BLG9CQUFvQjtBQUN4QkMsWUFBVSxFQURjO0FBRXhCQyxhQUFXLENBQUMsR0FGWTtBQUd4QkMsUUFBTSxFQUhrQjtBQUl4QkMsU0FBTyxDQUppQjtBQUt4QkMsV0FBUyxDQUxlO0FBTXhCQyxZQUFVO0FBTmMsQ0FBMUI7O0FBU0EsSUFBTUMsZUFBZSx5Q0FBckI7O0lBRXFCQyxtQjs7O0FBQ25COzs7Ozs7QUFNQTtBQUNBLGlDQUF1QjtBQUFBLFFBQVhDLElBQVcsdUVBQUosRUFBSTs7QUFBQTs7QUFBQSxRQUVuQkMsS0FGbUIsR0FVakJELElBVmlCLENBRW5CQyxLQUZtQjtBQUFBLFFBR25CQyxNQUhtQixHQVVqQkYsSUFWaUIsQ0FHbkJFLE1BSG1CO0FBQUEsUUFJbkJWLFFBSm1CLEdBVWpCUSxJQVZpQixDQUluQlIsUUFKbUI7QUFBQSxRQUtuQkMsU0FMbUIsR0FVakJPLElBVmlCLENBS25CUCxTQUxtQjtBQUFBLFFBTW5CQyxJQU5tQixHQVVqQk0sSUFWaUIsQ0FNbkJOLElBTm1CO0FBQUEsUUFPbkJDLEtBUG1CLEdBVWpCSyxJQVZpQixDQU9uQkwsS0FQbUI7QUFBQSxRQVFuQkMsT0FSbUIsR0FVakJJLElBVmlCLENBUW5CSixPQVJtQjtBQUFBLFFBU25CQyxRQVRtQixHQVVqQkcsSUFWaUIsQ0FTbkJILFFBVG1CO0FBQUEsK0JB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LENBQVQsSUFBa0IsQ0FGTCxDQUFmOztBQUtBLE1BQU1LLFNBQVMsQ0FBQ3BFLFFBQVF3RCxVQUFVLENBQWxCLEdBQXNCcEQsS0FBSytELEdBQUwsQ0FBU1YsT0FBTyxDQUFQLENBQVQsSUFBc0IsQ0FBN0MsSUFBa0RTLEtBQUssQ0FBTCxDQUFqRTtBQUNBLE1BQU1HLFNBQVMsQ0FBQ3BFLFNBQVN1RCxVQUFVLENBQW5CLEdBQXVCcEQsS0FBSytELEdBQUwsQ0FBU1YsT0FBTyxDQUFQLENBQVQsSUFBc0IsQ0FBOUMsSUFBbURTLEtBQUssQ0FBTCxDQUFsRTs7QUFFQSxNQUFNSSxlQUFlUixTQUFTaEIsU0FBVCxDQUFtQkUsTUFBbkIsQ0FBckI7QUFDQSxNQUFNdkQsT0FBT3FFLFNBQVNyRSxJQUFULEdBQWdCVyxLQUFLbUUsSUFBTCxDQUFVbkUsS0FBSytELEdBQUwsQ0FBUy9ELEtBQUtvRSxHQUFMLENBQVNKLE1BQVQsRUFBaUJDLE1BQWpCLENBQVQsQ0FBVixDQUE3Qjs7QUFFQSxTQUFPO0FBQ0w3RSxlQUFXOEUsYUFBYSxDQUFiLENBRE47QUFFTC9FLGNBQVUrRSxhQUFhLENBQWIsQ0FGTDtBQUdMN0U7QUFISyxHQUFQO0FBS0Q7OztBQUVESyxvQkFBb0IyRSxXQUFwQixHQUFrQyxxQkFBbEMiLCJmaWxlIjoid2ViLW1lcmNhdG9yLXZpZXdwb3J0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8vIFZpZXcgYW5kIFByb2plY3Rpb24gTWF0cml4IGNhbGN1bGF0aW9ucyBmb3IgbWFwYm94LWpzIHN0eWxlXG4vLyBtYXAgdmlldyBwcm9wZXJ0aWVzXG5pbXBvcnQgVmlld3BvcnQgZnJvbSAnLi92aWV3cG9ydCc7XG5cbmltcG9ydCB7XG4gIHByb2plY3RGbGF0LFxuICB1bnByb2plY3RGbGF0LFxuICBtYWtlUHJvamVjdGlvbk1hdHJpeEZyb21NZXJjYXRvclBhcmFtcyxcbiAgbWFrZVVuY2VudGVyZWRWaWV3TWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zXG59IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuXG4vLyBUT0RPIC0gaW1wb3J0IGZyb20gdmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdFxuLy8gaW1wb3J0IHtmaXRCb3VuZHN9IGZyb20gJy4uL3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QvZml0LWJvdW5kcyc7XG5cbi8vIFRPRE8gLSBpbXBvcnQgZnJvbSBtYXRoLmdsXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbmltcG9ydCB2ZWMyX2FkZCBmcm9tICdnbC12ZWMyL2FkZCc7XG5pbXBvcnQgdmVjMl9uZWdhdGUgZnJvbSAnZ2wtdmVjMi9uZWdhdGUnO1xuXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IERFRkFVTFRfTUFQX1NUQVRFID0ge1xuICBsYXRpdHVkZTogMzcsXG4gIGxvbmdpdHVkZTogLTEyMixcbiAgem9vbTogMTEsXG4gIHBpdGNoOiAwLFxuICBiZWFyaW5nOiAwLFxuICBhbHRpdHVkZTogMS41XG59O1xuXG5jb25zdCBFUlJfQVJHVU1FTlQgPSAnSWxsZWdhbCBhcmd1bWVudCB0byBXZWJNZXJjYXRvclZpZXdwb3J0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViTWVyY2F0b3JWaWV3cG9ydCBleHRlbmRzIFZpZXdwb3J0IHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogQ3JlYXRlcyB2aWV3L3Byb2plY3Rpb24gbWF0cmljZXMgZnJvbSBtZXJjYXRvciBwYXJhbXNcbiAgICogTm90ZTogVGhlIFZpZXdwb3J0IGlzIGltbXV0YWJsZSBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBvbmx5IGhhcyBhY2Nlc3NvcnMuXG4gICAqIEEgbmV3IHZpZXdwb3J0IGluc3RhbmNlIHNob3VsZCBiZSBjcmVhdGVkIGlmIGFueSBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGxldCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgem9vbSxcbiAgICAgIHBpdGNoLFxuICAgICAgYmVhcmluZyxcbiAgICAgIGFsdGl0dWRlXG4gICAgfSA9IG9wdHM7XG5cbiAgICBjb25zdCB7XG4gICAgICAvLyB4LCB5LCBwb3NpdGlvbiwgLi4uXG4gICAgICBmYXJaTXVsdGlwbGllciA9IDEwXG4gICAgfSA9IG9wdHM7XG5cbiAgICAvLyBWaWV3cG9ydCAtIHN1cHBvcnQgdW5kZWZpbmVkIGFyZ3VtZW50c1xuICAgIHdpZHRoID0gd2lkdGggIT09IHVuZGVmaW5lZCA/IHdpZHRoIDogREVGQVVMVF9NQVBfU1RBVEUud2lkdGg7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiBERUZBVUxUX01BUF9TVEFURS5oZWlnaHQ7XG4gICAgem9vbSA9IHpvb20gIT09IHVuZGVmaW5lZCA/IHpvb20gOiBERUZBVUxUX01BUF9TVEFURS56b29tO1xuICAgIGxhdGl0dWRlID0gbGF0aXR1ZGUgIT09IHVuZGVmaW5lZCA/IGxhdGl0dWRlIDogREVGQVVMVF9NQVBfU1RBVEUubGF0aXR1ZGU7XG4gICAgbG9uZ2l0dWRlID0gbG9uZ2l0dWRlICE9PSB1bmRlZmluZWQgPyBsb25naXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5sb25naXR1ZGU7XG4gICAgYmVhcmluZyA9IGJlYXJpbmcgIT09IHVuZGVmaW5lZCA/IGJlYXJpbmcgOiBERUZBVUxUX01BUF9TVEFURS5iZWFyaW5nO1xuICAgIHBpdGNoID0gcGl0Y2ggIT09IHVuZGVmaW5lZCA/IHBpdGNoIDogREVGQVVMVF9NQVBfU1RBVEUucGl0Y2g7XG4gICAgYWx0aXR1ZGUgPSBhbHRpdHVkZSAhPT0gdW5kZWZpbmVkID8gYWx0aXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5hbHRpdHVkZTtcblxuICAgIC8vIFNpbGVudGx5IGFsbG93IGFwcHMgdG8gc2VuZCBpbiAwLDAgdG8gZmFjaWxpdGF0ZSBpc29tb3JwaGljIHJlbmRlciBldGNcbiAgICB3aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG5cbiAgICAvLyBBbHRpdHVkZSAtIHByZXZlbnQgZGl2aXNpb24gYnkgMFxuICAgIC8vIFRPRE8gLSBqdXN0IHRocm93IGFuIEVycm9yIGluc3RlYWQ/XG4gICAgYWx0aXR1ZGUgPSBNYXRoLm1heCgwLjc1LCBhbHRpdHVkZSk7XG5cbiAgICBjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gbWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZSxcbiAgICAgIGZhclpNdWx0aXBsaWVyXG4gICAgfSk7XG5cbiAgICAvLyBUaGUgdW5jZW50ZXJlZCBtYXRyaXggYWxsb3dzIHVzIHR3byBtb3ZlIHRoZSBjZW50ZXIgYWRkaXRpb24gdG8gdGhlXG4gICAgLy8gc2hhZGVyIChjaGVhcCkgd2hpY2ggZ2l2ZXMgYSBjb29yZGluYXRlIHN5c3RlbSB0aGF0IGhhcyBpdHMgY2VudGVyIGluXG4gICAgLy8gdGhlIGxheWVyJ3MgY2VudGVyIHBvc2l0aW9uLiBUaGlzIG1ha2VzIHJvdGF0aW9ucyBhbmQgb3RoZXIgbW9kZWxNYXRyeFxuICAgIC8vIHRyYW5zZm9ybXMgbXVjaCBtb3JlIHVzZWZ1bC5cbiAgICBjb25zdCB2aWV3TWF0cml4VW5jZW50ZXJlZCA9IG1ha2VVbmNlbnRlcmVkVmlld01hdHJpeEZyb21NZXJjYXRvclBhcmFtcyh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgem9vbSxcbiAgICAgIHBpdGNoLFxuICAgICAgYmVhcmluZyxcbiAgICAgIGFsdGl0dWRlXG4gICAgfSk7XG5cbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7XG4gICAgICAvLyB4LCB5LCBwb3NpdGlvbiwgLi4uXG4gICAgICAvLyBUT0RPIC8gaGFjayAtIHByZXZlbnQgdmVydGljYWwgb2Zmc2V0cyBpZiBub3QgRmlyc3RQZXJzb25WaWV3cG9ydFxuICAgICAgcG9zaXRpb246IG9wdHMucG9zaXRpb24gJiYgW29wdHMucG9zaXRpb25bMF0sIG9wdHMucG9zaXRpb25bMV0sIDBdLFxuICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgIHZpZXdNYXRyaXg6IHZpZXdNYXRyaXhVbmNlbnRlcmVkLFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUsXG4gICAgICB6b29tLFxuICAgICAgcHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIGZvY2FsRGlzdGFuY2U6IDEgLy8gVmlld3BvcnQgaXMgYWxyZWFkeSBjYXJlZnVsbHkgc2V0IHVwIHRvIFwiZm9jdXNcIiBvbiBncm91bmRcbiAgICB9KSk7XG5cbiAgICAvLyBTYXZlIHBhcmFtZXRlcnNcbiAgICB0aGlzLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgdGhpcy5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICB0aGlzLnBpdGNoID0gcGl0Y2g7XG4gICAgdGhpcy5iZWFyaW5nID0gYmVhcmluZztcbiAgICB0aGlzLmFsdGl0dWRlID0gYWx0aXR1ZGU7XG5cbiAgICAvLyBCaW5kIG1ldGhvZHNcbiAgICB0aGlzLm1ldGVyc1RvTG5nTGF0RGVsdGEgPSB0aGlzLm1ldGVyc1RvTG5nTGF0RGVsdGEuYmluZCh0aGlzKTtcbiAgICB0aGlzLmxuZ0xhdERlbHRhVG9NZXRlcnMgPSB0aGlzLmxuZ0xhdERlbHRhVG9NZXRlcnMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZE1ldGVyc1RvTG5nTGF0ID0gdGhpcy5hZGRNZXRlcnNUb0xuZ0xhdC5iaW5kKHRoaXMpO1xuXG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgLyoqXG4gICAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gICAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gICAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gICAqIHBlcnNwZWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAgICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgX3Byb2plY3RGbGF0KGxuZ0xhdCwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHByb2plY3RGbGF0KGxuZ0xhdCwgc2NhbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCB3b3JsZCBwb2ludCBbeCx5XSBvbiBtYXAgb250byB7bGF0LCBsb259IG9uIHNwaGVyZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdHxWZWN0b3J9IHh5IC0gb2JqZWN0IHdpdGgge3gseX0gbWVtYmVyc1xuICAgKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAgICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAgICogICBIYXMgdG9BcnJheSBtZXRob2QgaWYgeW91IG5lZWQgYSBHZW9KU09OIEFycmF5LlxuICAgKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gICAqL1xuICBfdW5wcm9qZWN0RmxhdCh4eSwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHVucHJvamVjdEZsYXQoeHksIHNjYWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIG1ldGVyIG9mZnNldCB0byBhIGxuZ2xhdCBvZmZzZXRcbiAgICpcbiAgICogTm90ZTogVXNlcyBzaW1wbGUgbGluZWFyIGFwcHJveGltYXRpb24gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcbiAgICogRXJyb3IgaW5jcmVhc2VzIHdpdGggc2l6ZSBvZiBvZmZzZXQgKHJvdWdobHkgMSUgcGVyIDEwMGttKVxuICAgKlxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSB4eXogLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICogQHJldHVybiB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIC0gYXJyYXkgb2YgW2xuZyxsYXQsel0gZGVsdGFzXG4gICAqL1xuICBtZXRlcnNUb0xuZ0xhdERlbHRhKHh5eikge1xuICAgIGNvbnN0IFt4LCB5LCB6ID0gMF0gPSB4eXo7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh4KSAmJiBOdW1iZXIuaXNGaW5pdGUoeSkgJiYgTnVtYmVyLmlzRmluaXRlKHopLCBFUlJfQVJHVU1FTlQpO1xuICAgIGNvbnN0IHtwaXhlbHNQZXJNZXRlciwgZGVncmVlc1BlclBpeGVsfSA9IHRoaXMuZGlzdGFuY2VTY2FsZXM7XG4gICAgY29uc3QgZGVsdGFMbmcgPSB4ICogcGl4ZWxzUGVyTWV0ZXJbMF0gKiBkZWdyZWVzUGVyUGl4ZWxbMF07XG4gICAgY29uc3QgZGVsdGFMYXQgPSB5ICogcGl4ZWxzUGVyTWV0ZXJbMV0gKiBkZWdyZWVzUGVyUGl4ZWxbMV07XG4gICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyBbZGVsdGFMbmcsIGRlbHRhTGF0XSA6IFtkZWx0YUxuZywgZGVsdGFMYXQsIHpdO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgbG5nbGF0IG9mZnNldCB0byBhIG1ldGVyIG9mZnNldFxuICAgKlxuICAgKiBOb3RlOiBVc2VzIHNpbXBsZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBhcm91bmQgdGhlIHZpZXdwb3J0IGNlbnRlclxuICAgKiBFcnJvciBpbmNyZWFzZXMgd2l0aCBzaXplIG9mIG9mZnNldCAocm91Z2hseSAxJSBwZXIgMTAwa20pXG4gICAqXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIGRlbHRhTG5nTGF0WiAtIGFycmF5IG9mIFtsbmcsbGF0LHpdIGRlbHRhc1xuICAgKiBAcmV0dXJuIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICovXG4gIGxuZ0xhdERlbHRhVG9NZXRlcnMoZGVsdGFMbmdMYXRaKSB7XG4gICAgY29uc3QgW2RlbHRhTG5nLCBkZWx0YUxhdCwgZGVsdGFaID0gMF0gPSBkZWx0YUxuZ0xhdFo7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShkZWx0YUxuZykgJiYgTnVtYmVyLmlzRmluaXRlKGRlbHRhTGF0KSAmJiBOdW1iZXIuaXNGaW5pdGUoZGVsdGFaKSxcbiAgICAgIEVSUl9BUkdVTUVOVCk7XG4gICAgY29uc3Qge3BpeGVsc1BlckRlZ3JlZSwgbWV0ZXJzUGVyUGl4ZWx9ID0gdGhpcy5kaXN0YW5jZVNjYWxlcztcbiAgICBjb25zdCBkZWx0YVggPSBkZWx0YUxuZyAqIHBpeGVsc1BlckRlZ3JlZVswXSAqIG1ldGVyc1BlclBpeGVsWzBdO1xuICAgIGNvbnN0IGRlbHRhWSA9IGRlbHRhTGF0ICogcGl4ZWxzUGVyRGVncmVlWzFdICogbWV0ZXJzUGVyUGl4ZWxbMV07XG4gICAgcmV0dXJuIGRlbHRhTG5nTGF0Wi5sZW5ndGggPT09IDIgPyBbZGVsdGFYLCBkZWx0YVldIDogW2RlbHRhWCwgZGVsdGFZLCBkZWx0YVpdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG1ldGVyIGRlbHRhIHRvIGEgYmFzZSBsbmdsYXQgY29vcmRpbmF0ZSwgcmV0dXJuaW5nIGEgbmV3IGxuZ2xhdCBhcnJheVxuICAgKlxuICAgKiBOb3RlOiBVc2VzIHNpbXBsZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBhcm91bmQgdGhlIHZpZXdwb3J0IGNlbnRlclxuICAgKiBFcnJvciBpbmNyZWFzZXMgd2l0aCBzaXplIG9mIG9mZnNldCAocm91Z2hseSAxJSBwZXIgMTAwa20pXG4gICAqXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIGxuZ0xhdFogLSBiYXNlIGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgeHl6IC0gYXJyYXkgb2YgbWV0ZXIgZGVsdGFzXG4gICAqIEByZXR1cm4ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSBhcnJheSBvZiBbbG5nLGxhdCx6XSBkZWx0YXNcbiAgICovXG4gIGFkZE1ldGVyc1RvTG5nTGF0KGxuZ0xhdFosIHh5eikge1xuICAgIGNvbnN0IFtsbmcsIGxhdCwgWiA9IDBdID0gbG5nTGF0WjtcbiAgICBjb25zdCBbZGVsdGFMbmcsIGRlbHRhTGF0LCBkZWx0YVogPSAwXSA9IHRoaXMubWV0ZXJzVG9MbmdMYXREZWx0YShsbmdMYXRaLCB4eXopO1xuICAgIHJldHVybiBsbmdMYXRaLmxlbmd0aCA9PT0gMiA/XG4gICAgICBbbG5nICsgZGVsdGFMbmcsIGxhdCArIGRlbHRhTGF0XSA6XG4gICAgICBbbG5nICsgZGVsdGFMbmcsIGxhdCArIGRlbHRhTGF0LCBaICsgZGVsdGFaXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBjZW50ZXIgdGhhdCBwbGFjZSBhIGdpdmVuIFtsbmcsIGxhdF0gY29vcmRpbmF0ZSBhdCBzY3JlZW5cbiAgICogcG9pbnQgW3gsIHldXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsbGF0XSBjb29yZGluYXRlc1xuICAgKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzcGhlcmUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvcyAtIFt4LHldIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNjcmVlbi5cbiAgICogQHJldHVybiB7QXJyYXl9IFtsbmcsbGF0XSBuZXcgbWFwIGNlbnRlci5cbiAgICovXG4gIGdldExvY2F0aW9uQXRQb2ludCh7bG5nTGF0LCBwb3N9KSB7XG4gICAgY29uc3QgZnJvbUxvY2F0aW9uID0gdGhpcy5wcm9qZWN0RmxhdCh0aGlzLnVucHJvamVjdChwb3MpKTtcbiAgICBjb25zdCB0b0xvY2F0aW9uID0gdGhpcy5wcm9qZWN0RmxhdChsbmdMYXQpO1xuXG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5wcm9qZWN0RmxhdChbdGhpcy5sb25naXR1ZGUsIHRoaXMubGF0aXR1ZGVdKTtcblxuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHZlYzJfYWRkKFtdLCB0b0xvY2F0aW9uLCB2ZWMyX25lZ2F0ZShbXSwgZnJvbUxvY2F0aW9uKSk7XG4gICAgY29uc3QgbmV3Q2VudGVyID0gdmVjMl9hZGQoW10sIGNlbnRlciwgdHJhbnNsYXRlKTtcbiAgICByZXR1cm4gdGhpcy51bnByb2plY3RGbGF0KG5ld0NlbnRlcik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyB2aWV3cG9ydCB0aGF0IGZpdCBhcm91bmQgdGhlIGdpdmVuIHJlY3RhbmdsZS5cbiAgICogT25seSBzdXBwb3J0cyBub24tcGVyc3BlY3RpdmUgbW9kZS5cbiAgICogQHBhcmFtIHtBcnJheX0gYm91bmRzIC0gW1tsb24sIGxhdF0sIFtsb24sIGxhdF1dXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wYWRkaW5nXSAtIFRoZSBhbW91bnQgb2YgcGFkZGluZyBpbiBwaXhlbHMgdG8gYWRkIHRvIHRoZSBnaXZlbiBib3VuZHMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm9mZnNldF0gLSBUaGUgY2VudGVyIG9mIHRoZSBnaXZlbiBib3VuZHMgcmVsYXRpdmUgdG8gdGhlIG1hcCdzIGNlbnRlcixcbiAgICogICAgW3gsIHldIG1lYXN1cmVkIGluIHBpeGVscy5cbiAgICogQHJldHVybnMge1dlYk1lcmNhdG9yVmlld3BvcnR9XG4gICAqL1xuICBmaXRCb3VuZHMoYm91bmRzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzO1xuICAgIGNvbnN0IHtsb25naXR1ZGUsIGxhdGl0dWRlLCB6b29tfSA9IGZpdEJvdW5kcyhPYmplY3QuYXNzaWduKHt3aWR0aCwgaGVpZ2h0LCBib3VuZHN9LCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHt3aWR0aCwgaGVpZ2h0LCBsb25naXR1ZGUsIGxhdGl0dWRlLCB6b29tfSk7XG4gIH1cblxuICAvLyBUT0RPIC0gc2hvdWxkIHN1cHBvcnQgdXNlciBzdXBwbGllZCBjb25zdHJhaW50c1xuICBpc01hcFN5bmNoZWQoKSB7XG4gICAgY29uc3QgTUFQQk9YX0xJTUlUUyA9IHtcbiAgICAgIHBpdGNoOiA2MCxcbiAgICAgIHpvb206IDQwXG4gICAgfTtcblxuICAgIGNvbnN0IHtwaXRjaCwgem9vbX0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIHBpdGNoIDw9IE1BUEJPWF9MSU1JVFMucGl0Y2ggJiYgem9vbSA8PSBNQVBCT1hfTElNSVRTLnpvb207XG4gIH1cbn1cblxuLy8gVE9ETyAtIGludmVzdGlnYXRlIGlmIHdlIGNhbiBtb3ZlIHRoaXMgdmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdFxuXG4vKipcbiAqIFJldHVybnMgbWFwIHNldHRpbmdzIHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCB6b29tfVxuICogdGhhdCB3aWxsIGNvbnRhaW4gdGhlIHByb3ZpZGVkIGNvcm5lcnMgd2l0aGluIHRoZSBwcm92aWRlZCB3aWR0aC5cbiAqIE9ubHkgc3VwcG9ydHMgbm9uLXBlcnNwZWN0aXZlIG1vZGUuXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSB2aWV3cG9ydCB3aWR0aFxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIHZpZXdwb3J0IGhlaWdodFxuICogQHBhcmFtIHtBcnJheX0gYm91bmRzIC0gW1tsb24sIGxhdF0sIFtsb24sIGxhdF1dXG4gKiBAcGFyYW0ge051bWJlcn0gW3BhZGRpbmddIC0gVGhlIGFtb3VudCBvZiBwYWRkaW5nIGluIHBpeGVscyB0byBhZGQgdG8gdGhlIGdpdmVuIGJvdW5kcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtvZmZzZXRdIC0gVGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gYm91bmRzIHJlbGF0aXZlIHRvIHRoZSBtYXAncyBjZW50ZXIsXG4gKiAgICBbeCwgeV0gbWVhc3VyZWQgaW4gcGl4ZWxzLlxuICogQHJldHVybnMge09iamVjdH0gLSBsYXRpdHVkZSwgbG9uZ2l0dWRlIGFuZCB6b29tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXRCb3VuZHMoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBib3VuZHMsXG4gIC8vIG9wdGlvbnNcbiAgcGFkZGluZyA9IDAsXG4gIG9mZnNldCA9IFswLCAwXVxufSkge1xuICBjb25zdCBbW3dlc3QsIHNvdXRoXSwgW2Vhc3QsIG5vcnRoXV0gPSBib3VuZHM7XG5cbiAgY29uc3Qgdmlld3BvcnQgPSBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGxvbmdpdHVkZTogMCxcbiAgICBsYXRpdHVkZTogMCxcbiAgICB6b29tOiAwXG4gIH0pO1xuXG4gIGNvbnN0IG53ID0gdmlld3BvcnQucHJvamVjdChbd2VzdCwgbm9ydGhdKTtcbiAgY29uc3Qgc2UgPSB2aWV3cG9ydC5wcm9qZWN0KFtlYXN0LCBzb3V0aF0pO1xuICBjb25zdCBzaXplID0gW1xuICAgIE1hdGguYWJzKHNlWzBdIC0gbndbMF0pLFxuICAgIE1hdGguYWJzKHNlWzFdIC0gbndbMV0pXG4gIF07XG4gIGNvbnN0IGNlbnRlciA9IFtcbiAgICAoc2VbMF0gKyBud1swXSkgLyAyLFxuICAgIChzZVsxXSArIG53WzFdKSAvIDJcbiAgXTtcblxuICBjb25zdCBzY2FsZVggPSAod2lkdGggLSBwYWRkaW5nICogMiAtIE1hdGguYWJzKG9mZnNldFswXSkgKiAyKSAvIHNpemVbMF07XG4gIGNvbnN0IHNjYWxlWSA9IChoZWlnaHQgLSBwYWRkaW5nICogMiAtIE1hdGguYWJzKG9mZnNldFsxXSkgKiAyKSAvIHNpemVbMV07XG5cbiAgY29uc3QgY2VudGVyTG5nTGF0ID0gdmlld3BvcnQudW5wcm9qZWN0KGNlbnRlcik7XG4gIGNvbnN0IHpvb20gPSB2aWV3cG9ydC56b29tICsgTWF0aC5sb2cyKE1hdGguYWJzKE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKSkpO1xuXG4gIHJldHVybiB7XG4gICAgbG9uZ2l0dWRlOiBjZW50ZXJMbmdMYXRbMF0sXG4gICAgbGF0aXR1ZGU6IGNlbnRlckxuZ0xhdFsxXSxcbiAgICB6b29tXG4gIH07XG59XG5cbldlYk1lcmNhdG9yVmlld3BvcnQuZGlzcGxheU5hbWUgPSAnV2ViTWVyY2F0b3JWaWV3cG9ydCc7XG4iXX0=