'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var _log = require('../utils/log');

var _log2 = _interopRequireDefault(_log);

var _math = require('math.gl');

var _utils = require('../math/utils');

var _scale = require('gl-mat4/scale');

var _scale2 = _interopRequireDefault(_scale);

var _translate = require('gl-mat4/translate');

var _translate2 = _interopRequireDefault(_translate);

var _multiply = require('gl-mat4/multiply');

var _multiply2 = _interopRequireDefault(_multiply);

var _invert = require('gl-mat4/invert');

var _invert2 = _interopRequireDefault(_invert);

var _perspective = require('gl-mat4/perspective');

var _perspective2 = _interopRequireDefault(_perspective);

var _lerp = require('gl-vec2/lerp');

var _lerp2 = _interopRequireDefault(_lerp);

var _viewportMercatorProject = require('viewport-mercator-project');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ZERO_VECTOR = [0, 0, 0];

var IDENTITY = (0, _utils.createMat4)();

var DEFAULT_DISTANCE_SCALES = {
  pixelsPerMeter: [1, 1, 1],
  metersPerPixel: [1, 1, 1],
  pixelsPerDegree: [1, 1, 1],
  degreesPerPixel: [1, 1, 1]
};

var DEFAULT_ZOOM = 0;

var ERR_ARGUMENT = 'Illegal argument to Viewport';

var Viewport = function () {
  /**
   * @classdesc
   * Manages coordinate system transformations for deck.gl.
   *
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   */
  /* eslint-disable complexity, max-statements */
  function Viewport() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Viewport);

    var _opts$id = opts.id,
        id = _opts$id === undefined ? null : _opts$id,
        _opts$x = opts.x,
        x = _opts$x === undefined ? 0 : _opts$x,
        _opts$y = opts.y,
        y = _opts$y === undefined ? 0 : _opts$y,
        _opts$width = opts.width,
        width = _opts$width === undefined ? 1 : _opts$width,
        _opts$height = opts.height,
        height = _opts$height === undefined ? 1 : _opts$height,
        _opts$viewMatrix = opts.viewMatrix,
        viewMatrix = _opts$viewMatrix === undefined ? IDENTITY : _opts$viewMatrix,
        _opts$projectionMatri = opts.projectionMatrix,
        projectionMatrix = _opts$projectionMatri === undefined ? null : _opts$projectionMatri,
        _opts$fovy = opts.fovy,
        fovy = _opts$fovy === undefined ? 75 : _opts$fovy,
        _opts$near = opts.near,
        near = _opts$near === undefined ? 0.1 : _opts$near,
        _opts$far = opts.far,
        far = _opts$far === undefined ? 1000 : _opts$far,
        _opts$longitude = opts.longitude,
        longitude = _opts$longitude === undefined ? null : _opts$longitude,
        _opts$latitude = opts.latitude,
        latitude = _opts$latitude === undefined ? null : _opts$latitude,
        _opts$zoom = opts.zoom,
        zoom = _opts$zoom === undefined ? null : _opts$zoom,
        _opts$position = opts.position,
        position = _opts$position === undefined ? null : _opts$position,
        _opts$modelMatrix = opts.modelMatrix,
        modelMatrix = _opts$modelMatrix === undefined ? null : _opts$modelMatrix,
        _opts$distanceScales = opts.distanceScales,
        distanceScales = _opts$distanceScales === undefined ? null : _opts$distanceScales;


    this.id = id || this.constructor.displayName || 'viewport';

    // Check if we have a geospatial anchor
    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);

    // Silently allow apps to send in w,h = 0,0
    this.x = x;
    this.y = y;
    this.width = width || 1;
    this.height = height || 1;

    this.zoom = zoom;
    if (!Number.isFinite(this.zoom)) {
      this.zoom = this.isGeospatial ? (0, _viewportMercatorProject.getMercatorMeterZoom)({ latitude: latitude }) : DEFAULT_ZOOM;
    }
    this.scale = Math.pow(2, this.zoom);

    // Calculate distance scales if lng/lat/zoom are provided
    this.distanceScales = this.isGeospatial ? (0, _viewportMercatorProject.getMercatorDistanceScales)({ latitude: latitude, longitude: longitude, scale: this.scale }) : distanceScales || DEFAULT_DISTANCE_SCALES;

    this.focalDistance = opts.focalDistance || 1;

    this.distanceScales.metersPerPixel = new _math.Vector3(this.distanceScales.metersPerPixel);
    this.distanceScales.pixelsPerMeter = new _math.Vector3(this.distanceScales.pixelsPerMeter);

    this.position = ZERO_VECTOR;
    this.meterOffset = ZERO_VECTOR;
    if (position) {
      // Apply model matrix if supplied
      this.position = position;
      this.modelMatrix = modelMatrix;
      this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;
    }

    // Determine camera center
    this.center = this.isGeospatial ? (0, _viewportMercatorProject.getMercatorWorldPosition)({
      longitude: longitude, latitude: latitude, zoom: this.zoom, meterOffset: this.meterOffset
    }) : position;

    // console.log(this.scale, this.distanceScales.pixelsPerMeter);

    this.viewMatrixUncentered = viewMatrix;

    // Make a centered version of the matrix for projection modes without an offset
    this.viewMatrix = new _math.Matrix4()
    // Apply the uncentered view matrix
    .multiplyRight(this.viewMatrixUncentered)
    // The Mercator world coordinate system is upper left,
    // but GL expects lower left, so we flip it around the center after all transforms are done
    .scale([1, -1, 1])
    // And center it
    .translate(new _math.Vector3(this.center || ZERO_VECTOR).negate());

    // Create a projection matrix if not supplied
    if (projectionMatrix) {
      this.projectionMatrix = projectionMatrix;
    } else {
      (0, _assert2.default)(Number.isFinite(fovy));
      var DEGREES_TO_RADIANS = Math.PI / 180;
      var fovyRadians = fovy * DEGREES_TO_RADIANS;
      var aspect = this.width / this.height;
      this.projectionMatrix = (0, _perspective2.default)([], fovyRadians, aspect, near, far);
    }

    // Init pixel matrices
    this._initMatrices();

    // Bind methods for easy access
    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
    this.getMatrices = this.getMatrices.bind(this);
  }
  /* eslint-enable complexity, max-statements */

  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.


  _createClass(Viewport, [{
    key: 'equals',
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && (0, _math.equals)(viewport.projectionMatrix, this.projectionMatrix) && (0, _math.equals)(viewport.viewMatrix, this.viewMatrix);
      // TODO - check distance scales?
    }

    /**
     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
     * using viewport projection parameters
     * - [longitude, latitude] to [x, y]
     * - [longitude, latitude, Z] => [x, y, z]
     * Note: By default, returns top-left coordinates for canvas/SVG type render
     *
     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @return {Array} - [x, y] or [x, y, z] in top left coords
     */

  }, {
    key: 'project',
    value: function project(xyz) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$topLeft = _ref.topLeft,
          topLeft = _ref$topLeft === undefined ? false : _ref$topLeft;

      var _xyz = _slicedToArray(xyz, 3),
          x0 = _xyz[0],
          y0 = _xyz[1],
          _xyz$ = _xyz[2],
          z0 = _xyz$ === undefined ? 0 : _xyz$;

      (0, _assert2.default)(Number.isFinite(x0) && Number.isFinite(y0) && Number.isFinite(z0), ERR_ARGUMENT);

      var _projectFlat2 = this.projectFlat([x0, y0]),
          _projectFlat3 = _slicedToArray(_projectFlat2, 2),
          X = _projectFlat3[0],
          Y = _projectFlat3[1];

      var v = (0, _utils.transformVector)(this.pixelProjectionMatrix, [X, Y, z0, 1]);

      var _v = _slicedToArray(v, 2),
          x = _v[0],
          y = _v[1];

      var y2 = topLeft ? this.height - y : y;
      return xyz.length === 2 ? [x, y2] : [x, y2, 0];
    }

    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
     */

  }, {
    key: 'unproject',
    value: function unproject(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === undefined ? false : _ref2$topLeft;

      var _xyz2 = _slicedToArray(xyz, 3),
          x = _xyz2[0],
          y = _xyz2[1],
          _xyz2$ = _xyz2[2],
          targetZ = _xyz2$ === undefined ? 0 : _xyz2$;

      var y2 = topLeft ? this.height - y : y;

      // since we don't know the correct projected z value for the point,
      // unproject two points to get a line and then find the point on that line with z=0
      var coord0 = (0, _utils.transformVector)(this.pixelUnprojectionMatrix, [x, y2, 0, 1]);
      var coord1 = (0, _utils.transformVector)(this.pixelUnprojectionMatrix, [x, y2, 1, 1]);

      if (!coord0 || !coord1) {
        return null;
      }

      var z0 = coord0[2];
      var z1 = coord1[2];

      var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);
      var v = (0, _lerp2.default)([], coord0, coord1, t);

      var vUnprojected = this.unprojectFlat(v);
      return xyz.length === 2 ? vUnprojected : [vUnprojected[0], vUnprojected[1], 0];
    }

    // NON_LINEAR PROJECTION HOOKS
    // Used for web meractor projection

    /**
     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
     * Performs the nonlinear part of the web mercator projection.
     * Remaining projection is done with 4x4 matrices which also handles
     * perspective.
     * @param {Array} lngLat - [lng, lat] coordinates
     *   Specifies a point on the sphere to project onto the map.
     * @return {Array} [x,y] coordinates.
     */

  }, {
    key: 'projectFlat',
    value: function projectFlat(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          x = _ref4[0],
          y = _ref4[1];

      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._projectFlat.apply(this, arguments);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._unprojectFlat.apply(this, arguments);
    }

    // TODO - why do we need these?

  }, {
    key: '_projectFlat',
    value: function _projectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }
  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }
  }, {
    key: 'getMercatorParams',
    value: function getMercatorParams() {
      var lngLat = this._addMetersToLngLat([this.longitude || 0, this.latitude || 0], this.meterOffset);
      return {
        longitude: lngLat[0],
        latitude: lngLat[1]
      };
    }
  }, {
    key: 'isMapSynched',
    value: function isMapSynched() {
      return false;
    }
  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      return this.distanceScales;
    }
  }, {
    key: 'getMatrices',
    value: function getMatrices() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$modelMatrix = _ref5.modelMatrix,
          modelMatrix = _ref5$modelMatrix === undefined ? null : _ref5$modelMatrix;

      var modelViewProjectionMatrix = this.viewProjectionMatrix;
      var pixelProjectionMatrix = this.pixelProjectionMatrix;
      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;

      if (modelMatrix) {
        modelViewProjectionMatrix = (0, _multiply2.default)([], this.viewProjectionMatrix, modelMatrix);
        pixelProjectionMatrix = (0, _multiply2.default)([], this.pixelProjectionMatrix, modelMatrix);
        pixelUnprojectionMatrix = (0, _invert2.default)([], pixelProjectionMatrix);
      }

      var matrices = Object.assign({
        modelViewProjectionMatrix: modelViewProjectionMatrix,
        viewProjectionMatrix: this.viewProjectionMatrix,
        viewMatrix: this.viewMatrix,
        projectionMatrix: this.projectionMatrix,

        // project/unproject between pixels and world
        pixelProjectionMatrix: pixelProjectionMatrix,
        pixelUnprojectionMatrix: pixelUnprojectionMatrix,

        width: this.width,
        height: this.height,
        scale: this.scale
      });

      return matrices;
    }

    // EXPERIMENTAL METHODS

    // Support for relative viewport dimensions
    // TODO - parses same strings a number of times

  }, {
    key: 'getDimensions',
    value: function getDimensions(_ref6) {
      var width = _ref6.width,
          height = _ref6.height;

      return {
        /* eslint-disable max-len */
        x: typeof this.x === 'string' ? Math.round(parseFloat(this.x) / 100 * width) : this.x,
        y: typeof this.y === 'string' ? Math.round(parseFloat(this.y) / 100 * height) : this.y,
        width: typeof this.width === 'string' ? Math.round(parseFloat(this.width) / 100 * width) : this.width,
        height: typeof this.height === 'string' ? Math.round(parseFloat(this.x) / 100 * height) : this.height
        /* eslint-enable max-len */
      };
    }
  }, {
    key: 'getCameraPosition',
    value: function getCameraPosition() {
      return this.cameraPosition;
    }
  }, {
    key: 'getCameraDirection',
    value: function getCameraDirection() {
      return this.cameraDirection;
    }
  }, {
    key: 'getCameraUp',
    value: function getCameraUp() {
      return this.cameraUp;
    }

    // TODO - these are duplicating WebMercator methods

  }, {
    key: '_addMetersToLngLat',
    value: function _addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = _slicedToArray(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;

      var _metersToLngLatDelta2 = this._metersToLngLatDelta(xyz),
          _metersToLngLatDelta3 = _slicedToArray(_metersToLngLatDelta2, 3),
          deltaLng = _metersToLngLatDelta3[0],
          deltaLat = _metersToLngLatDelta3[1],
          _metersToLngLatDelta4 = _metersToLngLatDelta3[2],
          deltaZ = _metersToLngLatDelta4 === undefined ? 0 : _metersToLngLatDelta4;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }
  }, {
    key: '_metersToLngLatDelta',
    value: function _metersToLngLatDelta(xyz) {
      var _xyz3 = _slicedToArray(xyz, 3),
          x = _xyz3[0],
          y = _xyz3[1],
          _xyz3$ = _xyz3[2],
          z = _xyz3$ === undefined ? 0 : _xyz3$;

      (0, _assert2.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _distanceScales = this.distanceScales,
          pixelsPerMeter = _distanceScales.pixelsPerMeter,
          degreesPerPixel = _distanceScales.degreesPerPixel;

      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }

    // INTERNAL METHODS

  }, {
    key: '_initMatrices',
    value: function _initMatrices() {
      // Note: As usual, matrix operations should be applied in "reverse" order
      // since vectors will be multiplied in from the right during transformation
      var vpm = (0, _utils.createMat4)();
      (0, _multiply2.default)(vpm, vpm, this.projectionMatrix);
      (0, _multiply2.default)(vpm, vpm, this.viewMatrix);
      this.viewProjectionMatrix = vpm;

      // console.log('VPM', this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);

      // Calculate inverse view matrix
      this.viewMatrixInverse = (0, _invert2.default)([], this.viewMatrix) || this.viewMatrix;

      // Decompose camera directions

      var _extractCameraVectors = (0, _utils.extractCameraVectors)({
        viewMatrix: this.viewMatrix,
        viewMatrixInverse: this.viewMatrixInverse
      }),
          eye = _extractCameraVectors.eye,
          direction = _extractCameraVectors.direction,
          up = _extractCameraVectors.up;

      this.cameraPosition = eye;
      this.cameraDirection = direction;
      this.cameraUp = up;

      // console.log(this.cameraPosition, this.cameraDirection, this.cameraUp);

      /*
       * Builds matrices that converts preprojected lngLats to screen pixels
       * and vice versa.
       * Note: Currently returns bottom-left coordinates!
       * Note: Starts with the GL projection matrix and adds steps to the
       *       scale and translate that matrix onto the window.
       * Note: WebGL controls clip space to screen projection with gl.viewport
       *       and does not need this step.
       */

      // matrix for conversion from world location to screen (pixel) coordinates
      var m = (0, _utils.createMat4)();
      (0, _scale2.default)(m, m, [this.width / 2, -this.height / 2, 1]);
      (0, _translate2.default)(m, m, [1, -1, 0]);
      (0, _multiply2.default)(m, m, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = m;

      this.pixelUnprojectionMatrix = (0, _invert2.default)((0, _utils.createMat4)(), this.pixelProjectionMatrix);
      if (!this.pixelUnprojectionMatrix) {
        _log2.default.warn('Pixel project matrix not invertible');
        // throw new Error('Pixel project matrix not invertible');
      }
    }
  }]);

  return Viewport;
}();

exports.default = Viewport;


Viewport.displayName = 'Viewport';
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL3ZpZXdwb3J0cy92aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJaRVJPX1ZFQ1RPUiIsIklERU5USVRZIiwiREVGQVVMVF9ESVNUQU5DRV9TQ0FMRVMiLCJwaXhlbHNQZXJNZXRlciIsIm1ldGVyc1BlclBpeGVsIiwicGl4ZWxzUGVyRGVncmVlIiwiZGVncmVlc1BlclBpeGVsIiwiREVGQVVMVF9aT09NIiwiRVJSX0FSR1VNRU5UIiwiVmlld3BvcnQiLCJvcHRzIiwiaWQiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0Iiwidmlld01hdHJpeCIsInByb2plY3Rpb25NYXRyaXgiLCJmb3Z5IiwibmVhciIsImZhciIsImxvbmdpdHVkZSIsImxhdGl0dWRlIiwiem9vbSIsInBvc2l0aW9uIiwibW9kZWxNYXRyaXgiLCJkaXN0YW5jZVNjYWxlcyIsImNvbnN0cnVjdG9yIiwiZGlzcGxheU5hbWUiLCJpc0dlb3NwYXRpYWwiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInNjYWxlIiwiTWF0aCIsInBvdyIsImZvY2FsRGlzdGFuY2UiLCJtZXRlck9mZnNldCIsInRyYW5zZm9ybVZlY3RvciIsImNlbnRlciIsInZpZXdNYXRyaXhVbmNlbnRlcmVkIiwibXVsdGlwbHlSaWdodCIsInRyYW5zbGF0ZSIsIm5lZ2F0ZSIsIkRFR1JFRVNfVE9fUkFESUFOUyIsIlBJIiwiZm92eVJhZGlhbnMiLCJhc3BlY3QiLCJfaW5pdE1hdHJpY2VzIiwiZXF1YWxzIiwiYmluZCIsInByb2plY3QiLCJ1bnByb2plY3QiLCJwcm9qZWN0RmxhdCIsInVucHJvamVjdEZsYXQiLCJnZXRNYXRyaWNlcyIsInZpZXdwb3J0IiwieHl6IiwidG9wTGVmdCIsIngwIiwieTAiLCJ6MCIsIlgiLCJZIiwidiIsInBpeGVsUHJvamVjdGlvbk1hdHJpeCIsInkyIiwibGVuZ3RoIiwidGFyZ2V0WiIsImNvb3JkMCIsInBpeGVsVW5wcm9qZWN0aW9uTWF0cml4IiwiY29vcmQxIiwiejEiLCJ0IiwidlVucHJvamVjdGVkIiwiX3Byb2plY3RGbGF0IiwiYXJndW1lbnRzIiwiX3VucHJvamVjdEZsYXQiLCJsbmdMYXQiLCJfYWRkTWV0ZXJzVG9MbmdMYXQiLCJtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4Iiwidmlld1Byb2plY3Rpb25NYXRyaXgiLCJtYXRyaWNlcyIsIk9iamVjdCIsImFzc2lnbiIsInJvdW5kIiwicGFyc2VGbG9hdCIsImNhbWVyYVBvc2l0aW9uIiwiY2FtZXJhRGlyZWN0aW9uIiwiY2FtZXJhVXAiLCJsbmdMYXRaIiwibG5nIiwibGF0IiwiWiIsIl9tZXRlcnNUb0xuZ0xhdERlbHRhIiwiZGVsdGFMbmciLCJkZWx0YUxhdCIsImRlbHRhWiIsInoiLCJ2cG0iLCJ2aWV3TWF0cml4SW52ZXJzZSIsImV5ZSIsImRpcmVjdGlvbiIsInVwIiwibSIsIndhcm4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O3FqQkFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUVBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUlBOztBQU1BOzs7Ozs7OztBQVJBLElBQU1BLGNBQWMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBcEI7O0FBVUEsSUFBTUMsV0FBVyx3QkFBakI7O0FBRUEsSUFBTUMsMEJBQTBCO0FBQzlCQyxrQkFBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FEYztBQUU5QkMsa0JBQWdCLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBRmM7QUFHOUJDLG1CQUFpQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQUhhO0FBSTlCQyxtQkFBaUIsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVA7QUFKYSxDQUFoQzs7QUFPQSxJQUFNQyxlQUFl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QUFWO0FBQ0EsMkJBQVdBLENBQVgsRUFBY0EsQ0FBZCxFQUFpQixDQUFDLEtBQUt6RixLQUFMLEdBQWEsQ0FBZCxFQUFpQixDQUFDLEtBQUtDLE1BQU4sR0FBZSxDQUFoQyxFQUFtQyxDQUFuQyxDQUFqQjtBQUNBLCtCQUFld0YsQ0FBZixFQUFrQkEsQ0FBbEIsRUFBcUIsQ0FBQyxDQUFELEVBQUksQ0FBQyxDQUFMLEVBQVEsQ0FBUixDQUFyQjtBQUNBLDhCQUFjQSxDQUFkLEVBQWlCQSxDQUFqQixFQUFvQixLQUFLdkIsb0JBQXpCO0FBQ0EsV0FBS2hCLHFCQUFMLEdBQTZCdUMsQ0FBN0I7O0FBRUEsV0FBS2xDLHVCQUFMLEdBQStCLHNCQUFZLHdCQUFaLEVBQTBCLEtBQUtMLHFCQUEvQixDQUEvQjtBQUNBLFVBQUksQ0FBQyxLQUFLSyx1QkFBVixFQUFtQztBQUNqQyxzQkFBSW1DLElBQUosQ0FBUyxxQ0FBVDtBQUNBO0FBQ0Q7QUFDRjs7Ozs7O2tCQXBYa0IvRixROzs7QUF1WHJCQSxTQUFTbUIsV0FBVCxHQUF1QixVQUF2QiIsImZpbGUiOiJ2aWV3cG9ydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgbG9nIGZyb20gJy4uL3V0aWxzL2xvZyc7XG5cbmltcG9ydCB7TWF0cml4NCwgVmVjdG9yMywgZXF1YWxzfSBmcm9tICdtYXRoLmdsJztcbmltcG9ydCB7dHJhbnNmb3JtVmVjdG9yLCBjcmVhdGVNYXQ0LCBleHRyYWN0Q2FtZXJhVmVjdG9yc30gZnJvbSAnLi4vbWF0aC91dGlscyc7XG5pbXBvcnQgbWF0NF9zY2FsZSBmcm9tICdnbC1tYXQ0L3NjYWxlJztcbmltcG9ydCBtYXQ0X3RyYW5zbGF0ZSBmcm9tICdnbC1tYXQ0L3RyYW5zbGF0ZSc7XG5pbXBvcnQgbWF0NF9tdWx0aXBseSBmcm9tICdnbC1tYXQ0L211bHRpcGx5JztcbmltcG9ydCBtYXQ0X2ludmVydCBmcm9tICdnbC1tYXQ0L2ludmVydCc7XG5pbXBvcnQgbWF0NF9wZXJzcGVjdGl2ZSBmcm9tICdnbC1tYXQ0L3BlcnNwZWN0aXZlJztcblxuaW1wb3J0IHZlYzJfbGVycCBmcm9tICdnbC12ZWMyL2xlcnAnO1xuXG5jb25zdCBaRVJPX1ZFQ1RPUiA9IFswLCAwLCAwXTtcblxuaW1wb3J0IHtcbiAgZ2V0TWVyY2F0b3JEaXN0YW5jZVNjYWxlcyxcbiAgZ2V0TWVyY2F0b3JXb3JsZFBvc2l0aW9uLFxuICBnZXRNZXJjYXRvck1ldGVyWm9vbVxufSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcblxuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBJREVOVElUWSA9IGNyZWF0ZU1hdDQoKTtcblxuY29uc3QgREVGQVVMVF9ESVNUQU5DRV9TQ0FMRVMgPSB7XG4gIHBpeGVsc1Blck1ldGVyOiBbMSwgMSwgMV0sXG4gIG1ldGVyc1BlclBpeGVsOiBbMSwgMSwgMV0sXG4gIHBpeGVsc1BlckRlZ3JlZTogWzEsIDEsIDFdLFxuICBkZWdyZWVzUGVyUGl4ZWw6IFsxLCAxLCAxXVxufTtcblxuY29uc3QgREVGQVVMVF9aT09NID0gMDtcblxuY29uc3QgRVJSX0FSR1VNRU5UID0gJ0lsbGVnYWwgYXJndW1lbnQgdG8gVmlld3BvcnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3cG9ydCB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIE1hbmFnZXMgY29vcmRpbmF0ZSBzeXN0ZW0gdHJhbnNmb3JtYXRpb25zIGZvciBkZWNrLmdsLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgVmlld3BvcnQgaXMgaW1tdXRhYmxlIGluIHRoZSBzZW5zZSB0aGF0IGl0IG9ubHkgaGFzIGFjY2Vzc29ycy5cbiAgICogQSBuZXcgdmlld3BvcnQgaW5zdGFuY2Ugc2hvdWxkIGJlIGNyZWF0ZWQgaWYgYW55IHBhcmFtZXRlcnMgaGF2ZSBjaGFuZ2VkLlxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHMgKi9cbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQgPSBudWxsLFxuXG4gICAgICAvLyBXaW5kb3cgd2lkdGgvaGVpZ2h0IGluIHBpeGVscyAoZm9yIHBpeGVsIHByb2plY3Rpb24pXG4gICAgICB4ID0gMCxcbiAgICAgIHkgPSAwLFxuICAgICAgd2lkdGggPSAxLFxuICAgICAgaGVpZ2h0ID0gMSxcblxuICAgICAgLy8gdmlldyBtYXRyaXhcbiAgICAgIHZpZXdNYXRyaXggPSBJREVOVElUWSxcblxuICAgICAgLy8gUHJvamVjdGlvbiBtYXRyaXhcbiAgICAgIHByb2plY3Rpb25NYXRyaXggPSBudWxsLFxuXG4gICAgICAvLyBQZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCBwYXJhbWV0ZXJzLCB1c2VkIGlmIHByb2plY3Rpb25NYXRyaXggbm90IHN1cHBsaWVkXG4gICAgICBmb3Z5ID0gNzUsXG4gICAgICBuZWFyID0gMC4xLCAgLy8gRGlzdGFuY2Ugb2YgbmVhciBjbGlwcGluZyBwbGFuZVxuICAgICAgZmFyID0gMTAwMCwgLy8gRGlzdGFuY2Ugb2YgZmFyIGNsaXBwaW5nIHBsYW5lXG5cbiAgICAgIC8vIEFuY2hvcjogbG5nIGxhdCB6b29tIHdpbGwgbWFrZSB0aGlzIHZpZXdwb3J0IHdvcmsgd2l0aCBnZW9zcGF0aWFsIGNvb3JkaW5hdGUgc3lzdGVtc1xuICAgICAgbG9uZ2l0dWRlID0gbnVsbCxcbiAgICAgIGxhdGl0dWRlID0gbnVsbCxcbiAgICAgIHpvb20gPSBudWxsLFxuXG4gICAgICAvLyBBbmNob3IgcG9zaXRpb24gb2Zmc2V0IChpbiBtZXRlcnMgZm9yIGdlb3NwYXRpYWwgdmlld3BvcnRzKVxuICAgICAgcG9zaXRpb24gPSBudWxsLFxuICAgICAgLy8gQSBtb2RlbCBtYXRyaXggdG8gYmUgYXBwbGllZCB0byBwb3NpdGlvbiwgdG8gbWF0Y2ggdGhlIGxheWVyIHByb3BzIEFQSVxuICAgICAgbW9kZWxNYXRyaXggPSBudWxsLFxuXG4gICAgICBkaXN0YW5jZVNjYWxlcyA9IG51bGxcbiAgICB9ID0gb3B0cztcblxuICAgIHRoaXMuaWQgPSBpZCB8fCB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICd2aWV3cG9ydCc7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgZ2Vvc3BhdGlhbCBhbmNob3JcbiAgICB0aGlzLmlzR2Vvc3BhdGlhbCA9IE51bWJlci5pc0Zpbml0ZShsYXRpdHVkZSkgJiYgTnVtYmVyLmlzRmluaXRlKGxvbmdpdHVkZSk7XG5cbiAgICAvLyBTaWxlbnRseSBhbGxvdyBhcHBzIHRvIHNlbmQgaW4gdyxoID0gMCwwXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAxO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG5cbiAgICB0aGlzLnpvb20gPSB6b29tO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHRoaXMuem9vbSkpIHtcbiAgICAgIHRoaXMuem9vbSA9IHRoaXMuaXNHZW9zcGF0aWFsID8gZ2V0TWVyY2F0b3JNZXRlclpvb20oe2xhdGl0dWRlfSkgOiBERUZBVUxUX1pPT007XG4gICAgfVxuICAgIHRoaXMuc2NhbGUgPSBNYXRoLnBvdygyLCB0aGlzLnpvb20pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIHNjYWxlcyBpZiBsbmcvbGF0L3pvb20gYXJlIHByb3ZpZGVkXG4gICAgdGhpcy5kaXN0YW5jZVNjYWxlcyA9IHRoaXMuaXNHZW9zcGF0aWFsID9cbiAgICAgIGdldE1lcmNhdG9yRGlzdGFuY2VTY2FsZXMoe2xhdGl0dWRlLCBsb25naXR1ZGUsIHNjYWxlOiB0aGlzLnNjYWxlfSkgOlxuICAgICAgZGlzdGFuY2VTY2FsZXMgfHwgREVGQVVMVF9ESVNUQU5DRV9TQ0FMRVM7XG5cbiAgICB0aGlzLmZvY2FsRGlzdGFuY2UgPSBvcHRzLmZvY2FsRGlzdGFuY2UgfHwgMTtcblxuICAgIHRoaXMuZGlzdGFuY2VTY2FsZXMubWV0ZXJzUGVyUGl4ZWwgPSBuZXcgVmVjdG9yMyh0aGlzLmRpc3RhbmNlU2NhbGVzLm1ldGVyc1BlclBpeGVsKTtcbiAgICB0aGlzLmRpc3RhbmNlU2NhbGVzLnBpeGVsc1Blck1ldGVyID0gbmV3IFZlY3RvcjModGhpcy5kaXN0YW5jZVNjYWxlcy5waXhlbHNQZXJNZXRlcik7XG5cbiAgICB0aGlzLnBvc2l0aW9uID0gWkVST19WRUNUT1I7XG4gICAgdGhpcy5tZXRlck9mZnNldCA9IFpFUk9fVkVDVE9SO1xuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgLy8gQXBwbHkgbW9kZWwgbWF0cml4IGlmIHN1cHBsaWVkXG4gICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICB0aGlzLm1vZGVsTWF0cml4ID0gbW9kZWxNYXRyaXg7XG4gICAgICB0aGlzLm1ldGVyT2Zmc2V0ID0gbW9kZWxNYXRyaXggPyBtb2RlbE1hdHJpeC50cmFuc2Zvcm1WZWN0b3IocG9zaXRpb24pIDogcG9zaXRpb247XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIGNhbWVyYSBjZW50ZXJcbiAgICB0aGlzLmNlbnRlciA9IHRoaXMuaXNHZW9zcGF0aWFsID9cbiAgICAgIGdldE1lcmNhdG9yV29ybGRQb3NpdGlvbih7XG4gICAgICAgIGxvbmdpdHVkZSwgbGF0aXR1ZGUsIHpvb206IHRoaXMuem9vbSwgbWV0ZXJPZmZzZXQ6IHRoaXMubWV0ZXJPZmZzZXRcbiAgICAgIH0pIDpcbiAgICAgIHBvc2l0aW9uO1xuXG4gICAgLy8gY29uc29sZS5sb2codGhpcy5zY2FsZSwgdGhpcy5kaXN0YW5jZVNjYWxlcy5waXhlbHNQZXJNZXRlcik7XG5cbiAgICB0aGlzLnZpZXdNYXRyaXhVbmNlbnRlcmVkID0gdmlld01hdHJpeDtcblxuICAgIC8vIE1ha2UgYSBjZW50ZXJlZCB2ZXJzaW9uIG9mIHRoZSBtYXRyaXggZm9yIHByb2plY3Rpb24gbW9kZXMgd2l0aG91dCBhbiBvZmZzZXRcbiAgICB0aGlzLnZpZXdNYXRyaXggPSBuZXcgTWF0cml4NCgpXG4gICAgICAvLyBBcHBseSB0aGUgdW5jZW50ZXJlZCB2aWV3IG1hdHJpeFxuICAgICAgLm11bHRpcGx5UmlnaHQodGhpcy52aWV3TWF0cml4VW5jZW50ZXJlZClcbiAgICAgIC8vIFRoZSBNZXJjYXRvciB3b3JsZCBjb29yZGluYXRlIHN5c3RlbSBpcyB1cHBlciBsZWZ0LFxuICAgICAgLy8gYnV0IEdMIGV4cGVjdHMgbG93ZXIgbGVmdCwgc28gd2UgZmxpcCBpdCBhcm91bmQgdGhlIGNlbnRlciBhZnRlciBhbGwgdHJhbnNmb3JtcyBhcmUgZG9uZVxuICAgICAgLnNjYWxlKFsxLCAtMSwgMV0pXG4gICAgICAvLyBBbmQgY2VudGVyIGl0XG4gICAgICAudHJhbnNsYXRlKG5ldyBWZWN0b3IzKHRoaXMuY2VudGVyIHx8IFpFUk9fVkVDVE9SKS5uZWdhdGUoKSk7XG5cbiAgICAvLyBDcmVhdGUgYSBwcm9qZWN0aW9uIG1hdHJpeCBpZiBub3Qgc3VwcGxpZWRcbiAgICBpZiAocHJvamVjdGlvbk1hdHJpeCkge1xuICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gcHJvamVjdGlvbk1hdHJpeDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShmb3Z5KSk7XG4gICAgICBjb25zdCBERUdSRUVTX1RPX1JBRElBTlMgPSBNYXRoLlBJIC8gMTgwO1xuICAgICAgY29uc3QgZm92eVJhZGlhbnMgPSBmb3Z5ICogREVHUkVFU19UT19SQURJQU5TO1xuICAgICAgY29uc3QgYXNwZWN0ID0gdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0O1xuICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbWF0NF9wZXJzcGVjdGl2ZShbXSwgZm92eVJhZGlhbnMsIGFzcGVjdCwgbmVhciwgZmFyKTtcbiAgICB9XG5cbiAgICAvLyBJbml0IHBpeGVsIG1hdHJpY2VzXG4gICAgdGhpcy5faW5pdE1hdHJpY2VzKCk7XG5cbiAgICAvLyBCaW5kIG1ldGhvZHMgZm9yIGVhc3kgYWNjZXNzXG4gICAgdGhpcy5lcXVhbHMgPSB0aGlzLmVxdWFscy5iaW5kKHRoaXMpO1xuICAgIHRoaXMucHJvamVjdCA9IHRoaXMucHJvamVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMudW5wcm9qZWN0ID0gdGhpcy51bnByb2plY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLnByb2plY3RGbGF0ID0gdGhpcy5wcm9qZWN0RmxhdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMudW5wcm9qZWN0RmxhdCA9IHRoaXMudW5wcm9qZWN0RmxhdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0TWF0cmljZXMgPSB0aGlzLmdldE1hdHJpY2VzLmJpbmQodGhpcyk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIC8vIFR3byB2aWV3cG9ydHMgYXJlIGVxdWFsIGlmIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGlkZW50aWNhbCwgYW5kIGlmXG4gIC8vIHRoZWlyIHZpZXcgYW5kIHByb2plY3Rpb24gbWF0cmljZXMgYXJlIChhcHByb3hpbWF0ZWx5KSBlcXVhbC5cbiAgZXF1YWxzKHZpZXdwb3J0KSB7XG4gICAgaWYgKCEodmlld3BvcnQgaW5zdGFuY2VvZiBWaWV3cG9ydCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlld3BvcnQud2lkdGggPT09IHRoaXMud2lkdGggJiZcbiAgICAgIHZpZXdwb3J0LmhlaWdodCA9PT0gdGhpcy5oZWlnaHQgJiZcbiAgICAgIGVxdWFscyh2aWV3cG9ydC5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnByb2plY3Rpb25NYXRyaXgpICYmXG4gICAgICBlcXVhbHModmlld3BvcnQudmlld01hdHJpeCwgdGhpcy52aWV3TWF0cml4KTtcbiAgICAgIC8vIFRPRE8gLSBjaGVjayBkaXN0YW5jZSBzY2FsZXM/XG4gIH1cblxuICAvKipcbiAgICogUHJvamVjdHMgeHl6IChwb3NzaWJseSBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlKSB0byBwaXhlbCBjb29yZGluYXRlcyBpbiB3aW5kb3dcbiAgICogdXNpbmcgdmlld3BvcnQgcHJvamVjdGlvbiBwYXJhbWV0ZXJzXG4gICAqIC0gW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIHRvIFt4LCB5XVxuICAgKiAtIFtsb25naXR1ZGUsIGxhdGl0dWRlLCBaXSA9PiBbeCwgeSwgel1cbiAgICogTm90ZTogQnkgZGVmYXVsdCwgcmV0dXJucyB0b3AtbGVmdCBjb29yZGluYXRlcyBmb3IgY2FudmFzL1NWRyB0eXBlIHJlbmRlclxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXRaIC0gW2xuZywgbGF0XSBvciBbbG5nLCBsYXQsIFpdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy50b3BMZWZ0PXRydWUgLSBXaGV0aGVyIHByb2plY3RlZCBjb29yZHMgYXJlIHRvcCBsZWZ0XG4gICAqIEByZXR1cm4ge0FycmF5fSAtIFt4LCB5XSBvciBbeCwgeSwgel0gaW4gdG9wIGxlZnQgY29vcmRzXG4gICAqL1xuICBwcm9qZWN0KHh5eiwge3RvcExlZnQgPSBmYWxzZX0gPSB7fSkge1xuICAgIGNvbnN0IFt4MCwgeTAsIHowID0gMF0gPSB4eXo7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh4MCkgJiYgTnVtYmVyLmlzRmluaXRlKHkwKSAmJiBOdW1iZXIuaXNGaW5pdGUoejApLCBFUlJfQVJHVU1FTlQpO1xuXG4gICAgY29uc3QgW1gsIFldID0gdGhpcy5wcm9qZWN0RmxhdChbeDAsIHkwXSk7XG4gICAgY29uc3QgdiA9IHRyYW5zZm9ybVZlY3Rvcih0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCwgW1gsIFksIHowLCAxXSk7XG5cbiAgICBjb25zdCBbeCwgeV0gPSB2O1xuICAgIGNvbnN0IHkyID0gdG9wTGVmdCA/IHRoaXMuaGVpZ2h0IC0geSA6IHk7XG4gICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyBbeCwgeTJdIDogW3gsIHkyLCAwXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3QgcGl4ZWwgY29vcmRpbmF0ZXMgb24gc2NyZWVuIG9udG8gd29ybGQgY29vcmRpbmF0ZXMsXG4gICAqIChwb3NzaWJseSBbbG9uLCBsYXRdKSBvbiBtYXAuXG4gICAqIC0gW3gsIHldID0+IFtsbmcsIGxhdF1cbiAgICogLSBbeCwgeSwgel0gPT4gW2xuZywgbGF0LCBaXVxuICAgKiBAcGFyYW0ge0FycmF5fSB4eXogLVxuICAgKiBAcmV0dXJuIHtBcnJheXxudWxsfSAtIFtsbmcsIGxhdCwgWl0gb3IgW1gsIFksIFpdXG4gICAqL1xuICB1bnByb2plY3QoeHl6LCB7dG9wTGVmdCA9IGZhbHNlfSA9IHt9KSB7XG4gICAgY29uc3QgW3gsIHksIHRhcmdldFogPSAwXSA9IHh5ejtcblxuICAgIGNvbnN0IHkyID0gdG9wTGVmdCA/IHRoaXMuaGVpZ2h0IC0geSA6IHk7XG5cbiAgICAvLyBzaW5jZSB3ZSBkb24ndCBrbm93IHRoZSBjb3JyZWN0IHByb2plY3RlZCB6IHZhbHVlIGZvciB0aGUgcG9pbnQsXG4gICAgLy8gdW5wcm9qZWN0IHR3byBwb2ludHMgdG8gZ2V0IGEgbGluZSBhbmQgdGhlbiBmaW5kIHRoZSBwb2ludCBvbiB0aGF0IGxpbmUgd2l0aCB6PTBcbiAgICBjb25zdCBjb29yZDAgPSB0cmFuc2Zvcm1WZWN0b3IodGhpcy5waXhlbFVucHJvamVjdGlvbk1hdHJpeCwgW3gsIHkyLCAwLCAxXSk7XG4gICAgY29uc3QgY29vcmQxID0gdHJhbnNmb3JtVmVjdG9yKHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB5MiwgMSwgMV0pO1xuXG4gICAgaWYgKCFjb29yZDAgfHwgIWNvb3JkMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgejAgPSBjb29yZDBbMl07XG4gICAgY29uc3QgejEgPSBjb29yZDFbMl07XG5cbiAgICBjb25zdCB0ID0gejAgPT09IHoxID8gMCA6ICh0YXJnZXRaIC0gejApIC8gKHoxIC0gejApO1xuICAgIGNvbnN0IHYgPSB2ZWMyX2xlcnAoW10sIGNvb3JkMCwgY29vcmQxLCB0KTtcblxuICAgIGNvbnN0IHZVbnByb2plY3RlZCA9IHRoaXMudW5wcm9qZWN0RmxhdCh2KTtcbiAgICByZXR1cm4geHl6Lmxlbmd0aCA9PT0gMiA/IHZVbnByb2plY3RlZCA6IFt2VW5wcm9qZWN0ZWRbMF0sIHZVbnByb2plY3RlZFsxXSwgMF07XG4gIH1cblxuICAvLyBOT05fTElORUFSIFBST0pFQ1RJT04gSE9PS1NcbiAgLy8gVXNlZCBmb3Igd2ViIG1lcmFjdG9yIHByb2plY3Rpb25cblxuICAvKipcbiAgICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAgICogUGVyZm9ybXMgdGhlIG5vbmxpbmVhciBwYXJ0IG9mIHRoZSB3ZWIgbWVyY2F0b3IgcHJvamVjdGlvbi5cbiAgICogUmVtYWluaW5nIHByb2plY3Rpb24gaXMgZG9uZSB3aXRoIDR4NCBtYXRyaWNlcyB3aGljaCBhbHNvIGhhbmRsZXNcbiAgICogcGVyc3BlY3RpdmUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gW3gseV0gY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm9qZWN0RmxhdChbeCwgeV0sIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB0aGlzLl9wcm9qZWN0RmxhdCguLi5hcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCB3b3JsZCBwb2ludCBbeCx5XSBvbiBtYXAgb250byB7bGF0LCBsb259IG9uIHNwaGVyZVxuICAgKiBAcGFyYW0ge29iamVjdHxWZWN0b3J9IHh5IC0gb2JqZWN0IHdpdGgge3gseX0gbWVtYmVyc1xuICAgKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAgICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAgICogICBIYXMgdG9BcnJheSBtZXRob2QgaWYgeW91IG5lZWQgYSBHZW9KU09OIEFycmF5LlxuICAgKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gICAqL1xuICB1bnByb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VucHJvamVjdEZsYXQoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8vIFRPRE8gLSB3aHkgZG8gd2UgbmVlZCB0aGVzZT9cbiAgX3Byb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHh5ejtcbiAgfVxuXG4gIF91bnByb2plY3RGbGF0KHh5eiwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHh5ejtcbiAgfVxuXG4gIGdldE1lcmNhdG9yUGFyYW1zKCkge1xuICAgIGNvbnN0IGxuZ0xhdCA9IHRoaXMuX2FkZE1ldGVyc1RvTG5nTGF0KFxuICAgICAgW3RoaXMubG9uZ2l0dWRlIHx8IDAsIHRoaXMubGF0aXR1ZGUgfHwgMF0sXG4gICAgICB0aGlzLm1ldGVyT2Zmc2V0XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgbG9uZ2l0dWRlOiBsbmdMYXRbMF0sXG4gICAgICBsYXRpdHVkZTogbG5nTGF0WzFdXG4gICAgfTtcbiAgfVxuXG4gIGlzTWFwU3luY2hlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXREaXN0YW5jZVNjYWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZVNjYWxlcztcbiAgfVxuXG4gIGdldE1hdHJpY2VzKHttb2RlbE1hdHJpeCA9IG51bGx9ID0ge30pIHtcbiAgICBsZXQgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXg7XG4gICAgbGV0IHBpeGVsUHJvamVjdGlvbk1hdHJpeCA9IHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4O1xuICAgIGxldCBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCA9IHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXg7XG5cbiAgICBpZiAobW9kZWxNYXRyaXgpIHtcbiAgICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSBtYXQ0X211bHRpcGx5KFtdLCB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4LCBtb2RlbE1hdHJpeCk7XG4gICAgICBwaXhlbFByb2plY3Rpb25NYXRyaXggPSBtYXQ0X211bHRpcGx5KFtdLCB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCwgbW9kZWxNYXRyaXgpO1xuICAgICAgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSBtYXQ0X2ludmVydChbXSwgcGl4ZWxQcm9qZWN0aW9uTWF0cml4KTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRyaWNlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIHZpZXdQcm9qZWN0aW9uTWF0cml4OiB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgICAgdmlld01hdHJpeDogdGhpcy52aWV3TWF0cml4LFxuICAgICAgcHJvamVjdGlvbk1hdHJpeDogdGhpcy5wcm9qZWN0aW9uTWF0cml4LFxuXG4gICAgICAvLyBwcm9qZWN0L3VucHJvamVjdCBiZXR3ZWVuIHBpeGVscyBhbmQgd29ybGRcbiAgICAgIHBpeGVsUHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LFxuXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBzY2FsZTogdGhpcy5zY2FsZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1hdHJpY2VzO1xuICB9XG5cbiAgLy8gRVhQRVJJTUVOVEFMIE1FVEhPRFNcblxuICAvLyBTdXBwb3J0IGZvciByZWxhdGl2ZSB2aWV3cG9ydCBkaW1lbnNpb25zXG4gIC8vIFRPRE8gLSBwYXJzZXMgc2FtZSBzdHJpbmdzIGEgbnVtYmVyIG9mIHRpbWVzXG4gIGdldERpbWVuc2lvbnMoe3dpZHRoLCBoZWlnaHR9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICAgIHg6IHR5cGVvZiB0aGlzLnggPT09ICdzdHJpbmcnID8gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHRoaXMueCkgLyAxMDAgKiB3aWR0aCkgOiB0aGlzLngsXG4gICAgICB5OiB0eXBlb2YgdGhpcy55ID09PSAnc3RyaW5nJyA/IE1hdGgucm91bmQocGFyc2VGbG9hdCh0aGlzLnkpIC8gMTAwICogaGVpZ2h0KSA6IHRoaXMueSxcbiAgICAgIHdpZHRoOiB0eXBlb2YgdGhpcy53aWR0aCA9PT0gJ3N0cmluZycgPyBNYXRoLnJvdW5kKHBhcnNlRmxvYXQodGhpcy53aWR0aCkgLyAxMDAgKiB3aWR0aCkgOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0eXBlb2YgdGhpcy5oZWlnaHQgPT09ICdzdHJpbmcnID8gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHRoaXMueCkgLyAxMDAgKiBoZWlnaHQpIDogdGhpcy5oZWlnaHRcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICAgIH07XG4gIH1cblxuICBnZXRDYW1lcmFQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jYW1lcmFQb3NpdGlvbjtcbiAgfVxuXG4gIGdldENhbWVyYURpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jYW1lcmFEaXJlY3Rpb247XG4gIH1cblxuICBnZXRDYW1lcmFVcCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW1lcmFVcDtcbiAgfVxuXG4gIC8vIFRPRE8gLSB0aGVzZSBhcmUgZHVwbGljYXRpbmcgV2ViTWVyY2F0b3IgbWV0aG9kc1xuICBfYWRkTWV0ZXJzVG9MbmdMYXQobG5nTGF0WiwgeHl6KSB7XG4gICAgY29uc3QgW2xuZywgbGF0LCBaID0gMF0gPSBsbmdMYXRaO1xuICAgIGNvbnN0IFtkZWx0YUxuZywgZGVsdGFMYXQsIGRlbHRhWiA9IDBdID0gdGhpcy5fbWV0ZXJzVG9MbmdMYXREZWx0YSh4eXopO1xuICAgIHJldHVybiBsbmdMYXRaLmxlbmd0aCA9PT0gMiA/XG4gICAgICBbbG5nICsgZGVsdGFMbmcsIGxhdCArIGRlbHRhTGF0XSA6XG4gICAgICBbbG5nICsgZGVsdGFMbmcsIGxhdCArIGRlbHRhTGF0LCBaICsgZGVsdGFaXTtcbiAgfVxuXG4gIF9tZXRlcnNUb0xuZ0xhdERlbHRhKHh5eikge1xuICAgIGNvbnN0IFt4LCB5LCB6ID0gMF0gPSB4eXo7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh4KSAmJiBOdW1iZXIuaXNGaW5pdGUoeSkgJiYgTnVtYmVyLmlzRmluaXRlKHopLCBFUlJfQVJHVU1FTlQpO1xuICAgIGNvbnN0IHtwaXhlbHNQZXJNZXRlciwgZGVncmVlc1BlclBpeGVsfSA9IHRoaXMuZGlzdGFuY2VTY2FsZXM7XG4gICAgY29uc3QgZGVsdGFMbmcgPSB4ICogcGl4ZWxzUGVyTWV0ZXJbMF0gKiBkZWdyZWVzUGVyUGl4ZWxbMF07XG4gICAgY29uc3QgZGVsdGFMYXQgPSB5ICogcGl4ZWxzUGVyTWV0ZXJbMV0gKiBkZWdyZWVzUGVyUGl4ZWxbMV07XG4gICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyBbZGVsdGFMbmcsIGRlbHRhTGF0XSA6IFtkZWx0YUxuZywgZGVsdGFMYXQsIHpdO1xuICB9XG5cbiAgLy8gSU5URVJOQUwgTUVUSE9EU1xuXG4gIF9pbml0TWF0cmljZXMoKSB7XG4gICAgLy8gTm90ZTogQXMgdXN1YWwsIG1hdHJpeCBvcGVyYXRpb25zIHNob3VsZCBiZSBhcHBsaWVkIGluIFwicmV2ZXJzZVwiIG9yZGVyXG4gICAgLy8gc2luY2UgdmVjdG9ycyB3aWxsIGJlIG11bHRpcGxpZWQgaW4gZnJvbSB0aGUgcmlnaHQgZHVyaW5nIHRyYW5zZm9ybWF0aW9uXG4gICAgY29uc3QgdnBtID0gY3JlYXRlTWF0NCgpO1xuICAgIG1hdDRfbXVsdGlwbHkodnBtLCB2cG0sIHRoaXMucHJvamVjdGlvbk1hdHJpeCk7XG4gICAgbWF0NF9tdWx0aXBseSh2cG0sIHZwbSwgdGhpcy52aWV3TWF0cml4KTtcbiAgICB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4ID0gdnBtO1xuXG4gICAgLy8gY29uc29sZS5sb2coJ1ZQTScsIHRoaXMudmlld01hdHJpeCwgdGhpcy5wcm9qZWN0aW9uTWF0cml4LCB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4KTtcblxuICAgIC8vIENhbGN1bGF0ZSBpbnZlcnNlIHZpZXcgbWF0cml4XG4gICAgdGhpcy52aWV3TWF0cml4SW52ZXJzZSA9IG1hdDRfaW52ZXJ0KFtdLCB0aGlzLnZpZXdNYXRyaXgpIHx8IHRoaXMudmlld01hdHJpeDtcblxuICAgIC8vIERlY29tcG9zZSBjYW1lcmEgZGlyZWN0aW9uc1xuICAgIGNvbnN0IHtleWUsIGRpcmVjdGlvbiwgdXB9ID0gZXh0cmFjdENhbWVyYVZlY3RvcnMoe1xuICAgICAgdmlld01hdHJpeDogdGhpcy52aWV3TWF0cml4LFxuICAgICAgdmlld01hdHJpeEludmVyc2U6IHRoaXMudmlld01hdHJpeEludmVyc2VcbiAgICB9KTtcbiAgICB0aGlzLmNhbWVyYVBvc2l0aW9uID0gZXllO1xuICAgIHRoaXMuY2FtZXJhRGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHRoaXMuY2FtZXJhVXAgPSB1cDtcblxuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuY2FtZXJhUG9zaXRpb24sIHRoaXMuY2FtZXJhRGlyZWN0aW9uLCB0aGlzLmNhbWVyYVVwKTtcblxuICAgIC8qXG4gICAgICogQnVpbGRzIG1hdHJpY2VzIHRoYXQgY29udmVydHMgcHJlcHJvamVjdGVkIGxuZ0xhdHMgdG8gc2NyZWVuIHBpeGVsc1xuICAgICAqIGFuZCB2aWNlIHZlcnNhLlxuICAgICAqIE5vdGU6IEN1cnJlbnRseSByZXR1cm5zIGJvdHRvbS1sZWZ0IGNvb3JkaW5hdGVzIVxuICAgICAqIE5vdGU6IFN0YXJ0cyB3aXRoIHRoZSBHTCBwcm9qZWN0aW9uIG1hdHJpeCBhbmQgYWRkcyBzdGVwcyB0byB0aGVcbiAgICAgKiAgICAgICBzY2FsZSBhbmQgdHJhbnNsYXRlIHRoYXQgbWF0cml4IG9udG8gdGhlIHdpbmRvdy5cbiAgICAgKiBOb3RlOiBXZWJHTCBjb250cm9scyBjbGlwIHNwYWNlIHRvIHNjcmVlbiBwcm9qZWN0aW9uIHdpdGggZ2wudmlld3BvcnRcbiAgICAgKiAgICAgICBhbmQgZG9lcyBub3QgbmVlZCB0aGlzIHN0ZXAuXG4gICAgICovXG5cbiAgICAvLyBtYXRyaXggZm9yIGNvbnZlcnNpb24gZnJvbSB3b3JsZCBsb2NhdGlvbiB0byBzY3JlZW4gKHBpeGVsKSBjb29yZGluYXRlc1xuICAgIGNvbnN0IG0gPSBjcmVhdGVNYXQ0KCk7XG4gICAgbWF0NF9zY2FsZShtLCBtLCBbdGhpcy53aWR0aCAvIDIsIC10aGlzLmhlaWdodCAvIDIsIDFdKTtcbiAgICBtYXQ0X3RyYW5zbGF0ZShtLCBtLCBbMSwgLTEsIDBdKTtcbiAgICBtYXQ0X211bHRpcGx5KG0sIG0sIHRoaXMudmlld1Byb2plY3Rpb25NYXRyaXgpO1xuICAgIHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gbTtcblxuICAgIHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSBtYXQ0X2ludmVydChjcmVhdGVNYXQ0KCksIHRoaXMucGl4ZWxQcm9qZWN0aW9uTWF0cml4KTtcbiAgICBpZiAoIXRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXgpIHtcbiAgICAgIGxvZy53YXJuKCdQaXhlbCBwcm9qZWN0IG1hdHJpeCBub3QgaW52ZXJ0aWJsZScpO1xuICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdQaXhlbCBwcm9qZWN0IG1hdHJpeCBub3QgaW52ZXJ0aWJsZScpO1xuICAgIH1cbiAgfVxufVxuXG5WaWV3cG9ydC5kaXNwbGF5TmFtZSA9ICdWaWV3cG9ydCc7XG4iXX0=