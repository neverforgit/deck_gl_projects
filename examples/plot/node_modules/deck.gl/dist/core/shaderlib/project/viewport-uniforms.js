'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */


exports.getUniformsFromViewport = getUniformsFromViewport;

var _multiply = require('gl-mat4/multiply');

var _multiply2 = _interopRequireDefault(_multiply);

var _transformMat = require('gl-vec4/transformMat4');

var _transformMat2 = _interopRequireDefault(_transformMat);

var _log = require('../../utils/log');

var _log2 = _interopRequireDefault(_log);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _constants = require('../../lib/constants');

var _viewportMercatorProject = require('viewport-mercator-project');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// To quickly set a vector to zero
var ZERO_VECTOR = [0, 0, 0, 0];
// 4x4 matrix that drops 4th component of vector
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
var IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

// TODO - import these utils from fp64 package
function fp64ify(a) {
  var hiPart = Math.fround(a);
  var loPart = a - hiPart;
  return [hiPart, loPart];
}

// calculate WebGL 64 bit matrix (transposed "Float64Array")
function fp64ifyMatrix4(matrix) {
  // Transpose the projection matrix to column major for GLSL.
  var matrixFP64 = new Float32Array(32);
  for (var i = 0; i < 4; ++i) {
    for (var j = 0; j < 4; ++j) {
      var index = i * 4 + j;

      var _fp64ify = fp64ify(matrix[j * 4 + i]);

      var _fp64ify2 = _slicedToArray(_fp64ify, 2);

      matrixFP64[index * 2] = _fp64ify2[0];
      matrixFP64[index * 2 + 1] = _fp64ify2[1];
    }
  }
  return matrixFP64;
}

// Calculate transformed projectionCenter (using 64 bit precision JS)
// This is the key to offset mode precision
// (avoids doing this addition in 32 bit precision in GLSL)
function calculateProjectionCenter(_ref) {
  var coordinateOrigin = _ref.coordinateOrigin,
      coordinateZoom = _ref.coordinateZoom,
      viewProjectionMatrix = _ref.viewProjectionMatrix;

  var positionPixels = (0, _viewportMercatorProject.projectFlat)(coordinateOrigin, Math.pow(2, coordinateZoom));
  // projectionCenter = new Matrix4(viewProjectionMatrix)
  //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);
  return (0, _transformMat2.default)([], [positionPixels[0], positionPixels[1], 0.0, 1.0], viewProjectionMatrix);
}

// The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,
// has lower performance but provides error checking.
// Uncomment when debugging
function calculateMatrixAndOffset(_ref2) {
  var viewport = _ref2.viewport,
      modelMatrix = _ref2.modelMatrix,
      coordinateSystem = _ref2.coordinateSystem,
      coordinateOrigin = _ref2.coordinateOrigin,
      coordinateZoom = _ref2.coordinateZoom;
  var viewMatrixUncentered = viewport.viewMatrixUncentered;
  var viewMatrix = viewport.viewMatrix;
  var projectionMatrix = viewport.projectionMatrix;
  var viewProjectionMatrix = viewport.viewProjectionMatrix;


  var projectionCenter = void 0;

  switch (coordinateSystem) {

    case _constants.COORDINATE_SYSTEM.IDENTITY:
    case _constants.COORDINATE_SYSTEM.LNGLAT:
      projectionCenter = ZERO_VECTOR;
      break;

    // TODO: make lighitng work for meter offset mode
    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
      projectionCenter = calculateProjectionCenter({
        coordinateOrigin: coordinateOrigin, coordinateZoom: coordinateZoom, viewProjectionMatrix: viewProjectionMatrix
      });

      // Always apply uncentered projection matrix if available (shader adds center)
      viewMatrix = viewMatrixUncentered || viewMatrix;

      // Zero out 4th coordinate ("after" model matrix) - avoids further translations
      // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)
      //   .multiplyRight(VECTOR_TO_POINT_MATRIX);
      viewProjectionMatrix = (0, _multiply2.default)([], projectionMatrix, viewMatrix);
      viewProjectionMatrix = (0, _multiply2.default)([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
      break;

    default:
      throw new Error('Unknown projection mode');
  }

  return {
    viewMatrix: viewMatrix,
    viewProjectionMatrix: viewProjectionMatrix,
    projectionCenter: projectionCenter,
    cameraPos: viewport.cameraPosition
  };
}

/**
 * Returns uniforms for shaders based on current projection
 * includes: projection matrix suitable for shaders
 *
 * TODO - Ensure this works with any viewport, not just WebMercatorViewports
 *
 * @param {WebMercatorViewport} viewport -
 * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
 */
function getUniformsFromViewport() {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      viewport = _ref3.viewport,
      _ref3$modelMatrix = _ref3.modelMatrix,
      modelMatrix = _ref3$modelMatrix === undefined ? null : _ref3$modelMatrix,
      _ref3$coordinateSyste = _ref3.coordinateSystem,
      coordinateSystem = _ref3$coordinateSyste === undefined ? _constants.COORDINATE_SYSTEM.LNGLAT : _ref3$coordinateSyste,
      _ref3$coordinateOrigi = _ref3.coordinateOrigin,
      coordinateOrigin = _ref3$coordinateOrigi === undefined ? [0, 0] : _ref3$coordinateOrigi,
      projectionMode = _ref3.projectionMode,
      positionOrigin = _ref3.positionOrigin;

  (0, _assert2.default)(viewport);

  if (projectionMode !== undefined) {
    coordinateSystem = projectionMode;
    _log2.default.deprecated('projectionMode', 'coordinateSystem');
  }
  if (positionOrigin !== undefined) {
    coordinateOrigin = positionOrigin;
    _log2.default.deprecated('positionOrigin', 'coordinateOrigin');
  }

  var coordinateZoom = viewport.zoom;
  (0, _assert2.default)(coordinateZoom >= 0);

  var _calculateMatrixAndOf = calculateMatrixAndOffset({
    coordinateSystem: coordinateSystem, coordinateOrigin: coordinateOrigin, coordinateZoom: coordinateZoom, modelMatrix: modelMatrix, viewport: viewport
  }),
      projectionCenter = _calculateMatrixAndOf.projectionCenter,
      viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix,
      cameraPos = _calculateMatrixAndOf.cameraPos;

  (0, _assert2.default)(viewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');

  // Calculate projection pixels per unit
  var distanceScales = viewport.getDistanceScales();

  // TODO - does this depend on useDevicePixelRatio?
  var devicePixelRatio = window && window.devicePixelRatio || 1;
  var viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];

  var glModelMatrix = new Float32Array(modelMatrix || IDENTITY_MATRIX);
  var glViewProjectionMatrix = new Float32Array(viewProjectionMatrix);

  var glViewProjectionMatrixFP64 = fp64ifyMatrix4(viewProjectionMatrix);
  var scaleFP64 = fp64ify(viewport.scale);

  return {
    // Projection mode values
    project_uCoordinateSystem: coordinateSystem,
    project_uCenter: projectionCenter,

    // Screen size
    project_uViewportSize: viewportSize,
    project_uDevicePixelRatio: devicePixelRatio,

    // Distance at which screen pixels are projected
    project_uFocalDistance: viewport.focalDistance || 1,
    project_uPixelsPerUnit: distanceScales.pixelsPerMeter,
    project_uScale: viewport.scale, // This is the mercator scale (2 ** zoom)

    project_uModelMatrix: glModelMatrix,
    project_uViewProjectionMatrix: glViewProjectionMatrix,

    // 64 bit support
    project_uViewProjectionMatrixFP64: fp64ifyMatrix4(viewProjectionMatrix),

    // This is for lighting calculations
    project_uCameraPosition: new Float32Array(cameraPos),

    project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,
    project64_uScale: scaleFP64,

    //
    // DEPRECATED UNIFORMS - For backwards compatibility with old custom layers
    //
    projectionMode: coordinateSystem,
    projectionCenter: projectionCenter,

    projectionOrigin: coordinateOrigin,
    modelMatrix: glModelMatrix,
    viewMatrix: viewport.viewMatrix,
    projectionMatrix: glViewProjectionMatrix,
    projectionPixelsPerUnit: distanceScales.pixelsPerMeter,
    projectionScale: viewport.scale, // This is the mercator scale (2 ** zoom)
    viewportSize: viewportSize,
    devicePixelRatio: devicePixelRatio,
    cameraPos: new Float32Array(cameraPos),

    projectionFP64: glViewProjectionMatrixFP64,
    projectionScaleFP64: scaleFP64
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb3JlL3NoYWRlcmxpYi9wcm9qZWN0L3ZpZXdwb3J0LXVuaWZvcm1zLmpzIl0sIm5hbWVzIjpbImdldFVuaWZvcm1zRnJvbVZpZXdwb3J0IiwiWkVST19WRUNUT1IiLCJWRUNUT1JfVE9fUE9JTlRfTUFUUklYIiwiSURFTlRJVFlfTUFUUklYIiwiZnA2NGlmeSIsImEiLCJoaVBhcnQiLCJNYXRoIiwiZnJvdW5kIiwibG9QYXJ0IiwiZnA2NGlmeU1hdHJpeDQiLCJtYXRyaXgiLCJtYXRyaXhGUDY0IiwiRmxvYXQzMkFycmF5IiwiaSIsImoiLCJpbmRleCIsImNhbGN1bGF0ZVByb2plY3Rpb25DZW50ZXIiLCJjb29yZGluYXRlT3JpZ2luIiwiY29vcmRpbmF0ZVpvb20iLCJ2aWV3UHJvamVjdGlvbk1hdHJpeCIsInBvc2l0aW9uUGl4ZWxzIiwicG93IiwiY2FsY3VsYXRlTWF0cml4QW5kT2Zmc2V0Iiwidmlld3BvcnQiLCJtb2RlbE1hdHJpeCIsImNvb3JkaW5hdGVTeXN0ZW0iLCJ2aWV3TWF0cml4VW5jZW50ZXJlZCIsInZpZXdNYXRyaXgiLCJwcm9qZWN0aW9uTWF0cml4IiwicHJvamVjdGlvbkNlbnRlciIsIklERU5USVRZIiwiTE5HTEFUIiwiTUVURVJfT0ZGU0VUUyIsIkVycm9yIiwiY2FtZXJhUG9zIiwiY2FtZXJhUG9zaXRpb24iLCJwcm9qZWN0aW9uTW9kZSIsInBvc2l0aW9uT3JpZ2luIiwidW5kZWZpbmVkIiwiZGVwcmVjYXRlZCIsInpvb20iLCJkaXN0YW5jZVNjYWxlcyIsImdldERpc3RhbmNlU2NhbGVzIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIndpbmRvdyIsInZpZXdwb3J0U2l6ZSIsIndpZHRoIiwiaGVpZ2h0IiwiZ2xNb2RlbE1hdHJpeCIsImdsVmlld1Byb2plY3Rpb25NYXRyaXgiLCJnbFZpZXdQcm9qZWN0aW9uTWF0cml4RlA2NCIsInNjYWxlRlA2NCIsInNjYWxlIiwicHJvamVjdF91Q29vcmRpbmF0ZVN5c3RlbSIsInByb2plY3RfdUNlbnRlciIsInByb2plY3RfdVZpZXdwb3J0U2l6ZSIsInByb2plY3RfdURldmljZVBpeGVsUmF0aW8iLCJwcm9qZWN0X3VGb2NhbERpc3RhbmNlIiwiZm9jYWxEaXN0YW5jZSIsInByb2plY3RfdVBpeGVsc1BlclVuaXQiLCJwaXhlbHNQZXJNZXRlciIsInByb2plY3RfdVNjYWxlIiwicHJvamVjdF91TW9kZWxNYXRyaXgiLCJwcm9qZWN0X3VWaWV3UHJvamVjdGlvbk1hdHJpeCIsInByb2plY3RfdVZpZXdQcm9qZWN0aW9uTWF0cml4RlA2NCIsInByb2plY3RfdUNhbWVyYVBvc2l0aW9uIiwicHJvamVjdDY0X3VWaWV3UHJvamVjdGlvbk1hdHJpeCIsInByb2plY3Q2NF91U2NhbGUiLCJwcm9qZWN0aW9uT3JpZ2luIiwicHJvamVjdGlvblBpeGVsc1BlclVuaXQiLCJwcm9qZWN0aW9uU2NhbGUiLCJwcm9qZWN0aW9uRlA2NCIsInByb2plY3Rpb25TY2FsZUZQNjQiXSwibWFwcGluZ3MiOiI7Ozs7Ozt5cEJBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztRQStHZ0JBLHVCLEdBQUFBLHVCOztBQTlHaEI7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFFQTs7OztBQUVBO0FBQ0EsSUFBTUMsY0FBYyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBcEI7QUFDQTtBQUNBLElBQU1DLHlCQUF5QixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCLEVBQStCLENBQS9CLEVBQWtDLENBQWxDLEVBQXFDLENBQXJDLEVBQXdDLENBQXhDLEVBQTJDLENBQTND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QXdCTGlCLHNCQUFrQmhCLFNBeEJiOztBQTBCTDtBQUNBO0FBQ0E7QUFDQWYsb0JBQWdCWCxnQkE3Qlg7QUE4QkxJLHNDQTlCSzs7QUFnQ0x1QyxzQkFBa0JuRCxnQkFoQ2I7QUFpQ0xPLGlCQUFhd0IsYUFqQ1I7QUFrQ0xyQixnQkFBWUosU0FBU0ksVUFsQ2hCO0FBbUNMQyxzQkFBa0JxQixzQkFuQ2I7QUFvQ0xvQiw2QkFBeUI1QixlQUFlbUIsY0FwQ25DO0FBcUNMVSxxQkFBaUIvQyxTQUFTNkIsS0FyQ3JCLEVBcUM0QjtBQUNqQ1AsOEJBdENLO0FBdUNMRixzQ0F2Q0s7QUF3Q0xULGVBQVcsSUFBSXRCLFlBQUosQ0FBaUJzQixTQUFqQixDQXhDTjs7QUEwQ0xxQyxvQkFBZ0JyQiwwQkExQ1g7QUEyQ0xzQix5QkFBcUJyQjtBQTNDaEIsR0FBUDtBQTZDRCIsImZpbGUiOiJ2aWV3cG9ydC11bmlmb3Jtcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgbWF0NF9tdWx0aXBseSBmcm9tICdnbC1tYXQ0L211bHRpcGx5JztcbmltcG9ydCB2ZWM0X3RyYW5zZm9ybU1hdDQgZnJvbSAnZ2wtdmVjNC90cmFuc2Zvcm1NYXQ0JztcblxuaW1wb3J0IGxvZyBmcm9tICcuLi8uLi91dGlscy9sb2cnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHtDT09SRElOQVRFX1NZU1RFTX0gZnJvbSAnLi4vLi4vbGliL2NvbnN0YW50cyc7XG5cbmltcG9ydCB7cHJvamVjdEZsYXR9IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuXG4vLyBUbyBxdWlja2x5IHNldCBhIHZlY3RvciB0byB6ZXJvXG5jb25zdCBaRVJPX1ZFQ1RPUiA9IFswLCAwLCAwLCAwXTtcbi8vIDR4NCBtYXRyaXggdGhhdCBkcm9wcyA0dGggY29tcG9uZW50IG9mIHZlY3RvclxuY29uc3QgVkVDVE9SX1RPX1BPSU5UX01BVFJJWCA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwXTtcbmNvbnN0IElERU5USVRZX01BVFJJWCA9IFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXTtcblxuLy8gVE9ETyAtIGltcG9ydCB0aGVzZSB1dGlscyBmcm9tIGZwNjQgcGFja2FnZVxuZnVuY3Rpb24gZnA2NGlmeShhKSB7XG4gIGNvbnN0IGhpUGFydCA9IE1hdGguZnJvdW5kKGEpO1xuICBjb25zdCBsb1BhcnQgPSBhIC0gaGlQYXJ0O1xuICByZXR1cm4gW2hpUGFydCwgbG9QYXJ0XTtcbn1cblxuLy8gY2FsY3VsYXRlIFdlYkdMIDY0IGJpdCBtYXRyaXggKHRyYW5zcG9zZWQgXCJGbG9hdDY0QXJyYXlcIilcbmZ1bmN0aW9uIGZwNjRpZnlNYXRyaXg0KG1hdHJpeCkge1xuICAvLyBUcmFuc3Bvc2UgdGhlIHByb2plY3Rpb24gbWF0cml4IHRvIGNvbHVtbiBtYWpvciBmb3IgR0xTTC5cbiAgY29uc3QgbWF0cml4RlA2NCA9IG5ldyBGbG9hdDMyQXJyYXkoMzIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgKytqKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGkgKiA0ICsgajtcbiAgICAgIFttYXRyaXhGUDY0W2luZGV4ICogMl0sIG1hdHJpeEZQNjRbaW5kZXggKiAyICsgMV1dID0gZnA2NGlmeShtYXRyaXhbaiAqIDQgKyBpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRyaXhGUDY0O1xufVxuXG4vLyBDYWxjdWxhdGUgdHJhbnNmb3JtZWQgcHJvamVjdGlvbkNlbnRlciAodXNpbmcgNjQgYml0IHByZWNpc2lvbiBKUylcbi8vIFRoaXMgaXMgdGhlIGtleSB0byBvZmZzZXQgbW9kZSBwcmVjaXNpb25cbi8vIChhdm9pZHMgZG9pbmcgdGhpcyBhZGRpdGlvbiBpbiAzMiBiaXQgcHJlY2lzaW9uIGluIEdMU0wpXG5mdW5jdGlvbiBjYWxjdWxhdGVQcm9qZWN0aW9uQ2VudGVyKHtjb29yZGluYXRlT3JpZ2luLCBjb29yZGluYXRlWm9vbSwgdmlld1Byb2plY3Rpb25NYXRyaXh9KSB7XG4gIGNvbnN0IHBvc2l0aW9uUGl4ZWxzID0gcHJvamVjdEZsYXQoY29vcmRpbmF0ZU9yaWdpbiwgTWF0aC5wb3coMiwgY29vcmRpbmF0ZVpvb20pKTtcbiAgLy8gcHJvamVjdGlvbkNlbnRlciA9IG5ldyBNYXRyaXg0KHZpZXdQcm9qZWN0aW9uTWF0cml4KVxuICAvLyAgIC50cmFuc2Zvcm1WZWN0b3IoW3Bvc2l0aW9uUGl4ZWxzWzBdLCBwb3NpdGlvblBpeGVsc1sxXSwgMC4wLCAxLjBdKTtcbiAgcmV0dXJuIHZlYzRfdHJhbnNmb3JtTWF0NChbXSxcbiAgICBbcG9zaXRpb25QaXhlbHNbMF0sIHBvc2l0aW9uUGl4ZWxzWzFdLCAwLjAsIDEuMF0sXG4gICAgdmlld1Byb2plY3Rpb25NYXRyaXgpO1xufVxuXG4vLyBUaGUgY29kZSB0aGF0IHV0aWxpemVzIE1hdHJpeDQgZG9lcyB0aGUgc2FtZSBjYWxjdWxhdGlvbiBhcyB0aGVpciBtYXQ0IGNvdW50ZXJwYXJ0cyxcbi8vIGhhcyBsb3dlciBwZXJmb3JtYW5jZSBidXQgcHJvdmlkZXMgZXJyb3IgY2hlY2tpbmcuXG4vLyBVbmNvbW1lbnQgd2hlbiBkZWJ1Z2dpbmdcbmZ1bmN0aW9uIGNhbGN1bGF0ZU1hdHJpeEFuZE9mZnNldCh7XG4gIC8vIFVOQ0hBTkdFRFxuICB2aWV3cG9ydCxcbiAgbW9kZWxNYXRyaXgsXG4gIC8vIE5FVyBQQVJBTVNcbiAgY29vcmRpbmF0ZVN5c3RlbSxcbiAgY29vcmRpbmF0ZU9yaWdpbixcbiAgY29vcmRpbmF0ZVpvb21cbn0pIHtcbiAgY29uc3Qge3ZpZXdNYXRyaXhVbmNlbnRlcmVkfSA9IHZpZXdwb3J0O1xuICBsZXQge3ZpZXdNYXRyaXh9ID0gdmlld3BvcnQ7XG4gIGNvbnN0IHtwcm9qZWN0aW9uTWF0cml4fSA9IHZpZXdwb3J0O1xuICBsZXQge3ZpZXdQcm9qZWN0aW9uTWF0cml4fSA9IHZpZXdwb3J0O1xuXG4gIGxldCBwcm9qZWN0aW9uQ2VudGVyO1xuXG4gIHN3aXRjaCAoY29vcmRpbmF0ZVN5c3RlbSkge1xuXG4gIGNhc2UgQ09PUkRJTkFURV9TWVNURU0uSURFTlRJVFk6XG4gIGNhc2UgQ09PUkRJTkFURV9TWVNURU0uTE5HTEFUOlxuICAgIHByb2plY3Rpb25DZW50ZXIgPSBaRVJPX1ZFQ1RPUjtcbiAgICBicmVhaztcblxuICAvLyBUT0RPOiBtYWtlIGxpZ2hpdG5nIHdvcmsgZm9yIG1ldGVyIG9mZnNldCBtb2RlXG4gIGNhc2UgQ09PUkRJTkFURV9TWVNURU0uTUVURVJfT0ZGU0VUUzpcbiAgICBwcm9qZWN0aW9uQ2VudGVyID0gY2FsY3VsYXRlUHJvamVjdGlvbkNlbnRlcih7XG4gICAgICBjb29yZGluYXRlT3JpZ2luLCBjb29yZGluYXRlWm9vbSwgdmlld1Byb2plY3Rpb25NYXRyaXhcbiAgICB9KTtcblxuICAgIC8vIEFsd2F5cyBhcHBseSB1bmNlbnRlcmVkIHByb2plY3Rpb24gbWF0cml4IGlmIGF2YWlsYWJsZSAoc2hhZGVyIGFkZHMgY2VudGVyKVxuICAgIHZpZXdNYXRyaXggPSB2aWV3TWF0cml4VW5jZW50ZXJlZCB8fCB2aWV3TWF0cml4O1xuXG4gICAgLy8gWmVybyBvdXQgNHRoIGNvb3JkaW5hdGUgKFwiYWZ0ZXJcIiBtb2RlbCBtYXRyaXgpIC0gYXZvaWRzIGZ1cnRoZXIgdHJhbnNsYXRpb25zXG4gICAgLy8gdmlld01hdHJpeCA9IG5ldyBNYXRyaXg0KHZpZXdNYXRyaXhVbmNlbnRlcmVkIHx8IHZpZXdNYXRyaXgpXG4gICAgLy8gICAubXVsdGlwbHlSaWdodChWRUNUT1JfVE9fUE9JTlRfTUFUUklYKTtcbiAgICB2aWV3UHJvamVjdGlvbk1hdHJpeCA9IG1hdDRfbXVsdGlwbHkoW10sIHByb2plY3Rpb25NYXRyaXgsIHZpZXdNYXRyaXgpO1xuICAgIHZpZXdQcm9qZWN0aW9uTWF0cml4ID0gbWF0NF9tdWx0aXBseShbXSwgdmlld1Byb2plY3Rpb25NYXRyaXgsIFZFQ1RPUl9UT19QT0lOVF9NQVRSSVgpO1xuICAgIGJyZWFrO1xuXG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb2plY3Rpb24gbW9kZScpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2aWV3TWF0cml4LFxuICAgIHZpZXdQcm9qZWN0aW9uTWF0cml4LFxuICAgIHByb2plY3Rpb25DZW50ZXIsXG4gICAgY2FtZXJhUG9zOiB2aWV3cG9ydC5jYW1lcmFQb3NpdGlvblxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdW5pZm9ybXMgZm9yIHNoYWRlcnMgYmFzZWQgb24gY3VycmVudCBwcm9qZWN0aW9uXG4gKiBpbmNsdWRlczogcHJvamVjdGlvbiBtYXRyaXggc3VpdGFibGUgZm9yIHNoYWRlcnNcbiAqXG4gKiBUT0RPIC0gRW5zdXJlIHRoaXMgd29ya3Mgd2l0aCBhbnkgdmlld3BvcnQsIG5vdCBqdXN0IFdlYk1lcmNhdG9yVmlld3BvcnRzXG4gKlxuICogQHBhcmFtIHtXZWJNZXJjYXRvclZpZXdwb3J0fSB2aWV3cG9ydCAtXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IC0gNHg0IHByb2plY3Rpb24gbWF0cml4IHRoYXQgY2FuIGJlIHVzZWQgaW4gc2hhZGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5pZm9ybXNGcm9tVmlld3BvcnQoe1xuICB2aWV3cG9ydCxcbiAgbW9kZWxNYXRyaXggPSBudWxsLFxuICBjb29yZGluYXRlU3lzdGVtID0gQ09PUkRJTkFURV9TWVNURU0uTE5HTEFULFxuICBjb29yZGluYXRlT3JpZ2luID0gWzAsIDBdLFxuICAvLyBEZXByZWNhdGVkXG4gIHByb2plY3Rpb25Nb2RlLFxuICBwb3NpdGlvbk9yaWdpblxufSA9IHt9KSB7XG4gIGFzc2VydCh2aWV3cG9ydCk7XG5cbiAgaWYgKHByb2plY3Rpb25Nb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb29yZGluYXRlU3lzdGVtID0gcHJvamVjdGlvbk1vZGU7XG4gICAgbG9nLmRlcHJlY2F0ZWQoJ3Byb2plY3Rpb25Nb2RlJywgJ2Nvb3JkaW5hdGVTeXN0ZW0nKTtcbiAgfVxuICBpZiAocG9zaXRpb25PcmlnaW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvb3JkaW5hdGVPcmlnaW4gPSBwb3NpdGlvbk9yaWdpbjtcbiAgICBsb2cuZGVwcmVjYXRlZCgncG9zaXRpb25PcmlnaW4nLCAnY29vcmRpbmF0ZU9yaWdpbicpO1xuICB9XG5cbiAgY29uc3QgY29vcmRpbmF0ZVpvb20gPSB2aWV3cG9ydC56b29tO1xuICBhc3NlcnQoY29vcmRpbmF0ZVpvb20gPj0gMCk7XG5cbiAgY29uc3Qge3Byb2plY3Rpb25DZW50ZXIsIHZpZXdQcm9qZWN0aW9uTWF0cml4LCBjYW1lcmFQb3N9ID1cbiAgICBjYWxjdWxhdGVNYXRyaXhBbmRPZmZzZXQoe1xuICAgICAgY29vcmRpbmF0ZVN5c3RlbSwgY29vcmRpbmF0ZU9yaWdpbiwgY29vcmRpbmF0ZVpvb20sIG1vZGVsTWF0cml4LCB2aWV3cG9ydFxuICAgIH0pO1xuXG4gIGFzc2VydCh2aWV3UHJvamVjdGlvbk1hdHJpeCwgJ1ZpZXdwb3J0IG1pc3NpbmcgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCcpO1xuXG4gIC8vIENhbGN1bGF0ZSBwcm9qZWN0aW9uIHBpeGVscyBwZXIgdW5pdFxuICBjb25zdCBkaXN0YW5jZVNjYWxlcyA9IHZpZXdwb3J0LmdldERpc3RhbmNlU2NhbGVzKCk7XG5cbiAgLy8gVE9ETyAtIGRvZXMgdGhpcyBkZXBlbmQgb24gdXNlRGV2aWNlUGl4ZWxSYXRpbz9cbiAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9ICh3aW5kb3cgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDE7XG4gIGNvbnN0IHZpZXdwb3J0U2l6ZSA9IFt2aWV3cG9ydC53aWR0aCAqIGRldmljZVBpeGVsUmF0aW8sIHZpZXdwb3J0LmhlaWdodCAqIGRldmljZVBpeGVsUmF0aW9dO1xuXG4gIGNvbnN0IGdsTW9kZWxNYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KG1vZGVsTWF0cml4IHx8IElERU5USVRZX01BVFJJWCk7XG4gIGNvbnN0IGdsVmlld1Byb2plY3Rpb25NYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHZpZXdQcm9qZWN0aW9uTWF0cml4KTtcblxuICBjb25zdCBnbFZpZXdQcm9qZWN0aW9uTWF0cml4RlA2NCA9IGZwNjRpZnlNYXRyaXg0KHZpZXdQcm9qZWN0aW9uTWF0cml4KTtcbiAgY29uc3Qgc2NhbGVGUDY0ID0gZnA2NGlmeSh2aWV3cG9ydC5zY2FsZSk7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBQcm9qZWN0aW9uIG1vZGUgdmFsdWVzXG4gICAgcHJvamVjdF91Q29vcmRpbmF0ZVN5c3RlbTogY29vcmRpbmF0ZVN5c3RlbSxcbiAgICBwcm9qZWN0X3VDZW50ZXI6IHByb2plY3Rpb25DZW50ZXIsXG5cbiAgICAvLyBTY3JlZW4gc2l6ZVxuICAgIHByb2plY3RfdVZpZXdwb3J0U2l6ZTogdmlld3BvcnRTaXplLFxuICAgIHByb2plY3RfdURldmljZVBpeGVsUmF0aW86IGRldmljZVBpeGVsUmF0aW8sXG5cbiAgICAvLyBEaXN0YW5jZSBhdCB3aGljaCBzY3JlZW4gcGl4ZWxzIGFyZSBwcm9qZWN0ZWRcbiAgICBwcm9qZWN0X3VGb2NhbERpc3RhbmNlOiB2aWV3cG9ydC5mb2NhbERpc3RhbmNlIHx8IDEsXG4gICAgcHJvamVjdF91UGl4ZWxzUGVyVW5pdDogZGlzdGFuY2VTY2FsZXMucGl4ZWxzUGVyTWV0ZXIsXG4gICAgcHJvamVjdF91U2NhbGU6IHZpZXdwb3J0LnNjYWxlLCAvLyBUaGlzIGlzIHRoZSBtZXJjYXRvciBzY2FsZSAoMiAqKiB6b29tKVxuXG4gICAgcHJvamVjdF91TW9kZWxNYXRyaXg6IGdsTW9kZWxNYXRyaXgsXG4gICAgcHJvamVjdF91Vmlld1Byb2plY3Rpb25NYXRyaXg6IGdsVmlld1Byb2plY3Rpb25NYXRyaXgsXG5cbiAgICAvLyA2NCBiaXQgc3VwcG9ydFxuICAgIHByb2plY3RfdVZpZXdQcm9qZWN0aW9uTWF0cml4RlA2NDogZnA2NGlmeU1hdHJpeDQodmlld1Byb2plY3Rpb25NYXRyaXgpLFxuXG4gICAgLy8gVGhpcyBpcyBmb3IgbGlnaHRpbmcgY2FsY3VsYXRpb25zXG4gICAgcHJvamVjdF91Q2FtZXJhUG9zaXRpb246IG5ldyBGbG9hdDMyQXJyYXkoY2FtZXJhUG9zKSxcblxuICAgIHByb2plY3Q2NF91Vmlld1Byb2plY3Rpb25NYXRyaXg6IGdsVmlld1Byb2plY3Rpb25NYXRyaXhGUDY0LFxuICAgIHByb2plY3Q2NF91U2NhbGU6IHNjYWxlRlA2NCxcblxuICAgIC8vXG4gICAgLy8gREVQUkVDQVRFRCBVTklGT1JNUyAtIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBjdXN0b20gbGF5ZXJzXG4gICAgLy9cbiAgICBwcm9qZWN0aW9uTW9kZTogY29vcmRpbmF0ZVN5c3RlbSxcbiAgICBwcm9qZWN0aW9uQ2VudGVyLFxuXG4gICAgcHJvamVjdGlvbk9yaWdpbjogY29vcmRpbmF0ZU9yaWdpbixcbiAgICBtb2RlbE1hdHJpeDogZ2xNb2RlbE1hdHJpeCxcbiAgICB2aWV3TWF0cml4OiB2aWV3cG9ydC52aWV3TWF0cml4LFxuICAgIHByb2plY3Rpb25NYXRyaXg6IGdsVmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgcHJvamVjdGlvblBpeGVsc1BlclVuaXQ6IGRpc3RhbmNlU2NhbGVzLnBpeGVsc1Blck1ldGVyLFxuICAgIHByb2plY3Rpb25TY2FsZTogdmlld3BvcnQuc2NhbGUsIC8vIFRoaXMgaXMgdGhlIG1lcmNhdG9yIHNjYWxlICgyICoqIHpvb20pXG4gICAgdmlld3BvcnRTaXplLFxuICAgIGRldmljZVBpeGVsUmF0aW8sXG4gICAgY2FtZXJhUG9zOiBuZXcgRmxvYXQzMkFycmF5KGNhbWVyYVBvcyksXG5cbiAgICBwcm9qZWN0aW9uRlA2NDogZ2xWaWV3UHJvamVjdGlvbk1hdHJpeEZQNjQsXG4gICAgcHJvamVjdGlvblNjYWxlRlA2NDogc2NhbGVGUDY0XG4gIH07XG59XG4iXX0=