'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MAPBOX_LIMITS = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _webMercatorViewport = require('../viewports/web-mercator-viewport');

var _webMercatorViewport2 = _interopRequireDefault(_webMercatorViewport);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// MAPBOX LIMITS
var MAPBOX_LIMITS = exports.MAPBOX_LIMITS = {
  minZoom: 0,
  maxZoom: 20,
  minPitch: 0,
  maxPitch: 60
};

var defaultState = {
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

/* Utils */
function mod(value, divisor) {
  var modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}

function ensureFinite(value, fallbackValue) {
  return Number.isFinite(value) ? value : fallbackValue;
}

var MapState = function () {
  function MapState() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        bearing = _ref.bearing,
        pitch = _ref.pitch,
        altitude = _ref.altitude,
        maxZoom = _ref.maxZoom,
        minZoom = _ref.minZoom,
        maxPitch = _ref.maxPitch,
        minPitch = _ref.minPitch,
        startPanLngLat = _ref.startPanLngLat,
        startZoomLngLat = _ref.startZoomLngLat,
        startBearing = _ref.startBearing,
        startPitch = _ref.startPitch,
        startZoom = _ref.startZoom;

    _classCallCheck(this, MapState);

    (0, _assert2.default)(Number.isFinite(width), '`width` must be supplied');
    (0, _assert2.default)(Number.isFinite(height), '`height` must be supplied');
    (0, _assert2.default)(Number.isFinite(longitude), '`longitude` must be supplied');
    (0, _assert2.default)(Number.isFinite(latitude), '`latitude` must be supplied');
    (0, _assert2.default)(Number.isFinite(zoom), '`zoom` must be supplied');

    this._viewportProps = this._applyConstraints({
      width: width,
      height: height,
      latitude: latitude,
      longitude: longitude,
      zoom: zoom,
      bearing: ensureFinite(bearing, defaultState.bearing),
      pitch: ensureFinite(pitch, defaultState.pitch),
      altitude: ensureFinite(altitude, defaultState.altitude),
      maxZoom: ensureFinite(maxZoom, MAPBOX_LIMITS.maxZoom),
      minZoom: ensureFinite(minZoom, MAPBOX_LIMITS.minZoom),
      maxPitch: ensureFinite(maxPitch, MAPBOX_LIMITS.maxPitch),
      minPitch: ensureFinite(minPitch, MAPBOX_LIMITS.minPitch)
    });

    this._interactiveState = {
      startPanLngLat: startPanLngLat,
      startZoomLngLat: startZoomLngLat,
      startBearing: startBearing,
      startPitch: startPitch,
      startZoom: startZoom
    };
  }

  /* Public API */

  _createClass(MapState, [{
    key: 'getViewportProps',
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: 'getInteractiveState',
    value: function getInteractiveState() {
      return this._interactiveState;
    }

    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'panStart',
    value: function panStart(_ref2) {
      var pos = _ref2.pos;

      return this._getUpdatedState({
        startPanLngLat: this._unproject(pos)
      });
    }

    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     * @param {[Number, Number], optional} startPos - where the pointer grabbed at
     *   the start of the operation. Must be supplied of `panStart()` was not called
     */

  }, {
    key: 'pan',
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;

      var startPanLngLat = this._interactiveState.startPanLngLat || this._unproject(startPos);

      // take the start lnglat and put it where the mouse is down.
      (0, _assert2.default)(startPanLngLat, '`startPanLngLat` prop is required ' + 'for mouse pan behavior to calculate where to position the map.');

      var _calculateNewLngLat2 = this._calculateNewLngLat({ startPanLngLat: startPanLngLat, pos: pos }),
          _calculateNewLngLat3 = _slicedToArray(_calculateNewLngLat2, 2),
          longitude = _calculateNewLngLat3[0],
          latitude = _calculateNewLngLat3[1];

      return this._getUpdatedState({
        longitude: longitude,
        latitude: latitude
      });
    }

    /**
     * End panning
     * Must call if `panStart()` was called
     */

  }, {
    key: 'panEnd',
    value: function panEnd() {
      return this._getUpdatedState({
        startPanLngLat: null
      });
    }

    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the center is
     */

  }, {
    key: 'rotateStart',
    value: function rotateStart(_ref4) {
      var pos = _ref4.pos;

      return this._getUpdatedState({
        startBearing: this._viewportProps.bearing,
        startPitch: this._viewportProps.pitch
      });
    }

    /**
     * Rotate
     * @param {Number} deltaScaleX - a number between [-1, 1] specifying the
     *   change to bearing.
     * @param {Number} deltaScaleY - a number between [-1, 1] specifying the
     *   change to pitch. -1 sets to minPitch and 1 sets to maxPitch.
     */

  }, {
    key: 'rotate',
    value: function rotate(_ref5) {
      var deltaScaleX = _ref5.deltaScaleX,
          deltaScaleY = _ref5.deltaScaleY;

      (0, _assert2.default)(deltaScaleX >= -1 && deltaScaleX <= 1, '`deltaScaleX` must be a number between [-1, 1]');
      (0, _assert2.default)(deltaScaleY >= -1 && deltaScaleY <= 1, '`deltaScaleY` must be a number between [-1, 1]');

      var _interactiveState = this._interactiveState,
          startBearing = _interactiveState.startBearing,
          startPitch = _interactiveState.startPitch;


      if (!Number.isFinite(startBearing)) {
        startBearing = this._viewportProps.bearing;
      }
      if (!Number.isFinite(startPitch)) {
        startPitch = this._viewportProps.pitch;
      }

      var _calculateNewPitchAnd = this._calculateNewPitchAndBearing({
        deltaScaleX: deltaScaleX,
        deltaScaleY: deltaScaleY,
        startBearing: startBearing,
        startPitch: startPitch
      }),
          pitch = _calculateNewPitchAnd.pitch,
          bearing = _calculateNewPitchAnd.bearing;

      return this._getUpdatedState({
        bearing: bearing,
        pitch: pitch
      });
    }

    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */

  }, {
    key: 'rotateEnd',
    value: function rotateEnd() {
      return this._getUpdatedState({
        startBearing: null,
        startPitch: null
      });
    }

    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the center is
     */

  }, {
    key: 'zoomStart',
    value: function zoomStart(_ref6) {
      var pos = _ref6.pos;

      return this._getUpdatedState({
        startZoomLngLat: this._unproject(pos),
        startZoom: this._viewportProps.zoom
      });
    }

    /**
     * Zoom
     * @param {[Number, Number]} pos - position on screen where the current center is
     * @param {[Number, Number]} startPos - the center position at
     *   the start of the operation. Must be supplied of `zoomStart()` was not called
     * @param {Number} scale - a number between [0, 1] specifying the accumulated
     *   relative scale.
     */

  }, {
    key: 'zoom',
    value: function zoom(_ref7) {
      var pos = _ref7.pos,
          startPos = _ref7.startPos,
          scale = _ref7.scale;

      (0, _assert2.default)(scale > 0, '`scale` must be a positive number');

      // Make sure we zoom around the current mouse position rather than map center
      var startZoomLngLat = this._interactiveState.startZoomLngLat || this._unproject(startPos) || this._unproject(pos);
      var startZoom = this._interactiveState.startZoom;


      if (!Number.isFinite(startZoom)) {
        startZoom = this._viewportProps.zoom;
      }

      // take the start lnglat and put it where the mouse is down.
      (0, _assert2.default)(startZoomLngLat, '`startZoomLngLat` prop is required ' + 'for zoom behavior to calculate where to position the map.');

      var zoom = this._calculateNewZoom({ scale: scale, startZoom: startZoom });

      var zoomedViewport = new _webMercatorViewport2.default(Object.assign({}, this._viewportProps, { zoom: zoom }));

      var _zoomedViewport$getLo = zoomedViewport.getLocationAtPoint({ lngLat: startZoomLngLat, pos: pos }),
          _zoomedViewport$getLo2 = _slicedToArray(_zoomedViewport$getLo, 2),
          longitude = _zoomedViewport$getLo2[0],
          latitude = _zoomedViewport$getLo2[1];

      return this._getUpdatedState({
        zoom: zoom,
        longitude: longitude,
        latitude: latitude
      });
    }

    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */

  }, {
    key: 'zoomEnd',
    value: function zoomEnd() {
      return this._getUpdatedState({
        startZoomLngLat: null,
        startZoom: null
      });
    }
  }, {
    key: 'moveLeft',
    value: function moveLeft() {
      return this._getUpdatedState({
        bearing: this._viewportProps.bearing - 3
      });
    }
  }, {
    key: 'moveRight',
    value: function moveRight() {
      return this._getUpdatedState({
        bearing: this._viewportProps.bearing + 3
      });
    }
  }, {
    key: 'moveForward',
    value: function moveForward() {
      return this._getUpdatedState({
        pitch: this._viewportProps.pitch + 3
      });
    }
  }, {
    key: 'moveBackward',
    value: function moveBackward() {
      return this._getUpdatedState({
        pitch: this._viewportProps.pitch - 3
      });
    }
  }, {
    key: 'zoomIn',
    value: function zoomIn() {
      return this._getUpdatedState({
        zoom: this._viewportProps.zoom + 0.2
      });
    }
  }, {
    key: 'zoomOut',
    value: function zoomOut() {
      return this._getUpdatedState({
        zoom: this._viewportProps.zoom - 0.2
      });
    }

    /* Private methods */

  }, {
    key: '_getUpdatedState',
    value: function _getUpdatedState(newProps) {
      // Update _viewportProps
      return new MapState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }

    // Apply any constraints (mathematical or defined by _viewportProps) to map state

  }, {
    key: '_applyConstraints',
    value: function _applyConstraints(props) {
      // Normalize degrees
      props.longitude = mod(props.longitude + 180, 360) - 180;
      props.bearing = mod(props.bearing + 180, 360) - 180;

      // Ensure zoom is within specified range
      var maxZoom = props.maxZoom,
          minZoom = props.minZoom,
          zoom = props.zoom;

      props.zoom = zoom > maxZoom ? maxZoom : zoom;
      props.zoom = zoom < minZoom ? minZoom : zoom;

      // Ensure pitch is within specified range
      var maxPitch = props.maxPitch,
          minPitch = props.minPitch,
          pitch = props.pitch;


      props.pitch = pitch > maxPitch ? maxPitch : pitch;
      props.pitch = pitch < minPitch ? minPitch : pitch;

      return props;
    }
  }, {
    key: '_unproject',
    value: function _unproject(pos) {
      var viewport = new _webMercatorViewport2.default(this._viewportProps);
      return pos && viewport.unproject(pos, { topLeft: false });
    }

    // Calculate a new lnglat based on pixel dragging position

  }, {
    key: '_calculateNewLngLat',
    value: function _calculateNewLngLat(_ref8) {
      var startPanLngLat = _ref8.startPanLngLat,
          pos = _ref8.pos;

      var viewport = new _webMercatorViewport2.default(this._viewportProps);
      return viewport.getLocationAtPoint({ lngLat: startPanLngLat, pos: pos });
    }

    // Calculates new zoom

  }, {
    key: '_calculateNewZoom',
    value: function _calculateNewZoom(_ref9) {
      var scale = _ref9.scale,
          startZoom = _ref9.startZoom;
      var _viewportProps = this._viewportProps,
          maxZoom = _viewportProps.maxZoom,
          minZoom = _viewportProps.minZoom;

      var zoom = startZoom + Math.log2(scale);
      zoom = zoom > maxZoom ? maxZoom : zoom;
      zoom = zoom < minZoom ? minZoom : zoom;
      return zoom;
    }

    // Calculates a new pitch and bearing from a position (coming from an event)

  }, {
    key: '_calculateNewPitchAndBearing',
    value: function _calculateNewPitchAndBearing(_ref10) {
      var deltaScaleX = _ref10.deltaScaleX,
          deltaScaleY = _ref10.deltaScaleY,
          startBearing = _ref10.startBearing,
          startPitch = _ref10.startPitch;
      var _viewportProps2 = this._viewportProps,
          minPitch = _viewportProps2.minPitch,
          maxPitch = _viewportProps2.maxPitch;


      var bearing = startBearing + 180 * deltaScaleX;
      var pitch = startPitch;
      if (deltaScaleY > 0) {
        // Gradually increase pitch
        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
      } else if (deltaScaleY < 0) {
        // Gradually decrease pitch
        pitch = startPitch - deltaScaleY * (minPitch - startPitch);
      }

      return {
        pitch: pitch,
        bearing: bearing
      };
    }
  }]);

  return MapState;
}();

exports.default = MapState;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2NvbnRyb2xsZXJzL21hcC1zdGF0ZS5qcyJdLCJuYW1lcyI6WyJNQVBCT1hfTElNSVRTIiwibWluWm9vbSIsIm1heFpvb20iLCJtaW5QaXRjaCIsIm1heFBpdGNoIiwiZGVmYXVsdFN0YXRlIiwicGl0Y2giLCJiZWFyaW5nIiwiYWx0aXR1ZGUiLCJtb2QiLCJ2YWx1ZSIsImRpdmlzb3IiLCJtb2R1bHVzIiwiZW5zdXJlRmluaXRlIiwiZmFsbGJhY2tWYWx1ZSIsIk51bWJlciIsImlzRmluaXRlIiwiTWFwU3RhdGUiLCJ3aWR0aCIsImhlaWdodCIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInN0YXJ0UGFuTG5nTGF0Iiwic3RhcnRab29tTG5nTGF0Iiwic3RhcnRCZWFyaW5nIiwic3RhcnRQaXRjaCIsInN0YXJ0Wm9vbSIsIl92aWV3cG9ydFByb3BzIiwiX2FwcGx5Q29uc3RyYWludHMiLCJfaW50ZXJhY3RpdmVTdGF0ZSIsInBvcyIsIl9nZXRVcGRhdGVkU3RhdGUiLCJfdW5wcm9qZWN0Iiwic3RhcnRQb3MiLCJfY2FsY3VsYXRlTmV3TG5nTGF0IiwiZGVsdGFTY2FsZVgiLCJkZWx0YVNjYWxlWSIsIl9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmciLCJzY2FsZSIsIl9jYWxjdWxhdGVOZXdab29tIiwiem9vbWVkVmlld3BvcnQiLCJPYmplY3QiLCJhc3NpZ24iLCJnZXRMb2NhdGlvbkF0UG9pbnQiLCJsbmdMYXQiLCJuZXdQcm9wcyIsInByb3BzIiwidmlld3BvcnQiLCJ1bnByb2plY3QiLCJ0b3BMZWZ0IiwiTWF0aCIsImxvZzIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7Ozs7Ozs7QUFFQTtBQUNPLElBQU1BLHdDQUFnQjtBQUMzQkMsV0FBUyxDQURrQjtBQUUzQkMsV0FBUyxFQUZrQjtBQUczQkMsWUFBVSxDQUhpQjtBQUkzQkMsWUFBVTtBQUppQixDQUF0Qjs7QUFPUCxJQUFN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OlsiaW1wb3J0IFBlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydCBmcm9tICcuLi92aWV3cG9ydHMvd2ViLW1lcmNhdG9yLXZpZXdwb3J0JztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuLy8gTUFQQk9YIExJTUlUU1xuZXhwb3J0IGNvbnN0IE1BUEJPWF9MSU1JVFMgPSB7XG4gIG1pblpvb206IDAsXG4gIG1heFpvb206IDIwLFxuICBtaW5QaXRjaDogMCxcbiAgbWF4UGl0Y2g6IDYwXG59O1xuXG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gIHBpdGNoOiAwLFxuICBiZWFyaW5nOiAwLFxuICBhbHRpdHVkZTogMS41XG59O1xuXG4vKiBVdGlscyAqL1xuZnVuY3Rpb24gbW9kKHZhbHVlLCBkaXZpc29yKSB7XG4gIGNvbnN0IG1vZHVsdXMgPSB2YWx1ZSAlIGRpdmlzb3I7XG4gIHJldHVybiBtb2R1bHVzIDwgMCA/IGRpdmlzb3IgKyBtb2R1bHVzIDogbW9kdWx1cztcbn1cblxuZnVuY3Rpb24gZW5zdXJlRmluaXRlKHZhbHVlLCBmYWxsYmFja1ZhbHVlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBmYWxsYmFja1ZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXBTdGF0ZSB7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIC8qKiBNYXBib3ggdmlld3BvcnQgcHJvcGVydGllcyAqL1xuICAgIC8qKiBUaGUgd2lkdGggb2YgdGhlIHZpZXdwb3J0ICovXG4gICAgd2lkdGgsXG4gICAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0ICovXG4gICAgaGVpZ2h0LFxuICAgIC8qKiBUaGUgbGF0aXR1ZGUgYXQgdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnQgKi9cbiAgICBsYXRpdHVkZSxcbiAgICAvKiogVGhlIGxvbmdpdHVkZSBhdCB0aGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydCAqL1xuICAgIGxvbmdpdHVkZSxcbiAgICAvKiogVGhlIHRpbGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLiAqL1xuICAgIHpvb20sXG4gICAgLyoqIFRoZSBiZWFyaW5nIG9mIHRoZSB2aWV3cG9ydCBpbiBkZWdyZWVzICovXG4gICAgYmVhcmluZyxcbiAgICAvKiogVGhlIHBpdGNoIG9mIHRoZSB2aWV3cG9ydCBpbiBkZWdyZWVzICovXG4gICAgcGl0Y2gsXG4gICAgLyoqXG4gICAgKiBTcGVjaWZ5IHRoZSBhbHRpdHVkZSBvZiB0aGUgdmlld3BvcnQgY2FtZXJhXG4gICAgKiBVbml0OiBtYXAgaGVpZ2h0cywgZGVmYXVsdCAxLjVcbiAgICAqIE5vbi1wdWJsaWMgQVBJLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvaXNzdWVzLzExMzdcbiAgICAqL1xuICAgIGFsdGl0dWRlLFxuXG4gICAgLyoqIFZpZXdwb3J0IGNvbnN0cmFpbnRzICovXG4gICAgbWF4Wm9vbSxcbiAgICBtaW5ab29tLFxuICAgIG1heFBpdGNoLFxuICAgIG1pblBpdGNoLFxuXG4gICAgLyoqIEludGVyYWN0aW9uIHN0YXRlcywgcmVxdWlyZWQgdG8gY2FsY3VsYXRlIGNoYW5nZSBkdXJpbmcgdHJhbnNmb3JtICovXG4gICAgLyogVGhlIHBvaW50IG9uIG1hcCBiZWluZyBncmFiYmVkIHdoZW4gdGhlIG9wZXJhdGlvbiBmaXJzdCBzdGFydGVkICovXG4gICAgc3RhcnRQYW5MbmdMYXQsXG4gICAgLyogQ2VudGVyIG9mIHRoZSB6b29tIHdoZW4gdGhlIG9wZXJhdGlvbiBmaXJzdCBzdGFydGVkICovXG4gICAgc3RhcnRab29tTG5nTGF0LFxuICAgIC8qKiBCZWFyaW5nIHdoZW4gY3VycmVudCBwZXJzcGVjdGl2ZSByb3RhdGUgb3BlcmF0aW9uIHN0YXJ0ZWQgKi9cbiAgICBzdGFydEJlYXJpbmcsXG4gICAgLyoqIFBpdGNoIHdoZW4gY3VycmVudCBwZXJzcGVjdGl2ZSByb3RhdGUgb3BlcmF0aW9uIHN0YXJ0ZWQgKi9cbiAgICBzdGFydFBpdGNoLFxuICAgIC8qKiBab29tIHdoZW4gY3VycmVudCB6b29tIG9wZXJhdGlvbiBzdGFydGVkICovXG4gICAgc3RhcnRab29tXG4gIH0gPSB7fSkge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUod2lkdGgpLCAnYHdpZHRoYCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShoZWlnaHQpLCAnYGhlaWdodGAgbXVzdCBiZSBzdXBwbGllZCcpO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUobG9uZ2l0dWRlKSwgJ2Bsb25naXR1ZGVgIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGxhdGl0dWRlKSwgJ2BsYXRpdHVkZWAgbXVzdCBiZSBzdXBwbGllZCcpO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoem9vbSksICdgem9vbWAgbXVzdCBiZSBzdXBwbGllZCcpO1xuXG4gICAgdGhpcy5fdmlld3BvcnRQcm9wcyA9IHRoaXMuX2FwcGx5Q29uc3RyYWludHMoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIHpvb20sXG4gICAgICBiZWFyaW5nOiBlbnN1cmVGaW5pdGUoYmVhcmluZywgZGVmYXVsdFN0YXRlLmJlYXJpbmcpLFxuICAgICAgcGl0Y2g6IGVuc3VyZUZpbml0ZShwaXRjaCwgZGVmYXVsdFN0YXRlLnBpdGNoKSxcbiAgICAgIGFsdGl0dWRlOiBlbnN1cmVGaW5pdGUoYWx0aXR1ZGUsIGRlZmF1bHRTdGF0ZS5hbHRpdHVkZSksXG4gICAgICBtYXhab29tOiBlbnN1cmVGaW5pdGUobWF4Wm9vbSwgTUFQQk9YX0xJTUlUUy5tYXhab29tKSxcbiAgICAgIG1pblpvb206IGVuc3VyZUZpbml0ZShtaW5ab29tLCBNQVBCT1hfTElNSVRTLm1pblpvb20pLFxuICAgICAgbWF4UGl0Y2g6IGVuc3VyZUZpbml0ZShtYXhQaXRjaCwgTUFQQk9YX0xJTUlUUy5tYXhQaXRjaCksXG4gICAgICBtaW5QaXRjaDogZW5zdXJlRmluaXRlKG1pblBpdGNoLCBNQVBCT1hfTElNSVRTLm1pblBpdGNoKVxuICAgIH0pO1xuXG4gICAgdGhpcy5faW50ZXJhY3RpdmVTdGF0ZSA9IHtcbiAgICAgIHN0YXJ0UGFuTG5nTGF0LFxuICAgICAgc3RhcnRab29tTG5nTGF0LFxuICAgICAgc3RhcnRCZWFyaW5nLFxuICAgICAgc3RhcnRQaXRjaCxcbiAgICAgIHN0YXJ0Wm9vbVxuICAgIH07XG4gIH1cblxuICAvKiBQdWJsaWMgQVBJICovXG5cbiAgZ2V0Vmlld3BvcnRQcm9wcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRQcm9wcztcbiAgfVxuXG4gIGdldEludGVyYWN0aXZlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVyYWN0aXZlU3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgcGFubmluZ1xuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgcG9pbnRlciBncmFic1xuICAgKi9cbiAgcGFuU3RhcnQoe3Bvc30pIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHN0YXJ0UGFuTG5nTGF0OiB0aGlzLl91bnByb2plY3QocG9zKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhblxuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgcG9pbnRlciBpc1xuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl0sIG9wdGlvbmFsfSBzdGFydFBvcyAtIHdoZXJlIHRoZSBwb2ludGVyIGdyYWJiZWQgYXRcbiAgICogICB0aGUgc3RhcnQgb2YgdGhlIG9wZXJhdGlvbi4gTXVzdCBiZSBzdXBwbGllZCBvZiBgcGFuU3RhcnQoKWAgd2FzIG5vdCBjYWxsZWRcbiAgICovXG4gIHBhbih7cG9zLCBzdGFydFBvc30pIHtcbiAgICBjb25zdCBzdGFydFBhbkxuZ0xhdCA9IHRoaXMuX2ludGVyYWN0aXZlU3RhdGUuc3RhcnRQYW5MbmdMYXQgfHwgdGhpcy5fdW5wcm9qZWN0KHN0YXJ0UG9zKTtcblxuICAgIC8vIHRha2UgdGhlIHN0YXJ0IGxuZ2xhdCBhbmQgcHV0IGl0IHdoZXJlIHRoZSBtb3VzZSBpcyBkb3duLlxuICAgIGFzc2VydChzdGFydFBhbkxuZ0xhdCwgJ2BzdGFydFBhbkxuZ0xhdGAgcHJvcCBpcyByZXF1aXJlZCAnICtcbiAgICAgICdmb3IgbW91c2UgcGFuIGJlaGF2aW9yIHRvIGNhbGN1bGF0ZSB3aGVyZSB0byBwb3NpdGlvbiB0aGUgbWFwLicpO1xuXG4gICAgY29uc3QgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdID0gdGhpcy5fY2FsY3VsYXRlTmV3TG5nTGF0KHtzdGFydFBhbkxuZ0xhdCwgcG9zfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRW5kIHBhbm5pbmdcbiAgICogTXVzdCBjYWxsIGlmIGBwYW5TdGFydCgpYCB3YXMgY2FsbGVkXG4gICAqL1xuICBwYW5FbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBzdGFydFBhbkxuZ0xhdDogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHJvdGF0aW5nXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBjZW50ZXIgaXNcbiAgICovXG4gIHJvdGF0ZVN0YXJ0KHtwb3N9KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBzdGFydEJlYXJpbmc6IHRoaXMuX3ZpZXdwb3J0UHJvcHMuYmVhcmluZyxcbiAgICAgIHN0YXJ0UGl0Y2g6IHRoaXMuX3ZpZXdwb3J0UHJvcHMucGl0Y2hcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb3RhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhU2NhbGVYIC0gYSBudW1iZXIgYmV0d2VlbiBbLTEsIDFdIHNwZWNpZnlpbmcgdGhlXG4gICAqICAgY2hhbmdlIHRvIGJlYXJpbmcuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVNjYWxlWSAtIGEgbnVtYmVyIGJldHdlZW4gWy0xLCAxXSBzcGVjaWZ5aW5nIHRoZVxuICAgKiAgIGNoYW5nZSB0byBwaXRjaC4gLTEgc2V0cyB0byBtaW5QaXRjaCBhbmQgMSBzZXRzIHRvIG1heFBpdGNoLlxuICAgKi9cbiAgcm90YXRlKHtkZWx0YVNjYWxlWCwgZGVsdGFTY2FsZVl9KSB7XG4gICAgYXNzZXJ0KGRlbHRhU2NhbGVYID49IC0xICYmIGRlbHRhU2NhbGVYIDw9IDEsXG4gICAgICAnYGRlbHRhU2NhbGVYYCBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gWy0xLCAxXScpO1xuICAgIGFzc2VydChkZWx0YVNjYWxlWSA+PSAtMSAmJiBkZWx0YVNjYWxlWSA8PSAxLFxuICAgICAgJ2BkZWx0YVNjYWxlWWAgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIFstMSwgMV0nKTtcblxuICAgIGxldCB7c3RhcnRCZWFyaW5nLCBzdGFydFBpdGNofSA9IHRoaXMuX2ludGVyYWN0aXZlU3RhdGU7XG5cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShzdGFydEJlYXJpbmcpKSB7XG4gICAgICBzdGFydEJlYXJpbmcgPSB0aGlzLl92aWV3cG9ydFByb3BzLmJlYXJpbmc7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHN0YXJ0UGl0Y2gpKSB7XG4gICAgICBzdGFydFBpdGNoID0gdGhpcy5fdmlld3BvcnRQcm9wcy5waXRjaDtcbiAgICB9XG5cbiAgICBjb25zdCB7cGl0Y2gsIGJlYXJpbmd9ID0gdGhpcy5fY2FsY3VsYXRlTmV3UGl0Y2hBbmRCZWFyaW5nKHtcbiAgICAgIGRlbHRhU2NhbGVYLFxuICAgICAgZGVsdGFTY2FsZVksXG4gICAgICBzdGFydEJlYXJpbmcsXG4gICAgICBzdGFydFBpdGNoXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIGJlYXJpbmcsXG4gICAgICBwaXRjaFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCByb3RhdGluZ1xuICAgKiBNdXN0IGNhbGwgaWYgYHJvdGF0ZVN0YXJ0KClgIHdhcyBjYWxsZWRcbiAgICovXG4gIHJvdGF0ZUVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHN0YXJ0QmVhcmluZzogbnVsbCxcbiAgICAgIHN0YXJ0UGl0Y2g6IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB6b29taW5nXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBjZW50ZXIgaXNcbiAgICovXG4gIHpvb21TdGFydCh7cG9zfSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgc3RhcnRab29tTG5nTGF0OiB0aGlzLl91bnByb2plY3QocG9zKSxcbiAgICAgIHN0YXJ0Wm9vbTogdGhpcy5fdmlld3BvcnRQcm9wcy56b29tXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogWm9vbVxuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgY3VycmVudCBjZW50ZXIgaXNcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBzdGFydFBvcyAtIHRoZSBjZW50ZXIgcG9zaXRpb24gYXRcbiAgICogICB0aGUgc3RhcnQgb2YgdGhlIG9wZXJhdGlvbi4gTXVzdCBiZSBzdXBwbGllZCBvZiBgem9vbVN0YXJ0KClgIHdhcyBub3QgY2FsbGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSAtIGEgbnVtYmVyIGJldHdlZW4gWzAsIDFdIHNwZWNpZnlpbmcgdGhlIGFjY3VtdWxhdGVkXG4gICAqICAgcmVsYXRpdmUgc2NhbGUuXG4gICAqL1xuICB6b29tKHtwb3MsIHN0YXJ0UG9zLCBzY2FsZX0pIHtcbiAgICBhc3NlcnQoc2NhbGUgPiAwLCAnYHNjYWxlYCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgd2Ugem9vbSBhcm91bmQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb24gcmF0aGVyIHRoYW4gbWFwIGNlbnRlclxuICAgIGNvbnN0IHN0YXJ0Wm9vbUxuZ0xhdCA9IHRoaXMuX2ludGVyYWN0aXZlU3RhdGUuc3RhcnRab29tTG5nTGF0IHx8XG4gICAgICB0aGlzLl91bnByb2plY3Qoc3RhcnRQb3MpIHx8IHRoaXMuX3VucHJvamVjdChwb3MpO1xuICAgIGxldCB7c3RhcnRab29tfSA9IHRoaXMuX2ludGVyYWN0aXZlU3RhdGU7XG5cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShzdGFydFpvb20pKSB7XG4gICAgICBzdGFydFpvb20gPSB0aGlzLl92aWV3cG9ydFByb3BzLnpvb207XG4gICAgfVxuXG4gICAgLy8gdGFrZSB0aGUgc3RhcnQgbG5nbGF0IGFuZCBwdXQgaXQgd2hlcmUgdGhlIG1vdXNlIGlzIGRvd24uXG4gICAgYXNzZXJ0KHN0YXJ0Wm9vbUxuZ0xhdCwgJ2BzdGFydFpvb21MbmdMYXRgIHByb3AgaXMgcmVxdWlyZWQgJyArXG4gICAgICAnZm9yIHpvb20gYmVoYXZpb3IgdG8gY2FsY3VsYXRlIHdoZXJlIHRvIHBvc2l0aW9uIHRoZSBtYXAuJyk7XG5cbiAgICBjb25zdCB6b29tID0gdGhpcy5fY2FsY3VsYXRlTmV3Wm9vbSh7c2NhbGUsIHN0YXJ0Wm9vbX0pO1xuXG4gICAgY29uc3Qgem9vbWVkVmlld3BvcnQgPSBuZXcgUGVyc3BlY3RpdmVNZXJjYXRvclZpZXdwb3J0KFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fdmlld3BvcnRQcm9wcywge3pvb219KVxuICAgICk7XG4gICAgY29uc3QgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdID0gem9vbWVkVmlld3BvcnQuZ2V0TG9jYXRpb25BdFBvaW50KHtsbmdMYXQ6IHN0YXJ0Wm9vbUxuZ0xhdCwgcG9zfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHpvb20sXG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCB6b29taW5nXG4gICAqIE11c3QgY2FsbCBpZiBgem9vbVN0YXJ0KClgIHdhcyBjYWxsZWRcbiAgICovXG4gIHpvb21FbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBzdGFydFpvb21MbmdMYXQ6IG51bGwsXG4gICAgICBzdGFydFpvb206IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIG1vdmVMZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgYmVhcmluZzogdGhpcy5fdmlld3BvcnRQcm9wcy5iZWFyaW5nIC0gM1xuICAgIH0pO1xuICB9XG5cbiAgbW92ZVJpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgYmVhcmluZzogdGhpcy5fdmlld3BvcnRQcm9wcy5iZWFyaW5nICsgM1xuICAgIH0pO1xuICB9XG5cbiAgbW92ZUZvcndhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBwaXRjaDogdGhpcy5fdmlld3BvcnRQcm9wcy5waXRjaCArIDNcbiAgICB9KTtcbiAgfVxuXG4gIG1vdmVCYWNrd2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHBpdGNoOiB0aGlzLl92aWV3cG9ydFByb3BzLnBpdGNoIC0gM1xuICAgIH0pO1xuICB9XG5cbiAgem9vbUluKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgem9vbTogdGhpcy5fdmlld3BvcnRQcm9wcy56b29tICsgMC4yXG4gICAgfSk7XG4gIH1cblxuICB6b29tT3V0KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgem9vbTogdGhpcy5fdmlld3BvcnRQcm9wcy56b29tIC0gMC4yXG4gICAgfSk7XG4gIH1cblxuICAvKiBQcml2YXRlIG1ldGhvZHMgKi9cblxuICBfZ2V0VXBkYXRlZFN0YXRlKG5ld1Byb3BzKSB7XG4gICAgLy8gVXBkYXRlIF92aWV3cG9ydFByb3BzXG4gICAgcmV0dXJuIG5ldyBNYXBTdGF0ZShPYmplY3QuYXNzaWduKHt9LCB0aGlzLl92aWV3cG9ydFByb3BzLCB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlLCBuZXdQcm9wcykpO1xuICB9XG5cbiAgLy8gQXBwbHkgYW55IGNvbnN0cmFpbnRzIChtYXRoZW1hdGljYWwgb3IgZGVmaW5lZCBieSBfdmlld3BvcnRQcm9wcykgdG8gbWFwIHN0YXRlXG4gIF9hcHBseUNvbnN0cmFpbnRzKHByb3BzKSB7XG4gICAgLy8gTm9ybWFsaXplIGRlZ3JlZXNcbiAgICBwcm9wcy5sb25naXR1ZGUgPSBtb2QocHJvcHMubG9uZ2l0dWRlICsgMTgwLCAzNjApIC0gMTgwO1xuICAgIHByb3BzLmJlYXJpbmcgPSBtb2QocHJvcHMuYmVhcmluZyArIDE4MCwgMzYwKSAtIDE4MDtcblxuICAgIC8vIEVuc3VyZSB6b29tIGlzIHdpdGhpbiBzcGVjaWZpZWQgcmFuZ2VcbiAgICBjb25zdCB7bWF4Wm9vbSwgbWluWm9vbSwgem9vbX0gPSBwcm9wcztcbiAgICBwcm9wcy56b29tID0gem9vbSA+IG1heFpvb20gPyBtYXhab29tIDogem9vbTtcbiAgICBwcm9wcy56b29tID0gem9vbSA8IG1pblpvb20gPyBtaW5ab29tIDogem9vbTtcblxuICAgIC8vIEVuc3VyZSBwaXRjaCBpcyB3aXRoaW4gc3BlY2lmaWVkIHJhbmdlXG4gICAgY29uc3Qge21heFBpdGNoLCBtaW5QaXRjaCwgcGl0Y2h9ID0gcHJvcHM7XG5cbiAgICBwcm9wcy5waXRjaCA9IHBpdGNoID4gbWF4UGl0Y2ggPyBtYXhQaXRjaCA6IHBpdGNoO1xuICAgIHByb3BzLnBpdGNoID0gcGl0Y2ggPCBtaW5QaXRjaCA/IG1pblBpdGNoIDogcGl0Y2g7XG5cbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cblxuICBfdW5wcm9qZWN0KHBvcykge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gbmV3IFBlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydCh0aGlzLl92aWV3cG9ydFByb3BzKTtcbiAgICByZXR1cm4gcG9zICYmIHZpZXdwb3J0LnVucHJvamVjdChwb3MsIHt0b3BMZWZ0OiBmYWxzZX0pO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGEgbmV3IGxuZ2xhdCBiYXNlZCBvbiBwaXhlbCBkcmFnZ2luZyBwb3NpdGlvblxuICBfY2FsY3VsYXRlTmV3TG5nTGF0KHtzdGFydFBhbkxuZ0xhdCwgcG9zfSkge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gbmV3IFBlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydCh0aGlzLl92aWV3cG9ydFByb3BzKTtcbiAgICByZXR1cm4gdmlld3BvcnQuZ2V0TG9jYXRpb25BdFBvaW50KHtsbmdMYXQ6IHN0YXJ0UGFuTG5nTGF0LCBwb3N9KTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZXMgbmV3IHpvb21cbiAgX2NhbGN1bGF0ZU5ld1pvb20oe3NjYWxlLCBzdGFydFpvb219KSB7XG4gICAgY29uc3Qge21heFpvb20sIG1pblpvb219ID0gdGhpcy5fdmlld3BvcnRQcm9wcztcbiAgICBsZXQgem9vbSA9IHN0YXJ0Wm9vbSArIE1hdGgubG9nMihzY2FsZSk7XG4gICAgem9vbSA9IHpvb20gPiBtYXhab29tID8gbWF4Wm9vbSA6IHpvb207XG4gICAgem9vbSA9IHpvb20gPCBtaW5ab29tID8gbWluWm9vbSA6IHpvb207XG4gICAgcmV0dXJuIHpvb207XG4gIH1cblxuICAvLyBDYWxjdWxhdGVzIGEgbmV3IHBpdGNoIGFuZCBiZWFyaW5nIGZyb20gYSBwb3NpdGlvbiAoY29taW5nIGZyb20gYW4gZXZlbnQpXG4gIF9jYWxjdWxhdGVOZXdQaXRjaEFuZEJlYXJpbmcoe2RlbHRhU2NhbGVYLCBkZWx0YVNjYWxlWSwgc3RhcnRCZWFyaW5nLCBzdGFydFBpdGNofSkge1xuICAgIGNvbnN0IHttaW5QaXRjaCwgbWF4UGl0Y2h9ID0gdGhpcy5fdmlld3BvcnRQcm9wcztcblxuICAgIGNvbnN0IGJlYXJpbmcgPSBzdGFydEJlYXJpbmcgKyAxODAgKiBkZWx0YVNjYWxlWDtcbiAgICBsZXQgcGl0Y2ggPSBzdGFydFBpdGNoO1xuICAgIGlmIChkZWx0YVNjYWxlWSA+IDApIHtcbiAgICAgIC8vIEdyYWR1YWxseSBpbmNyZWFzZSBwaXRjaFxuICAgICAgcGl0Y2ggPSBzdGFydFBpdGNoICsgZGVsdGFTY2FsZVkgKiAobWF4UGl0Y2ggLSBzdGFydFBpdGNoKTtcbiAgICB9IGVsc2UgaWYgKGRlbHRhU2NhbGVZIDwgMCkge1xuICAgICAgLy8gR3JhZHVhbGx5IGRlY3JlYXNlIHBpdGNoXG4gICAgICBwaXRjaCA9IHN0YXJ0UGl0Y2ggLSBkZWx0YVNjYWxlWSAqIChtaW5QaXRjaCAtIHN0YXJ0UGl0Y2gpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmdcbiAgICB9O1xuICB9XG59XG4iXX0=