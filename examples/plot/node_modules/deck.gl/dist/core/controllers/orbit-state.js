'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _orbitViewport = require('../viewports/orbit-viewport');

var _orbitViewport2 = _interopRequireDefault(_orbitViewport);

var _add = require('gl-vec3/add');

var _add2 = _interopRequireDefault(_add);

var _scale = require('gl-vec3/scale');

var _scale2 = _interopRequireDefault(_scale);

var _lerp = require('gl-vec3/lerp');

var _lerp2 = _interopRequireDefault(_lerp);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultState = {
  lookAt: [0, 0, 0],
  rotationX: 0,
  rotationY: 0,
  fov: 50,
  near: 1,
  far: 100,
  translationX: 0,
  translationY: 0,
  zoom: 1
};

var defaultConstraints = {
  minZoom: 0,
  maxZoom: Infinity
};

/* Helpers */

// Whether number is between bounds
function inRange(x, min, max) {
  return x >= min && x <= max;
}
// Constrain number between bounds
function clamp(x, min, max) {
  return x < min ? min : x > max ? max : x;
}
// Get ratio of x on domain
function interpolate(x, domain0, domain1) {
  if (domain0 === domain1) {
    return x === domain0 ? 0 : Infinity;
  }
  return (x - domain0) / (domain1 - domain0);
}

function ensureFinite(value, fallbackValue) {
  return Number.isFinite(value) ? value : fallbackValue;
}

var OrbitState = function () {
  function OrbitState(_ref) {
    var width = _ref.width,
        height = _ref.height,
        distance = _ref.distance,
        rotationX = _ref.rotationX,
        rotationY = _ref.rotationY,
        bounds = _ref.bounds,
        lookAt = _ref.lookAt,
        fov = _ref.fov,
        near = _ref.near,
        far = _ref.far,
        translationX = _ref.translationX,
        translationY = _ref.translationY,
        zoom = _ref.zoom,
        minZoom = _ref.minZoom,
        maxZoom = _ref.maxZoom,
        startPanPos = _ref.startPanPos,
        startPanTranslation = _ref.startPanTranslation,
        startRotateCenter = _ref.startRotateCenter,
        startRotateViewport = _ref.startRotateViewport,
        startZoomPos = _ref.startZoomPos,
        startZoom = _ref.startZoom;

    _classCallCheck(this, OrbitState);

    (0, _assert2.default)(Number.isFinite(width), '`width` must be supplied');
    (0, _assert2.default)(Number.isFinite(height), '`height` must be supplied');
    (0, _assert2.default)(Number.isFinite(distance), '`distance` must be supplied');

    this._viewportProps = this._applyConstraints({
      width: width,
      height: height,
      distance: distance,
      rotationX: ensureFinite(rotationX, defaultState.rotationX),
      rotationY: ensureFinite(rotationY, defaultState.rotationY),

      bounds: bounds,
      lookAt: lookAt || defaultState.lookAt,

      fov: ensureFinite(fov, defaultState.fov),
      near: ensureFinite(near, defaultState.near),
      far: ensureFinite(far, defaultState.far),
      translationX: ensureFinite(translationX, defaultState.translationX),
      translationY: ensureFinite(translationY, defaultState.translationY),
      zoom: ensureFinite(zoom, defaultState.zoom),

      minZoom: ensureFinite(minZoom, defaultConstraints.minZoom),
      maxZoom: ensureFinite(maxZoom, defaultConstraints.maxZoom)
    });

    this._interactiveState = {
      startPanPos: startPanPos,
      startPanTranslation: startPanTranslation,
      startRotateCenter: startRotateCenter,
      startRotateViewport: startRotateViewport,
      startZoomPos: startZoomPos,
      startZoom: startZoom
    };
  }

  /* Public API */

  _createClass(OrbitState, [{
    key: 'getViewportProps',
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: 'getInteractiveState',
    value: function getInteractiveState() {
      return this._interactiveState;
    }

    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'panStart',
    value: function panStart(_ref2) {
      var pos = _ref2.pos;
      var _viewportProps = this._viewportProps,
          translationX = _viewportProps.translationX,
          translationY = _viewportProps.translationY;


      return this._getUpdatedOrbitState({
        startPanTranslation: [translationX, translationY],
        startPanPos: pos
      });
    }

    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */

  }, {
    key: 'pan',
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;

      var startPanPos = this._interactiveState.startPanPos || startPos;
      (0, _assert2.default)(startPanPos, '`startPanPos` props is required');

      var _ref4 = this._interactiveState.startPanTranslation || [],
          _ref5 = _slicedToArray(_ref4, 2),
          translationX = _ref5[0],
          translationY = _ref5[1];

      translationX = ensureFinite(translationX, this._viewportProps.translationX);
      translationY = ensureFinite(translationY, this._viewportProps.translationY);

      var deltaX = pos[0] - startPanPos[0];
      var deltaY = pos[1] - startPanPos[1];

      return this._getUpdatedOrbitState({
        translationX: translationX + deltaX,
        translationY: translationY - deltaY
      });
    }

    /**
     * End panning
     * Must call if `panStart()` was called
     */

  }, {
    key: 'panEnd',
    value: function panEnd() {
      return this._getUpdatedOrbitState({
        startPanTranslation: null,
        startPanPos: null
      });
    }

    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'rotateStart',
    value: function rotateStart(_ref6) {
      var pos = _ref6.pos;

      // Rotation center should be the worldspace position at the center of the
      // the screen. If not found, use the last one.
      var startRotateCenter = this._getLocationAtCenter() || this._interactiveState.startRotateCenter;

      return this._getUpdatedOrbitState({
        startRotateCenter: startRotateCenter,
        startRotateViewport: this._viewportProps
      });
    }

    /**
     * Rotate
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */

  }, {
    key: 'rotate',
    value: function rotate(_ref7) {
      var deltaScaleX = _ref7.deltaScaleX,
          deltaScaleY = _ref7.deltaScaleY;
      var _interactiveState = this._interactiveState,
          startRotateCenter = _interactiveState.startRotateCenter,
          startRotateViewport = _interactiveState.startRotateViewport;

      var _ref8 = startRotateViewport || {},
          rotationX = _ref8.rotationX,
          rotationY = _ref8.rotationY,
          translationX = _ref8.translationX,
          translationY = _ref8.translationY;

      rotationX = ensureFinite(rotationX, this._viewportProps.rotationX);
      rotationY = ensureFinite(rotationY, this._viewportProps.rotationY);
      translationX = ensureFinite(translationX, this._viewportProps.translationX);
      translationY = ensureFinite(translationY, this._viewportProps.translationY);

      var newRotationX = clamp(rotationX - deltaScaleY * 180, -89.999, 89.999);
      var newRotationY = (rotationY - deltaScaleX * 180) % 360;

      var newTranslationX = translationX;
      var newTranslationY = translationY;

      if (startRotateCenter) {
        // Keep rotation center at the center of the screen
        var oldViewport = new _orbitViewport2.default(startRotateViewport);
        var oldCenterPos = oldViewport.project(startRotateCenter);

        var newViewport = new _orbitViewport2.default(Object.assign({}, startRotateViewport, {
          rotationX: newRotationX,
          rotationY: newRotationY
        }));
        var newCenterPos = newViewport.project(startRotateCenter);

        newTranslationX += oldCenterPos[0] - newCenterPos[0];
        newTranslationY -= oldCenterPos[1] - newCenterPos[1];
      }

      return this._getUpdatedOrbitState({
        rotationX: newRotationX,
        rotationY: newRotationY,
        translationX: newTranslationX,
        translationY: newTranslationY
      });
    }

    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */

  }, {
    key: 'rotateEnd',
    value: function rotateEnd() {
      return this._getUpdatedOrbitState({
        startRotateCenter: null,
        startRotateViewport: null
      });
    }

    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'zoomStart',
    value: function zoomStart(_ref9) {
      var pos = _ref9.pos;

      return this._getUpdatedOrbitState({
        startZoomPos: pos,
        startZoom: this._viewportProps.zoom
      });
    }

    /**
     * Zoom
     * @param {[Number, Number]} pos - position on screen where the current center is
     * @param {[Number, Number]} startPos - the center position at
     *   the start of the operation. Must be supplied of `zoomStart()` was not called
     * @param {Number} scale - a number between [0, 1] specifying the accumulated
     *   relative scale.
     */

  }, {
    key: 'zoom',
    value: function zoom(_ref10) {
      var pos = _ref10.pos,
          startPos = _ref10.startPos,
          scale = _ref10.scale;
      var _viewportProps2 = this._viewportProps,
          zoom = _viewportProps2.zoom,
          minZoom = _viewportProps2.minZoom,
          maxZoom = _viewportProps2.maxZoom,
          width = _viewportProps2.width,
          height = _viewportProps2.height,
          translationX = _viewportProps2.translationX,
          translationY = _viewportProps2.translationY;


      var startZoomPos = this._interactiveState.startZoomPos || startPos || pos;

      var newZoom = clamp(zoom * scale, minZoom, maxZoom);
      var deltaX = pos[0] - startZoomPos[0];
      var deltaY = pos[1] - startZoomPos[1];

      // Zoom around the center position
      var cx = startZoomPos[0] - width / 2;
      var cy = height / 2 - startZoomPos[1];
      var newTranslationX = cx - (cx - translationX) * newZoom / zoom + deltaX;
      var newTranslationY = cy - (cy - translationY) * newZoom / zoom - deltaY;

      return this._getUpdatedOrbitState({
        zoom: newZoom,
        translationX: newTranslationX,
        translationY: newTranslationY
      });
    }

    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */

  }, {
    key: 'zoomEnd',
    value: function zoomEnd() {
      return this._getUpdatedOrbitState({
        startZoomPos: null,
        startZoom: null
      });
    }

    /* Private methods */

  }, {
    key: '_getUpdatedOrbitState',
    value: function _getUpdatedOrbitState(newProps) {
      // Update _viewportProps
      return new OrbitState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }

    // Apply any constraints (mathematical or defined by _viewportProps) to map state

  }, {
    key: '_applyConstraints',
    value: function _applyConstraints(props) {
      // Ensure zoom is within specified range
      var maxZoom = props.maxZoom,
          minZoom = props.minZoom,
          zoom = props.zoom;

      props.zoom = zoom > maxZoom ? maxZoom : zoom;
      props.zoom = zoom < minZoom ? minZoom : zoom;

      return props;
    }

    /* Cast a ray into the screen center and take the average of all
     * intersections with the bounding box:
     *
     *                         (x=w/2)
     *                          .
     *                          .
     *   (bounding box)         .
     *           _-------------_.
     *          | "-_           :-_
     *         |     "-_        .  "-_
     *        |         "-------+-----:
     *       |.........|........C....|............. (y=h/2)
     *      |         |         .   |
     *     |         |          .  |
     *    |         |           . |
     *   |         |            .|
     *  |         |             |                      Y
     *   "-_     |             |.             Z       |
     *      "-_ |             | .              "-_   |
     *         "-------------"                    "-|_____ X
     */

  }, {
    key: '_getLocationAtCenter',
    value: function _getLocationAtCenter() {
      var _viewportProps3 = this._viewportProps,
          width = _viewportProps3.width,
          height = _viewportProps3.height,
          bounds = _viewportProps3.bounds;


      if (!bounds) {
        return null;
      }

      var viewport = new _orbitViewport2.default(this._viewportProps);

      var C0 = viewport.unproject([width / 2, height / 2, 0]);
      var C1 = viewport.unproject([width / 2, height / 2, 1]);
      var sum = [0, 0, 0];
      var count = 0;

      [
      // depth at intersection with X = minX
      interpolate(bounds.minX, C0[0], C1[0]),
      // depth at intersection with X = maxX
      interpolate(bounds.maxX, C0[0], C1[0]),
      // depth at intersection with Y = minY
      interpolate(bounds.minY, C0[1], C1[1]),
      // depth at intersection with Y = maxY
      interpolate(bounds.maxY, C0[1], C1[1]),
      // depth at intersection with Z = minZ
      interpolate(bounds.minZ, C0[2], C1[2]),
      // depth at intersection with Z = maxZ
      interpolate(bounds.maxZ, C0[2], C1[2])].forEach(function (d) {
        // worldspace position of the intersection
        var C = (0, _lerp2.default)([], C0, C1, d);
        // check if position is on the bounding box
        if (inRange(C[0], bounds.minX, bounds.maxX) && inRange(C[1], bounds.minY, bounds.maxY) && inRange(C[2], bounds.minZ, bounds.maxZ)) {
          count++;
          (0, _add2.default)(sum, sum, C);
        }
      });

      return count > 0 ? (0, _scale2.default)([], sum, 1 / count) : null;
    }
  }]);

  return OrbitState;
}();

exports.default = OrbitState;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2NvbnRyb2xsZXJzL29yYml0LXN0YXRlLmpzIl0sIm5hbWVzIjpbImRlZmF1bHRTdGF0ZSIsImxvb2tBdCIsInJvdGF0aW9uWCIsInJvdGF0aW9uWSIsImZvdiIsIm5lYXIiLCJmYXIiLCJ0cmFuc2xhdGlvblgiLCJ0cmFuc2xhdGlvblkiLCJ6b29tIiwiZGVmYXVsdENvbnN0cmFpbnRzIiwibWluWm9vbSIsIm1heFpvb20iLCJJbmZpbml0eSIsImluUmFuZ2UiLCJ4IiwibWluIiwibWF4IiwiY2xhbXAiLCJpbnRlcnBvbGF0ZSIsImRvbWFpbjAiLCJkb21haW4xIiwiZW5zdXJlRmluaXRlIiwidmFsdWUiLCJmYWxsYmFja1ZhbHVlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJPcmJpdFN0YXRlIiwid2lkdGgiLCJoZWlnaHQiLCJkaXN0YW5jZSIsImJvdW5kcyIsInN0YXJ0UGFuUG9zIiwic3RhcnRQYW5UcmFuc2xhdGlvbiIsInN0YXJ0Um90YXRlQ2VudGVyIiwic3RhcnRSb3RhdGVWaWV3cG9ydCIsInN0YXJ0Wm9vbVBvcyIsInN0YXJ0Wm9vbSIsIl92aWV3cG9ydFByb3BzIiwiX2FwcGx5Q29uc3RyYWludHMiLCJfaW50ZXJhY3RpdmVTdGF0ZSIsInBvcyIsIl9nZXRVcGRhdGVkT3JiaXRTdGF0ZSIsInN0YXJ0UG9zIiwiZGVsdGFYIiwiZGVsdGFZIiwiX2dldExvY2F0aW9uQXRDZW50ZXIiLCJkZWx0YVNjYWxlWCIsImRlbHRhU2NhbGVZIiwibmV3Um90YXRpb25YIiwibmV3Um90YXRpb25ZIiwibmV3VHJhbnNsYXRpb25YIiwibmV3VHJhbnNsYXRpb25ZIiwib2xkVmlld3BvcnQiLCJvbGRDZW50ZXJQb3MiLCJwcm9qZWN0IiwibmV3Vmlld3BvcnQiLCJPYmplY3QiLCJhc3NpZ24iLCJuZXdDZW50ZXJQb3MiLCJzY2FsZSIsIm5ld1pvb20iLCJjeCIsImN5IiwibmV3UHJvcHMiLCJwcm9wcyIsInZpZXdwb3J0IiwiQzAiLCJ1bnByb2plY3QiLCJDMSIsInN1bSIsImNvdW50IiwibWluWCIsIm1heFgiLCJtaW5ZIiwibWF4WSIsIm1pbloiLCJtYXhaIiwiZm9yRWFjaCIsIkMiLCJkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7QUFFQSxJQUFNQSxlQUFlO0FBQ25CQyxVQUFRLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBRFc7QUFFbkJDLGFBQVcsQ0FGUTtBQUduQkMsYUFBVyxDQUhRO0FBSW5CQyxPQUFLLEVBSmM7QUFLbkJDLFFBQU0sQ0FMYTtBQU1uQkMsT0FBSyxHQU5jO0FBT25CQyxnQkFBYyxDQVBLO0FBUW5CQyxnQkFBYyxDQVJLO0FBU25CQyxRQUFNO0FBVGEsQ0FBckI7O0FBWUEsSUFBTUMscUJBQXFCO0FBQ3pCQyxXQUFTLENBRGdCO0FBRXpCQyxXQUFTQztBQUZnQixDQUEzQjs7QUFLQTs7QUFFQTtBQUNBLFNBQVNDLE9BQVQsQ0FBaUJDLENBQWpCLEVBQW9CQyxHQUFwQixFQUF5QkMsR0FBekIsRUFBOEI7QUFDNUIsU0FBT0YsS0FBS0MsR0FBTCxJQUFZRCxLQUFLRSxHQUF4QjtBQUNEO0FBQ0Q7QUFDQSxTQUFTQyxLQUFULENBQWVILENBQWYsRUFBa0JDLEdBQWxCLEVBQXVCQyxHQUF2QixFQUE0QjtBQUMxQixTQUFPRixJQUFJQyxHQUFKLEdBQVVBLEdBQVYsR0FBaUJELElBQUlFLEdBQUosR0FBVUEsR0FBVixHQUFnQkYsQ0FBeEM7QUFDRDtBQUNEO0FBQ0EsU0FBU0ksV0FBVCxDQUFxQkosQ0FBckIsRUFBd0JLLE9BQXhCLEVBQWlDQyxPQUFqQyxFQUEwQztBQUN4QyxNQUFJRCxZQUFZQyxPQUFoQixFQUF5QjtBQUN2QixXQUFPTixNQUFNSyxPQUFOLEdBQWdCLENBQWhCLEdBQW9CUCxRQUEzQjtBQUNEO0FBQ0QsU0FBTyxDQUFDRSxJQUFJSyxPQUFMLEtBQWlCQyxVQUFVRCxPQUEzQixDQUFQO0FBQ0Q7O0FB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QyxJQUFsQyxDQURBLElBRUE3RCxRQUFRaUUsRUFBRSxDQUFGLENBQVIsRUFBY2hELE9BQU82QyxJQUFyQixFQUEyQjdDLE9BQU84QyxJQUFsQyxDQUZKLEVBRTZDO0FBQzNDTjtBQUNBLDZCQUFTRCxHQUFULEVBQWNBLEdBQWQsRUFBbUJTLENBQW5CO0FBQ0Q7QUFDRixPQXZCRDs7QUF5QkEsYUFBT1IsUUFBUSxDQUFSLEdBQVkscUJBQVcsRUFBWCxFQUFlRCxHQUFmLEVBQW9CLElBQUlDLEtBQXhCLENBQVosR0FBNkMsSUFBcEQ7QUFDRDs7Ozs7O2tCQTFVa0I1QyxVIiwiZmlsZSI6Im9yYml0LXN0YXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE9yYml0Vmlld3BvcnQgZnJvbSAnLi4vdmlld3BvcnRzL29yYml0LXZpZXdwb3J0JztcbmltcG9ydCB2ZWMzX2FkZCBmcm9tICdnbC12ZWMzL2FkZCc7XG5pbXBvcnQgdmVjM19zY2FsZSBmcm9tICdnbC12ZWMzL3NjYWxlJztcbmltcG9ydCB2ZWMzX2xlcnAgZnJvbSAnZ2wtdmVjMy9sZXJwJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgZGVmYXVsdFN0YXRlID0ge1xuICBsb29rQXQ6IFswLCAwLCAwXSxcbiAgcm90YXRpb25YOiAwLFxuICByb3RhdGlvblk6IDAsXG4gIGZvdjogNTAsXG4gIG5lYXI6IDEsXG4gIGZhcjogMTAwLFxuICB0cmFuc2xhdGlvblg6IDAsXG4gIHRyYW5zbGF0aW9uWTogMCxcbiAgem9vbTogMVxufTtcblxuY29uc3QgZGVmYXVsdENvbnN0cmFpbnRzID0ge1xuICBtaW5ab29tOiAwLFxuICBtYXhab29tOiBJbmZpbml0eVxufTtcblxuLyogSGVscGVycyAqL1xuXG4vLyBXaGV0aGVyIG51bWJlciBpcyBiZXR3ZWVuIGJvdW5kc1xuZnVuY3Rpb24gaW5SYW5nZSh4LCBtaW4sIG1heCkge1xuICByZXR1cm4geCA+PSBtaW4gJiYgeCA8PSBtYXg7XG59XG4vLyBDb25zdHJhaW4gbnVtYmVyIGJldHdlZW4gYm91bmRzXG5mdW5jdGlvbiBjbGFtcCh4LCBtaW4sIG1heCkge1xuICByZXR1cm4geCA8IG1pbiA/IG1pbiA6ICh4ID4gbWF4ID8gbWF4IDogeCk7XG59XG4vLyBHZXQgcmF0aW8gb2YgeCBvbiBkb21haW5cbmZ1bmN0aW9uIGludGVycG9sYXRlKHgsIGRvbWFpbjAsIGRvbWFpbjEpIHtcbiAgaWYgKGRvbWFpbjAgPT09IGRvbWFpbjEpIHtcbiAgICByZXR1cm4geCA9PT0gZG9tYWluMCA/IDAgOiBJbmZpbml0eTtcbiAgfVxuICByZXR1cm4gKHggLSBkb21haW4wKSAvIChkb21haW4xIC0gZG9tYWluMCk7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUZpbml0ZSh2YWx1ZSwgZmFsbGJhY2tWYWx1ZSkge1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogZmFsbGJhY2tWYWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3JiaXRTdGF0ZSB7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIC8qIFZpZXdwb3J0IGFyZ3VtZW50cyAqL1xuICAgIHdpZHRoLCAvLyBXaWR0aCBvZiB2aWV3cG9ydFxuICAgIGhlaWdodCwgLy8gSGVpZ2h0IG9mIHZpZXdwb3J0XG4gICAgZGlzdGFuY2UsIC8vIEZyb20gZXllIHRvIHRhcmdldFxuICAgIHJvdGF0aW9uWCwgLy8gUm90YXRpb24gYXJvdW5kIHggYXhpc1xuICAgIHJvdGF0aW9uWSwgLy8gUm90YXRpb24gYXJvdW5kIHkgYXhpc1xuXG4gICAgLy8gQm91bmRpbmcgYm94IG9mIHRoZSBtb2RlbCwgaW4gdGhlIHNoYXBlIG9mIHttaW5YLCBtYXhYLCBtaW5ZLCBtYXhZLCBtaW5aLCBtYXhafVxuICAgIGJvdW5kcyxcblxuICAgIC8qIFZpZXcgbWF0cml4IGFyZ3VtZW50cyAqL1xuICAgIGxvb2tBdCwgLy8gV2hpY2ggcG9pbnQgaXMgY2FtZXJhIGxvb2tpbmcgYXQsIGRlZmF1bHQgb3JpZ2luXG5cbiAgICAvKiBQcm9qZWN0aW9uIG1hdHJpeCBhcmd1bWVudHMgKi9cbiAgICBmb3YsIC8vIEZpZWxkIG9mIHZpZXcgY292ZXJlZCBieSBjYW1lcmFcbiAgICBuZWFyLCAvLyBEaXN0YW5jZSBvZiBuZWFyIGNsaXBwaW5nIHBsYW5lXG4gICAgZmFyLCAvLyBEaXN0YW5jZSBvZiBmYXIgY2xpcHBpbmcgcGxhbmVcblxuICAgIC8qIEFmdGVyIHByb2plY3Rpb24gKi9cbiAgICB0cmFuc2xhdGlvblgsIC8vIGluIHBpeGVsc1xuICAgIHRyYW5zbGF0aW9uWSwgLy8gaW4gcGl4ZWxzXG4gICAgem9vbSxcblxuICAgIC8qIFZpZXdwb3J0IGNvbnN0cmFpbnRzICovXG4gICAgbWluWm9vbSxcbiAgICBtYXhab29tLFxuXG4gICAgLyoqIEludGVyYWN0aW9uIHN0YXRlcywgcmVxdWlyZWQgdG8gY2FsY3VsYXRlIGNoYW5nZSBkdXJpbmcgdHJhbnNmb3JtICovXG4gICAgLy8gTW9kZWwgc3RhdGUgd2hlbiB0aGUgcGFuIG9wZXJhdGlvbiBmaXJzdCBzdGFydGVkXG4gICAgc3RhcnRQYW5Qb3MsXG4gICAgc3RhcnRQYW5UcmFuc2xhdGlvbixcbiAgICAvLyBNb2RlbCBzdGF0ZSB3aGVuIHRoZSByb3RhdGUgb3BlcmF0aW9uIGZpcnN0IHN0YXJ0ZWRcbiAgICBzdGFydFJvdGF0ZUNlbnRlcixcbiAgICBzdGFydFJvdGF0ZVZpZXdwb3J0LFxuICAgIC8vIE1vZGVsIHN0YXRlIHdoZW4gdGhlIHpvb20gb3BlcmF0aW9uIGZpcnN0IHN0YXJ0ZWRcbiAgICBzdGFydFpvb21Qb3MsXG4gICAgc3RhcnRab29tXG4gIH0pIHtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHdpZHRoKSwgJ2B3aWR0aGAgbXVzdCBiZSBzdXBwbGllZCcpO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoaGVpZ2h0KSwgJ2BoZWlnaHRgIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGRpc3RhbmNlKSwgJ2BkaXN0YW5jZWAgbXVzdCBiZSBzdXBwbGllZCcpO1xuXG4gICAgdGhpcy5fdmlld3BvcnRQcm9wcyA9IHRoaXMuX2FwcGx5Q29uc3RyYWludHMoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIHJvdGF0aW9uWDogZW5zdXJlRmluaXRlKHJvdGF0aW9uWCwgZGVmYXVsdFN0YXRlLnJvdGF0aW9uWCksXG4gICAgICByb3RhdGlvblk6IGVuc3VyZUZpbml0ZShyb3RhdGlvblksIGRlZmF1bHRTdGF0ZS5yb3RhdGlvblkpLFxuXG4gICAgICBib3VuZHMsXG4gICAgICBsb29rQXQ6IGxvb2tBdCB8fCBkZWZhdWx0U3RhdGUubG9va0F0LFxuXG4gICAgICBmb3Y6IGVuc3VyZUZpbml0ZShmb3YsIGRlZmF1bHRTdGF0ZS5mb3YpLFxuICAgICAgbmVhcjogZW5zdXJlRmluaXRlKG5lYXIsIGRlZmF1bHRTdGF0ZS5uZWFyKSxcbiAgICAgIGZhcjogZW5zdXJlRmluaXRlKGZhciwgZGVmYXVsdFN0YXRlLmZhciksXG4gICAgICB0cmFuc2xhdGlvblg6IGVuc3VyZUZpbml0ZSh0cmFuc2xhdGlvblgsIGRlZmF1bHRTdGF0ZS50cmFuc2xhdGlvblgpLFxuICAgICAgdHJhbnNsYXRpb25ZOiBlbnN1cmVGaW5pdGUodHJhbnNsYXRpb25ZLCBkZWZhdWx0U3RhdGUudHJhbnNsYXRpb25ZKSxcbiAgICAgIHpvb206IGVuc3VyZUZpbml0ZSh6b29tLCBkZWZhdWx0U3RhdGUuem9vbSksXG5cbiAgICAgIG1pblpvb206IGVuc3VyZUZpbml0ZShtaW5ab29tLCBkZWZhdWx0Q29uc3RyYWludHMubWluWm9vbSksXG4gICAgICBtYXhab29tOiBlbnN1cmVGaW5pdGUobWF4Wm9vbSwgZGVmYXVsdENvbnN0cmFpbnRzLm1heFpvb20pXG4gICAgfSk7XG5cbiAgICB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlID0ge1xuICAgICAgc3RhcnRQYW5Qb3MsXG4gICAgICBzdGFydFBhblRyYW5zbGF0aW9uLFxuICAgICAgc3RhcnRSb3RhdGVDZW50ZXIsXG4gICAgICBzdGFydFJvdGF0ZVZpZXdwb3J0LFxuICAgICAgc3RhcnRab29tUG9zLFxuICAgICAgc3RhcnRab29tXG4gICAgfTtcbiAgfVxuXG4gIC8qIFB1YmxpYyBBUEkgKi9cblxuICBnZXRWaWV3cG9ydFByb3BzKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFByb3BzO1xuICB9XG5cbiAgZ2V0SW50ZXJhY3RpdmVTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJhY3RpdmVTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBwYW5uaW5nXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBwb2ludGVyIGdyYWJzXG4gICAqL1xuICBwYW5TdGFydCh7cG9zfSkge1xuICAgIGNvbnN0IHt0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWX0gPSB0aGlzLl92aWV3cG9ydFByb3BzO1xuXG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRPcmJpdFN0YXRlKHtcbiAgICAgIHN0YXJ0UGFuVHJhbnNsYXRpb246IFt0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWV0sXG4gICAgICBzdGFydFBhblBvczogcG9zXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFuXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBwb2ludGVyIGlzXG4gICAqL1xuICBwYW4oe3Bvcywgc3RhcnRQb3N9KSB7XG4gICAgY29uc3Qgc3RhcnRQYW5Qb3MgPSB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlLnN0YXJ0UGFuUG9zIHx8IHN0YXJ0UG9zO1xuICAgIGFzc2VydChzdGFydFBhblBvcywgJ2BzdGFydFBhblBvc2AgcHJvcHMgaXMgcmVxdWlyZWQnKTtcblxuICAgIGxldCBbdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblldID0gdGhpcy5faW50ZXJhY3RpdmVTdGF0ZS5zdGFydFBhblRyYW5zbGF0aW9uIHx8IFtdO1xuICAgIHRyYW5zbGF0aW9uWCA9IGVuc3VyZUZpbml0ZSh0cmFuc2xhdGlvblgsIHRoaXMuX3ZpZXdwb3J0UHJvcHMudHJhbnNsYXRpb25YKTtcbiAgICB0cmFuc2xhdGlvblkgPSBlbnN1cmVGaW5pdGUodHJhbnNsYXRpb25ZLCB0aGlzLl92aWV3cG9ydFByb3BzLnRyYW5zbGF0aW9uWSk7XG5cbiAgICBjb25zdCBkZWx0YVggPSBwb3NbMF0gLSBzdGFydFBhblBvc1swXTtcbiAgICBjb25zdCBkZWx0YVkgPSBwb3NbMV0gLSBzdGFydFBhblBvc1sxXTtcblxuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkT3JiaXRTdGF0ZSh7XG4gICAgICB0cmFuc2xhdGlvblg6IHRyYW5zbGF0aW9uWCArIGRlbHRhWCxcbiAgICAgIHRyYW5zbGF0aW9uWTogdHJhbnNsYXRpb25ZIC0gZGVsdGFZXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRW5kIHBhbm5pbmdcbiAgICogTXVzdCBjYWxsIGlmIGBwYW5TdGFydCgpYCB3YXMgY2FsbGVkXG4gICAqL1xuICBwYW5FbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRPcmJpdFN0YXRlKHtcbiAgICAgIHN0YXJ0UGFuVHJhbnNsYXRpb246IG51bGwsXG4gICAgICBzdGFydFBhblBvczogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHJvdGF0aW5nXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBwb2ludGVyIGdyYWJzXG4gICAqL1xuICByb3RhdGVTdGFydCh7cG9zfSkge1xuICAgIC8vIFJvdGF0aW9uIGNlbnRlciBzaG91bGQgYmUgdGhlIHdvcmxkc3BhY2UgcG9zaXRpb24gYXQgdGhlIGNlbnRlciBvZiB0aGVcbiAgICAvLyB0aGUgc2NyZWVuLiBJZiBub3QgZm91bmQsIHVzZSB0aGUgbGFzdCBvbmUuXG4gICAgY29uc3Qgc3RhcnRSb3RhdGVDZW50ZXIgPSB0aGlzLl9nZXRMb2NhdGlvbkF0Q2VudGVyKCkgfHxcbiAgICAgIHRoaXMuX2ludGVyYWN0aXZlU3RhdGUuc3RhcnRSb3RhdGVDZW50ZXI7XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE9yYml0U3RhdGUoe1xuICAgICAgc3RhcnRSb3RhdGVDZW50ZXIsXG4gICAgICBzdGFydFJvdGF0ZVZpZXdwb3J0OiB0aGlzLl92aWV3cG9ydFByb3BzXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUm90YXRlXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBwb2ludGVyIGlzXG4gICAqL1xuICByb3RhdGUoe2RlbHRhU2NhbGVYLCBkZWx0YVNjYWxlWX0pIHtcbiAgICBjb25zdCB7c3RhcnRSb3RhdGVDZW50ZXIsIHN0YXJ0Um90YXRlVmlld3BvcnR9ID0gdGhpcy5faW50ZXJhY3RpdmVTdGF0ZTtcblxuICAgIGxldCB7cm90YXRpb25YLCByb3RhdGlvblksIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZfSA9IHN0YXJ0Um90YXRlVmlld3BvcnQgfHwge307XG4gICAgcm90YXRpb25YID0gZW5zdXJlRmluaXRlKHJvdGF0aW9uWCwgdGhpcy5fdmlld3BvcnRQcm9wcy5yb3RhdGlvblgpO1xuICAgIHJvdGF0aW9uWSA9IGVuc3VyZUZpbml0ZShyb3RhdGlvblksIHRoaXMuX3ZpZXdwb3J0UHJvcHMucm90YXRpb25ZKTtcbiAgICB0cmFuc2xhdGlvblggPSBlbnN1cmVGaW5pdGUodHJhbnNsYXRpb25YLCB0aGlzLl92aWV3cG9ydFByb3BzLnRyYW5zbGF0aW9uWCk7XG4gICAgdHJhbnNsYXRpb25ZID0gZW5zdXJlRmluaXRlKHRyYW5zbGF0aW9uWSwgdGhpcy5fdmlld3BvcnRQcm9wcy50cmFuc2xhdGlvblkpO1xuXG4gICAgY29uc3QgbmV3Um90YXRpb25YID0gY2xhbXAocm90YXRpb25YIC0gZGVsdGFTY2FsZVkgKiAxODAsIC04OS45OTksIDg5Ljk5OSk7XG4gICAgY29uc3QgbmV3Um90YXRpb25ZID0gKHJvdGF0aW9uWSAtIGRlbHRhU2NhbGVYICogMTgwKSAlIDM2MDtcblxuICAgIGxldCBuZXdUcmFuc2xhdGlvblggPSB0cmFuc2xhdGlvblg7XG4gICAgbGV0IG5ld1RyYW5zbGF0aW9uWSA9IHRyYW5zbGF0aW9uWTtcblxuICAgIGlmIChzdGFydFJvdGF0ZUNlbnRlcikge1xuICAgICAgLy8gS2VlcCByb3RhdGlvbiBjZW50ZXIgYXQgdGhlIGNlbnRlciBvZiB0aGUgc2NyZWVuXG4gICAgICBjb25zdCBvbGRWaWV3cG9ydCA9IG5ldyBPcmJpdFZpZXdwb3J0KHN0YXJ0Um90YXRlVmlld3BvcnQpO1xuICAgICAgY29uc3Qgb2xkQ2VudGVyUG9zID0gb2xkVmlld3BvcnQucHJvamVjdChzdGFydFJvdGF0ZUNlbnRlcik7XG5cbiAgICAgIGNvbnN0IG5ld1ZpZXdwb3J0ID0gbmV3IE9yYml0Vmlld3BvcnQoT2JqZWN0LmFzc2lnbih7fSwgc3RhcnRSb3RhdGVWaWV3cG9ydCwge1xuICAgICAgICByb3RhdGlvblg6IG5ld1JvdGF0aW9uWCxcbiAgICAgICAgcm90YXRpb25ZOiBuZXdSb3RhdGlvbllcbiAgICAgIH0pKTtcbiAgICAgIGNvbnN0IG5ld0NlbnRlclBvcyA9IG5ld1ZpZXdwb3J0LnByb2plY3Qoc3RhcnRSb3RhdGVDZW50ZXIpO1xuXG4gICAgICBuZXdUcmFuc2xhdGlvblggKz0gb2xkQ2VudGVyUG9zWzBdIC0gbmV3Q2VudGVyUG9zWzBdO1xuICAgICAgbmV3VHJhbnNsYXRpb25ZIC09IG9sZENlbnRlclBvc1sxXSAtIG5ld0NlbnRlclBvc1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE9yYml0U3RhdGUoe1xuICAgICAgcm90YXRpb25YOiBuZXdSb3RhdGlvblgsXG4gICAgICByb3RhdGlvblk6IG5ld1JvdGF0aW9uWSxcbiAgICAgIHRyYW5zbGF0aW9uWDogbmV3VHJhbnNsYXRpb25YLFxuICAgICAgdHJhbnNsYXRpb25ZOiBuZXdUcmFuc2xhdGlvbllcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmQgcm90YXRpbmdcbiAgICogTXVzdCBjYWxsIGlmIGByb3RhdGVTdGFydCgpYCB3YXMgY2FsbGVkXG4gICAqL1xuICByb3RhdGVFbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRPcmJpdFN0YXRlKHtcbiAgICAgIHN0YXJ0Um90YXRlQ2VudGVyOiBudWxsLFxuICAgICAgc3RhcnRSb3RhdGVWaWV3cG9ydDogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHpvb21pbmdcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIHBvaW50ZXIgZ3JhYnNcbiAgICovXG4gIHpvb21TdGFydCh7cG9zfSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkT3JiaXRTdGF0ZSh7XG4gICAgICBzdGFydFpvb21Qb3M6IHBvcyxcbiAgICAgIHN0YXJ0Wm9vbTogdGhpcy5fdmlld3BvcnRQcm9wcy56b29tXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogWm9vbVxuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgY3VycmVudCBjZW50ZXIgaXNcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBzdGFydFBvcyAtIHRoZSBjZW50ZXIgcG9zaXRpb24gYXRcbiAgICogICB0aGUgc3RhcnQgb2YgdGhlIG9wZXJhdGlvbi4gTXVzdCBiZSBzdXBwbGllZCBvZiBgem9vbVN0YXJ0KClgIHdhcyBub3QgY2FsbGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSAtIGEgbnVtYmVyIGJldHdlZW4gWzAsIDFdIHNwZWNpZnlpbmcgdGhlIGFjY3VtdWxhdGVkXG4gICAqICAgcmVsYXRpdmUgc2NhbGUuXG4gICAqL1xuICB6b29tKHtwb3MsIHN0YXJ0UG9zLCBzY2FsZX0pIHtcbiAgICBjb25zdCB7em9vbSwgbWluWm9vbSwgbWF4Wm9vbSwgd2lkdGgsIGhlaWdodCwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvbll9ID0gdGhpcy5fdmlld3BvcnRQcm9wcztcblxuICAgIGNvbnN0IHN0YXJ0Wm9vbVBvcyA9IHRoaXMuX2ludGVyYWN0aXZlU3RhdGUuc3RhcnRab29tUG9zIHx8IHN0YXJ0UG9zIHx8IHBvcztcblxuICAgIGNvbnN0IG5ld1pvb20gPSBjbGFtcCh6b29tICogc2NhbGUsIG1pblpvb20sIG1heFpvb20pO1xuICAgIGNvbnN0IGRlbHRhWCA9IHBvc1swXSAtIHN0YXJ0Wm9vbVBvc1swXTtcbiAgICBjb25zdCBkZWx0YVkgPSBwb3NbMV0gLSBzdGFydFpvb21Qb3NbMV07XG5cbiAgICAvLyBab29tIGFyb3VuZCB0aGUgY2VudGVyIHBvc2l0aW9uXG4gICAgY29uc3QgY3ggPSBzdGFydFpvb21Qb3NbMF0gLSB3aWR0aCAvIDI7XG4gICAgY29uc3QgY3kgPSBoZWlnaHQgLyAyIC0gc3RhcnRab29tUG9zWzFdO1xuICAgIGNvbnN0IG5ld1RyYW5zbGF0aW9uWCA9IGN4IC0gKGN4IC0gdHJhbnNsYXRpb25YKSAqIG5ld1pvb20gLyB6b29tICsgZGVsdGFYO1xuICAgIGNvbnN0IG5ld1RyYW5zbGF0aW9uWSA9IGN5IC0gKGN5IC0gdHJhbnNsYXRpb25ZKSAqIG5ld1pvb20gLyB6b29tIC0gZGVsdGFZO1xuXG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRPcmJpdFN0YXRlKHtcbiAgICAgIHpvb206IG5ld1pvb20sXG4gICAgICB0cmFuc2xhdGlvblg6IG5ld1RyYW5zbGF0aW9uWCxcbiAgICAgIHRyYW5zbGF0aW9uWTogbmV3VHJhbnNsYXRpb25ZXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRW5kIHpvb21pbmdcbiAgICogTXVzdCBjYWxsIGlmIGB6b29tU3RhcnQoKWAgd2FzIGNhbGxlZFxuICAgKi9cbiAgem9vbUVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE9yYml0U3RhdGUoe1xuICAgICAgc3RhcnRab29tUG9zOiBudWxsLFxuICAgICAgc3RhcnRab29tOiBudWxsXG4gICAgfSk7XG4gIH1cblxuICAvKiBQcml2YXRlIG1ldGhvZHMgKi9cblxuICBfZ2V0VXBkYXRlZE9yYml0U3RhdGUobmV3UHJvcHMpIHtcbiAgICAvLyBVcGRhdGUgX3ZpZXdwb3J0UHJvcHNcbiAgICByZXR1cm4gbmV3IE9yYml0U3RhdGUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fdmlld3BvcnRQcm9wcywgdGhpcy5faW50ZXJhY3RpdmVTdGF0ZSwgbmV3UHJvcHMpKTtcbiAgfVxuXG4gIC8vIEFwcGx5IGFueSBjb25zdHJhaW50cyAobWF0aGVtYXRpY2FsIG9yIGRlZmluZWQgYnkgX3ZpZXdwb3J0UHJvcHMpIHRvIG1hcCBzdGF0ZVxuICBfYXBwbHlDb25zdHJhaW50cyhwcm9wcykge1xuICAgIC8vIEVuc3VyZSB6b29tIGlzIHdpdGhpbiBzcGVjaWZpZWQgcmFuZ2VcbiAgICBjb25zdCB7bWF4Wm9vbSwgbWluWm9vbSwgem9vbX0gPSBwcm9wcztcbiAgICBwcm9wcy56b29tID0gem9vbSA+IG1heFpvb20gPyBtYXhab29tIDogem9vbTtcbiAgICBwcm9wcy56b29tID0gem9vbSA8IG1pblpvb20gPyBtaW5ab29tIDogem9vbTtcblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIC8qIENhc3QgYSByYXkgaW50byB0aGUgc2NyZWVuIGNlbnRlciBhbmQgdGFrZSB0aGUgYXZlcmFnZSBvZiBhbGxcbiAgICogaW50ZXJzZWN0aW9ucyB3aXRoIHRoZSBib3VuZGluZyBib3g6XG4gICAqXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICh4PXcvMilcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIC5cbiAgICogICAoYm91bmRpbmcgYm94KSAgICAgICAgIC5cbiAgICogICAgICAgICAgIF8tLS0tLS0tLS0tLS0tXy5cbiAgICogICAgICAgICAgfCBcIi1fICAgICAgICAgICA6LV9cbiAgICogICAgICAgICB8ICAgICBcIi1fICAgICAgICAuICBcIi1fXG4gICAqICAgICAgICB8ICAgICAgICAgXCItLS0tLS0tKy0tLS0tOlxuICAgKiAgICAgICB8Li4uLi4uLi4ufC4uLi4uLi4uQy4uLi58Li4uLi4uLi4uLi4uLiAoeT1oLzIpXG4gICAqICAgICAgfCAgICAgICAgIHwgICAgICAgICAuICAgfFxuICAgKiAgICAgfCAgICAgICAgIHwgICAgICAgICAgLiAgfFxuICAgKiAgICB8ICAgICAgICAgfCAgICAgICAgICAgLiB8XG4gICAqICAgfCAgICAgICAgIHwgICAgICAgICAgICAufFxuICAgKiAgfCAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICBZXG4gICAqICAgXCItXyAgICAgfCAgICAgICAgICAgICB8LiAgICAgICAgICAgICBaICAgICAgIHxcbiAgICogICAgICBcIi1fIHwgICAgICAgICAgICAgfCAuICAgICAgICAgICAgICBcIi1fICAgfFxuICAgKiAgICAgICAgIFwiLS0tLS0tLS0tLS0tLVwiICAgICAgICAgICAgICAgICAgICBcIi18X19fX18gWFxuICAgKi9cbiAgX2dldExvY2F0aW9uQXRDZW50ZXIoKSB7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHQsIGJvdW5kc30gPSB0aGlzLl92aWV3cG9ydFByb3BzO1xuXG4gICAgaWYgKCFib3VuZHMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHZpZXdwb3J0ID0gbmV3IE9yYml0Vmlld3BvcnQodGhpcy5fdmlld3BvcnRQcm9wcyk7XG5cbiAgICBjb25zdCBDMCA9IHZpZXdwb3J0LnVucHJvamVjdChbd2lkdGggLyAyLCBoZWlnaHQgLyAyLCAwXSk7XG4gICAgY29uc3QgQzEgPSB2aWV3cG9ydC51bnByb2plY3QoW3dpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgMV0pO1xuICAgIGNvbnN0IHN1bSA9IFswLCAwLCAwXTtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgW1xuICAgICAgLy8gZGVwdGggYXQgaW50ZXJzZWN0aW9uIHdpdGggWCA9IG1pblhcbiAgICAgIGludGVycG9sYXRlKGJvdW5kcy5taW5YLCBDMFswXSwgQzFbMF0pLFxuICAgICAgLy8gZGVwdGggYXQgaW50ZXJzZWN0aW9uIHdpdGggWCA9IG1heFhcbiAgICAgIGludGVycG9sYXRlKGJvdW5kcy5tYXhYLCBDMFswXSwgQzFbMF0pLFxuICAgICAgLy8gZGVwdGggYXQgaW50ZXJzZWN0aW9uIHdpdGggWSA9IG1pbllcbiAgICAgIGludGVycG9sYXRlKGJvdW5kcy5taW5ZLCBDMFsxXSwgQzFbMV0pLFxuICAgICAgLy8gZGVwdGggYXQgaW50ZXJzZWN0aW9uIHdpdGggWSA9IG1heFlcbiAgICAgIGludGVycG9sYXRlKGJvdW5kcy5tYXhZLCBDMFsxXSwgQzFbMV0pLFxuICAgICAgLy8gZGVwdGggYXQgaW50ZXJzZWN0aW9uIHdpdGggWiA9IG1pblpcbiAgICAgIGludGVycG9sYXRlKGJvdW5kcy5taW5aLCBDMFsyXSwgQzFbMl0pLFxuICAgICAgLy8gZGVwdGggYXQgaW50ZXJzZWN0aW9uIHdpdGggWiA9IG1heFpcbiAgICAgIGludGVycG9sYXRlKGJvdW5kcy5tYXhaLCBDMFsyXSwgQzFbMl0pXG4gICAgXS5mb3JFYWNoKGQgPT4ge1xuICAgICAgLy8gd29ybGRzcGFjZSBwb3NpdGlvbiBvZiB0aGUgaW50ZXJzZWN0aW9uXG4gICAgICBjb25zdCBDID0gdmVjM19sZXJwKFtdLCBDMCwgQzEsIGQpO1xuICAgICAgLy8gY2hlY2sgaWYgcG9zaXRpb24gaXMgb24gdGhlIGJvdW5kaW5nIGJveFxuICAgICAgaWYgKGluUmFuZ2UoQ1swXSwgYm91bmRzLm1pblgsIGJvdW5kcy5tYXhYKSAmJlxuICAgICAgICAgIGluUmFuZ2UoQ1sxXSwgYm91bmRzLm1pblksIGJvdW5kcy5tYXhZKSAmJlxuICAgICAgICAgIGluUmFuZ2UoQ1syXSwgYm91bmRzLm1pblosIGJvdW5kcy5tYXhaKSkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICB2ZWMzX2FkZChzdW0sIHN1bSwgQyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY291bnQgPiAwID8gdmVjM19zY2FsZShbXSwgc3VtLCAxIC8gY291bnQpIDogbnVsbDtcbiAgfVxufVxuIl19