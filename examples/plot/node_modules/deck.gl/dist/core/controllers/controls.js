'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 Uber Technologies, Inc.

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var _mapState = require('./map-state');

var _mapState2 = _interopRequireDefault(_mapState);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// EVENT HANDLING PARAMETERS
var ZOOM_ACCEL = 0.01;

var PITCH_MOUSE_THRESHOLD = 5;
var PITCH_ACCEL = 1.2;

var EVENT_TYPES = {
  WHEEL: ['wheel'],
  PAN: ['panstart', 'panmove', 'panend'],
  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],
  DOUBLE_TAP: ['doubletap'],
  KEYBOARD: ['keydown', 'keyup']
};

var Controls = function () {
  /**
   * @classdesc
   * A class that handles events and updates mercator style viewport parameters
   */
  function Controls(ViewportState) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Controls);

    (0, _assert2.default)(ViewportState);
    this.ViewportState = ViewportState;
    this.viewportState = null;
    this.viewportStateProps = null;
    this.eventManager = null;
    this._events = null;

    this._state = {
      isDragging: false
    };

    this.handleEvent = this.handleEvent.bind(this);

    this.setOptions(options);

    if (this.constructor === Controls) {
      Object.seal(this);
    }
  }

  /**
   * Callback for events
   * @param {hammer.Event} event
   */


  _createClass(Controls, [{
    key: 'handleEvent',
    value: function handleEvent(event) {
      var ViewportState = this.ViewportState;

      this.viewportState = new ViewportState(Object.assign({}, this.viewportStateProps, this._state));

      switch (event.type) {
        case 'panstart':
          return this._onPanStart(event);
        case 'panmove':
          return this._onPan(event);
        case 'panend':
          return this._onPanEnd(event);
        case 'pinchstart':
          return this._onPinchStart(event);
        case 'pinch':
          return this._onPinch(event);
        case 'pinchend':
          return this._onPinchEnd(event);
        case 'doubletap':
          return this._onDoubleTap(event);
        case 'wheel':
          return this._onWheel(event);
        case 'keydown':
          return this._onKeyDown(event);
        case 'keyup':
          return this._onKeyUp(event);
        default:
          return false;
      }
    }

    /* Event utils */
    // Event object: http://hammerjs.github.io/api/#event-object

  }, {
    key: 'getCenter',
    value: function getCenter(event) {
      var _event$offsetCenter = event.offsetCenter,
          x = _event$offsetCenter.x,
          y = _event$offsetCenter.y;

      return [x, y];
    }
  }, {
    key: 'isFunctionKeyPressed',
    value: function isFunctionKeyPressed(event) {
      var srcEvent = event.srcEvent;

      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
  }, {
    key: 'isDragging',
    value: function isDragging() {
      return this._state.isDragging;
    }

    /**
     * Extract interactivity options
     */

  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      var onViewportChange = options.onViewportChange,
          _options$onStateChang = options.onStateChange,
          onStateChange = _options$onStateChang === undefined ? this.onStateChange : _options$onStateChang,
          _options$eventManager = options.eventManager,
          eventManager = _options$eventManager === undefined ? this.eventManager : _options$eventManager,
          _options$scrollZoom = options.scrollZoom,
          scrollZoom = _options$scrollZoom === undefined ? true : _options$scrollZoom,
          _options$dragPan = options.dragPan,
          dragPan = _options$dragPan === undefined ? true : _options$dragPan,
          _options$dragRotate = options.dragRotate,
          dragRotate = _options$dragRotate === undefined ? true : _options$dragRotate,
          _options$doubleClickZ = options.doubleClickZoom,
          doubleClickZoom = _options$doubleClickZ === undefined ? true : _options$doubleClickZ,
          _options$touchZoomRot = options.touchZoomRotate,
          touchZoomRotate = _options$touchZoomRot === undefined ? true : _options$touchZoomRot,
          _options$keyboard = options.keyboard,
          keyboard = _options$keyboard === undefined ? true : _options$keyboard;


      this.onViewportChange = onViewportChange;
      this.onStateChange = onStateChange;
      this.viewportStateProps = options;

      if (this.eventManager !== eventManager) {
        // EventManager has changed
        this.eventManager = eventManager;
        this._events = {};
      }

      // Register/unregister events
      var isInteractive = Boolean(this.onViewportChange);
      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
      this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && touchZoomRotate);
      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);

      this.scrollZoom = scrollZoom;
      this.dragPan = dragPan;
      this.dragRotate = dragRotate;
      this.doubleClickZoom = doubleClickZoom;
      this.touchZoomRotate = touchZoomRotate;
    }
  }, {
    key: 'toggleEvents',
    value: function toggleEvents(eventNames, enabled) {
      var _this = this;

      if (this.eventManager) {
        eventNames.forEach(function (eventName) {
          if (_this._events[eventName] !== enabled) {
            _this._events[eventName] = enabled;
            if (enabled) {
              _this.eventManager.on(eventName, _this.handleEvent);
            } else {
              _this.eventManager.off(eventName, _this.handleEvent);
            }
          }
        });
      }
    }

    // Private Methods

  }, {
    key: 'setState',
    value: function setState(newState) {
      Object.assign(this._state, newState);
      if (this.onStateChange) {
        this.onStateChange(this._state);
      }
    }

    /* Callback util */
    // formats map state and invokes callback function

  }, {
    key: 'updateViewport',
    value: function updateViewport(newViewportState) {
      var extraState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var oldViewport = this.viewportState.getViewportProps();
      var newViewport = newViewportState.getViewportProps();

      if (this.onViewportChange && Object.keys(newViewport).some(function (key) {
        return oldViewport[key] !== newViewport[key];
      })) {
        // Viewport has changed
        var viewport = this.viewportState.getViewport ? this.viewportState.getViewport() : null;
        this.onViewportChange(newViewport, viewport);
      }

      this.setState(Object.assign({}, newViewportState.getInteractiveState(), extraState));
    }

    /* Event handlers */
    // Default handler for the `panstart` event.

  }, {
    key: '_onPanStart',
    value: function _onPanStart(event) {
      var pos = this.getCenter(event);
      var newViewportState = this.viewportState.panStart({ pos: pos }).rotateStart({ pos: pos });
      return this.updateViewport(newViewportState, { isDragging: true });
    }

    // Default handler for the `panmove` event.

  }, {
    key: '_onPan',
    value: function _onPan(event) {
      return this.isFunctionKeyPressed(event) ? this._onPanMove(event) : this._onPanRotate(event);
    }

    // Default handler for the `panend` event.

  }, {
    key: '_onPanEnd',
    value: function _onPanEnd(event) {
      var newViewportState = this.viewportState.panEnd().rotateEnd();
      return this.updateViewport(newViewportState, { isDragging: false });
    }

    // Default handler for panning to move.
    // Called by `_onPan` when panning without function key pressed.

  }, {
    key: '_onPanMove',
    value: function _onPanMove(event) {
      if (!this.dragPan) {
        return false;
      }
      var pos = this.getCenter(event);
      var newViewportState = this.viewportState.pan({ pos: pos });
      return this.updateViewport(newViewportState);
    }

    // Default handler for panning to rotate.
    // Called by `_onPan` when panning with function key pressed.

  }, {
    key: '_onPanRotate',
    value: function _onPanRotate(event) {
      return this.viewportState instanceof _mapState2.default ? this._onPanRotateMap(event) : this._onPanRotateStandard(event);
    }

    // Normal pan to rotate

  }, {
    key: '_onPanRotateStandard',
    value: function _onPanRotateStandard(event) {
      if (!this.dragRotate) {
        return false;
      }

      var deltaX = event.deltaX,
          deltaY = event.deltaY;

      var _viewportState$getVie = this.viewportState.getViewportProps(),
          width = _viewportState$getVie.width,
          height = _viewportState$getVie.height;

      var deltaScaleX = deltaX / width;
      var deltaScaleY = deltaY / height;

      var newViewportState = this.viewportState.rotate({ deltaScaleX: deltaScaleX, deltaScaleY: deltaScaleY });
      return this.updateViewport(newViewportState);
    }

    // Map specific pan to rotate
    // TODO - is this mapStateSpecific?

  }, {
    key: '_onPanRotateMap',
    value: function _onPanRotateMap(event) {
      if (!this.dragRotate) {
        return false;
      }

      var deltaX = event.deltaX,
          deltaY = event.deltaY;

      var _getCenter = this.getCenter(event),
          _getCenter2 = _slicedToArray(_getCenter, 2),
          centerY = _getCenter2[1];

      var startY = centerY - deltaY;

      var _viewportState$getVie2 = this.viewportState.getViewportProps(),
          width = _viewportState$getVie2.width,
          height = _viewportState$getVie2.height;

      var deltaScaleX = deltaX / width;
      var deltaScaleY = 0;

      if (deltaY > 0) {
        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
          // Move from 0 to -1 as we drag upwards
          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
        }
      } else if (deltaY < 0) {
        if (startY > PITCH_MOUSE_THRESHOLD) {
          // Move from 0 to 1 as we drag upwards
          deltaScaleY = 1 - centerY / startY;
        }
      }
      deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));

      var newMapState = this.viewportState.rotate({ deltaScaleX: deltaScaleX, deltaScaleY: deltaScaleY });
      return this.updateViewport(newMapState);
    }

    // Default handler for the `wheel` event.

  }, {
    key: '_onWheel',
    value: function _onWheel(event) {
      if (!this.scrollZoom) {
        return false;
      }
      event.srcEvent.preventDefault();

      var pos = this.getCenter(event);
      var delta = event.delta;

      // Map wheel delta to relative scale

      var scale = 2 / (1 + Math.exp(-Math.abs(delta * ZOOM_ACCEL)));
      if (delta < 0 && scale !== 0) {
        scale = 1 / scale;
      }

      var newViewportState = this.viewportState.zoom({ pos: pos, scale: scale });
      return this.updateViewport(newViewportState);
    }

    // Default handler for the `pinchstart` event.

  }, {
    key: '_onPinchStart',
    value: function _onPinchStart(event) {
      var pos = this.getCenter(event);
      var newViewportState = this.viewportState.zoomStart({ pos: pos });
      return this.updateViewport(newViewportState, { isDragging: true });
    }

    // Default handler for the `pinch` event.

  }, {
    key: '_onPinch',
    value: function _onPinch(event) {
      if (!this.touchZoomRotate) {
        return false;
      }
      var pos = this.getCenter(event);
      var scale = event.scale;

      var newViewportState = this.viewportState.zoom({ pos: pos, scale: scale });
      return this.updateViewport(newViewportState);
    }

    // Default handler for the `pinchend` event.

  }, {
    key: '_onPinchEnd',
    value: function _onPinchEnd(event) {
      var newViewportState = this.viewportState.zoomEnd();
      return this.updateViewport(newViewportState, { isDragging: false });
    }

    // Default handler for the `doubletap` event.

  }, {
    key: '_onDoubleTap',
    value: function _onDoubleTap(event) {
      if (!this.doubleClickZoom) {
        return false;
      }
      var pos = this.getCenter(event);
      var isZoomOut = this.isFunctionKeyPressed(event);

      var newViewportState = this.viewportState.zoom({ pos: pos, scale: isZoomOut ? 0.5 : 2 });
      return this.updateViewport(newViewportState);
    }
  }, {
    key: '_onKeyDown',
    value: function _onKeyDown(event) {
      if (this.viewportState.isDragging) {
        return;
      }

      var KEY_BINDINGS = {
        w: 'moveForward',
        W: 'moveForward',
        ArrowUp: 'moveForward',

        s: 'moveBackward',
        S: 'moveBackward',
        ArrowDown: 'moveBackward',

        a: 'moveLeft',
        A: 'moveLeft',
        ArrowLeft: 'moveLeft',

        d: 'moveRight',
        D: 'moveRight',
        ArrowRight: 'moveRight',

        '=': 'zoomIn',
        '+': 'zoomIn',

        '-': 'zoomOut',

        '[': 'moveDown',
        ']': 'moveUp'
      };

      // keyCode is deprecated from web standards
      // code is not supported by IE/Edge
      var key = event.key;
      var handler = KEY_BINDINGS[key];
      if (this.viewportState[handler]) {
        var newViewportState = this.viewportState[handler]();
        this.updateViewport(newViewportState);
      }
    }
    /* eslint-enable complexity */

  }, {
    key: '_onKeyUp',
    value: function _onKeyUp(event) {}
  }]);

  return Controls;
}();

exports.default = Controls;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2NvbnRyb2xsZXJzL2NvbnRyb2xzLmpzIl0sIm5hbWVzIjpbIlpPT01fQUNDRUwiLCJQSVRDSF9NT1VTRV9USFJFU0hPTEQiLCJQSVRDSF9BQ0NFTCIsIkVWRU5UX1RZUEVTIiwiV0hFRUwiLCJQQU4iLCJQSU5DSCIsIkRPVUJMRV9UQVAiLCJLRVlCT0FSRCIsIkNvbnRyb2xzIiwiVmlld3BvcnRTdGF0ZSIsIm9wdGlvbnMiLCJ2aWV3cG9ydFN0YXRlIiwidmlld3BvcnRTdGF0ZVByb3BzIiwiZXZlbnRNYW5hZ2VyIiwiX2V2ZW50cyIsIl9zdGF0ZSIsImlzRHJhZ2dpbmciLCJoYW5kbGVFdmVudCIsImJpbmQiLCJzZXRPcHRpb25zIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJzZWFsIiwiZXZlbnQiLCJhc3NpZ24iLCJ0eXBlIiwiX29uUGFuU3RhcnQiLCJfb25QYW4iLCJfb25QYW5FbmQiLCJfb25QaW5jaFN0YXJ0IiwiX29uUGluY2giLCJfb25QaW5jaEVuZCIsIl9vbkRvdWJsZVRhcCIsIl9vbldoZWVsIiwiX29uS2V5RG93biIsIl9vbktleVVwIiwib2Zmc2V0Q2VudGVyIiwieCIsInkiLCJzcmNFdmVudCIsIkJvb2xlYW4iLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5Iiwib25WaWV3cG9ydENoYW5nZSIsIm9uU3RhdGVDaGFuZ2UiLCJzY3JvbGxab29tIiwiZHJhZ1BhbiIsImRyYWdSb3RhdGUiLCJkb3VibGVDbGlja1pvb20iLCJ0b3VjaFpvb21Sb3RhdGUiLCJrZXlib2FyZCIsImlzSW50ZXJhY3RpdmUiLCJ0b2dnbGVFdmVudHMiLCJldmVudE5hbWVzIiwiZW5hYmxlZCIsImZvckVhY2giLCJldmVudE5hbWUiLCJvbiIsIm9mZiIsIm5ld1N0YXRlIiwibmV3Vmlld3BvcnRTdGF0ZSIsImV4dHJhU3RhdGUiLCJvbGRWaWV3cG9ydCIsImdldFZpZXdwb3J0UHJvcHMiLCJuZXdWaWV3cG9ydCIsImtleXMiLCJzb21lIiwia2V5Iiwidmlld3BvcnQiLCJnZXRWaWV3cG9ydCIsInNldFN0YXRlIiwiZ2V0SW50ZXJhY3RpdmVTdGF0ZSIsInBvcyIsImdldENlbnRlciIsInBhblN0YXJ0Iiwicm90YXRlU3RhcnQiLCJ1cGRhdGVWaWV3cG9ydCIsImlzRnVuY3Rpb25LZXlQcmVzc2VkIiwiX29uUGFuTW92ZSIsIl9vblBhblJvdGF0ZSIsInBhbkVuZCIsInJvdGF0ZUVuZCIsInBhbiIsIl9vblBhblJvdGF0ZU1hcCIsIl9vblBhblJvdGF0ZVN0YW5kYXJkIiwiZGVsdGFYIiwiZGVsdGFZIiwid2lkdGgiLCJoZWlnaHQiLCJkZWx0YVNjYWxlWCIsImRlbHRhU2NhbGVZIiwicm90YXRlIiwiY2VudGVyWSIsInN0YXJ0WSIsIk1hdGgiLCJhYnMiLCJtaW4iLCJtYXgiLCJuZXdNYXBTdGF0ZSIsInByZXZlbnREZWZhdWx0IiwiZGVsdGEiLCJzY2FsZSIsImV4cCIsInpvb20iLCJ6b29tU3RhcnQiLCJ6b29tRW5kIiwiaXNab29tT3V0IiwiS0VZX0JJTkRJTkdTIiwidyIsIlciLCJBcnJvd1VwIiwicyIsIlMiLCJBcnJvd0Rvd24iLCJhIiwiQSIsIkFycm93TGVmdCIsImQiLCJEIiwiQXJyb3dSaWdodCIsImhhbmRsZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O3FqQkFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUNBOzs7Ozs7OztBQUVBO0FBQ0EsSUFBTUEsYUFBYSxJQUFuQjs7QUFFQSxJQUFNQyx3QkFBd0IsQ0FBOUI7QUFDQSxJQUFNQyxjQUFjLEdBQXBCOztBQUVBLElBQU1DLGNBQWM7QUFDbEJDLFNBQU8sQ0FBQyxPQUFELENBRFc7QUFFbEJDLE9BQUssQ0FBQyxVQUFELEVBQWEsU0FBYixFQUF3QixRQUF4QixDQUZhO0FBR2xCQyxTQUFPLENBQUMsWUFBRCxFQUFlLFdBQWYs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V0FkZ0I7QUFlbkJDLG9CQUFZLFdBZk87O0FBaUJuQixhQUFLLFFBakJjO0FBa0JuQixhQUFLLFFBbEJjOztBQW9CbkIsYUFBSyxTQXBCYzs7QUFzQm5CLGFBQUssVUF0QmM7QUF1Qm5CLGFBQUs7QUF2QmMsT0FBckI7O0FBMEJBO0FBQ0E7QUFDQSxVQUFNcEQsTUFBTTlDLE1BQU04QyxHQUFsQjtBQUNBLFVBQU1xRCxVQUFVYixhQUFheEMsR0FBYixDQUFoQjtBQUNBLFVBQUksS0FBSzFELGFBQUwsQ0FBbUIrRyxPQUFuQixDQUFKLEVBQWlDO0FBQy9CLFlBQU01RCxtQkFBbUIsS0FBS25ELGFBQUwsQ0FBbUIrRyxPQUFuQixHQUF6QjtBQUNBLGFBQUs1QyxjQUFMLENBQW9CaEIsZ0JBQXBCO0FBQ0Q7QUFDRjtBQUNEOzs7OzZCQUVTdkMsSyxFQUFPLENBQ2Y7Ozs7OztrQkF0VmtCZixRIiwiZmlsZSI6ImNvbnRyb2xzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG5cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IE1hcFN0YXRlIGZyb20gJy4vbWFwLXN0YXRlJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuLy8gRVZFTlQgSEFORExJTkcgUEFSQU1FVEVSU1xuY29uc3QgWk9PTV9BQ0NFTCA9IDAuMDE7XG5cbmNvbnN0IFBJVENIX01PVVNFX1RIUkVTSE9MRCA9IDU7XG5jb25zdCBQSVRDSF9BQ0NFTCA9IDEuMjtcblxuY29uc3QgRVZFTlRfVFlQRVMgPSB7XG4gIFdIRUVMOiBbJ3doZWVsJ10sXG4gIFBBTjogWydwYW5zdGFydCcsICdwYW5tb3ZlJywgJ3BhbmVuZCddLFxuICBQSU5DSDogWydwaW5jaHN0YXJ0JywgJ3BpbmNobW92ZScsICdwaW5jaGVuZCddLFxuICBET1VCTEVfVEFQOiBbJ2RvdWJsZXRhcCddLFxuICBLRVlCT0FSRDogWydrZXlkb3duJywgJ2tleXVwJ11cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRyb2xzIHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogQSBjbGFzcyB0aGF0IGhhbmRsZXMgZXZlbnRzIGFuZCB1cGRhdGVzIG1lcmNhdG9yIHN0eWxlIHZpZXdwb3J0IHBhcmFtZXRlcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKFZpZXdwb3J0U3RhdGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGFzc2VydChWaWV3cG9ydFN0YXRlKTtcbiAgICB0aGlzLlZpZXdwb3J0U3RhdGUgPSBWaWV3cG9ydFN0YXRlO1xuICAgIHRoaXMudmlld3BvcnRTdGF0ZSA9IG51bGw7XG4gICAgdGhpcy52aWV3cG9ydFN0YXRlUHJvcHMgPSBudWxsO1xuICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gbnVsbDtcbiAgICB0aGlzLl9ldmVudHMgPSBudWxsO1xuXG4gICAgdGhpcy5fc3RhdGUgPSB7XG4gICAgICBpc0RyYWdnaW5nOiBmYWxzZVxuICAgIH07XG5cbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gdGhpcy5oYW5kbGVFdmVudC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IENvbnRyb2xzKSB7XG4gICAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgZm9yIGV2ZW50c1xuICAgKiBAcGFyYW0ge2hhbW1lci5FdmVudH0gZXZlbnRcbiAgICovXG4gIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3Qge1ZpZXdwb3J0U3RhdGV9ID0gdGhpcztcbiAgICB0aGlzLnZpZXdwb3J0U3RhdGUgPSBuZXcgVmlld3BvcnRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCB0aGlzLnZpZXdwb3J0U3RhdGVQcm9wcywgdGhpcy5fc3RhdGUpKTtcblxuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgIGNhc2UgJ3BhbnN0YXJ0JzpcbiAgICAgIHJldHVybiB0aGlzLl9vblBhblN0YXJ0KGV2ZW50KTtcbiAgICBjYXNlICdwYW5tb3ZlJzpcbiAgICAgIHJldHVybiB0aGlzLl9vblBhbihldmVudCk7XG4gICAgY2FzZSAncGFuZW5kJzpcbiAgICAgIHJldHVybiB0aGlzLl9vblBhbkVuZChldmVudCk7XG4gICAgY2FzZSAncGluY2hzdGFydCc6XG4gICAgICByZXR1cm4gdGhpcy5fb25QaW5jaFN0YXJ0KGV2ZW50KTtcbiAgICBjYXNlICdwaW5jaCc6XG4gICAgICByZXR1cm4gdGhpcy5fb25QaW5jaChldmVudCk7XG4gICAgY2FzZSAncGluY2hlbmQnOlxuICAgICAgcmV0dXJuIHRoaXMuX29uUGluY2hFbmQoZXZlbnQpO1xuICAgIGNhc2UgJ2RvdWJsZXRhcCc6XG4gICAgICByZXR1cm4gdGhpcy5fb25Eb3VibGVUYXAoZXZlbnQpO1xuICAgIGNhc2UgJ3doZWVsJzpcbiAgICAgIHJldHVybiB0aGlzLl9vbldoZWVsKGV2ZW50KTtcbiAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgIHJldHVybiB0aGlzLl9vbktleURvd24oZXZlbnQpO1xuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIHJldHVybiB0aGlzLl9vbktleVVwKGV2ZW50KTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qIEV2ZW50IHV0aWxzICovXG4gIC8vIEV2ZW50IG9iamVjdDogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9hcGkvI2V2ZW50LW9iamVjdFxuICBnZXRDZW50ZXIoZXZlbnQpIHtcbiAgICBjb25zdCB7b2Zmc2V0Q2VudGVyOiB7eCwgeX19ID0gZXZlbnQ7XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfVxuXG4gIGlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KSB7XG4gICAgY29uc3Qge3NyY0V2ZW50fSA9IGV2ZW50O1xuICAgIHJldHVybiBCb29sZWFuKHNyY0V2ZW50Lm1ldGFLZXkgfHwgc3JjRXZlbnQuYWx0S2V5IHx8IHNyY0V2ZW50LmN0cmxLZXkgfHwgc3JjRXZlbnQuc2hpZnRLZXkpO1xuICB9XG5cbiAgaXNEcmFnZ2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuaXNEcmFnZ2luZztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGludGVyYWN0aXZpdHkgb3B0aW9uc1xuICAgKi9cbiAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgb25WaWV3cG9ydENoYW5nZSxcbiAgICAgIG9uU3RhdGVDaGFuZ2UgPSB0aGlzLm9uU3RhdGVDaGFuZ2UsXG4gICAgICBldmVudE1hbmFnZXIgPSB0aGlzLmV2ZW50TWFuYWdlcixcbiAgICAgIHNjcm9sbFpvb20gPSB0cnVlLFxuICAgICAgZHJhZ1BhbiA9IHRydWUsXG4gICAgICBkcmFnUm90YXRlID0gdHJ1ZSxcbiAgICAgIGRvdWJsZUNsaWNrWm9vbSA9IHRydWUsXG4gICAgICB0b3VjaFpvb21Sb3RhdGUgPSB0cnVlLFxuICAgICAga2V5Ym9hcmQgPSB0cnVlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICB0aGlzLm9uVmlld3BvcnRDaGFuZ2UgPSBvblZpZXdwb3J0Q2hhbmdlO1xuICAgIHRoaXMub25TdGF0ZUNoYW5nZSA9IG9uU3RhdGVDaGFuZ2U7XG4gICAgdGhpcy52aWV3cG9ydFN0YXRlUHJvcHMgPSBvcHRpb25zO1xuXG4gICAgaWYgKHRoaXMuZXZlbnRNYW5hZ2VyICE9PSBldmVudE1hbmFnZXIpIHtcbiAgICAgIC8vIEV2ZW50TWFuYWdlciBoYXMgY2hhbmdlZFxuICAgICAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3Rlci91bnJlZ2lzdGVyIGV2ZW50c1xuICAgIGNvbnN0IGlzSW50ZXJhY3RpdmUgPSBCb29sZWFuKHRoaXMub25WaWV3cG9ydENoYW5nZSk7XG4gICAgdGhpcy50b2dnbGVFdmVudHMoRVZFTlRfVFlQRVMuV0hFRUwsIGlzSW50ZXJhY3RpdmUgJiYgc2Nyb2xsWm9vbSk7XG4gICAgdGhpcy50b2dnbGVFdmVudHMoRVZFTlRfVFlQRVMuUEFOLCBpc0ludGVyYWN0aXZlICYmIChkcmFnUGFuIHx8IGRyYWdSb3RhdGUpKTtcbiAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5QSU5DSCwgaXNJbnRlcmFjdGl2ZSAmJiB0b3VjaFpvb21Sb3RhdGUpO1xuICAgIHRoaXMudG9nZ2xlRXZlbnRzKEVWRU5UX1RZUEVTLkRPVUJMRV9UQVAsIGlzSW50ZXJhY3RpdmUgJiYgZG91YmxlQ2xpY2tab29tKTtcbiAgICB0aGlzLnRvZ2dsZUV2ZW50cyhFVkVOVF9UWVBFUy5LRVlCT0FSRCwgaXNJbnRlcmFjdGl2ZSAmJiBrZXlib2FyZCk7XG5cbiAgICB0aGlzLnNjcm9sbFpvb20gPSBzY3JvbGxab29tO1xuICAgIHRoaXMuZHJhZ1BhbiA9IGRyYWdQYW47XG4gICAgdGhpcy5kcmFnUm90YXRlID0gZHJhZ1JvdGF0ZTtcbiAgICB0aGlzLmRvdWJsZUNsaWNrWm9vbSA9IGRvdWJsZUNsaWNrWm9vbTtcbiAgICB0aGlzLnRvdWNoWm9vbVJvdGF0ZSA9IHRvdWNoWm9vbVJvdGF0ZTtcbiAgfVxuXG4gIHRvZ2dsZUV2ZW50cyhldmVudE5hbWVzLCBlbmFibGVkKSB7XG4gICAgaWYgKHRoaXMuZXZlbnRNYW5hZ2VyKSB7XG4gICAgICBldmVudE5hbWVzLmZvckVhY2goZXZlbnROYW1lID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50c1tldmVudE5hbWVdICE9PSBlbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzW2V2ZW50TmFtZV0gPSBlbmFibGVkO1xuICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5vbihldmVudE5hbWUsIHRoaXMuaGFuZGxlRXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5vZmYoZXZlbnROYW1lLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFByaXZhdGUgTWV0aG9kc1xuXG4gIHNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9zdGF0ZSwgbmV3U3RhdGUpO1xuICAgIGlmICh0aGlzLm9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgIHRoaXMub25TdGF0ZUNoYW5nZSh0aGlzLl9zdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2FsbGJhY2sgdXRpbCAqL1xuICAvLyBmb3JtYXRzIG1hcCBzdGF0ZSBhbmQgaW52b2tlcyBjYWxsYmFjayBmdW5jdGlvblxuICB1cGRhdGVWaWV3cG9ydChuZXdWaWV3cG9ydFN0YXRlLCBleHRyYVN0YXRlID0ge30pIHtcbiAgICBjb25zdCBvbGRWaWV3cG9ydCA9IHRoaXMudmlld3BvcnRTdGF0ZS5nZXRWaWV3cG9ydFByb3BzKCk7XG4gICAgY29uc3QgbmV3Vmlld3BvcnQgPSBuZXdWaWV3cG9ydFN0YXRlLmdldFZpZXdwb3J0UHJvcHMoKTtcblxuICAgIGlmICh0aGlzLm9uVmlld3BvcnRDaGFuZ2UgJiZcbiAgICAgIE9iamVjdC5rZXlzKG5ld1ZpZXdwb3J0KS5zb21lKGtleSA9PiBvbGRWaWV3cG9ydFtrZXldICE9PSBuZXdWaWV3cG9ydFtrZXldKSkge1xuICAgICAgLy8gVmlld3BvcnQgaGFzIGNoYW5nZWRcbiAgICAgIGNvbnN0IHZpZXdwb3J0ID0gdGhpcy52aWV3cG9ydFN0YXRlLmdldFZpZXdwb3J0ID8gdGhpcy52aWV3cG9ydFN0YXRlLmdldFZpZXdwb3J0KCkgOiBudWxsO1xuICAgICAgdGhpcy5vblZpZXdwb3J0Q2hhbmdlKG5ld1ZpZXdwb3J0LCB2aWV3cG9ydCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCBuZXdWaWV3cG9ydFN0YXRlLmdldEludGVyYWN0aXZlU3RhdGUoKSwgZXh0cmFTdGF0ZSkpO1xuICB9XG5cbiAgLyogRXZlbnQgaGFuZGxlcnMgKi9cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciB0aGUgYHBhbnN0YXJ0YCBldmVudC5cbiAgX29uUGFuU3RhcnQoZXZlbnQpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgY29uc3QgbmV3Vmlld3BvcnRTdGF0ZSA9IHRoaXMudmlld3BvcnRTdGF0ZS5wYW5TdGFydCh7cG9zfSkucm90YXRlU3RhcnQoe3Bvc30pO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld1ZpZXdwb3J0U3RhdGUsIHtpc0RyYWdnaW5nOiB0cnVlfSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHRoZSBgcGFubW92ZWAgZXZlbnQuXG4gIF9vblBhbihldmVudCkge1xuICAgIHJldHVybiB0aGlzLmlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KSA/IHRoaXMuX29uUGFuTW92ZShldmVudCkgOiB0aGlzLl9vblBhblJvdGF0ZShldmVudCk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHRoZSBgcGFuZW5kYCBldmVudC5cbiAgX29uUGFuRW5kKGV2ZW50KSB7XG4gICAgY29uc3QgbmV3Vmlld3BvcnRTdGF0ZSA9IHRoaXMudmlld3BvcnRTdGF0ZS5wYW5FbmQoKS5yb3RhdGVFbmQoKTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdWaWV3cG9ydFN0YXRlLCB7aXNEcmFnZ2luZzogZmFsc2V9KTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgcGFubmluZyB0byBtb3ZlLlxuICAvLyBDYWxsZWQgYnkgYF9vblBhbmAgd2hlbiBwYW5uaW5nIHdpdGhvdXQgZnVuY3Rpb24ga2V5IHByZXNzZWQuXG4gIF9vblBhbk1vdmUoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ1Bhbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgY29uc3QgbmV3Vmlld3BvcnRTdGF0ZSA9IHRoaXMudmlld3BvcnRTdGF0ZS5wYW4oe3Bvc30pO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld1ZpZXdwb3J0U3RhdGUpO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciBwYW5uaW5nIHRvIHJvdGF0ZS5cbiAgLy8gQ2FsbGVkIGJ5IGBfb25QYW5gIHdoZW4gcGFubmluZyB3aXRoIGZ1bmN0aW9uIGtleSBwcmVzc2VkLlxuICBfb25QYW5Sb3RhdGUoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3cG9ydFN0YXRlIGluc3RhbmNlb2YgTWFwU3RhdGUgP1xuICAgICAgdGhpcy5fb25QYW5Sb3RhdGVNYXAoZXZlbnQpIDpcbiAgICAgIHRoaXMuX29uUGFuUm90YXRlU3RhbmRhcmQoZXZlbnQpO1xuICB9XG5cbiAgLy8gTm9ybWFsIHBhbiB0byByb3RhdGVcbiAgX29uUGFuUm90YXRlU3RhbmRhcmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZHJhZ1JvdGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHtkZWx0YVgsIGRlbHRhWX0gPSBldmVudDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLnZpZXdwb3J0U3RhdGUuZ2V0Vmlld3BvcnRQcm9wcygpO1xuXG4gICAgY29uc3QgZGVsdGFTY2FsZVggPSBkZWx0YVggLyB3aWR0aDtcbiAgICBjb25zdCBkZWx0YVNjYWxlWSA9IGRlbHRhWSAvIGhlaWdodDtcblxuICAgIGNvbnN0IG5ld1ZpZXdwb3J0U3RhdGUgPSB0aGlzLnZpZXdwb3J0U3RhdGUucm90YXRlKHtkZWx0YVNjYWxlWCwgZGVsdGFTY2FsZVl9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdWaWV3cG9ydFN0YXRlKTtcbiAgfVxuXG4gIC8vIE1hcCBzcGVjaWZpYyBwYW4gdG8gcm90YXRlXG4gIC8vIFRPRE8gLSBpcyB0aGlzIG1hcFN0YXRlU3BlY2lmaWM/XG4gIF9vblBhblJvdGF0ZU1hcChldmVudCkge1xuICAgIGlmICghdGhpcy5kcmFnUm90YXRlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qge2RlbHRhWCwgZGVsdGFZfSA9IGV2ZW50O1xuICAgIGNvbnN0IFssIGNlbnRlclldID0gdGhpcy5nZXRDZW50ZXIoZXZlbnQpO1xuICAgIGNvbnN0IHN0YXJ0WSA9IGNlbnRlclkgLSBkZWx0YVk7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcy52aWV3cG9ydFN0YXRlLmdldFZpZXdwb3J0UHJvcHMoKTtcblxuICAgIGNvbnN0IGRlbHRhU2NhbGVYID0gZGVsdGFYIC8gd2lkdGg7XG4gICAgbGV0IGRlbHRhU2NhbGVZID0gMDtcblxuICAgIGlmIChkZWx0YVkgPiAwKSB7XG4gICAgICBpZiAoTWF0aC5hYnMoaGVpZ2h0IC0gc3RhcnRZKSA+IFBJVENIX01PVVNFX1RIUkVTSE9MRCkge1xuICAgICAgICAvLyBNb3ZlIGZyb20gMCB0byAtMSBhcyB3ZSBkcmFnIHVwd2FyZHNcbiAgICAgICAgZGVsdGFTY2FsZVkgPSBkZWx0YVkgLyAoc3RhcnRZIC0gaGVpZ2h0KSAqIFBJVENIX0FDQ0VMO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGVsdGFZIDwgMCkge1xuICAgICAgaWYgKHN0YXJ0WSA+IFBJVENIX01PVVNFX1RIUkVTSE9MRCkge1xuICAgICAgICAvLyBNb3ZlIGZyb20gMCB0byAxIGFzIHdlIGRyYWcgdXB3YXJkc1xuICAgICAgICBkZWx0YVNjYWxlWSA9IDEgLSBjZW50ZXJZIC8gc3RhcnRZO1xuICAgICAgfVxuICAgIH1cbiAgICBkZWx0YVNjYWxlWSA9IE1hdGgubWluKDEsIE1hdGgubWF4KC0xLCBkZWx0YVNjYWxlWSkpO1xuXG4gICAgY29uc3QgbmV3TWFwU3RhdGUgPSB0aGlzLnZpZXdwb3J0U3RhdGUucm90YXRlKHtkZWx0YVNjYWxlWCwgZGVsdGFTY2FsZVl9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdNYXBTdGF0ZSk7XG4gIH1cblxuICAvLyBEZWZhdWx0IGhhbmRsZXIgZm9yIHRoZSBgd2hlZWxgIGV2ZW50LlxuICBfb25XaGVlbChldmVudCkge1xuICAgIGlmICghdGhpcy5zY3JvbGxab29tKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGV2ZW50LnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgY29uc3Qge2RlbHRhfSA9IGV2ZW50O1xuXG4gICAgLy8gTWFwIHdoZWVsIGRlbHRhIHRvIHJlbGF0aXZlIHNjYWxlXG4gICAgbGV0IHNjYWxlID0gMiAvICgxICsgTWF0aC5leHAoLU1hdGguYWJzKGRlbHRhICogWk9PTV9BQ0NFTCkpKTtcbiAgICBpZiAoZGVsdGEgPCAwICYmIHNjYWxlICE9PSAwKSB7XG4gICAgICBzY2FsZSA9IDEgLyBzY2FsZTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdWaWV3cG9ydFN0YXRlID0gdGhpcy52aWV3cG9ydFN0YXRlLnpvb20oe3Bvcywgc2NhbGV9KTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdWaWV3cG9ydFN0YXRlKTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBwaW5jaHN0YXJ0YCBldmVudC5cbiAgX29uUGluY2hTdGFydChldmVudCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCBuZXdWaWV3cG9ydFN0YXRlID0gdGhpcy52aWV3cG9ydFN0YXRlLnpvb21TdGFydCh7cG9zfSk7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Vmlld3BvcnRTdGF0ZSwge2lzRHJhZ2dpbmc6IHRydWV9KTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBwaW5jaGAgZXZlbnQuXG4gIF9vblBpbmNoKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnRvdWNoWm9vbVJvdGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldENlbnRlcihldmVudCk7XG4gICAgY29uc3Qge3NjYWxlfSA9IGV2ZW50O1xuICAgIGNvbnN0IG5ld1ZpZXdwb3J0U3RhdGUgPSB0aGlzLnZpZXdwb3J0U3RhdGUuem9vbSh7cG9zLCBzY2FsZX0pO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld1ZpZXdwb3J0U3RhdGUpO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBoYW5kbGVyIGZvciB0aGUgYHBpbmNoZW5kYCBldmVudC5cbiAgX29uUGluY2hFbmQoZXZlbnQpIHtcbiAgICBjb25zdCBuZXdWaWV3cG9ydFN0YXRlID0gdGhpcy52aWV3cG9ydFN0YXRlLnpvb21FbmQoKTtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVWaWV3cG9ydChuZXdWaWV3cG9ydFN0YXRlLCB7aXNEcmFnZ2luZzogZmFsc2V9KTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgaGFuZGxlciBmb3IgdGhlIGBkb3VibGV0YXBgIGV2ZW50LlxuICBfb25Eb3VibGVUYXAoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZG91YmxlQ2xpY2tab29tKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICBjb25zdCBpc1pvb21PdXQgPSB0aGlzLmlzRnVuY3Rpb25LZXlQcmVzc2VkKGV2ZW50KTtcblxuICAgIGNvbnN0IG5ld1ZpZXdwb3J0U3RhdGUgPSB0aGlzLnZpZXdwb3J0U3RhdGUuem9vbSh7cG9zLCBzY2FsZTogaXNab29tT3V0ID8gMC41IDogMn0pO1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpZXdwb3J0KG5ld1ZpZXdwb3J0U3RhdGUpO1xuICB9XG5cbiAgX29uS2V5RG93bihldmVudCkge1xuICAgIGlmICh0aGlzLnZpZXdwb3J0U3RhdGUuaXNEcmFnZ2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IEtFWV9CSU5ESU5HUyA9IHtcbiAgICAgIHc6ICdtb3ZlRm9yd2FyZCcsXG4gICAgICBXOiAnbW92ZUZvcndhcmQnLFxuICAgICAgQXJyb3dVcDogJ21vdmVGb3J3YXJkJyxcblxuICAgICAgczogJ21vdmVCYWNrd2FyZCcsXG4gICAgICBTOiAnbW92ZUJhY2t3YXJkJyxcbiAgICAgIEFycm93RG93bjogJ21vdmVCYWNrd2FyZCcsXG5cbiAgICAgIGE6ICdtb3ZlTGVmdCcsXG4gICAgICBBOiAnbW92ZUxlZnQnLFxuICAgICAgQXJyb3dMZWZ0OiAnbW92ZUxlZnQnLFxuXG4gICAgICBkOiAnbW92ZVJpZ2h0JyxcbiAgICAgIEQ6ICdtb3ZlUmlnaHQnLFxuICAgICAgQXJyb3dSaWdodDogJ21vdmVSaWdodCcsXG5cbiAgICAgICc9JzogJ3pvb21JbicsXG4gICAgICAnKyc6ICd6b29tSW4nLFxuXG4gICAgICAnLSc6ICd6b29tT3V0JyxcblxuICAgICAgJ1snOiAnbW92ZURvd24nLFxuICAgICAgJ10nOiAnbW92ZVVwJ1xuICAgIH07XG5cbiAgICAvLyBrZXlDb2RlIGlzIGRlcHJlY2F0ZWQgZnJvbSB3ZWIgc3RhbmRhcmRzXG4gICAgLy8gY29kZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFL0VkZ2VcbiAgICBjb25zdCBrZXkgPSBldmVudC5rZXk7XG4gICAgY29uc3QgaGFuZGxlciA9IEtFWV9CSU5ESU5HU1trZXldO1xuICAgIGlmICh0aGlzLnZpZXdwb3J0U3RhdGVbaGFuZGxlcl0pIHtcbiAgICAgIGNvbnN0IG5ld1ZpZXdwb3J0U3RhdGUgPSB0aGlzLnZpZXdwb3J0U3RhdGVbaGFuZGxlcl0oKTtcbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQobmV3Vmlld3BvcnRTdGF0ZSk7XG4gICAgfVxuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSAqL1xuXG4gIF9vbktleVVwKGV2ZW50KSB7XG4gIH1cbn1cbiJdfQ==