'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ANIMATION_EVENTS = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _mjolnir = require('mjolnir.js');

var _controls = require('../../core/controllers/controls');

var _controls2 = _interopRequireDefault(_controls);

var _mapState = require('../../core/controllers/map-state');

var _mapState2 = _interopRequireDefault(_mapState);

var _cursors = require('../utils/cursors');

var _cursors2 = _interopRequireDefault(_cursors);

var _viewportAnimationUtils = require('./viewport-animation-utils.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global setInterval, clearInterval */


var VIEWPORT_ANIMATE_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];
var VIEWPORT_ANIMATE_FREQUENCY = 0.01;
var VIEWPORT_ANIMATION_DURATION = 0;
var VIEWPORT_ANIMATION_EASING_FUNC = function VIEWPORT_ANIMATION_EASING_FUNC(t) {
  return t;
};

var ANIMATION_EVENTS = exports.ANIMATION_EVENTS = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
};

var propTypes = {
  /** The width of the map. */
  width: _propTypes2.default.number.isRequired,
  /** The height of the map. */
  height: _propTypes2.default.number.isRequired,
  /** The longitude of the center of the map. */
  longitude: _propTypes2.default.number.isRequired,
  /** The latitude of the center of the map. */
  latitude: _propTypes2.default.number.isRequired,
  /** The tile zoom level of the map. */
  zoom: _propTypes2.default.number.isRequired,
  /** Specify the bearing of the viewport */
  bearing: _propTypes2.default.number,
  /** Specify the pitch of the viewport */
  pitch: _propTypes2.default.number,
  /** Altitude of the viewport camera. Default 1.5 "screen heights" */
  // Note: Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
  altitude: _propTypes2.default.number,

  /** Viewport constraints */
  // Max zoom level
  maxZoom: _propTypes2.default.number,
  // Min zoom level
  minZoom: _propTypes2.default.number,
  // Max pitch in degrees
  maxPitch: _propTypes2.default.number,
  // Min pitch in degrees
  minPitch: _propTypes2.default.number,

  /**
   * `onViewportChange` callback is fired when the user interacted with the
   * map. The object passed to the callback contains viewport properties
   * such as `longitude`, `latitude`, `zoom` etc.
   */
  onViewportChange: _propTypes2.default.func,

  /** Viewport animation **/
  // animation duration for viewport change
  animaitonDuration: _propTypes2.default.number,
  // function called for each animation step, can be used to perform custom animations.
  animationInterpolator: _propTypes2.default.func,
  // easing function
  viewportAnimationEasingFunc: _propTypes2.default.func,

  /** Enables control event handling */
  // Scroll to zoom
  scrollZoom: _propTypes2.default.bool,
  // Drag to pan
  dragPan: _propTypes2.default.bool,
  // Drag to rotate
  dragRotate: _propTypes2.default.bool,
  // Double click to zoom
  doubleClickZoom: _propTypes2.default.bool,
  // Pinch to zoom / rotate
  touchZoomRotate: _propTypes2.default.bool,

  /** Accessor that returns a cursor style to show interactive state */
  getCursor: _propTypes2.default.func,

  // A map control instance to replace the default map controls
  // The object must expose one property: `events` as an array of subscribed
  // event names; and two methods: `setState(state)` and `handle(event)`
  controls: _propTypes2.default.shape({
    events: _propTypes2.default.arrayOf(_propTypes2.default.string),
    handleEvent: _propTypes2.default.func
  })
};

var getDefaultCursor = function getDefaultCursor(_ref) {
  var isDragging = _ref.isDragging;
  return isDragging ? _cursors2.default.GRABBING : _cursors2.default.GRAB;
};

var defaultProps = Object.assign({}, _mapState.MAPBOX_LIMITS, {
  onViewportChange: null,
  animaitonDuration: VIEWPORT_ANIMATION_DURATION,
  animationInterpolator: _viewportAnimationUtils.viewportLinearInterpolator,
  viewportAnimationEasingFunc: VIEWPORT_ANIMATION_EASING_FUNC,

  scrollZoom: true,
  dragPan: true,
  dragRotate: true,
  doubleClickZoom: true,
  touchZoomRotate: true,

  getCursor: getDefaultCursor
});

var AnimationMapController = function (_PureComponent) {
  _inherits(AnimationMapController, _PureComponent);

  function AnimationMapController(props) {
    _classCallCheck(this, AnimationMapController);

    var _this = _possibleConstructorReturn(this, (AnimationMapController.__proto__ || Object.getPrototypeOf(AnimationMapController)).call(this, props));

    _this.state = {
      isDragging: false // Whether the cursor is down
    };

    // Private animation state
    _this.animationContext = {
      animationT: 0,
      animationInterval: null,
      animationStartState: null,
      animationEndState: null,
      animatedViewport: null
    };

    _this._updateViewport = _this._updateViewport.bind(_this);
    _this._createAnimationInterval = _this._createAnimationInterval.bind(_this);
    _this._isTheUpdateDueToCurrentAnimation = _this._isTheUpdateDueToCurrentAnimation.bind(_this);
    _this._animateViewportProp = _this._animateViewportProp.bind(_this);
    _this._endAnimation = _this._endAnimation.bind(_this);
    _this._recursiveUpdateChildren = _this._recursiveUpdateChildren.bind(_this);
    _this._isViewportAnimationEnabled = _this._isViewportAnimationEnabled.bind(_this);
    _this._isAnimationInProgress = _this._isAnimationInProgress.bind(_this);
    _this._processViewportChange = _this._processViewportChange.bind(_this);
    _this._shouldIgnoreViewportChange = _this._shouldIgnoreViewportChange.bind(_this);
    return _this;
  }

  _createClass(AnimationMapController, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var eventCanvas = this.refs.eventCanvas;


      var eventManager = new _mjolnir.EventManager(eventCanvas);

      this._eventManager = eventManager;

      // If props.controls is not provided, fallback to default MapControls instance
      // Cannot use defaultProps here because it needs to be per map instance
      this._controls = this.props.controls || new _controls2.default(_mapState2.default);
      this._controls.setOptions(Object.assign({}, this.props, {
        onStateChange: this._onInteractiveStateChange.bind(this),
        eventManager: eventManager
      }));

      this.animationContext = {
        animationT: 0,
        animationInterval: null,
        animationStartState: null,
        animationEndState: null,
        animatedViewport: null
      };
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps) {
      this.someVar = 'componentWillUpdate';
      this._controls.setOptions(nextProps);
      this._processViewportChange(nextProps);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (this.animationEndCallback) {
        this.animationEndCallback({ t: this.animationEndTime });
        this.animationEndCallback = null;
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._eventManager.destroy();
    }

    // Helper methods

  }, {
    key: '_animateViewportProp',
    value: function _animateViewportProp(startViewport, nextProps) {
      var endViewport = this._extractViewportFromProps(nextProps);
      if (this._didViewportAnimatePropChanged(startViewport, endViewport)) {
        var animationInterval = this._createAnimationInterval(nextProps);
        this.animationContext = {
          animationT: 0.0,
          animationStartViewport: startViewport,
          animationEndViewport: endViewport,
          animationInterval: animationInterval,
          animatedViewport: startViewport,
          onAnimationInterruption: nextProps.onAnimationInterruption,
          onAnimationStop: nextProps.onAnimationStop
        };
        this.forceUpdate();
      }
    }
  }, {
    key: '_createAnimationInterval',
    value: function _createAnimationInterval(nextProps) {
      var _this2 = this;

      if (this.animationContext.animationInterval) {
        clearInterval(this.animationContext.animationInterval);
      }
      var updateFrequency = nextProps.animaitonDuration * VIEWPORT_ANIMATE_FREQUENCY;
      return setInterval(function () {
        return _this2._updateViewport();
      }, updateFrequency);
    }
  }, {
    key: '_didViewportAnimatePropChanged',
    value: function _didViewportAnimatePropChanged(startViewport, endViewport) {
      // TODO: also check for `animationDuration` `animationFreeze`
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = VIEWPORT_ANIMATE_PROPS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var p = _step.value;

          if (startViewport[p] !== undefined && endViewport[p] !== undefined && startViewport[p] !== endViewport[p]) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return false;
    }
  }, {
    key: '_endAnimation',
    value: function _endAnimation() {
      clearInterval(this.animationContext.animationInterval);
      this.animationEndCallback = this.animationContext.onAnimationStop;
      this.animationEndTime = this.animationContext.animationT;
      // TODO: may be just set animationContext to null
      this.animationContext = {
        animationT: 0,
        animationInterval: null,
        animationStartState: null,
        animationEndState: null,
        animatedViewport: null,
        onAnimationStop: null,
        onAnimationInterruption: null
      };
    }

    // TODO: add viewport or viewportState prop to avoid this extraction.

  }, {
    key: '_extractViewportFromProps',
    value: function _extractViewportFromProps(props) {
      return {
        width: props.width,
        height: props.height,
        latitude: props.latitude,
        longitude: props.longitude,
        zoom: props.zoom,
        bearing: props.bearing,
        pitch: props.pitch,
        minZoom: props.minZoom,
        maxZoom: props.maxZoom
      };
    }
  }, {
    key: '_isAnimationInProgress',
    value: function _isAnimationInProgress() {
      return this.animationContext.animationInterval;
    }
  }, {
    key: '_isViewportAnimationEnabled',
    value: function _isViewportAnimationEnabled(props) {
      return props.animaitonDuration !== 0;
    }
  }, {
    key: '_isTheUpdateDueToCurrentAnimation',
    value: function _isTheUpdateDueToCurrentAnimation(nextProps) {
      if (this.animationContext.animatedViewport) {
        var newViewport = this._extractViewportFromProps(nextProps);
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = VIEWPORT_ANIMATE_PROPS[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var p = _step2.value;

            if (newViewport[p] !== this.animationContext.animatedViewport[p]) {
              return false;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        return true;
      }
      return false;
    }
  }, {
    key: '_onInteractiveStateChange',
    value: function _onInteractiveStateChange(interactiveState) {
      var _interactiveState$isD = interactiveState.isDragging,
          isDragging = _interactiveState$isD === undefined ? false : _interactiveState$isD;

      if (isDragging !== this.state.isDragging) {
        this.setState({ isDragging: isDragging });
      }
    }
  }, {
    key: '_processViewportChange',
    value: function _processViewportChange(nextProps) {

      if (this._shouldIgnoreViewportChange(nextProps)) {
        return;
      }

      var animationEndViewport = this.animationContext ? this.animationContext.animationEndViewport : null;
      var shouldSnapToEnd = this._shouldEndAnimation();
      if (this._isAnimationInProgress()) {
        this._endAnimation();
      }

      if (this._isViewportAnimationEnabled(nextProps)) {
        var startViewport = void 0;
        if (shouldSnapToEnd) {
          startViewport = animationEndViewport || this._extractViewportFromProps(this.props);
        } else {
          startViewport = this._extractViewportFromProps(this.props);
        }
        this._animateViewportProp(startViewport, nextProps);
      }
    }
  }, {
    key: '_recursiveUpdateChildren',
    value: function _recursiveUpdateChildren(children, viewport) {
      var _this3 = this;

      return _react.Children.map(children, function (child) {
        if (!(0, _react.isValidElement)(child)) {
          return child;
        }
        // TODO: we need to filter chidren and only update those that require
        // updated viewport prop.
        var childProps = Object.assign({}, viewport, { viewport: viewport });
        childProps.children = _this3._recursiveUpdateChildren(child.props.children, viewport);
        var cloned = (0, _react.cloneElement)(child, childProps);
        return cloned;
      });
    }
  }, {
    key: '_shouldEndAnimation',
    value: function _shouldEndAnimation() {
      return this.animationContext && this.animationContext.onAnimationInterruption === ANIMATION_EVENTS.SNAP_TO_END;
    }
  }, {
    key: '_shouldIgnoreViewportChange',
    value: function _shouldIgnoreViewportChange(nextProps) {
      // Ignore update if it is due to current active animation.
      if (this._isTheUpdateDueToCurrentAnimation(nextProps)) {
        return true;
      }

      // Ignore update if it is requested to ignore
      if (this.animationContext && this.animationContext.onAnimationInterruption === ANIMATION_EVENTS.IGNORE) {
        return true;
      }

      // Ignore if none of the viewport props changed.
      var start = this._extractViewportFromProps(this.props);
      var end = this._extractViewportFromProps(nextProps);
      if (!this._didViewportAnimatePropChanged(start, end)) {
        return true;
      }

      return false;
    }
  }, {
    key: '_updateViewport',
    value: function _updateViewport() {
      var t = this.props.viewportAnimationEasingFunc(this.animationContext.animationT);
      var animatedViewport = this.props.animationInterpolator(this.animationContext.animationStartViewport, this.animationContext.animationEndViewport, t);
      var currentTime = this.animationContext.animationT;
      if (currentTime <= 1.0) {
        // console.log(`Controller update pitch: ${animatedViewport.pitch} t: ${t}`);
        this.animationContext.animationT = currentTime + VIEWPORT_ANIMATE_FREQUENCY > 1.0 && currentTime + VIEWPORT_ANIMATE_FREQUENCY < 1.0 + VIEWPORT_ANIMATE_FREQUENCY ? 1.0 : currentTime + VIEWPORT_ANIMATE_FREQUENCY;
        this.animationContext.animatedViewport = Object.assign({}, this.animationContext.animationEndViewport, animatedViewport);
        if (this.props.onViewportChange) {
          this.props.onViewportChange(animatedViewport);
        }
      } else {
        this._endAnimation();
      }
      this.forceUpdate();
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          width = _props.width,
          height = _props.height,
          getCursor = _props.getCursor;


      var eventCanvasStyle = {
        width: width,
        height: height,
        position: 'relative',
        cursor: getCursor(this.state)
      };

      var childrenWithProps = void 0;
      if (this._isAnimationInProgress()) {
        childrenWithProps = this._recursiveUpdateChildren(this.props.children, this.animationContext.animatedViewport);
      } else {
        // console.log('=== AnimationController Render using original props for children');
        childrenWithProps = this._recursiveUpdateChildren(this.props.children, this._extractViewportFromProps(this.props));
      }

      return (0, _react.createElement)('div', {
        key: 'map-controls',
        ref: 'eventCanvas',
        style: eventCanvasStyle
      }, childrenWithProps);
    }
  }]);

  return AnimationMapController;
}(_react.PureComponent);

exports.default = AnimationMapController;


AnimationMapController.displayName = 'AnimationMapController';
AnimationMapController.propTypes = propTypes;
AnimationMapController.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFjdC9leHBlcmltZW50YWwvYW5pbWF0aW9uLW1hcC1jb250cm9sbGVyLmpzIl0sIm5hbWVzIjpbIlZJRVdQT1JUX0FOSU1BVEVfUFJPUFMiLCJWSUVXUE9SVF9BTklNQVRFX0ZSRVFVRU5DWSIsIlZJRVdQT1JUX0FOSU1BVElPTl9EVVJBVElPTiIsIlZJRVdQT1JUX0FOSU1BVElPTl9FQVNJTkdfRlVOQyIsInQiLCJBTklNQVRJT05fRVZFTlRTIiwiQlJFQUsiLCJTTkFQX1RPX0VORCIsIklHTk9SRSIsInByb3BUeXBlcyIsIndpZHRoIiwibnVtYmVyIiwiaXNSZXF1aXJlZCIsImhlaWdodCIsImxvbmdpdHVkZSIsImxhdGl0dWRlIiwiem9vbSIsImJlYXJpbmciLCJwaXRjaCIsImFsdGl0dWRlIiwibWF4Wm9vbSIsIm1pblpvb20iLCJtYXhQaXRjaCIsIm1pblBpdGNoIiwib25WaWV3cG9ydENoYW5nZSIsImZ1bmMiLCJhbmltYWl0b25EdXJhdGlvbiIsImFuaW1hdGlvbkludGVycG9sYXRvciIsInZpZXdwb3J0QW5pbWF0aW9uRWFzaW5nRnVuYyIsInNjcm9sbFpvb20iLCJib29sIiwiZHJhZ1BhbiIsImRyYWdSb3RhdGUiLCJkb3VibGVDbGlja1pvb20iLCJ0b3VjaFpvb21Sb3RhdGUiLCJnZXRDdXJzb3IiLCJjb250cm9scyIsInNoYXBlIiwiZXZlbnRzIiwiYXJyYXlPZiIsInN0cmluZyIsImhhbmRsZUV2ZW50IiwiZ2V0RGVmYXVsdEN1cnNvciIsImlzRHJhZ2dpbmciLCJHUkFCQklORyIsIkdSQUIiLCJkZWZhdWx0UHJvcHMiLCJPYmplY3QiLCJhc3NpZ24iLCJBbmltYXRpb25NYXBDb250cm9sbGVyIiwicHJvcHMiLCJzdGF0ZSIsImFuaW1hdGlvbkNvbnRleHQiLCJhbmltYXRpb25UIiwiYW5pbWF0aW9uSW50ZXJ2YWwiLCJhbmltYXRpb25TdGFydFN0YXRlIiwiYW5pbWF0aW9uRW5kU3RhdGUiLCJhbmltYXRlZFZpZXdwb3J0IiwiX3VwZGF0ZVZpZXdwb3J0IiwiYmluZCIsIl9jcmVhdGVBbmltYXRpb25JbnRlcnZhbCIsIl9pc1RoZVVwZGF0ZUR1ZVRvQ3VycmVudEFuaW1hdGlvbiIsIl9hbmltYXRlVmlld3BvcnRQcm9wIiwiX2VuZEFuaW1hdGlvbiIsIl9yZWN1cnNpdmVVcGRhdGVDaGlsZHJlbiIsIl9pc1ZpZXdwb3J0QW5pbWF0aW9uRW5hYmxlZCIsIl9pc0FuaW1hdGlvbkluUHJvZ3Jlc3MiLCJfcHJvY2Vzc1ZpZXdwb3J0Q2hhbmdlIiwiX3Nob3VsZElnbm9yZVZpZXdwb3J0Q2hhbmdlIiwiZXZlbnRDYW52YXMiLCJyZWZzIiwiZXZlbnRNYW5hZ2VyIiwiX2V2ZW50TWFuYWdlciIsIl9jb250cm9scyIsInNldE9wdGlvbnMiLCJvblN0YXRlQ2hhbmdlIiwiX29uSW50ZXJhY3RpdmVTdGF0ZUNoYW5nZSIsIm5leHRQcm9wcyIsInNvbWVWYXIiLCJhbmltYXRpb25FbmRDYWxsYmFjayIsImFuaW1hdGlvbkVuZFRpbWUiLCJkZXN0cm95Iiwic3RhcnRWaWV3cG9ydCIsImVuZFZpZXdwb3J0IiwiX2V4dHJhY3RWaWV3cG9ydEZyb21Qcm9wcyIsIl9kaWRWaWV3cG9ydEFuaW1hdGVQcm9wQ2hhbmdlZCIsImFuaW1hdGlvblN0YXJ0Vmlld3BvcnQiLCJhbmltYXRpb25FbmRWaWV3cG9ydCIsIm9uQW5pbWF0aW9uSW50ZXJydXB0aW9uIiwib25BbmltYXRpb25TdG9wIiwiZm9yY2VVcGRhdGUiLCJjbGVhckludGVydmFsIiwidXBkYXRlRnJlcXVlbmN5Iiwic2V0SW50ZXJ2YWwiLCJwIiwidW5kZWZpbmVkIiwibmV3Vmlld3BvcnQiLCJpbnRlcmFjdGl2ZVN0YXRlIiwic2V0U3RhdGUiLCJzaG91bGRTbmFwVG9FbmQiLCJfc2hvdWxkRW5kQW5pbWF0aW9uIiwiY2hpbGRyZW4iLCJ2aWV3cG9ydCIsIm1hcCIsImNoaWxkIiwiY2hpbGRQcm9wcyIsImNsb25lZCIsInN0YXJ0IiwiZW5kIiwiY3VycmVudFRpbWUiLCJldmVudENhbnZhc1N0eWxlIiwicG9zaXRpb24iLCJjdXJzb3IiLCJjaGlsZHJlbldpdGhQcm9wcyIsImtleSIsInJlZiIsInN0eWxlIiwiZGlzcGxheU5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUNBOztBQUNBOzs7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7O0FBRUE7Ozs7Ozs7OytlQVZBOzs7QUFZQSxJQUFNQSx5QkFBeUIsQ0FBQyxXQUFELEVBQWMsVUFBZCxFQUEwQixNQUExQixFQUFrQyxTQUFsQyxFQUE2QyxPQUE3QyxDQUEvQjtBQUNBLElBQU1DLDZCQUE2QixJQUFuQztBQUNBLElBQU1DLDhCQUE4QixDQUFwQztBQUNBLElBQU1DLGlDQUFpQyxTQUFqQ0EsOEJBQWlDO0FBQUEsU0FBS0MsQ0FBTDtBQUFBLENBQXZDOztBQUVPLElBQU1DLDhDQUFtQjtBQUM5QkMsU0FBTyxDQUR1QjtBQUU5QkMsZUFBYSxDQUZpQjtBQUc5QkMsVUFBUTtBQUhzQixDQUF6Qjs7QUFNUCxJQUFNQyxZQUFZO0FBQ2hCO0FBQ0FDLFNBQU8sb0JBQVVDLE1BQVYsQ0FBaUJDLFVBRlI7QUFHaEI7QUFDQUMsVUFBUSxvQkFBVUYsTUFBVixDQUFpQkMsVUFKVDtBQUtoQjtBQUNBRSxhQUFXLG9CQUFVSCxNQUFWLENBQWlCQyxVQU5aO0FBT2hCO0FBQ0FHLFlBQVUsb0JBQVVKLE1BQVYsQ0FBaUJDLFVBUlg7QUFTaEI7QUFDQUksUUFBTSxvQkFBVUwsTUFBVixDQUFpQkMsVUFWUDtBQVdoQjtBQUNBSyxXQUFTLG9CQUFVTixNQVpIO0FBYWhCO0FBQ0FPLFNBQU8sb0JBQVVQLE1BZEQ7QUFlaEI7QUFDQTtBQUNBUSxZQUFVLG9CQUFVUixNQWpCSjs7QUFtQmhCO0FBQ0E7QUFDQVMsV0FBUyxvQkFBVVQsTUFyQkg7QUFzQmhCO0FBQ0FVLFdBQVMsb0JBQVVWLE1BdkJIO0FBd0JoQjtBQUNBVyxZQUFVLG9CQUFVWCxNQXpCSjtBQTBCaEI7QUFDQVksWUFBVSxvQkFBVVosTUEzQko7O0FBNkJoQjs7Ozs7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SkQsTUFJTztBQUNMO0FBQ0F3RCw0QkFBb0IsS0FBS2pELHdCQUFMLENBQ2xCLEtBQUtkLEtBQUwsQ0FBV21ELFFBRE8sRUFFbEIsS0FBS2pCLHlCQUFMLENBQStCLEtBQUtsQyxLQUFwQyxDQUZrQixDQUFwQjtBQUdEOztBQUVELGFBQ0UsMEJBQWMsS0FBZCxFQUFxQjtBQUNuQmdFLGFBQUssY0FEYztBQUVuQkMsYUFBSyxhQUZjO0FBR25CQyxlQUFPTjtBQUhZLE9BQXJCLEVBS0VHLGlCQUxGLENBREY7QUFTRDs7Ozs7O2tCQXBTa0JoRSxzQjs7O0FBdVNyQkEsdUJBQXVCb0UsV0FBdkIsR0FBcUMsd0JBQXJDO0FBQ0FwRSx1QkFBdUJ4QyxTQUF2QixHQUFtQ0EsU0FBbkM7QUFDQXdDLHVCQUF1QkgsWUFBdkIsR0FBc0NBLFlBQXRDIiwiZmlsZSI6ImFuaW1hdGlvbi1tYXAtY29udHJvbGxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBzZXRJbnRlcnZhbCwgY2xlYXJJbnRlcnZhbCAqL1xuaW1wb3J0IHtQdXJlQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBjbG9uZUVsZW1lbnQsIENoaWxkcmVuLCBpc1ZhbGlkRWxlbWVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IHtFdmVudE1hbmFnZXJ9IGZyb20gJ21qb2xuaXIuanMnO1xuaW1wb3J0IENvbnRyb2xzIGZyb20gJy4uLy4uL2NvcmUvY29udHJvbGxlcnMvY29udHJvbHMnO1xuaW1wb3J0IE1hcFN0YXRlIGZyb20gJy4uLy4uL2NvcmUvY29udHJvbGxlcnMvbWFwLXN0YXRlJztcbmltcG9ydCB7TUFQQk9YX0xJTUlUU30gZnJvbSAnLi4vLi4vY29yZS9jb250cm9sbGVycy9tYXAtc3RhdGUnO1xuaW1wb3J0IENVUlNPUiBmcm9tICcuLi91dGlscy9jdXJzb3JzJztcblxuaW1wb3J0IHt2aWV3cG9ydExpbmVhckludGVycG9sYXRvcn0gZnJvbSAnLi92aWV3cG9ydC1hbmltYXRpb24tdXRpbHMuanMnO1xuXG5jb25zdCBWSUVXUE9SVF9BTklNQVRFX1BST1BTID0gWydsb25naXR1ZGUnLCAnbGF0aXR1ZGUnLCAnem9vbScsICdiZWFyaW5nJywgJ3BpdGNoJ107XG5jb25zdCBWSUVXUE9SVF9BTklNQVRFX0ZSRVFVRU5DWSA9IDAuMDE7XG5jb25zdCBWSUVXUE9SVF9BTklNQVRJT05fRFVSQVRJT04gPSAwO1xuY29uc3QgVklFV1BPUlRfQU5JTUFUSU9OX0VBU0lOR19GVU5DID0gdCA9PiB0O1xuXG5leHBvcnQgY29uc3QgQU5JTUFUSU9OX0VWRU5UUyA9IHtcbiAgQlJFQUs6IDEsXG4gIFNOQVBfVE9fRU5EOiAyLFxuICBJR05PUkU6IDNcbn07XG5cbmNvbnN0IHByb3BUeXBlcyA9IHtcbiAgLyoqIFRoZSB3aWR0aCBvZiB0aGUgbWFwLiAqL1xuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAvKiogVGhlIGhlaWdodCBvZiB0aGUgbWFwLiAqL1xuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFRoZSBsb25naXR1ZGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwLiAqL1xuICBsb25naXR1ZGU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFRoZSBsYXRpdHVkZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBtYXAuICovXG4gIGxhdGl0dWRlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBUaGUgdGlsZSB6b29tIGxldmVsIG9mIHRoZSBtYXAuICovXG4gIHpvb206IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFNwZWNpZnkgdGhlIGJlYXJpbmcgb2YgdGhlIHZpZXdwb3J0ICovXG4gIGJlYXJpbmc6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8qKiBTcGVjaWZ5IHRoZSBwaXRjaCBvZiB0aGUgdmlld3BvcnQgKi9cbiAgcGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8qKiBBbHRpdHVkZSBvZiB0aGUgdmlld3BvcnQgY2FtZXJhLiBEZWZhdWx0IDEuNSBcInNjcmVlbiBoZWlnaHRzXCIgKi9cbiAgLy8gTm90ZTogTm9uLXB1YmxpYyBBUEksIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qcy9pc3N1ZXMvMTEzN1xuICBhbHRpdHVkZTogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKiogVmlld3BvcnQgY29uc3RyYWludHMgKi9cbiAgLy8gTWF4IHpvb20gbGV2ZWxcbiAgbWF4Wm9vbTogUHJvcFR5cGVzLm51bWJlcixcbiAgLy8gTWluIHpvb20gbGV2ZWxcbiAgbWluWm9vbTogUHJvcFR5cGVzLm51bWJlcixcbiAgLy8gTWF4IHBpdGNoIGluIGRlZ3JlZXNcbiAgbWF4UGl0Y2g6IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIE1pbiBwaXRjaCBpbiBkZWdyZWVzXG4gIG1pblBpdGNoOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBgb25WaWV3cG9ydENoYW5nZWAgY2FsbGJhY2sgaXMgZmlyZWQgd2hlbiB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhlXG4gICAqIG1hcC4gVGhlIG9iamVjdCBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGNvbnRhaW5zIHZpZXdwb3J0IHByb3BlcnRpZXNcbiAgICogc3VjaCBhcyBgbG9uZ2l0dWRlYCwgYGxhdGl0dWRlYCwgYHpvb21gIGV0Yy5cbiAgICovXG4gIG9uVmlld3BvcnRDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKiBWaWV3cG9ydCBhbmltYXRpb24gKiovXG4gIC8vIGFuaW1hdGlvbiBkdXJhdGlvbiBmb3Igdmlld3BvcnQgY2hhbmdlXG4gIGFuaW1haXRvbkR1cmF0aW9uOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBmdW5jdGlvbiBjYWxsZWQgZm9yIGVhY2ggYW5pbWF0aW9uIHN0ZXAsIGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gY3VzdG9tIGFuaW1hdGlvbnMuXG4gIGFuaW1hdGlvbkludGVycG9sYXRvcjogUHJvcFR5cGVzLmZ1bmMsXG4gIC8vIGVhc2luZyBmdW5jdGlvblxuICB2aWV3cG9ydEFuaW1hdGlvbkVhc2luZ0Z1bmM6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKiBFbmFibGVzIGNvbnRyb2wgZXZlbnQgaGFuZGxpbmcgKi9cbiAgLy8gU2Nyb2xsIHRvIHpvb21cbiAgc2Nyb2xsWm9vbTogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIERyYWcgdG8gcGFuXG4gIGRyYWdQYW46IFByb3BUeXBlcy5ib29sLFxuICAvLyBEcmFnIHRvIHJvdGF0ZVxuICBkcmFnUm90YXRlOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gRG91YmxlIGNsaWNrIHRvIHpvb21cbiAgZG91YmxlQ2xpY2tab29tOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gUGluY2ggdG8gem9vbSAvIHJvdGF0ZVxuICB0b3VjaFpvb21Sb3RhdGU6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKiBBY2Nlc3NvciB0aGF0IHJldHVybnMgYSBjdXJzb3Igc3R5bGUgdG8gc2hvdyBpbnRlcmFjdGl2ZSBzdGF0ZSAqL1xuICBnZXRDdXJzb3I6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8vIEEgbWFwIGNvbnRyb2wgaW5zdGFuY2UgdG8gcmVwbGFjZSB0aGUgZGVmYXVsdCBtYXAgY29udHJvbHNcbiAgLy8gVGhlIG9iamVjdCBtdXN0IGV4cG9zZSBvbmUgcHJvcGVydHk6IGBldmVudHNgIGFzIGFuIGFycmF5IG9mIHN1YnNjcmliZWRcbiAgLy8gZXZlbnQgbmFtZXM7IGFuZCB0d28gbWV0aG9kczogYHNldFN0YXRlKHN0YXRlKWAgYW5kIGBoYW5kbGUoZXZlbnQpYFxuICBjb250cm9sczogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBldmVudHM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuICAgIGhhbmRsZUV2ZW50OiBQcm9wVHlwZXMuZnVuY1xuICB9KVxufTtcblxuY29uc3QgZ2V0RGVmYXVsdEN1cnNvciA9ICh7aXNEcmFnZ2luZ30pID0+IGlzRHJhZ2dpbmcgPyBDVVJTT1IuR1JBQkJJTkcgOiBDVVJTT1IuR1JBQjtcblxuY29uc3QgZGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgTUFQQk9YX0xJTUlUUywge1xuICBvblZpZXdwb3J0Q2hhbmdlOiBudWxsLFxuICBhbmltYWl0b25EdXJhdGlvbjogVklFV1BPUlRfQU5JTUFUSU9OX0RVUkFUSU9OLFxuICBhbmltYXRpb25JbnRlcnBvbGF0b3I6IHZpZXdwb3J0TGluZWFySW50ZXJwb2xhdG9yLFxuICB2aWV3cG9ydEFuaW1hdGlvbkVhc2luZ0Z1bmM6IFZJRVdQT1JUX0FOSU1BVElPTl9FQVNJTkdfRlVOQyxcblxuICBzY3JvbGxab29tOiB0cnVlLFxuICBkcmFnUGFuOiB0cnVlLFxuICBkcmFnUm90YXRlOiB0cnVlLFxuICBkb3VibGVDbGlja1pvb206IHRydWUsXG4gIHRvdWNoWm9vbVJvdGF0ZTogdHJ1ZSxcblxuICBnZXRDdXJzb3I6IGdldERlZmF1bHRDdXJzb3Jcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb25NYXBDb250cm9sbGVyIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNEcmFnZ2luZzogZmFsc2UgICAgICAvLyBXaGV0aGVyIHRoZSBjdXJzb3IgaXMgZG93blxuICAgIH07XG5cbiAgICAvLyBQcml2YXRlIGFuaW1hdGlvbiBzdGF0ZVxuICAgIHRoaXMuYW5pbWF0aW9uQ29udGV4dCA9IHtcbiAgICAgIGFuaW1hdGlvblQ6IDAsXG4gICAgICBhbmltYXRpb25JbnRlcnZhbDogbnVsbCxcbiAgICAgIGFuaW1hdGlvblN0YXJ0U3RhdGU6IG51bGwsXG4gICAgICBhbmltYXRpb25FbmRTdGF0ZTogbnVsbCxcbiAgICAgIGFuaW1hdGVkVmlld3BvcnQ6IG51bGxcbiAgICB9O1xuXG4gICAgdGhpcy5fdXBkYXRlVmlld3BvcnQgPSB0aGlzLl91cGRhdGVWaWV3cG9ydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2NyZWF0ZUFuaW1hdGlvbkludGVydmFsID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9uSW50ZXJ2YWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9pc1RoZVVwZGF0ZUR1ZVRvQ3VycmVudEFuaW1hdGlvbiA9IHRoaXMuX2lzVGhlVXBkYXRlRHVlVG9DdXJyZW50QW5pbWF0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYW5pbWF0ZVZpZXdwb3J0UHJvcCA9IHRoaXMuX2FuaW1hdGVWaWV3cG9ydFByb3AuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9lbmRBbmltYXRpb24gPSB0aGlzLl9lbmRBbmltYXRpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9yZWN1cnNpdmVVcGRhdGVDaGlsZHJlbiA9IHRoaXMuX3JlY3Vyc2l2ZVVwZGF0ZUNoaWxkcmVuLmJpbmQodGhpcyk7XG4gICAgdGhpcy5faXNWaWV3cG9ydEFuaW1hdGlvbkVuYWJsZWQgPSB0aGlzLl9pc1ZpZXdwb3J0QW5pbWF0aW9uRW5hYmxlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2lzQW5pbWF0aW9uSW5Qcm9ncmVzcyA9IHRoaXMuX2lzQW5pbWF0aW9uSW5Qcm9ncmVzcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3Byb2Nlc3NWaWV3cG9ydENoYW5nZSA9IHRoaXMuX3Byb2Nlc3NWaWV3cG9ydENoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3Nob3VsZElnbm9yZVZpZXdwb3J0Q2hhbmdlID0gdGhpcy5fc2hvdWxkSWdub3JlVmlld3BvcnRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHtldmVudENhbnZhc30gPSB0aGlzLnJlZnM7XG5cbiAgICBjb25zdCBldmVudE1hbmFnZXIgPSBuZXcgRXZlbnRNYW5hZ2VyKGV2ZW50Q2FudmFzKTtcblxuICAgIHRoaXMuX2V2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcblxuICAgIC8vIElmIHByb3BzLmNvbnRyb2xzIGlzIG5vdCBwcm92aWRlZCwgZmFsbGJhY2sgdG8gZGVmYXVsdCBNYXBDb250cm9scyBpbnN0YW5jZVxuICAgIC8vIENhbm5vdCB1c2UgZGVmYXVsdFByb3BzIGhlcmUgYmVjYXVzZSBpdCBuZWVkcyB0byBiZSBwZXIgbWFwIGluc3RhbmNlXG4gICAgdGhpcy5fY29udHJvbHMgPSB0aGlzLnByb3BzLmNvbnRyb2xzIHx8IG5ldyBDb250cm9scyhNYXBTdGF0ZSk7XG4gICAgdGhpcy5fY29udHJvbHMuc2V0T3B0aW9ucyhPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICBvblN0YXRlQ2hhbmdlOiB0aGlzLl9vbkludGVyYWN0aXZlU3RhdGVDaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgIGV2ZW50TWFuYWdlclxuICAgIH0pKTtcblxuICAgIHRoaXMuYW5pbWF0aW9uQ29udGV4dCA9IHtcbiAgICAgIGFuaW1hdGlvblQ6IDAsXG4gICAgICBhbmltYXRpb25JbnRlcnZhbDogbnVsbCxcbiAgICAgIGFuaW1hdGlvblN0YXJ0U3RhdGU6IG51bGwsXG4gICAgICBhbmltYXRpb25FbmRTdGF0ZTogbnVsbCxcbiAgICAgIGFuaW1hdGVkVmlld3BvcnQ6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICB0aGlzLnNvbWVWYXIgPSAnY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgdGhpcy5fY29udHJvbHMuc2V0T3B0aW9ucyhuZXh0UHJvcHMpO1xuICAgIHRoaXMuX3Byb2Nlc3NWaWV3cG9ydENoYW5nZShuZXh0UHJvcHMpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGlmICh0aGlzLmFuaW1hdGlvbkVuZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkVuZENhbGxiYWNrKHt0OiB0aGlzLmFuaW1hdGlvbkVuZFRpbWV9KTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRW5kQ2FsbGJhY2sgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuX2V2ZW50TWFuYWdlci5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBIZWxwZXIgbWV0aG9kc1xuXG4gIF9hbmltYXRlVmlld3BvcnRQcm9wKHN0YXJ0Vmlld3BvcnQsIG5leHRQcm9wcykge1xuICAgIGNvbnN0IGVuZFZpZXdwb3J0ID0gdGhpcy5fZXh0cmFjdFZpZXdwb3J0RnJvbVByb3BzKG5leHRQcm9wcyk7XG4gICAgaWYgKHRoaXMuX2RpZFZpZXdwb3J0QW5pbWF0ZVByb3BDaGFuZ2VkKHN0YXJ0Vmlld3BvcnQsIGVuZFZpZXdwb3J0KSkge1xuICAgICAgY29uc3QgYW5pbWF0aW9uSW50ZXJ2YWwgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25JbnRlcnZhbChuZXh0UHJvcHMpO1xuICAgICAgdGhpcy5hbmltYXRpb25Db250ZXh0ID0ge1xuICAgICAgICBhbmltYXRpb25UOiAwLjAsXG4gICAgICAgIGFuaW1hdGlvblN0YXJ0Vmlld3BvcnQ6IHN0YXJ0Vmlld3BvcnQsXG4gICAgICAgIGFuaW1hdGlvbkVuZFZpZXdwb3J0OiBlbmRWaWV3cG9ydCxcbiAgICAgICAgYW5pbWF0aW9uSW50ZXJ2YWwsXG4gICAgICAgIGFuaW1hdGVkVmlld3BvcnQ6IHN0YXJ0Vmlld3BvcnQsXG4gICAgICAgIG9uQW5pbWF0aW9uSW50ZXJydXB0aW9uOiBuZXh0UHJvcHMub25BbmltYXRpb25JbnRlcnJ1cHRpb24sXG4gICAgICAgIG9uQW5pbWF0aW9uU3RvcDogbmV4dFByb3BzLm9uQW5pbWF0aW9uU3RvcFxuICAgICAgfTtcbiAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQW5pbWF0aW9uSW50ZXJ2YWwobmV4dFByb3BzKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uQ29udGV4dC5hbmltYXRpb25JbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmFuaW1hdGlvbkNvbnRleHQuYW5pbWF0aW9uSW50ZXJ2YWwpO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVGcmVxdWVuY3kgPSBuZXh0UHJvcHMuYW5pbWFpdG9uRHVyYXRpb24gKiBWSUVXUE9SVF9BTklNQVRFX0ZSRVFVRU5DWTtcbiAgICByZXR1cm4gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5fdXBkYXRlVmlld3BvcnQoKSwgdXBkYXRlRnJlcXVlbmN5KTtcbiAgfVxuXG4gIF9kaWRWaWV3cG9ydEFuaW1hdGVQcm9wQ2hhbmdlZChzdGFydFZpZXdwb3J0LCBlbmRWaWV3cG9ydCkge1xuICAgIC8vIFRPRE86IGFsc28gY2hlY2sgZm9yIGBhbmltYXRpb25EdXJhdGlvbmAgYGFuaW1hdGlvbkZyZWV6ZWBcbiAgICBmb3IgKGNvbnN0IHAgb2YgVklFV1BPUlRfQU5JTUFURV9QUk9QUykge1xuICAgICAgaWYgKHN0YXJ0Vmlld3BvcnRbcF0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBlbmRWaWV3cG9ydFtwXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHN0YXJ0Vmlld3BvcnRbcF0gIT09IGVuZFZpZXdwb3J0W3BdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBfZW5kQW5pbWF0aW9uKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5hbmltYXRpb25Db250ZXh0LmFuaW1hdGlvbkludGVydmFsKTtcbiAgICB0aGlzLmFuaW1hdGlvbkVuZENhbGxiYWNrID0gdGhpcy5hbmltYXRpb25Db250ZXh0Lm9uQW5pbWF0aW9uU3RvcDtcbiAgICB0aGlzLmFuaW1hdGlvbkVuZFRpbWUgPSB0aGlzLmFuaW1hdGlvbkNvbnRleHQuYW5pbWF0aW9uVDtcbiAgICAvLyBUT0RPOiBtYXkgYmUganVzdCBzZXQgYW5pbWF0aW9uQ29udGV4dCB0byBudWxsXG4gICAgdGhpcy5hbmltYXRpb25Db250ZXh0ID0ge1xuICAgICAgYW5pbWF0aW9uVDogMCxcbiAgICAgIGFuaW1hdGlvbkludGVydmFsOiBudWxsLFxuICAgICAgYW5pbWF0aW9uU3RhcnRTdGF0ZTogbnVsbCxcbiAgICAgIGFuaW1hdGlvbkVuZFN0YXRlOiBudWxsLFxuICAgICAgYW5pbWF0ZWRWaWV3cG9ydDogbnVsbCxcbiAgICAgIG9uQW5pbWF0aW9uU3RvcDogbnVsbCxcbiAgICAgIG9uQW5pbWF0aW9uSW50ZXJydXB0aW9uOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIC8vIFRPRE86IGFkZCB2aWV3cG9ydCBvciB2aWV3cG9ydFN0YXRlIHByb3AgdG8gYXZvaWQgdGhpcyBleHRyYWN0aW9uLlxuICBfZXh0cmFjdFZpZXdwb3J0RnJvbVByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBwcm9wcy53aWR0aCxcbiAgICAgIGhlaWdodDogcHJvcHMuaGVpZ2h0LFxuICAgICAgbGF0aXR1ZGU6IHByb3BzLmxhdGl0dWRlLFxuICAgICAgbG9uZ2l0dWRlOiBwcm9wcy5sb25naXR1ZGUsXG4gICAgICB6b29tOiBwcm9wcy56b29tLFxuICAgICAgYmVhcmluZzogcHJvcHMuYmVhcmluZyxcbiAgICAgIHBpdGNoOiBwcm9wcy5waXRjaCxcbiAgICAgIG1pblpvb206IHByb3BzLm1pblpvb20sXG4gICAgICBtYXhab29tOiBwcm9wcy5tYXhab29tXG4gICAgfTtcbiAgfVxuXG4gIF9pc0FuaW1hdGlvbkluUHJvZ3Jlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uQ29udGV4dC5hbmltYXRpb25JbnRlcnZhbDtcbiAgfVxuXG4gIF9pc1ZpZXdwb3J0QW5pbWF0aW9uRW5hYmxlZChwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5hbmltYWl0b25EdXJhdGlvbiAhPT0gMDtcbiAgfVxuXG4gIF9pc1RoZVVwZGF0ZUR1ZVRvQ3VycmVudEFuaW1hdGlvbihuZXh0UHJvcHMpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25Db250ZXh0LmFuaW1hdGVkVmlld3BvcnQpIHtcbiAgICAgIGNvbnN0IG5ld1ZpZXdwb3J0ID0gdGhpcy5fZXh0cmFjdFZpZXdwb3J0RnJvbVByb3BzKG5leHRQcm9wcyk7XG4gICAgICBmb3IgKGNvbnN0IHAgb2YgVklFV1BPUlRfQU5JTUFURV9QUk9QUykge1xuICAgICAgICBpZiAobmV3Vmlld3BvcnRbcF0gIT09IHRoaXMuYW5pbWF0aW9uQ29udGV4dC5hbmltYXRlZFZpZXdwb3J0W3BdKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgX29uSW50ZXJhY3RpdmVTdGF0ZUNoYW5nZShpbnRlcmFjdGl2ZVN0YXRlKSB7XG4gICAgY29uc3Qge2lzRHJhZ2dpbmcgPSBmYWxzZX0gPSBpbnRlcmFjdGl2ZVN0YXRlO1xuICAgIGlmIChpc0RyYWdnaW5nICE9PSB0aGlzLnN0YXRlLmlzRHJhZ2dpbmcpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe2lzRHJhZ2dpbmd9KTtcbiAgICB9XG4gIH1cblxuICBfcHJvY2Vzc1ZpZXdwb3J0Q2hhbmdlKG5leHRQcm9wcykge1xuXG4gICAgaWYgKHRoaXMuX3Nob3VsZElnbm9yZVZpZXdwb3J0Q2hhbmdlKG5leHRQcm9wcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb25FbmRWaWV3cG9ydCA9IHRoaXMuYW5pbWF0aW9uQ29udGV4dCA/XG4gICAgICB0aGlzLmFuaW1hdGlvbkNvbnRleHQuYW5pbWF0aW9uRW5kVmlld3BvcnQgOiBudWxsO1xuICAgIGNvbnN0IHNob3VsZFNuYXBUb0VuZCA9IHRoaXMuX3Nob3VsZEVuZEFuaW1hdGlvbigpO1xuICAgIGlmICh0aGlzLl9pc0FuaW1hdGlvbkluUHJvZ3Jlc3MoKSkge1xuICAgICAgdGhpcy5fZW5kQW5pbWF0aW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzVmlld3BvcnRBbmltYXRpb25FbmFibGVkKG5leHRQcm9wcykpIHtcbiAgICAgIGxldCBzdGFydFZpZXdwb3J0O1xuICAgICAgaWYgKHNob3VsZFNuYXBUb0VuZCkge1xuICAgICAgICBzdGFydFZpZXdwb3J0ID0gYW5pbWF0aW9uRW5kVmlld3BvcnQgfHwgdGhpcy5fZXh0cmFjdFZpZXdwb3J0RnJvbVByb3BzKHRoaXMucHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRWaWV3cG9ydCA9IHRoaXMuX2V4dHJhY3RWaWV3cG9ydEZyb21Qcm9wcyh0aGlzLnByb3BzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FuaW1hdGVWaWV3cG9ydFByb3Aoc3RhcnRWaWV3cG9ydCwgbmV4dFByb3BzKTtcbiAgICB9XG4gIH1cblxuICBfcmVjdXJzaXZlVXBkYXRlQ2hpbGRyZW4oY2hpbGRyZW4sIHZpZXdwb3J0KSB7XG4gICAgcmV0dXJuIENoaWxkcmVuLm1hcChjaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogd2UgbmVlZCB0byBmaWx0ZXIgY2hpZHJlbiBhbmQgb25seSB1cGRhdGUgdGhvc2UgdGhhdCByZXF1aXJlXG4gICAgICAvLyB1cGRhdGVkIHZpZXdwb3J0IHByb3AuXG4gICAgICBjb25zdCBjaGlsZFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdmlld3BvcnQsIHt2aWV3cG9ydH0pO1xuICAgICAgY2hpbGRQcm9wcy5jaGlsZHJlbiA9IHRoaXMuX3JlY3Vyc2l2ZVVwZGF0ZUNoaWxkcmVuKGNoaWxkLnByb3BzLmNoaWxkcmVuLCB2aWV3cG9ydCk7XG4gICAgICBjb25zdCBjbG9uZWQgPSBjbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpO1xuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9KTtcbiAgfVxuXG4gIF9zaG91bGRFbmRBbmltYXRpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLmFuaW1hdGlvbkNvbnRleHQgJiZcbiAgICAgIHRoaXMuYW5pbWF0aW9uQ29udGV4dC5vbkFuaW1hdGlvbkludGVycnVwdGlvbiA9PT0gQU5JTUFUSU9OX0VWRU5UUy5TTkFQX1RPX0VORCk7XG4gIH1cblxuICBfc2hvdWxkSWdub3JlVmlld3BvcnRDaGFuZ2UobmV4dFByb3BzKSB7XG4gICAgLy8gSWdub3JlIHVwZGF0ZSBpZiBpdCBpcyBkdWUgdG8gY3VycmVudCBhY3RpdmUgYW5pbWF0aW9uLlxuICAgIGlmICh0aGlzLl9pc1RoZVVwZGF0ZUR1ZVRvQ3VycmVudEFuaW1hdGlvbihuZXh0UHJvcHMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgdXBkYXRlIGlmIGl0IGlzIHJlcXVlc3RlZCB0byBpZ25vcmVcbiAgICBpZiAodGhpcy5hbmltYXRpb25Db250ZXh0ICYmXG4gICAgICB0aGlzLmFuaW1hdGlvbkNvbnRleHQub25BbmltYXRpb25JbnRlcnJ1cHRpb24gPT09IEFOSU1BVElPTl9FVkVOVFMuSUdOT1JFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgaWYgbm9uZSBvZiB0aGUgdmlld3BvcnQgcHJvcHMgY2hhbmdlZC5cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2V4dHJhY3RWaWV3cG9ydEZyb21Qcm9wcyh0aGlzLnByb3BzKTtcbiAgICBjb25zdCBlbmQgPSB0aGlzLl9leHRyYWN0Vmlld3BvcnRGcm9tUHJvcHMobmV4dFByb3BzKTtcbiAgICBpZiAoIXRoaXMuX2RpZFZpZXdwb3J0QW5pbWF0ZVByb3BDaGFuZ2VkKHN0YXJ0LCBlbmQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBfdXBkYXRlVmlld3BvcnQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMucHJvcHMudmlld3BvcnRBbmltYXRpb25FYXNpbmdGdW5jKHRoaXMuYW5pbWF0aW9uQ29udGV4dC5hbmltYXRpb25UKTtcbiAgICBjb25zdCBhbmltYXRlZFZpZXdwb3J0ID0gdGhpcy5wcm9wcy5hbmltYXRpb25JbnRlcnBvbGF0b3IoXG4gICAgICB0aGlzLmFuaW1hdGlvbkNvbnRleHQuYW5pbWF0aW9uU3RhcnRWaWV3cG9ydCxcbiAgICAgIHRoaXMuYW5pbWF0aW9uQ29udGV4dC5hbmltYXRpb25FbmRWaWV3cG9ydCxcbiAgICAgIHRcbiAgICApO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGhpcy5hbmltYXRpb25Db250ZXh0LmFuaW1hdGlvblQ7XG4gICAgaWYgKGN1cnJlbnRUaW1lIDw9IDEuMCkge1xuICAgICAgLy8gY29uc29sZS5sb2coYENvbnRyb2xsZXIgdXBkYXRlIHBpdGNoOiAke2FuaW1hdGVkVmlld3BvcnQucGl0Y2h9IHQ6ICR7dH1gKTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uQ29udGV4dC5hbmltYXRpb25UID0gKFxuICAgICAgICBjdXJyZW50VGltZSArIFZJRVdQT1JUX0FOSU1BVEVfRlJFUVVFTkNZID4gMS4wICYmXG4gICAgICAgIGN1cnJlbnRUaW1lICsgVklFV1BPUlRfQU5JTUFURV9GUkVRVUVOQ1kgPCAxLjAgKyBWSUVXUE9SVF9BTklNQVRFX0ZSRVFVRU5DWVxuICAgICAgICApID8gMS4wIDogY3VycmVudFRpbWUgKyBWSUVXUE9SVF9BTklNQVRFX0ZSRVFVRU5DWTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uQ29udGV4dC5hbmltYXRlZFZpZXdwb3J0ID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQ29udGV4dC5hbmltYXRpb25FbmRWaWV3cG9ydCxcbiAgICAgICAgYW5pbWF0ZWRWaWV3cG9ydCk7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vblZpZXdwb3J0Q2hhbmdlKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25WaWV3cG9ydENoYW5nZShhbmltYXRlZFZpZXdwb3J0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZW5kQW5pbWF0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodCwgZ2V0Q3Vyc29yfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBldmVudENhbnZhc1N0eWxlID0ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIGN1cnNvcjogZ2V0Q3Vyc29yKHRoaXMuc3RhdGUpXG4gICAgfTtcblxuICAgIGxldCBjaGlsZHJlbldpdGhQcm9wcztcbiAgICBpZiAodGhpcy5faXNBbmltYXRpb25JblByb2dyZXNzKCkpIHtcbiAgICAgIGNoaWxkcmVuV2l0aFByb3BzID0gdGhpcy5fcmVjdXJzaXZlVXBkYXRlQ2hpbGRyZW4oXG4gICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQ29udGV4dC5hbmltYXRlZFZpZXdwb3J0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29uc29sZS5sb2coJz09PSBBbmltYXRpb25Db250cm9sbGVyIFJlbmRlciB1c2luZyBvcmlnaW5hbCBwcm9wcyBmb3IgY2hpbGRyZW4nKTtcbiAgICAgIGNoaWxkcmVuV2l0aFByb3BzID0gdGhpcy5fcmVjdXJzaXZlVXBkYXRlQ2hpbGRyZW4oXG4gICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIHRoaXMuX2V4dHJhY3RWaWV3cG9ydEZyb21Qcm9wcyh0aGlzLnByb3BzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAga2V5OiAnbWFwLWNvbnRyb2xzJyxcbiAgICAgICAgcmVmOiAnZXZlbnRDYW52YXMnLFxuICAgICAgICBzdHlsZTogZXZlbnRDYW52YXNTdHlsZVxuICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW5XaXRoUHJvcHNcbiAgICAgIClcbiAgICApO1xuICB9XG59XG5cbkFuaW1hdGlvbk1hcENvbnRyb2xsZXIuZGlzcGxheU5hbWUgPSAnQW5pbWF0aW9uTWFwQ29udHJvbGxlcic7XG5BbmltYXRpb25NYXBDb250cm9sbGVyLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbkFuaW1hdGlvbk1hcENvbnRyb2xsZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuIl19