'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _orbitViewport = require('../../core/viewports/orbit-viewport');

var _orbitViewport2 = _interopRequireDefault(_orbitViewport);

var _orbitState = require('../../core/controllers/orbit-state');

var _orbitState2 = _interopRequireDefault(_orbitState);

var _controls = require('../../core/controllers/controls');

var _controls2 = _interopRequireDefault(_controls);

var _mjolnir = require('mjolnir.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
  /* Viewport properties */
  lookAt: _propTypes2.default.arrayOf(_propTypes2.default.number), // target position
  distance: _propTypes2.default.number, // distance from camera to the target
  rotationX: _propTypes2.default.number, // rotation around X axis
  rotationY: _propTypes2.default.number, // rotation around Y axis
  translationX: _propTypes2.default.number, // translation x in screen space
  translationY: _propTypes2.default.number, // translation y in screen space
  zoom: _propTypes2.default.number, // scale in screen space
  minZoom: _propTypes2.default.number,
  maxZoom: _propTypes2.default.number,
  fov: _propTypes2.default.number, // field of view
  near: _propTypes2.default.number,
  far: _propTypes2.default.number,
  width: _propTypes2.default.number.isRequired, // viewport width in pixels
  height: _propTypes2.default.number.isRequired, // viewport height in pixels

  /* Model properties */
  bounds: _propTypes2.default.object, // bounds in the shape of {minX, minY, minZ, maxX, maxY, maxZ}

  /* Callbacks */
  onViewportChange: _propTypes2.default.func.isRequired,

  /* Controls */
  orbitControls: _propTypes2.default.object
};

var defaultProps = {
  lookAt: [0, 0, 0],
  rotationX: 0,
  rotationY: 0,
  translationX: 0,
  translationY: 0,
  distance: 10,
  zoom: 1,
  minZoom: 0,
  maxZoom: Infinity,
  fov: 50,
  near: 1,
  far: 1000
};

/*
 * Maps mouse interaction to a deck.gl Viewport
 */

var OrbitController = function (_React$Component) {
  _inherits(OrbitController, _React$Component);

  _createClass(OrbitController, null, [{
    key: 'getViewport',


    // Returns a deck.gl Viewport instance, to be used with the DeckGL component
    value: function getViewport(viewport) {
      return new _orbitViewport2.default(viewport);
    }
  }]);

  function OrbitController(props) {
    _classCallCheck(this, OrbitController);

    var _this = _possibleConstructorReturn(this, (OrbitController.__proto__ || Object.getPrototypeOf(OrbitController)).call(this, props));

    _this.state = {
      // Whether the cursor is down
      isDragging: false
    };

    _this._orbitControls = props.orbitControls || new _controls2.default(_orbitState2.default);
    return _this;
  }

  _createClass(OrbitController, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var eventCanvas = this.refs.eventCanvas;


      var eventManager = new _mjolnir.EventManager(eventCanvas);
      this._eventManager = eventManager;

      this._orbitControls.setOptions(Object.assign({}, this.props, {
        onStateChange: this._onInteractiveStateChange.bind(this),
        eventManager: eventManager
      }));
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps) {
      this._orbitControls.setOptions(nextProps);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this._eventManager) {
        // Must destroy because hammer adds event listeners to window
        this._eventManager.destroy();
      }
    }
  }, {
    key: '_onInteractiveStateChange',
    value: function _onInteractiveStateChange(_ref) {
      var _ref$isDragging = _ref.isDragging,
          isDragging = _ref$isDragging === undefined ? false : _ref$isDragging;

      if (isDragging !== this.state.isDragging) {
        this.setState({ isDragging: isDragging });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return (0, _react.createElement)('div', {
        ref: 'eventCanvas'
      }, this.props.children);
    }
  }]);

  return OrbitController;
}(_react2.default.Component);

exports.default = OrbitController;


OrbitController.propTypes = propTypes;
OrbitController.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFjdC9leHBlcmltZW50YWwvb3JiaXQtY29udHJvbGxlci5qcyJdLCJuYW1lcyI6WyJwcm9wVHlwZXMiLCJsb29rQXQiLCJhcnJheU9mIiwibnVtYmVyIiwiZGlzdGFuY2UiLCJyb3RhdGlvblgiLCJyb3RhdGlvblkiLCJ0cmFuc2xhdGlvblgiLCJ0cmFuc2xhdGlvblkiLCJ6b29tIiwibWluWm9vbSIsIm1heFpvb20iLCJmb3YiLCJuZWFyIiwiZmFyIiwid2lkdGgiLCJpc1JlcXVpcmVkIiwiaGVpZ2h0IiwiYm91bmRzIiwib2JqZWN0Iiwib25WaWV3cG9ydENoYW5nZSIsImZ1bmMiLCJvcmJpdENvbnRyb2xzIiwiZGVmYXVsdFByb3BzIiwiSW5maW5pdHkiLCJPcmJpdENvbnRyb2xsZXIiLCJ2aWV3cG9ydCIsInByb3BzIiwic3RhdGUiLCJpc0RyYWdnaW5nIiwiX29yYml0Q29udHJvbHMiLCJldmVudENhbnZhcyIsInJlZnMiLCJldmVudE1hbmFnZXIiLCJfZXZlbnRNYW5hZ2VyIiwic2V0T3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsIm9uU3RhdGVDaGFuZ2UiLCJfb25JbnRlcmFjdGl2ZVN0YXRlQ2hhbmdlIiwiYmluZCIsIm5leHRQcm9wcyIsImRlc3Ryb3kiLCJzZXRTdGF0ZSIsInJlZiIsImNoaWxkcmVuIiwiQ29tcG9uZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OztBQUVBLElBQU1BLFlBQVk7QUFDaEI7QUFDQUMsVUFBUSxvQkFBVUMsT0FBVixDQUFrQixvQkFBVUMsTUFBNUIsQ0FGUSxFQUU2QjtBQUM3Q0MsWUFBVSxvQkFBVUQsTUFISixFQUdZO0FBQzVCRSxhQUFXLG9CQUFVRixNQUpMLEVBSWE7QUFDN0JHLGFBQVcsb0JBQVVILE1BTEwsRUFLYTtBQUM3QkksZ0JBQWMsb0JBQVVKLE1BTlIsRUFNZ0I7QUFDaENLLGdCQUFjLG9CQUFVTCxNQVBSLEVBT2dCO0FBQ2hDTSxRQUFNLG9CQUFVTixNQVJBLEVBUVE7QUFDeEJPLFdBQVMsb0JBQVVQLE1BVEg7QUFVaEJRLFdBQVMsb0JBQVVSLE1BVkg7QUFXaEJTLE9BQUssb0JBQVVULE1BWEMsRUFXTztBQUN2QlUsUUFBTSxvQkFBVVYsTUFaQTtBQWFoQlcsT0FBSyxvQkFBVVgsTUFiQztBQWNoQlksU0FBTyxvQkFBVVosTUFBVixDQUFpQmEsVUFkUixFQWNvQjtBQUNwQ0MsVUFBUSxvQkFBVWQsTUFBVixDQUFpQmEsVUFmVCxFQWVxQjs7QUFFckM7QUFDQUUsVUFBUSxvQkFBVUMsTUFsQkYsRUFrQlU7O0FBRTFCO0FBQ0FDLG9CQUFrQixvQkFBVUMsSUFBVixDQUFlTCxVQXJCakI7O0FBdUJoQjtBQUNBTSxpQkFBZSxvQkFBVUg7QUF4QlQsQ0FBbEI7O0FBMkJBLElBQU1JLGVBQWU7QUFDbkJ0QixVQUFRLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBRFc7QUFFbkJJLGFBQVcsQ0FGUTtBQUduQkMsYUFBVyxDQUhRO0FBSW5CQyxnQkFBYyxDQUpLO0FBS25CQyxnQkFBYyxDQUxLO0FBTW5CSixZQUFVLEVBTlM7QUFPbkJLLFFBQU0sQ0FQYTtBQVFuQkMsV0FBUyxDQVJVO0FBU25CQyxXQUFTYSxRQVRVO0FBVW5CWixPQUFLLEVBVmM7QUFXbkJDLFFBQU0sQ0FYYTtBQVluQkMsT0FBSztBQVpjLENBQXJCOztBQWVBOzs7O0lBR3FCVyxlOzs7Ozs7O0FBRW5CO2dDQUNtQkMsUSxFQUFVO0FBQzNCLGFBQU8sNEJBQWtCQSxRQUFsQixDQUFQO0FBQ0Q7OztBQUVELDJCQUFZQyxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsa0lBQ1hBLEtBRFc7O0FBR2pCLFVBQUtDLEtBQUwsR0FBYTtBQUNYO0FBQ0FDLGtCQUFZO0FBRkQsS0FBYjs7QUFLQSxVQUFLQyxjQUFMLEdBQXNCSCxNQUFNTCxhQUFOLElBQXVCLDRDQUE3QztBQVJpQjtBQVNsQjs7Ozt3Q0FFbUI7QUFBQSxVQUNYUyxXQURXLEdBQ0ksS0FBS0MsSUFEVCxDQUNYRCxXQURXOzs7QUFHbEIsVUFBTUUsZUFBZSwwQkFBaUJGLFdBQWpCLENBQXJCO0FBQ0EsV0FBS0csYUFBTCxHQUFxQkQsWUFBckI7O0FBRUEsV0FBS0gsY0FBTCxDQUFvQkssVUFBcEIsQ0FBK0JDLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLEtBQUtWLEtBQXZCLEVBQThCO0FBQzNEVyx1QkFBZSxLQUFLQyx5QkFBTCxDQUErQkMsSUFBL0IsQ0FBb0MsSUFBcEMsQ0FENEM7QUFFM0RQO0FBRjJELE9BQTlCLENBQS9CO0FBSUQ7Ozt3Q0FFbUJRLFMsRUFBVztBQUM3QixXQUFLWCxjQUFMLENBQW9CSyxVQUFwQixDQUErQk0sU0FBL0I7QUFDRDs7OzJDQUVzQjtBQUNyQixVQUFJLEtBQUtQLGFBQVQsRUFBd0I7QUFDdEI7QUFDQSxhQUFLQSxhQUFMLENBQW1CUSxPQUFuQjtBQUNEO0FBQ0Y7OztvREFFK0M7QUFBQSxpQ0FBckJiLFVBQXFCO0FBQUEsVUFBckJBLFVBQXFCLG1DQUFSLEtBQVE7O0FBQzlDLFVBQUlBLGVBQWUsS0FBS0QsS0FBTCxDQUFXQyxVQUE5QixFQUEwQztBQUN4QyxhQUFLYyxRQUFMLENBQWMsRUFBQ2Qsc0JBQUQsRUFBZDtBQUNEO0FBQ0Y7Ozs2QkFFUTtBQUNQLGFBQ0UsMEJBQWMsS0FBZCxFQUFxQjtBQUNuQmUsYUFBSztBQURjLE9BQXJCLEVBRUcsS0FBS2pCLEtBQUwsQ0FBV2tCLFFBRmQsQ0FERjtBQUtEOzs7O0VBckQwQyxnQkFBTUMsUzs7a0JBQTlCckIsZTs7O0FBd0RyQkEsZ0JBQWdCekIsU0FBaEIsR0FBNEJBLFNBQTVCO0FBQ0F5QixnQkFBZ0JGLFlBQWhCLEdBQStCQSxZQUEvQiIsImZpbGUiOiJvcmJpdC1jb250cm9sbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7Y3JlYXRlRWxlbWVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBPcmJpdFZpZXdwb3J0IGZyb20gJy4uLy4uL2NvcmUvdmlld3BvcnRzL29yYml0LXZpZXdwb3J0JztcbmltcG9ydCBPcmJpdFN0YXRlIGZyb20gJy4uLy4uL2NvcmUvY29udHJvbGxlcnMvb3JiaXQtc3RhdGUnO1xuaW1wb3J0IENvbnRyb2xzIGZyb20gJy4uLy4uL2NvcmUvY29udHJvbGxlcnMvY29udHJvbHMnO1xuaW1wb3J0IHtFdmVudE1hbmFnZXJ9IGZyb20gJ21qb2xuaXIuanMnO1xuXG5jb25zdCBwcm9wVHlwZXMgPSB7XG4gIC8qIFZpZXdwb3J0IHByb3BlcnRpZXMgKi9cbiAgbG9va0F0OiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKSwgLy8gdGFyZ2V0IHBvc2l0aW9uXG4gIGRpc3RhbmNlOiBQcm9wVHlwZXMubnVtYmVyLCAvLyBkaXN0YW5jZSBmcm9tIGNhbWVyYSB0byB0aGUgdGFyZ2V0XG4gIHJvdGF0aW9uWDogUHJvcFR5cGVzLm51bWJlciwgLy8gcm90YXRpb24gYXJvdW5kIFggYXhpc1xuICByb3RhdGlvblk6IFByb3BUeXBlcy5udW1iZXIsIC8vIHJvdGF0aW9uIGFyb3VuZCBZIGF4aXNcbiAgdHJhbnNsYXRpb25YOiBQcm9wVHlwZXMubnVtYmVyLCAvLyB0cmFuc2xhdGlvbiB4IGluIHNjcmVlbiBzcGFjZVxuICB0cmFuc2xhdGlvblk6IFByb3BUeXBlcy5udW1iZXIsIC8vIHRyYW5zbGF0aW9uIHkgaW4gc2NyZWVuIHNwYWNlXG4gIHpvb206IFByb3BUeXBlcy5udW1iZXIsIC8vIHNjYWxlIGluIHNjcmVlbiBzcGFjZVxuICBtaW5ab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICBtYXhab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICBmb3Y6IFByb3BUeXBlcy5udW1iZXIsIC8vIGZpZWxkIG9mIHZpZXdcbiAgbmVhcjogUHJvcFR5cGVzLm51bWJlcixcbiAgZmFyOiBQcm9wVHlwZXMubnVtYmVyLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLCAvLyB2aWV3cG9ydCB3aWR0aCBpbiBwaXhlbHNcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsIC8vIHZpZXdwb3J0IGhlaWdodCBpbiBwaXhlbHNcblxuICAvKiBNb2RlbCBwcm9wZXJ0aWVzICovXG4gIGJvdW5kczogUHJvcFR5cGVzLm9iamVjdCwgLy8gYm91bmRzIGluIHRoZSBzaGFwZSBvZiB7bWluWCwgbWluWSwgbWluWiwgbWF4WCwgbWF4WSwgbWF4Wn1cblxuICAvKiBDYWxsYmFja3MgKi9cbiAgb25WaWV3cG9ydENoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAvKiBDb250cm9scyAqL1xuICBvcmJpdENvbnRyb2xzOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGxvb2tBdDogWzAsIDAsIDBdLFxuICByb3RhdGlvblg6IDAsXG4gIHJvdGF0aW9uWTogMCxcbiAgdHJhbnNsYXRpb25YOiAwLFxuICB0cmFuc2xhdGlvblk6IDAsXG4gIGRpc3RhbmNlOiAxMCxcbiAgem9vbTogMSxcbiAgbWluWm9vbTogMCxcbiAgbWF4Wm9vbTogSW5maW5pdHksXG4gIGZvdjogNTAsXG4gIG5lYXI6IDEsXG4gIGZhcjogMTAwMFxufTtcblxuLypcbiAqIE1hcHMgbW91c2UgaW50ZXJhY3Rpb24gdG8gYSBkZWNrLmdsIFZpZXdwb3J0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9yYml0Q29udHJvbGxlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgLy8gUmV0dXJucyBhIGRlY2suZ2wgVmlld3BvcnQgaW5zdGFuY2UsIHRvIGJlIHVzZWQgd2l0aCB0aGUgRGVja0dMIGNvbXBvbmVudFxuICBzdGF0aWMgZ2V0Vmlld3BvcnQodmlld3BvcnQpIHtcbiAgICByZXR1cm4gbmV3IE9yYml0Vmlld3BvcnQodmlld3BvcnQpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgLy8gV2hldGhlciB0aGUgY3Vyc29yIGlzIGRvd25cbiAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlXG4gICAgfTtcblxuICAgIHRoaXMuX29yYml0Q29udHJvbHMgPSBwcm9wcy5vcmJpdENvbnRyb2xzIHx8IG5ldyBDb250cm9scyhPcmJpdFN0YXRlKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHtldmVudENhbnZhc30gPSB0aGlzLnJlZnM7XG5cbiAgICBjb25zdCBldmVudE1hbmFnZXIgPSBuZXcgRXZlbnRNYW5hZ2VyKGV2ZW50Q2FudmFzKTtcbiAgICB0aGlzLl9ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG5cbiAgICB0aGlzLl9vcmJpdENvbnRyb2xzLnNldE9wdGlvbnMoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgb25TdGF0ZUNoYW5nZTogdGhpcy5fb25JbnRlcmFjdGl2ZVN0YXRlQ2hhbmdlLmJpbmQodGhpcyksXG4gICAgICBldmVudE1hbmFnZXJcbiAgICB9KSk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcykge1xuICAgIHRoaXMuX29yYml0Q29udHJvbHMuc2V0T3B0aW9ucyhuZXh0UHJvcHMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX2V2ZW50TWFuYWdlcikge1xuICAgICAgLy8gTXVzdCBkZXN0cm95IGJlY2F1c2UgaGFtbWVyIGFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHdpbmRvd1xuICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICBfb25JbnRlcmFjdGl2ZVN0YXRlQ2hhbmdlKHtpc0RyYWdnaW5nID0gZmFsc2V9KSB7XG4gICAgaWYgKGlzRHJhZ2dpbmcgIT09IHRoaXMuc3RhdGUuaXNEcmFnZ2luZykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7aXNEcmFnZ2luZ30pO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICByZWY6ICdldmVudENhbnZhcydcbiAgICAgIH0sIHRoaXMucHJvcHMuY2hpbGRyZW4pXG4gICAgKTtcbiAgfVxufVxuXG5PcmJpdENvbnRyb2xsZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuT3JiaXRDb250cm9sbGVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==