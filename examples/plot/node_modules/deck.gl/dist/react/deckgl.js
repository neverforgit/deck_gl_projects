'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _autobind = require('./utils/autobind');

var _autobind2 = _interopRequireDefault(_autobind);

var _core = require('../core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var DeckGLJS = _core.experimental.DeckGLJS;

var DeckGL = function (_React$Component) {
  _inherits(DeckGL, _React$Component);

  function DeckGL(props) {
    _classCallCheck(this, DeckGL);

    var _this = _possibleConstructorReturn(this, (DeckGL.__proto__ || Object.getPrototypeOf(DeckGL)).call(this, props));

    _this.state = {};
    (0, _autobind2.default)(_this);
    return _this;
  }

  _createClass(DeckGL, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.deck = new DeckGLJS(Object.assign({}, this.props, { canvas: this.refs.overlay }));
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.deck) {
        this.deck.setProps(nextProps);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.deck.finalize();
    }

    // Public API

  }, {
    key: 'queryObject',
    value: function queryObject(_ref) {
      var x = _ref.x,
          y = _ref.y,
          _ref$radius = _ref.radius,
          radius = _ref$radius === undefined ? 0 : _ref$radius,
          _ref$layerIds = _ref.layerIds,
          layerIds = _ref$layerIds === undefined ? null : _ref$layerIds;

      return this.deck.queryObject({ x: x, y: y, radius: radius, layerIds: layerIds });
    }
  }, {
    key: 'queryVisibleObjects',
    value: function queryVisibleObjects(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          _ref2$width = _ref2.width,
          width = _ref2$width === undefined ? 1 : _ref2$width,
          _ref2$height = _ref2.height,
          height = _ref2$height === undefined ? 1 : _ref2$height,
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === undefined ? null : _ref2$layerIds;

      return this.deck.queryVisibleObjects({ x: x, y: y, width: width, height: height, layerIds: layerIds });
    }

    // Private Helpers

    // Iterate over viewport descriptors and render children associate with viewports
    // at the specified positions
    // TODO - Can we supply a similar function for the non-React case?

  }, {
    key: '_renderChildrenUnderViewports',
    value: function _renderChildrenUnderViewports() {
      var _this2 = this;

      // Flatten out nested viewports array
      var viewports = this.deck ? this.deck.getViewports() : [];

      // Build a viewport id to viewport index
      var viewportMap = {};
      viewports.forEach(function (viewportDescriptor) {
        var viewport = _this2.deck._getViewportFromDescriptor(viewportDescriptor);
        if (viewport.id) {
          viewportMap[viewport.id] = viewport;
        }
      });

      return _react2.default.Children.toArray(this.props.children).map(function (child, i) {
        // If viewportId prop is provided, match with viewport
        var viewportId = child.props.viewportId;

        var viewport = viewportId && viewportMap[viewportId];
        if (viewport) {
          // Resolve potentially relative dimensions using the deck.gl container size
          var _viewport$getDimensio = viewport.getDimensions({ width: _this2.props.width, height: _this2.props.height }),
              x = _viewport$getDimensio.x,
              y = _viewport$getDimensio.y,
              width = _viewport$getDimensio.width,
              height = _viewport$getDimensio.height;

          // Clone the element with width and height set per viewport


          var newProps = Object.assign({}, child.props, {
            width: width,
            height: height
          });

          // Inject map properties
          // TODO - this is too react-map-gl specific
          Object.assign(newProps, viewport.getMercatorParams(), {
            visible: viewport.isMapSynched()
          });

          var clone = (0, _react.cloneElement)(child, newProps);

          // Wrap it in an absolutely positioning div
          var style = { position: 'absolute', left: x, top: y, width: width, height: height };
          var key = 'viewport-' + viewportId + '-' + i;
          child = (0, _react.createElement)('div', { key: key, id: key, style: style }, clone);
        }

        return child;
      });
    }
  }, {
    key: 'render',
    value: function render() {
      // Render the background elements (typically react-map-gl instances)
      // using the viewport descriptors
      var children = this._renderChildrenUnderViewports();

      // Render deck.gl as last child
      var _props = this.props,
          id = _props.id,
          width = _props.width,
          height = _props.height,
          style = _props.style;

      var deck = (0, _react.createElement)('canvas', {
        ref: 'overlay',
        key: 'overlay',
        id: id,
        style: Object.assign({}, style, { position: 'absolute', left: 0, top: 0, width: width, height: height })
      });
      children.push(deck);

      return (0, _react.createElement)('div', { id: 'deckgl-wrapper' }, children);
    }
  }]);

  return DeckGL;
}(_react2.default.Component);

exports.default = DeckGL;


DeckGL.propTypes = DeckGLJS.propTypes;
DeckGL.defaultProps = DeckGLJS.defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWFjdC9kZWNrZ2wuanMiXSwibmFtZXMiOlsiRGVja0dMSlMiLCJEZWNrR0wiLCJwcm9wcyIsInN0YXRlIiwiZGVjayIsIk9iamVjdCIsImFzc2lnbiIsImNhbnZhcyIsInJlZnMiLCJvdmVybGF5IiwibmV4dFByb3BzIiwic2V0UHJvcHMiLCJmaW5hbGl6ZSIsIngiLCJ5IiwicmFkaXVzIiwibGF5ZXJJZHMiLCJxdWVyeU9iamVjdCIsIndpZHRoIiwiaGVpZ2h0IiwicXVlcnlWaXNpYmxlT2JqZWN0cyIsInZpZXdwb3J0cyIsImdldFZpZXdwb3J0cyIsInZpZXdwb3J0TWFwIiwiZm9yRWFjaCIsInZpZXdwb3J0IiwiX2dldFZpZXdwb3J0RnJvbURlc2NyaXB0b3IiLCJ2aWV3cG9ydERlc2NyaXB0b3IiLCJpZCIsIkNoaWxkcmVuIiwidG9BcnJheSIsImNoaWxkcmVuIiwibWFwIiwiY2hpbGQiLCJpIiwidmlld3BvcnRJZCIsImdldERpbWVuc2lvbnMiLCJuZXdQcm9wcyIsImdldE1lcmNhdG9yUGFyYW1zIiwidmlzaWJsZSIsImlzTWFwU3luY2hlZCIsImNsb25lIiwic3R5bGUiLCJwb3NpdGlvbiIsImxlZnQiLCJ0b3AiLCJrZXkiLCJfcmVuZGVyQ2hpbGRyZW5VbmRlclZpZXdwb3J0cyIsInJlZiIsInB1c2giLCJDb21wb25lbnQiLCJwcm9wVHlwZXMiLCJkZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBb0JBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7K2VBdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztJQUtPQSxRLHNCQUFBQSxROztJQUVjQyxNOzs7QUFFbkIsa0JBQVlDLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxnSEFDWEEsS0FEVzs7QUFFakIsVUFBS0MsS0FBTCxHQUFhLEVBQWI7QUFD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QUFTa0IsSUFBVCxDQUFjN0MsSUFBZDs7QUFFQSxhQUFPLDBCQUFjLEtBQWQsRUFBcUIsRUFBQ3dCLElBQUksZ0JBQUwsRUFBckIsRUFBNkNHLFFBQTdDLENBQVA7QUFFRDs7OztFQXBHaUMsZ0JBQU1tQixTOztrQkFBckJqRCxNOzs7QUF1R3JCQSxPQUFPa0QsU0FBUCxHQUFtQm5ELFNBQVNtRCxTQUE1QjtBQUNBbEQsT0FBT21ELFlBQVAsR0FBc0JwRCxTQUFTb0QsWUFBL0IiLCJmaWxlIjoiZGVja2dsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBSZWFjdCwge2NyZWF0ZUVsZW1lbnQsIGNsb25lRWxlbWVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGF1dG9iaW5kIGZyb20gJy4vdXRpbHMvYXV0b2JpbmQnO1xuaW1wb3J0IHtleHBlcmltZW50YWx9IGZyb20gJy4uL2NvcmUnO1xuY29uc3Qge0RlY2tHTEpTfSA9IGV4cGVyaW1lbnRhbDtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVja0dMIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgYXV0b2JpbmQodGhpcyk7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLmRlY2sgPSBuZXcgRGVja0dMSlMoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge2NhbnZhczogdGhpcy5yZWZzLm92ZXJsYXl9KSk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmICh0aGlzLmRlY2spIHtcbiAgICAgIHRoaXMuZGVjay5zZXRQcm9wcyhuZXh0UHJvcHMpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuZGVjay5maW5hbGl6ZSgpO1xuICB9XG5cbiAgLy8gUHVibGljIEFQSVxuXG4gIHF1ZXJ5T2JqZWN0KHt4LCB5LCByYWRpdXMgPSAwLCBsYXllcklkcyA9IG51bGx9KSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjay5xdWVyeU9iamVjdCh7eCwgeSwgcmFkaXVzLCBsYXllcklkc30pO1xuICB9XG5cbiAgcXVlcnlWaXNpYmxlT2JqZWN0cyh7eCwgeSwgd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBsYXllcklkcyA9IG51bGx9KSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjay5xdWVyeVZpc2libGVPYmplY3RzKHt4LCB5LCB3aWR0aCwgaGVpZ2h0LCBsYXllcklkc30pO1xuICB9XG5cbiAgLy8gUHJpdmF0ZSBIZWxwZXJzXG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHZpZXdwb3J0IGRlc2NyaXB0b3JzIGFuZCByZW5kZXIgY2hpbGRyZW4gYXNzb2NpYXRlIHdpdGggdmlld3BvcnRzXG4gIC8vIGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb25zXG4gIC8vIFRPRE8gLSBDYW4gd2Ugc3VwcGx5IGEgc2ltaWxhciBmdW5jdGlvbiBmb3IgdGhlIG5vbi1SZWFjdCBjYXNlP1xuICBfcmVuZGVyQ2hpbGRyZW5VbmRlclZpZXdwb3J0cygpIHtcbiAgICAvLyBGbGF0dGVuIG91dCBuZXN0ZWQgdmlld3BvcnRzIGFycmF5XG4gICAgY29uc3Qgdmlld3BvcnRzID0gdGhpcy5kZWNrID8gdGhpcy5kZWNrLmdldFZpZXdwb3J0cygpIDogW107XG5cbiAgICAvLyBCdWlsZCBhIHZpZXdwb3J0IGlkIHRvIHZpZXdwb3J0IGluZGV4XG4gICAgY29uc3Qgdmlld3BvcnRNYXAgPSB7fTtcbiAgICB2aWV3cG9ydHMuZm9yRWFjaCh2aWV3cG9ydERlc2NyaXB0b3IgPT4ge1xuICAgICAgY29uc3Qgdmlld3BvcnQgPSB0aGlzLmRlY2suX2dldFZpZXdwb3J0RnJvbURlc2NyaXB0b3Iodmlld3BvcnREZXNjcmlwdG9yKTtcbiAgICAgIGlmICh2aWV3cG9ydC5pZCkge1xuICAgICAgICB2aWV3cG9ydE1hcFt2aWV3cG9ydC5pZF0gPSB2aWV3cG9ydDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBSZWFjdC5DaGlsZHJlbi50b0FycmF5KHRoaXMucHJvcHMuY2hpbGRyZW4pLm1hcCgoY2hpbGQsIGkpID0+IHtcbiAgICAgIC8vIElmIHZpZXdwb3J0SWQgcHJvcCBpcyBwcm92aWRlZCwgbWF0Y2ggd2l0aCB2aWV3cG9ydFxuICAgICAgY29uc3Qge3ZpZXdwb3J0SWR9ID0gY2hpbGQucHJvcHM7XG4gICAgICBjb25zdCB2aWV3cG9ydCA9IHZpZXdwb3J0SWQgJiYgdmlld3BvcnRNYXBbdmlld3BvcnRJZF07XG4gICAgICBpZiAodmlld3BvcnQpIHtcbiAgICAgICAgLy8gUmVzb2x2ZSBwb3RlbnRpYWxseSByZWxhdGl2ZSBkaW1lbnNpb25zIHVzaW5nIHRoZSBkZWNrLmdsIGNvbnRhaW5lciBzaXplXG4gICAgICAgIGNvbnN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSA9XG4gICAgICAgICAgdmlld3BvcnQuZ2V0RGltZW5zaW9ucyh7d2lkdGg6IHRoaXMucHJvcHMud2lkdGgsIGhlaWdodDogdGhpcy5wcm9wcy5oZWlnaHR9KTtcblxuICAgICAgICAvLyBDbG9uZSB0aGUgZWxlbWVudCB3aXRoIHdpZHRoIGFuZCBoZWlnaHQgc2V0IHBlciB2aWV3cG9ydFxuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIGNoaWxkLnByb3BzLCB7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEluamVjdCBtYXAgcHJvcGVydGllc1xuICAgICAgICAvLyBUT0RPIC0gdGhpcyBpcyB0b28gcmVhY3QtbWFwLWdsIHNwZWNpZmljXG4gICAgICAgIE9iamVjdC5hc3NpZ24obmV3UHJvcHMsIHZpZXdwb3J0LmdldE1lcmNhdG9yUGFyYW1zKCksIHtcbiAgICAgICAgICB2aXNpYmxlOiB2aWV3cG9ydC5pc01hcFN5bmNoZWQoKVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjbG9uZSA9IGNsb25lRWxlbWVudChjaGlsZCwgbmV3UHJvcHMpO1xuXG4gICAgICAgIC8vIFdyYXAgaXQgaW4gYW4gYWJzb2x1dGVseSBwb3NpdGlvbmluZyBkaXZcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB7cG9zaXRpb246ICdhYnNvbHV0ZScsIGxlZnQ6IHgsIHRvcDogeSwgd2lkdGgsIGhlaWdodH07XG4gICAgICAgIGNvbnN0IGtleSA9IGB2aWV3cG9ydC0ke3ZpZXdwb3J0SWR9LSR7aX1gO1xuICAgICAgICBjaGlsZCA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtrZXksIGlkOiBrZXksIHN0eWxlfSwgY2xvbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgLy8gUmVuZGVyIHRoZSBiYWNrZ3JvdW5kIGVsZW1lbnRzICh0eXBpY2FsbHkgcmVhY3QtbWFwLWdsIGluc3RhbmNlcylcbiAgICAvLyB1c2luZyB0aGUgdmlld3BvcnQgZGVzY3JpcHRvcnNcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX3JlbmRlckNoaWxkcmVuVW5kZXJWaWV3cG9ydHMoKTtcblxuICAgIC8vIFJlbmRlciBkZWNrLmdsIGFzIGxhc3QgY2hpbGRcbiAgICBjb25zdCB7aWQsIHdpZHRoLCBoZWlnaHQsIHN0eWxlfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZGVjayA9IGNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycsIHtcbiAgICAgIHJlZjogJ292ZXJsYXknLFxuICAgICAga2V5OiAnb3ZlcmxheScsXG4gICAgICBpZCxcbiAgICAgIHN0eWxlOiBPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwge3Bvc2l0aW9uOiAnYWJzb2x1dGUnLCBsZWZ0OiAwLCB0b3A6IDAsIHdpZHRoLCBoZWlnaHR9KVxuICAgIH0pO1xuICAgIGNoaWxkcmVuLnB1c2goZGVjayk7XG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZGl2Jywge2lkOiAnZGVja2dsLXdyYXBwZXInfSwgY2hpbGRyZW4pO1xuXG4gIH1cbn1cblxuRGVja0dMLnByb3BUeXBlcyA9IERlY2tHTEpTLnByb3BUeXBlcztcbkRlY2tHTC5kZWZhdWx0UHJvcHMgPSBEZWNrR0xKUy5kZWZhdWx0UHJvcHM7XG4iXX0=