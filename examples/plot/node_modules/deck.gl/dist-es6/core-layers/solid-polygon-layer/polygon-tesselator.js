var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Handles tesselation of polygons with holes
// - 2D surfaces
// - 2D outlines
// - 3D surfaces (top and sides only)
// - 3D wireframes (not yet)
import * as Polygon from './polygon';
import earcut from 'earcut';
import { get, count, flattenVertices, fillArray } from '../../core/lib/utils';
import { fp64ify } from '../../core/lib/utils/fp64';

// Maybe deck.gl or luma.gl needs to export this
function getPickingColor(index) {
  return [(index + 1) % 256, Math.floor((index + 1) / 256) % 256, Math.floor((index + 1) / 256 / 256) % 256];
}

function parseColor(color) {
  if (!Array.isArray(color)) {
    color = [get(color, 0), get(color, 1), get(color, 2), get(color, 3)];
  }
  color[3] = Number.isFinite(color[3]) ? color[3] : 255;
  return color;
}

var DEFAULT_COLOR = [0, 0, 0, 255]; // Black

// This class is set up to allow querying one attribute at a time
// the way the AttributeManager expects it
export var PolygonTesselator = function () {
  function PolygonTesselator(_ref) {
    var polygons = _ref.polygons,
        _ref$fp = _ref.fp64,
        fp64 = _ref$fp === undefined ? false : _ref$fp;

    _classCallCheck(this, PolygonTesselator);

    // Normalize all polygons
    this.polygons = polygons.map(function (polygon) {
      return Polygon.normalize(polygon);
    });
    // Count all polygon vertices
    this.pointCount = getPointCount(this.polygons);
    this.fp64 = fp64;
  }

  _createClass(PolygonTesselator, [{
    key: 'indices',
    value: function indices() {
      var polygons = this.polygons,
          indexCount = this.indexCount;

      return calculateIndices({ polygons: polygons, indexCount: indexCount });
    }
  }, {
    key: 'positions',
    value: function positions() {
      var polygons = this.polygons,
          pointCount = this.pointCount;

      return calculatePositions({ polygons: polygons, pointCount: pointCount, fp64: this.fp64 });
    }
  }, {
    key: 'normals',
    value: function normals() {
      var polygons = this.polygons,
          pointCount = this.pointCount;

      return calculateNormals({ polygons: polygons, pointCount: pointCount });
    }
  }, {
    key: 'colors',
    value: function colors() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$getColor = _ref2.getColor,
          getColor = _ref2$getColor === undefined ? function (x) {
        return DEFAULT_COLOR;
      } : _ref2$getColor;

      var polygons = this.polygons,
          pointCount = this.pointCount;

      return calculateColors({ polygons: polygons, pointCount: pointCount, getColor: getColor });
    }
  }, {
    key: 'pickingColors',
    value: function pickingColors() {
      var polygons = this.polygons,
          pointCount = this.pointCount;

      return calculatePickingColors({ polygons: polygons, pointCount: pointCount });
    }

    // getAttribute({size, accessor}) {
    //   const {polygons, pointCount} = this;
    //   return calculateAttribute({polygons, pointCount, size, accessor});
    // }

  }]);

  return PolygonTesselator;
}();

// Count number of points in a list of complex polygons
function getPointCount(polygons) {
  return polygons.reduce(function (points, polygon) {
    return points + Polygon.getVertexCount(polygon);
  }, 0);
}

// COunt number of triangles in a list of complex polygons
function getTriangleCount(polygons) {
  return polygons.reduce(function (triangles, polygon) {
    return triangles + Polygon.getTriangleCount(polygon);
  }, 0);
}

// Returns the offsets of each complex polygon in the combined array of all polygons
function getPolygonOffsets(polygons) {
  var offsets = new Array(count(polygons) + 1);
  offsets[0] = 0;
  var offset = 0;
  polygons.forEach(function (polygon, i) {
    offset += Polygon.getVertexCount(polygon);
    offsets[i + 1] = offset;
  });
  return offsets;
}

// Returns the offset of each hole polygon in the flattened array for that polygon
function getHoleIndices(complexPolygon) {
  var holeIndices = null;
  if (count(complexPolygon) > 1) {
    var polygonStartIndex = 0;
    holeIndices = [];
    complexPolygon.forEach(function (polygon) {
      polygonStartIndex += count(polygon);
      holeIndices.push(polygonStartIndex);
    });
    // Last element points to end of the flat array, remove it
    holeIndices.pop();
  }
  return holeIndices;
}

function calculateIndices(_ref3) {
  var polygons = _ref3.polygons,
      _ref3$IndexType = _ref3.IndexType,
      IndexType = _ref3$IndexType === undefined ? Uint32Array : _ref3$IndexType;

  // Calculate length of index array (3 * number of triangles)
  var indexCount = 3 * getTriangleCount(polygons);
  var offsets = getPolygonOffsets(polygons);

  // Allocate the attribute
  // TODO it's not the index count but the vertex count that must be checked
  if (IndexType === Uint16Array && indexCount > 65535) {
    throw new Error('Vertex count exceeds browser\'s limit');
  }
  var attribute = new IndexType(indexCount);

  // 1. get triangulated indices for the internal areas
  // 2. offset them by the number of indices in previous polygons
  var i = 0;
  polygons.forEach(function (polygon, polygonIndex) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = calculateSurfaceIndices(polygon)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var index = _step.value;

        attribute[i++] = index + offsets[polygonIndex];
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  });

  return attribute;
}

/*
 * Get vertex indices for drawing complexPolygon mesh
 * @private
 * @param {[Number,Number,Number][][]} complexPolygon
 * @returns {[Number]} indices
 */
function calculateSurfaceIndices(complexPolygon) {
  // Prepare an array of hole indices as expected by earcut
  var holeIndices = getHoleIndices(complexPolygon);
  // Flatten the polygon as expected by earcut
  var verts = flattenVertices2(complexPolygon);
  // Let earcut triangulate the polygon
  return earcut(verts, holeIndices, 3);
}

// TODO - refactor
function isContainer(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) || value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
}

// TODO - refactor, this file should not need a separate flatten func
// Flattens nested array of vertices, padding third coordinate as needed
export function flattenVertices2(nestedArray) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref4$result = _ref4.result,
      result = _ref4$result === undefined ? [] : _ref4$result,
      _ref4$dimensions = _ref4.dimensions,
      dimensions = _ref4$dimensions === undefined ? 3 : _ref4$dimensions;

  var index = -1;
  var vertexLength = 0;
  var length = count(nestedArray);
  while (++index < length) {
    var value = get(nestedArray, index);
    if (isContainer(value)) {
      flattenVertices(value, { result: result, dimensions: dimensions });
    } else {
      if (vertexLength < dimensions) {
        // eslint-disable-line
        result.push(value);
        vertexLength++;
      }
    }
  }
  // Add a third coordinate if needed
  if (vertexLength > 0 && vertexLength < dimensions) {
    result.push(0);
  }
  return result;
}

function calculatePositions(_ref5) {
  var polygons = _ref5.polygons,
      pointCount = _ref5.pointCount,
      fp64 = _ref5.fp64;

  // Flatten out all the vertices of all the sub subPolygons
  var attribute = new Float32Array(pointCount * 3);
  var attributeLow = void 0;
  if (fp64) {
    // We only need x, y component
    attributeLow = new Float32Array(pointCount * 2);
  }
  var i = 0;
  var j = 0;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = polygons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var polygon = _step2.value;

      Polygon.forEachVertex(polygon, function (vertex) {
        // eslint-disable-line
        var x = get(vertex, 0);
        var y = get(vertex, 1);
        var z = get(vertex, 2) || 0;
        attribute[i++] = x;
        attribute[i++] = y;
        attribute[i++] = z;
        if (fp64) {
          attributeLow[j++] = fp64ify(x)[1];
          attributeLow[j++] = fp64ify(y)[1];
        }
      });
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return { positions: attribute, positions64xyLow: attributeLow };
}

function calculateNormals(_ref6) {
  var polygons = _ref6.polygons,
      pointCount = _ref6.pointCount;

  // TODO - use generic vertex attribute?
  var attribute = new Float32Array(pointCount * 3);
  fillArray({ target: attribute, source: [0, 1, 0], start: 0, pointCount: pointCount });
  return attribute;
}

function calculateColors(_ref7) {
  var polygons = _ref7.polygons,
      pointCount = _ref7.pointCount,
      getColor = _ref7.getColor;

  var attribute = new Uint8ClampedArray(pointCount * 4);
  var i = 0;
  polygons.forEach(function (complexPolygon, polygonIndex) {
    // Calculate polygon color
    var color = getColor(polygonIndex);
    color = parseColor(color);

    var vertexCount = Polygon.getVertexCount(complexPolygon);
    fillArray({ target: attribute, source: color, start: i, count: vertexCount });
    i += color.length * vertexCount;
  });
  return attribute;
}

function calculatePickingColors(_ref8) {
  var polygons = _ref8.polygons,
      pointCount = _ref8.pointCount;

  var attribute = new Uint8ClampedArray(pointCount * 3);
  var i = 0;
  polygons.forEach(function (complexPolygon, polygonIndex) {
    var color = getPickingColor(polygonIndex);
    var vertexCount = Polygon.getVertexCount(complexPolygon);
    fillArray({ target: attribute, source: color, start: i, count: vertexCount });
    i += color.length * vertexCount;
  });
  return attribute;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlLWxheWVycy9zb2xpZC1wb2x5Z29uLWxheWVyL3BvbHlnb24tdGVzc2VsYXRvci5qcyJdLCJuYW1lcyI6WyJQb2x5Z29uIiwiZWFyY3V0IiwiZ2V0IiwiY291bnQiLCJmbGF0dGVuVmVydGljZXMiLCJmaWxsQXJyYXkiLCJmcDY0aWZ5IiwiZ2V0UGlja2luZ0NvbG9yIiwiaW5kZXgiLCJNYXRoIiwiZmxvb3IiLCJwYXJzZUNvbG9yIiwiY29sb3IiLCJBcnJheSIsImlzQXJyYXkiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIkRFRkFVTFRfQ09MT1IiLCJQb2x5Z29uVGVzc2VsYXRvciIsInBvbHlnb25zIiwiZnA2NCIsIm1hcCIsIm5vcm1hbGl6ZSIsInBvbHlnb24iLCJwb2ludENvdW50IiwiZ2V0UG9pbnRDb3VudCIsImluZGV4Q291bnQiLCJjYWxjdWxhdGVJbmRpY2VzIiwiY2FsY3VsYXRlUG9zaXRpb25zIiwiY2FsY3VsYXRlTm9ybWFscyIsImdldENvbG9yIiwiY2FsY3VsYXRlQ29sb3JzIiwiY2FsY3VsYXRlUGlja2luZ0NvbG9ycyIsInJlZHVjZSIsInBvaW50cyIsImdldFZlcnRleENvdW50IiwiZ2V0VHJpYW5nbGVDb3VudCIsInRyaWFuZ2xlcyIsImdldFBvbHlnb25PZmZzZXRzIiwib2Zmc2V0cyIsIm9mZnNldCIsImZvckVhY2giLCJpIiwiZ2V0SG9sZUluZGljZXMiLCJjb21wbGV4UG9seWdvbiIsImhvbGVJbmRpY2VzIiwicG9seWdvblN0YXJ0SW5kZXgiLCJwdXNoIiwicG9wIiwiSW5kZXhUeXBlIiwiVWludDMyQXJyYXkiLCJVaW50MTZBcnJheSIsIkVycm9yIiwiYXR0cmlidXRlIiwicG9seWdvbkluZGV4IiwiY2FsY3VsYXRlU3VyZmFjZUluZGljZXMiLCJ2ZXJ0cyIsImZsYXR0ZW5WZXJ0aWNlczIiLCJpc0NvbnRhaW5lciIsInZhbHVlIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJuZXN0ZWRBcnJheSIsInJlc3VsdCIsImRpbWVuc2lvbnMiLCJ2ZXJ0ZXhMZW5ndGgiLCJsZW5ndGgiLCJGbG9hdDMyQXJyYXkiLCJhdHRyaWJ1dGVMb3ciLCJqIiwiZm9yRWFjaFZlcnRleCIsIngiLCJ2ZXJ0ZXgiLCJ5IiwieiIsInBvc2l0aW9ucyIsInBvc2l0aW9uczY0eHlMb3ciLCJ0YXJnZXQiLCJzb3VyY2UiLCJzdGFydCIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwidmVydGV4Q291bnQiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEtBQUtBLE9BQVosTUFBeUIsV0FBekI7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5CO0FBQ0EsU0FBUUMsR0FBUixFQUFhQyxLQUFiLEVBQW9CQyxlQUFwQixFQUFxQ0MsU0FBckMsUUFBcUQsc0JBQXJEO0FBQ0EsU0FBUUMsT0FBUixRQUFzQiwyQkFBdEI7O0FBRUE7QUFDQSxTQUFTQyxlQUFULENBQXlCQyxLQUF6QixFQUFnQztBQUM5QixTQUFPLENBQ0wsQ0FBQ0EsUUFBUSxDQUFULElBQWMsR0FEVCxFQUVMQyxLQUFLQyxLQUFMLENBQVcsQ0FBQ0YsUUFBUSxDQUFULElBQWMsR0FBekIsSUFBZ0MsR0FGM0IsRUFHTEMsS0FBS0MsS0FBTCxDQUFXLENBQUNGLFFBQVEsQ0FBVCxJQUFjLEdBQWQsR0FBb0IsR0FBL0IsSUFBc0MsR0FIakMsQ0FBUDtBQUtEOztBQUVELFNBQVNHLFVBQVQsQ0FBb0JDLEtBQXBCLEVBQTJCO0FBQ3pCLE1BQUksQ0FBQ0MsTUFBTUMsT0FBTixDQUFjRixLQUFkLENBQUwsRUFBMkI7QUFDekJBLFlBQVEsQ0FBQ1YsSUFBSVUsS0FBSixFQUFXLENBQVgsQ0FBRCxFQUFnQlYsSUFBSVUsS0FBSixFQUFXLENBQVgsQ0FBaEIsRUFBK0JW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QUFVLEVBQUN3RSxRQUFReEIsU0FBVCxFQUFvQnlCLFFBQVFsRSxLQUE1QixFQUFtQ21FLE9BQU9yQyxDQUExQyxFQUE2Q3ZDLE9BQU84RSxXQUFwRCxFQUFWO0FBQ0F2QyxTQUFLOUIsTUFBTXNELE1BQU4sR0FBZWUsV0FBcEI7QUFDRCxHQUxEO0FBTUEsU0FBTzVCLFNBQVA7QUFDRCIsImZpbGUiOiJwb2x5Z29uLXRlc3NlbGF0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLy8gSGFuZGxlcyB0ZXNzZWxhdGlvbiBvZiBwb2x5Z29ucyB3aXRoIGhvbGVzXG4vLyAtIDJEIHN1cmZhY2VzXG4vLyAtIDJEIG91dGxpbmVzXG4vLyAtIDNEIHN1cmZhY2VzICh0b3AgYW5kIHNpZGVzIG9ubHkpXG4vLyAtIDNEIHdpcmVmcmFtZXMgKG5vdCB5ZXQpXG5pbXBvcnQgKiBhcyBQb2x5Z29uIGZyb20gJy4vcG9seWdvbic7XG5pbXBvcnQgZWFyY3V0IGZyb20gJ2VhcmN1dCc7XG5pbXBvcnQge2dldCwgY291bnQsIGZsYXR0ZW5WZXJ0aWNlcywgZmlsbEFycmF5fSBmcm9tICcuLi8uLi9jb3JlL2xpYi91dGlscyc7XG5pbXBvcnQge2ZwNjRpZnl9IGZyb20gJy4uLy4uL2NvcmUvbGliL3V0aWxzL2ZwNjQnO1xuXG4vLyBNYXliZSBkZWNrLmdsIG9yIGx1bWEuZ2wgbmVlZHMgdG8gZXhwb3J0IHRoaXNcbmZ1bmN0aW9uIGdldFBpY2tpbmdDb2xvcihpbmRleCkge1xuICByZXR1cm4gW1xuICAgIChpbmRleCArIDEpICUgMjU2LFxuICAgIE1hdGguZmxvb3IoKGluZGV4ICsgMSkgLyAyNTYpICUgMjU2LFxuICAgIE1hdGguZmxvb3IoKGluZGV4ICsgMSkgLyAyNTYgLyAyNTYpICUgMjU2XG4gIF07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ29sb3IoY29sb3IpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgIGNvbG9yID0gW2dldChjb2xvciwgMCksIGdldChjb2xvciwgMSksIGdldChjb2xvciwgMiksIGdldChjb2xvciwgMyldO1xuICB9XG4gIGNvbG9yWzNdID0gTnVtYmVyLmlzRmluaXRlKGNvbG9yWzNdKSA/IGNvbG9yWzNdIDogMjU1O1xuICByZXR1cm4gY29sb3I7XG59XG5cbmNvbnN0IERFRkFVTFRfQ09MT1IgPSBbMCwgMCwgMCwgMjU1XTsgLy8gQmxhY2tcblxuLy8gVGhpcyBjbGFzcyBpcyBzZXQgdXAgdG8gYWxsb3cgcXVlcnlpbmcgb25lIGF0dHJpYnV0ZSBhdCBhIHRpbWVcbi8vIHRoZSB3YXkgdGhlIEF0dHJpYnV0ZU1hbmFnZXIgZXhwZWN0cyBpdFxuZXhwb3J0IGNsYXNzIFBvbHlnb25UZXNzZWxhdG9yIHtcbiAgY29uc3RydWN0b3Ioe3BvbHlnb25zLCBmcDY0ID0gZmFsc2V9KSB7XG4gICAgLy8gTm9ybWFsaXplIGFsbCBwb2x5Z29uc1xuICAgIHRoaXMucG9seWdvbnMgPSBwb2x5Z29ucy5tYXAocG9seWdvbiA9PiBQb2x5Z29uLm5vcm1hbGl6ZShwb2x5Z29uKSk7XG4gICAgLy8gQ291bnQgYWxsIHBvbHlnb24gdmVydGljZXNcbiAgICB0aGlzLnBvaW50Q291bnQgPSBnZXRQb2ludENvdW50KHRoaXMucG9seWdvbnMpO1xuICAgIHRoaXMuZnA2NCA9IGZwNjQ7XG4gIH1cblxuICBpbmRpY2VzKCkge1xuICAgIGNvbnN0IHtwb2x5Z29ucywgaW5kZXhDb3VudH0gPSB0aGlzO1xuICAgIHJldHVybiBjYWxjdWxhdGVJbmRpY2VzKHtwb2x5Z29ucywgaW5kZXhDb3VudH0pO1xuICB9XG5cbiAgcG9zaXRpb25zKCkge1xuICAgIGNvbnN0IHtwb2x5Z29ucywgcG9pbnRDb3VudH0gPSB0aGlzO1xuICAgIHJldHVybiBjYWxjdWxhdGVQb3NpdGlvbnMoe3BvbHlnb25zLCBwb2ludENvdW50LCBmcDY0OiB0aGlzLmZwNjR9KTtcbiAgfVxuXG4gIG5vcm1hbHMoKSB7XG4gICAgY29uc3Qge3BvbHlnb25zLCBwb2ludENvdW50fSA9IHRoaXM7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZU5vcm1hbHMoe3BvbHlnb25zLCBwb2ludENvdW50fSk7XG4gIH1cblxuICBjb2xvcnMoe2dldENvbG9yID0geCA9PiBERUZBVUxUX0NPTE9SfSA9IHt9KSB7XG4gICAgY29uc3Qge3BvbHlnb25zLCBwb2ludENvdW50fSA9IHRoaXM7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZUNvbG9ycyh7cG9seWdvbnMsIHBvaW50Q291bnQsIGdldENvbG9yfSk7XG4gIH1cblxuICBwaWNraW5nQ29sb3JzKCkge1xuICAgIGNvbnN0IHtwb2x5Z29ucywgcG9pbnRDb3VudH0gPSB0aGlzO1xuICAgIHJldHVybiBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKHtwb2x5Z29ucywgcG9pbnRDb3VudH0pO1xuICB9XG5cbiAgLy8gZ2V0QXR0cmlidXRlKHtzaXplLCBhY2Nlc3Nvcn0pIHtcbiAgLy8gICBjb25zdCB7cG9seWdvbnMsIHBvaW50Q291bnR9ID0gdGhpcztcbiAgLy8gICByZXR1cm4gY2FsY3VsYXRlQXR0cmlidXRlKHtwb2x5Z29ucywgcG9pbnRDb3VudCwgc2l6ZSwgYWNjZXNzb3J9KTtcbiAgLy8gfVxufVxuXG4vLyBDb3VudCBudW1iZXIgb2YgcG9pbnRzIGluIGEgbGlzdCBvZiBjb21wbGV4IHBvbHlnb25zXG5mdW5jdGlvbiBnZXRQb2ludENvdW50KHBvbHlnb25zKSB7XG4gIHJldHVybiBwb2x5Z29ucy5yZWR1Y2UoKHBvaW50cywgcG9seWdvbikgPT4gcG9pbnRzICsgUG9seWdvbi5nZXRWZXJ0ZXhDb3VudChwb2x5Z29uKSwgMCk7XG59XG5cbi8vIENPdW50IG51bWJlciBvZiB0cmlhbmdsZXMgaW4gYSBsaXN0IG9mIGNvbXBsZXggcG9seWdvbnNcbmZ1bmN0aW9uIGdldFRyaWFuZ2xlQ291bnQocG9seWdvbnMpIHtcbiAgcmV0dXJuIHBvbHlnb25zLnJlZHVjZSgodHJpYW5nbGVzLCBwb2x5Z29uKSA9PiB0cmlhbmdsZXMgKyBQb2x5Z29uLmdldFRyaWFuZ2xlQ291bnQocG9seWdvbiksIDApO1xufVxuXG4vLyBSZXR1cm5zIHRoZSBvZmZzZXRzIG9mIGVhY2ggY29tcGxleCBwb2x5Z29uIGluIHRoZSBjb21iaW5lZCBhcnJheSBvZiBhbGwgcG9seWdvbnNcbmZ1bmN0aW9uIGdldFBvbHlnb25PZmZzZXRzKHBvbHlnb25zKSB7XG4gIGNvbnN0IG9mZnNldHMgPSBuZXcgQXJyYXkoY291bnQocG9seWdvbnMpICsgMSk7XG4gIG9mZnNldHNbMF0gPSAwO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgcG9seWdvbnMuZm9yRWFjaCgocG9seWdvbiwgaSkgPT4ge1xuICAgIG9mZnNldCArPSBQb2x5Z29uLmdldFZlcnRleENvdW50KHBvbHlnb24pO1xuICAgIG9mZnNldHNbaSArIDFdID0gb2Zmc2V0O1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbi8vIFJldHVybnMgdGhlIG9mZnNldCBvZiBlYWNoIGhvbGUgcG9seWdvbiBpbiB0aGUgZmxhdHRlbmVkIGFycmF5IGZvciB0aGF0IHBvbHlnb25cbmZ1bmN0aW9uIGdldEhvbGVJbmRpY2VzKGNvbXBsZXhQb2x5Z29uKSB7XG4gIGxldCBob2xlSW5kaWNlcyA9IG51bGw7XG4gIGlmIChjb3VudChjb21wbGV4UG9seWdvbikgPiAxKSB7XG4gICAgbGV0IHBvbHlnb25TdGFydEluZGV4ID0gMDtcbiAgICBob2xlSW5kaWNlcyA9IFtdO1xuICAgIGNvbXBsZXhQb2x5Z29uLmZvckVhY2gocG9seWdvbiA9PiB7XG4gICAgICBwb2x5Z29uU3RhcnRJbmRleCArPSBjb3VudChwb2x5Z29uKTtcbiAgICAgIGhvbGVJbmRpY2VzLnB1c2gocG9seWdvblN0YXJ0SW5kZXgpO1xuICAgIH0pO1xuICAgIC8vIExhc3QgZWxlbWVudCBwb2ludHMgdG8gZW5kIG9mIHRoZSBmbGF0IGFycmF5LCByZW1vdmUgaXRcbiAgICBob2xlSW5kaWNlcy5wb3AoKTtcbiAgfVxuICByZXR1cm4gaG9sZUluZGljZXM7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUluZGljZXMoe3BvbHlnb25zLCBJbmRleFR5cGUgPSBVaW50MzJBcnJheX0pIHtcbiAgLy8gQ2FsY3VsYXRlIGxlbmd0aCBvZiBpbmRleCBhcnJheSAoMyAqIG51bWJlciBvZiB0cmlhbmdsZXMpXG4gIGNvbnN0IGluZGV4Q291bnQgPSAzICogZ2V0VHJpYW5nbGVDb3VudChwb2x5Z29ucyk7XG4gIGNvbnN0IG9mZnNldHMgPSBnZXRQb2x5Z29uT2Zmc2V0cyhwb2x5Z29ucyk7XG5cbiAgLy8gQWxsb2NhdGUgdGhlIGF0dHJpYnV0ZVxuICAvLyBUT0RPIGl0J3Mgbm90IHRoZSBpbmRleCBjb3VudCBidXQgdGhlIHZlcnRleCBjb3VudCB0aGF0IG11c3QgYmUgY2hlY2tlZFxuICBpZiAoSW5kZXhUeXBlID09PSBVaW50MTZBcnJheSAmJiBpbmRleENvdW50ID4gNjU1MzUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBjb3VudCBleGNlZWRzIGJyb3dzZXJcXCdzIGxpbWl0Jyk7XG4gIH1cbiAgY29uc3QgYXR0cmlidXRlID0gbmV3IEluZGV4VHlwZShpbmRleENvdW50KTtcblxuICAvLyAxLiBnZXQgdHJpYW5ndWxhdGVkIGluZGljZXMgZm9yIHRoZSBpbnRlcm5hbCBhcmVhc1xuICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgcG9seWdvbnNcbiAgbGV0IGkgPSAwO1xuICBwb2x5Z29ucy5mb3JFYWNoKChwb2x5Z29uLCBwb2x5Z29uSW5kZXgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzKHBvbHlnb24pKSB7XG4gICAgICBhdHRyaWJ1dGVbaSsrXSA9IGluZGV4ICsgb2Zmc2V0c1twb2x5Z29uSW5kZXhdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGF0dHJpYnV0ZTtcbn1cblxuLypcbiAqIEdldCB2ZXJ0ZXggaW5kaWNlcyBmb3IgZHJhd2luZyBjb21wbGV4UG9seWdvbiBtZXNoXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcixOdW1iZXJdW11bXX0gY29tcGxleFBvbHlnb25cbiAqIEByZXR1cm5zIHtbTnVtYmVyXX0gaW5kaWNlc1xuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyhjb21wbGV4UG9seWdvbikge1xuICAvLyBQcmVwYXJlIGFuIGFycmF5IG9mIGhvbGUgaW5kaWNlcyBhcyBleHBlY3RlZCBieSBlYXJjdXRcbiAgY29uc3QgaG9sZUluZGljZXMgPSBnZXRIb2xlSW5kaWNlcyhjb21wbGV4UG9seWdvbik7XG4gIC8vIEZsYXR0ZW4gdGhlIHBvbHlnb24gYXMgZXhwZWN0ZWQgYnkgZWFyY3V0XG4gIGNvbnN0IHZlcnRzID0gZmxhdHRlblZlcnRpY2VzMihjb21wbGV4UG9seWdvbik7XG4gIC8vIExldCBlYXJjdXQgdHJpYW5ndWxhdGUgdGhlIHBvbHlnb25cbiAgcmV0dXJuIGVhcmN1dCh2ZXJ0cywgaG9sZUluZGljZXMsIDMpO1xufVxuXG4vLyBUT0RPIC0gcmVmYWN0b3JcbmZ1bmN0aW9uIGlzQ29udGFpbmVyKHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpIHx8XG4gICAgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jztcbn1cblxuLy8gVE9ETyAtIHJlZmFjdG9yLCB0aGlzIGZpbGUgc2hvdWxkIG5vdCBuZWVkIGEgc2VwYXJhdGUgZmxhdHRlbiBmdW5jXG4vLyBGbGF0dGVucyBuZXN0ZWQgYXJyYXkgb2YgdmVydGljZXMsIHBhZGRpbmcgdGhpcmQgY29vcmRpbmF0ZSBhcyBuZWVkZWRcbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuVmVydGljZXMyKG5lc3RlZEFycmF5LCB7cmVzdWx0ID0gW10sIGRpbWVuc2lvbnMgPSAzfSA9IHt9KSB7XG4gIGxldCBpbmRleCA9IC0xO1xuICBsZXQgdmVydGV4TGVuZ3RoID0gMDtcbiAgY29uc3QgbGVuZ3RoID0gY291bnQobmVzdGVkQXJyYXkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0KG5lc3RlZEFycmF5LCBpbmRleCk7XG4gICAgaWYgKGlzQ29udGFpbmVyKHZhbHVlKSkge1xuICAgICAgZmxhdHRlblZlcnRpY2VzKHZhbHVlLCB7cmVzdWx0LCBkaW1lbnNpb25zfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2ZXJ0ZXhMZW5ndGggPCBkaW1lbnNpb25zKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB2ZXJ0ZXhMZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gQWRkIGEgdGhpcmQgY29vcmRpbmF0ZSBpZiBuZWVkZWRcbiAgaWYgKHZlcnRleExlbmd0aCA+IDAgJiYgdmVydGV4TGVuZ3RoIDwgZGltZW5zaW9ucykge1xuICAgIHJlc3VsdC5wdXNoKDApO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9ucyh7cG9seWdvbnMsIHBvaW50Q291bnQsIGZwNjR9KSB7XG4gIC8vIEZsYXR0ZW4gb3V0IGFsbCB0aGUgdmVydGljZXMgb2YgYWxsIHRoZSBzdWIgc3ViUG9seWdvbnNcbiAgY29uc3QgYXR0cmlidXRlID0gbmV3IEZsb2F0MzJBcnJheShwb2ludENvdW50ICogMyk7XG4gIGxldCBhdHRyaWJ1dGVMb3c7XG4gIGlmIChmcDY0KSB7XG4gICAgLy8gV2Ugb25seSBuZWVkIHgsIHkgY29tcG9uZW50XG4gICAgYXR0cmlidXRlTG93ID0gbmV3IEZsb2F0MzJBcnJheShwb2ludENvdW50ICogMik7XG4gIH1cbiAgbGV0IGkgPSAwO1xuICBsZXQgaiA9IDA7XG4gIGZvciAoY29uc3QgcG9seWdvbiBvZiBwb2x5Z29ucykge1xuICAgIFBvbHlnb24uZm9yRWFjaFZlcnRleChwb2x5Z29uLCB2ZXJ0ZXggPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICBjb25zdCB4ID0gZ2V0KHZlcnRleCwgMCk7XG4gICAgICBjb25zdCB5ID0gZ2V0KHZlcnRleCwgMSk7XG4gICAgICBjb25zdCB6ID0gZ2V0KHZlcnRleCwgMikgfHwgMDtcbiAgICAgIGF0dHJpYnV0ZVtpKytdID0geDtcbiAgICAgIGF0dHJpYnV0ZVtpKytdID0geTtcbiAgICAgIGF0dHJpYnV0ZVtpKytdID0gejtcbiAgICAgIGlmIChmcDY0KSB7XG4gICAgICAgIGF0dHJpYnV0ZUxvd1tqKytdID0gZnA2NGlmeSh4KVsxXTtcbiAgICAgICAgYXR0cmlidXRlTG93W2orK10gPSBmcDY0aWZ5KHkpWzFdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7cG9zaXRpb25zOiBhdHRyaWJ1dGUsIHBvc2l0aW9uczY0eHlMb3c6IGF0dHJpYnV0ZUxvd307XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZU5vcm1hbHMoe3BvbHlnb25zLCBwb2ludENvdW50fSkge1xuICAvLyBUT0RPIC0gdXNlIGdlbmVyaWMgdmVydGV4IGF0dHJpYnV0ZT9cbiAgY29uc3QgYXR0cmlidXRlID0gbmV3IEZsb2F0MzJBcnJheShwb2ludENvdW50ICogMyk7XG4gIGZpbGxBcnJheSh7dGFyZ2V0OiBhdHRyaWJ1dGUsIHNvdXJjZTogWzAsIDEsIDBdLCBzdGFydDogMCwgcG9pbnRDb3VudH0pO1xuICByZXR1cm4gYXR0cmlidXRlO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVDb2xvcnMoe3BvbHlnb25zLCBwb2ludENvdW50LCBnZXRDb2xvcn0pIHtcbiAgY29uc3QgYXR0cmlidXRlID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHBvaW50Q291bnQgKiA0KTtcbiAgbGV0IGkgPSAwO1xuICBwb2x5Z29ucy5mb3JFYWNoKChjb21wbGV4UG9seWdvbiwgcG9seWdvbkluZGV4KSA9PiB7XG4gICAgLy8gQ2FsY3VsYXRlIHBvbHlnb24gY29sb3JcbiAgICBsZXQgY29sb3IgPSBnZXRDb2xvcihwb2x5Z29uSW5kZXgpO1xuICAgIGNvbG9yID0gcGFyc2VDb2xvcihjb2xvcik7XG5cbiAgICBjb25zdCB2ZXJ0ZXhDb3VudCA9IFBvbHlnb24uZ2V0VmVydGV4Q291bnQoY29tcGxleFBvbHlnb24pO1xuICAgIGZpbGxBcnJheSh7dGFyZ2V0OiBhdHRyaWJ1dGUsIHNvdXJjZTogY29sb3IsIHN0YXJ0OiBpLCBjb3VudDogdmVydGV4Q291bnR9KTtcbiAgICBpICs9IGNvbG9yLmxlbmd0aCAqIHZlcnRleENvdW50O1xuICB9KTtcbiAgcmV0dXJuIGF0dHJpYnV0ZTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUGlja2luZ0NvbG9ycyh7cG9seWdvbnMsIHBvaW50Q291bnR9KSB7XG4gIGNvbnN0IGF0dHJpYnV0ZSA9IG5ldyBVaW50OENsYW1wZWRBcnJheShwb2ludENvdW50ICogMyk7XG4gIGxldCBpID0gMDtcbiAgcG9seWdvbnMuZm9yRWFjaCgoY29tcGxleFBvbHlnb24sIHBvbHlnb25JbmRleCkgPT4ge1xuICAgIGNvbnN0IGNvbG9yID0gZ2V0UGlja2luZ0NvbG9yKHBvbHlnb25JbmRleCk7XG4gICAgY29uc3QgdmVydGV4Q291bnQgPSBQb2x5Z29uLmdldFZlcnRleENvdW50KGNvbXBsZXhQb2x5Z29uKTtcbiAgICBmaWxsQXJyYXkoe3RhcmdldDogYXR0cmlidXRlLCBzb3VyY2U6IGNvbG9yLCBzdGFydDogaSwgY291bnQ6IHZlcnRleENvdW50fSk7XG4gICAgaSArPSBjb2xvci5sZW5ndGggKiB2ZXJ0ZXhDb3VudDtcbiAgfSk7XG4gIHJldHVybiBhdHRyaWJ1dGU7XG59XG4iXX0=