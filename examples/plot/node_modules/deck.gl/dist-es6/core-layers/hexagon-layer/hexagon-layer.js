var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import { CompositeLayer } from '../../core';
import HexagonCellLayer from '../hexagon-cell-layer/hexagon-cell-layer';
import { log } from '../../core/lib/utils';

import BinSorter from '../../core/utils/bin-sorter';
import { getQuantizeScale, getLinearScale } from '../../core/utils/scale-utils';
import { defaultColorRange } from '../../core/utils/color-utils';
import { pointToHexbin } from './hexagon-aggregator';

function nop() {}

var defaultProps = {
  // color
  colorDomain: null,
  colorRange: defaultColorRange,
  getColorValue: function getColorValue(points) {
    return points.length;
  },
  lowerPercentile: 0,
  upperPercentile: 100,
  onSetColorDomain: nop,

  // elevation
  elevationDomain: null,
  elevationRange: [0, 1000],
  getElevationValue: function getElevationValue(points) {
    return points.length;
  },
  elevationLowerPercentile: 0,
  elevationUpperPercentile: 100,
  elevationScale: 1,
  onSetElevationDomain: nop,

  radius: 1000,
  coverage: 1,
  extruded: false,
  hexagonAggregator: pointToHexbin,
  getPosition: function getPosition(x) {
    return x.position;
  },
  fp64: false,
  // Optional settings for 'lighting' shader module
  lightSettings: {
    lightsPosition: [-122.45, 37.75, 8000, -122.0, 38.00, 5000],
    ambientRatio: 0.05,
    diffuseRatio: 0.6,
    specularRatio: 0.8,
    lightsStrength: [2.0, 0.0, 0.0, 0.0],
    numberOfLights: 2
  }
};

var HexagonLayer = function (_CompositeLayer) {
  _inherits(HexagonLayer, _CompositeLayer);

  function HexagonLayer(props) {
    _classCallCheck(this, HexagonLayer);

    if (!props.hexagonAggregator && !props.radius) {
      log.once(0, 'HexagonLayer: Default hexagonAggregator requires radius prop to be set, ' + 'Now using 1000 meter as default');

      props.radius = defaultProps.radius;
    }

    if (Number.isFinite(props.upperPercentile) && (props.upperPercentile > 100 || props.upperPercentile < 0)) {
      log.once(0, 'HexagonLayer: upperPercentile should be between 0 and 100. ' + 'Assign to 100 by default');

      props.upperPercentile = defaultProps.upperPercentile;
    }

    if (Number.isFinite(props.lowerPercentile) && (props.lowerPercentile > 100 || props.lowerPercentile < 0)) {
      log.once(0, 'HexagonLayer: lowerPercentile should be between 0 and 100. ' + 'Assign to 0 by default');

      props.lowerPercentile = defaultProps.upperPercentile;
    }

    if (props.lowerPercentile >= props.upperPercentile) {
      log.once(0, 'HexagonLayer: lowerPercentile should not be bigger than ' + 'upperPercentile. Assign to 0 by default');

      props.lowerPercentile = defaultProps.lowerPercentile;
    }

    return _possibleConstructorReturn(this, (HexagonLayer.__proto__ || Object.getPrototypeOf(HexagonLayer)).call(this, props));
  }

  _createClass(HexagonLayer, [{
    key: 'initializeState',
    value: function initializeState() {
      this.state = {
        hexagons: [],
        hexagonVertices: null,
        sortedColorBins: null,
        sortedElevationBins: null,
        colorValueDomain: null,
        elevationValueDomain: null,
        colorScaleFunc: nop,
        elevationScaleFunc: nop,
        dimensionUpdaters: this.getDimensionUpdaters()
      };
    }
  }, {
    key: 'shouldUpdateState',
    value: function shouldUpdateState(_ref) {
      var changeFlags = _ref.changeFlags;

      return changeFlags.somethingChanged;
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref2) {
      var _this2 = this;

      var oldProps = _ref2.oldProps,
          props = _ref2.props,
          changeFlags = _ref2.changeFlags;

      var dimensionChanges = this.getDimensionChanges(oldProps, props);

      if (changeFlags.dataChanged || this.needsReProjectPoints(oldProps, props)) {
        // project data into hexagons, and get sortedColorBins
        this.getHexagons();
      } else if (dimensionChanges) {
        dimensionChanges.forEach(function (f) {
          return typeof f === 'function' && f.apply(_this2);
        });
      }
    }
  }, {
    key: 'needsReProjectPoints',
    value: function needsReProjectPoints(oldProps, props) {
      return oldProps.radius !== props.radius || oldProps.hexagonAggregator !== props.hexagonAggregator;
    }
  }, {
    key: 'getDimensionUpdaters',
    value: function getDimensionUpdaters() {
      // dimension updaters are sequential,
      // if the first one needs to be called, the 2nd and 3rd one will automatically
      // be called. e.g. if ColorValue needs to be updated, getColorValueDomain and getColorScale
      // will automatically be called
      return {
        getColor: [{
          id: 'value',
          triggers: ['getColorValue'],
          updater: this.getSortedColorBins
        }, {
          id: 'domain',
          triggers: ['lowerPercentile', 'upperPercentile'],
          updater: this.getColorValueDomain
        }, {
          id: 'scaleFunc',
          triggers: ['colorDomain', 'colorRange'],
          updater: this.getColorScale
        }],
        getElevation: [{
          id: 'value',
          triggers: ['getElevationValue'],
          updater: this.getSortedElevationBins
        }, {
          id: 'domain',
          triggers: ['elevationLowerPercentile', 'elevationUpperPercentile'],
          updater: this.getElevationValueDomain
        }, {
          id: 'scaleFunc',
          triggers: ['elevationDomain', 'elevationRange'],
          updater: this.getElevationScale
        }]
      };
    }
  }, {
    key: 'getDimensionChanges',
    value: function getDimensionChanges(oldProps, props) {
      var dimensionUpdaters = this.state.dimensionUpdaters;

      var updaters = [];

      // get dimension to be updated
      for (var dimensionKey in dimensionUpdaters) {

        // return the first triggered updater for each dimension
        var needUpdate = dimensionUpdaters[dimensionKey].find(function (item) {
          return item.triggers.some(function (t) {
            return oldProps[t] !== props[t];
          });
        });

        if (needUpdate) {
          updaters.push(needUpdate.updater);
        }
      }

      return updaters.length ? updaters : null;
    }
  }, {
    key: 'getHexagons',
    value: function getHexagons() {
      var hexagonAggregator = this.props.hexagonAggregator;
      var viewport = this.context.viewport;

      var _hexagonAggregator = hexagonAggregator(this.props, viewport),
          hexagons = _hexagonAggregator.hexagons,
          hexagonVertices = _hexagonAggregator.hexagonVertices;

      this.setState({ hexagons: hexagons, hexagonVertices: hexagonVertices });
      this.getSortedBins();
    }
  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(_ref3) {
      var info = _ref3.info;
      var _state = this.state,
          sortedColorBins = _state.sortedColorBins,
          sortedElevationBins = _state.sortedElevationBins;

      var isPicked = info.picked && info.index > -1;

      var object = null;
      if (isPicked) {

        var cell = this.state.hexagons[info.index];

        var colorValue = sortedColorBins.binMap[cell.index] && sortedColorBins.binMap[cell.index].value;
        var elevationValue = sortedElevationBins.binMap[cell.index] && sortedElevationBins.binMap[cell.index].value;

        object = Object.assign({
          colorValue: colorValue,
          elevationValue: elevationValue
        }, cell);
      }

      // add bin colorValue and elevationValue to info
      return Object.assign(info, {
        picked: Boolean(object),
        // override object with picked cell
        object: object
      });
    }
  }, {
    key: 'getUpdateTriggers',
    value: function getUpdateTriggers() {
      var _this3 = this;

      var dimensionUpdaters = this.state.dimensionUpdaters;

      // merge all dimension triggers

      var updateTriggers = {};

      var _loop = function _loop(dimensionKey) {

        updateTriggers[dimensionKey] = {};

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = dimensionUpdaters[dimensionKey][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var step = _step.value;


            step.triggers.forEach(function (prop) {
              updateTriggers[dimensionKey][prop] = _this3.props[prop];
            });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      };

      for (var dimensionKey in dimensionUpdaters) {
        _loop(dimensionKey);
      }

      return updateTriggers;
    }
  }, {
    key: 'getValueDomain',
    value: function getValueDomain() {
      this.getColorValueDomain();
      this.getElevationValueDomain();
    }
  }, {
    key: 'getSortedBins',
    value: function getSortedBins() {
      this.getSortedColorBins();
      this.getSortedElevationBins();
    }
  }, {
    key: 'getSortedColorBins',
    value: function getSortedColorBins() {
      var getColorValue = this.props.getColorValue;

      var sortedColorBins = new BinSorter(this.state.hexagons || [], getColorValue);

      this.setState({ sortedColorBins: sortedColorBins });
      this.getColorValueDomain();
    }
  }, {
    key: 'getSortedElevationBins',
    value: function getSortedElevationBins() {
      var getElevationValue = this.props.getElevationValue;

      var sortedElevationBins = new BinSorter(this.state.hexagons || [], getElevationValue);
      this.setState({ sortedElevationBins: sortedElevationBins });
      this.getElevationValueDomain();
    }
  }, {
    key: 'getColorValueDomain',
    value: function getColorValueDomain() {
      var _props = this.props,
          lowerPercentile = _props.lowerPercentile,
          upperPercentile = _props.upperPercentile,
          onSetColorDomain = _props.onSetColorDomain;


      this.state.colorValueDomain = this.state.sortedColorBins.getValueRange([lowerPercentile, upperPercentile]);

      if (typeof onSetColorDomain === 'function') {
        onSetColorDomain(this.state.colorValueDomain);
      }

      this.getColorScale();
    }
  }, {
    key: 'getElevationValueDomain',
    value: function getElevationValueDomain() {
      var _props2 = this.props,
          elevationLowerPercentile = _props2.elevationLowerPercentile,
          elevationUpperPercentile = _props2.elevationUpperPercentile,
          onSetElevationDomain = _props2.onSetElevationDomain;


      this.state.elevationValueDomain = this.state.sortedElevationBins.getValueRange([elevationLowerPercentile, elevationUpperPercentile]);

      if (typeof onSetElevationDomain === 'function') {
        onSetElevationDomain(this.state.elevationValueDomain);
      }

      this.getElevationScale();
    }
  }, {
    key: 'getColorScale',
    value: function getColorScale() {
      var colorRange = this.props.colorRange;

      var colorDomain = this.props.colorDomain || this.state.colorValueDomain;

      this.state.colorScaleFunc = getQuantizeScale(colorDomain, colorRange);
    }
  }, {
    key: 'getElevationScale',
    value: function getElevationScale() {
      var elevationRange = this.props.elevationRange;

      var elevationDomain = this.props.elevationDomain || this.state.elevationValueDomain;

      this.state.elevationScaleFunc = getLinearScale(elevationDomain, elevationRange);
    }
  }, {
    key: '_onGetSublayerColor',
    value: function _onGetSublayerColor(cell) {
      var _state2 = this.state,
          sortedColorBins = _state2.sortedColorBins,
          colorScaleFunc = _state2.colorScaleFunc,
          colorValueDomain = _state2.colorValueDomain;


      var cv = sortedColorBins.binMap[cell.index] && sortedColorBins.binMap[cell.index].value;
      var colorDomain = this.props.colorDomain || colorValueDomain;

      var isColorValueInDomain = cv >= colorDomain[0] && cv <= colorDomain[colorDomain.length - 1];

      // if cell value is outside domain, set alpha to 0
      var color = isColorValueInDomain ? colorScaleFunc(cv) : [0, 0, 0, 0];

      // add alpha to color if not defined in colorRange
      color[3] = Number.isFinite(color[3]) ? color[3] : 255;

      return color;
    }
  }, {
    key: '_onGetSublayerElevation',
    value: function _onGetSublayerElevation(cell) {
      var _state3 = this.state,
          sortedElevationBins = _state3.sortedElevationBins,
          elevationScaleFunc = _state3.elevationScaleFunc,
          elevationValueDomain = _state3.elevationValueDomain;

      var ev = sortedElevationBins.binMap[cell.index] && sortedElevationBins.binMap[cell.index].value;

      var elevationDomain = this.props.elevationDomain || elevationValueDomain;

      var isElevationValueInDomain = ev >= elevationDomain[0] && ev <= elevationDomain[elevationDomain.length - 1];

      // if cell value is outside domain, set elevation to -1
      return isElevationValueInDomain ? elevationScaleFunc(ev) : -1;
    }

    // for subclassing, override this method to return
    // customized sub layer props

  }, {
    key: 'getSubLayerProps',
    value: function getSubLayerProps() {
      var _props3 = this.props,
          id = _props3.id,
          radius = _props3.radius,
          elevationScale = _props3.elevationScale,
          extruded = _props3.extruded,
          coverage = _props3.coverage,
          lightSettings = _props3.lightSettings,
          fp64 = _props3.fp64;


      var forwardProps = this.getBaseLayerProps();

      // return props to the sublayer constructor
      return Object.assign({}, forwardProps, {
        id: id + '-hexagon-cell',
        data: this.state.hexagons,

        fp64: fp64,
        hexagonVertices: this.state.hexagonVertices,
        radius: radius,
        elevationScale: elevationScale,
        angle: Math.PI,
        extruded: extruded,
        coverage: coverage,
        lightSettings: lightSettings,

        getColor: this._onGetSublayerColor.bind(this),
        getElevation: this._onGetSublayerElevation.bind(this),
        updateTriggers: this.getUpdateTriggers()
      });
    }

    // for subclassing, override this method to return
    // customized sub layer class

  }, {
    key: 'getSubLayerClass',
    value: function getSubLayerClass() {
      return HexagonCellLayer;
    }
  }, {
    key: 'renderLayers',
    value: function renderLayers() {
      var SubLayerClass = this.getSubLayerClass();

      return new SubLayerClass(this.getSubLayerProps());
    }
  }]);

  return HexagonLayer;
}(CompositeLayer);

export default HexagonLayer;


HexagonLayer.layerName = 'HexagonLayer';
HexagonLayer.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlLWxheWVycy9oZXhhZ29uLWxheWVyL2hleGFnb24tbGF5ZXIuanMiXSwibmFtZXMiOlsiQ29tcG9zaXRlTGF5ZXIiLCJIZXhhZ29uQ2VsbExheWVyIiwibG9nIiwiQmluU29ydGVyIiwiZ2V0UXVhbnRpemVTY2FsZSIsImdldExpbmVhclNjYWxlIiwiZGVmYXVsdENvbG9yUmFuZ2UiLCJwb2ludFRvSGV4YmluIiwibm9wIiwiZGVmYXVsdFByb3BzIiwiY29sb3JEb21haW4iLCJjb2xvclJhbmdlIiwiZ2V0Q29sb3JWYWx1ZSIsInBvaW50cyIsImxlbmd0aCIsImxvd2VyUGVyY2VudGlsZSIsInVwcGVyUGVyY2VudGlsZSIsIm9uU2V0Q29sb3JEb21haW4iLCJlbGV2YXRpb25Eb21haW4iLCJlbGV2YXRpb25SYW5nZSIsImdldEVsZXZhdGlvblZhbHVlIiwiZWxldmF0aW9uTG93ZXJQZXJjZW50aWxlIiwiZWxldmF0aW9uVXBwZXJQZXJjZW50aWxlIiwiZWxldmF0aW9uU2NhbGUiLCJvblNldEVsZXZhdGlvbkRvbWFpbiIsInJhZGl1cyIsImNvdmVyYWdlIiwiZXh0cnVkZWQiLCJoZXhhZ29uQWdncmVnYXRvciIsImdldFBvc2l0aW9uIiwieCIsInBvc2l0aW9uIiwiZnA2NCIsImxpZ2h0U2V0dGluZ3MiLCJsaWdodHNQb3NpdGlvbiIsImFtYmllbnRSYXRpbyIsImRpZmZ1c2VSYXRpbyIsInNwZWN1bGFyUmF0aW8iLCJsaWdodHNTdHJlbmd0aCIsIm51bWJlck9mTGlnaHRzIiwiSGV4YWdvbkxheWVyIiwicHJvcHMiLCJvbmNlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJzdGF0ZSIsImhleGFnb25zIiwiaGV4YWdvblZlcnRpY2VzIiwic29ydGVkQ29sb3JCaW5zIiwic29ydGVkRWxldmF0aW9uQmlucyIsImNvbG9yVmFsdWVEb21haW4iLCJlbGV2YXRpb25WYWx1ZURvbWFpbiIsImNvbG9yU2NhbGVGdW5jIiwiZWxldmF0aW9uU2NhbGVGdW5jIiwiZGltZW5zaW9uVXBkYXRlcnMiLCJnZXREaW1lbnNpb25VcGRhdGVycyIsImNoYW5nZUZsYWdzIiwic29tZXRoaW5nQ2hhbmdlZCIsIm9sZFByb3BzIiwiZGltZW5zaW9uQ2hhbmdlcyIsImdldERpbWVuc2lvbkNoYW5nZXMiLCJkYXRhQ2hhbmdlZCIsIm5lZWRzUmVQcm9qZWN0UG9pbnRzIiwiZ2V0SGV4YWdvbnMiLCJmb3JFYWNoIiwiZiIsImFwcGx5IiwiZ2V0Q29sb3IiLCJpZCIsInRyaWdnZXJzIiwidXBkYXRlciIsImdldFNvcnRlZENvbG9yQmlucyIsImdldENvbG9yVmFsdWVEb21haW4iLCJnZXRDb2xvclNjYWxlIiwiZ2V0RWxldmF0aW9uIiwiZ2V0U29ydGVkRWxldmF0aW9uQmlucyIsImdldEVsZXZhdGlvblZhbHVlRG9tYWluIiwiZ2V0RWxldmF0aW9uU2NhbGUiLCJ1cGRhdGVycyIsImRpbWVuc2lvbktleSIsIm5lZWRVcGRhdGUiLCJmaW5kIiwiaXRlbSIsInNvbWUiLCJ0IiwicHVzaCIsInZpZXdwb3J0IiwiY29udGV4dCIsInNldFN0YXRlIiwiZ2V0U29ydGVkQmlucyIsImluZm8iLCJpc1BpY2tlZCIsInBpY2tlZCIsImluZGV4Iiwib2JqZWN0IiwiY2VsbCIsImNvbG9yVmFsdWUiLCJiaW5NYXAiLCJ2YWx1ZSIsImVsZXZhdGlvblZhbHVlIiwiT2JqZWN0IiwiYXNzaWduIiwiQm9vbGVhbiIsInVwZGF0ZVRyaWdnZXJzIiwic3RlcCIsInByb3AiLCJnZXRWYWx1ZVJhbmdlIiwiY3YiLCJpc0NvbG9yVmFsdWVJbkRvbWFpbiIsImNvbG9yIiwiZXYiLCJpc0VsZXZhdGlvblZhbHVlSW5Eb21haW4iLCJmb3J3YXJkUHJvcHMiLCJnZXRCYXNlTGF5ZXJQcm9wcyIsImRhdGEiLCJhbmdsZSIsIk1hdGgiLCJQSSIsIl9vbkdldFN1YmxheWVyQ29sb3IiLCJiaW5kIiwiX29uR2V0U3VibGF5ZXJFbGV2YXRpb24iLCJnZXRVcGRhdGVUcmlnZ2VycyIsIlN1YkxheWVyQ2xhc3MiLCJnZXRTdWJMYXllckNsYXNzIiwiZ2V0U3ViTGF5ZXJQcm9wcyIsImxheWVyTmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRQSxjQUFSLFFBQTZCLFlBQTdCO0FBQ0EsT0FBT0MsZ0JBQVAsTUFBNkIsMENBQTdCO0FBQ0EsU0FBUUMsR0FBUixRQUFrQixzQkFBbEI7O0FBRUEsT0FBT0MsU0FBUCxNQUFzQiw2QkFBdEI7QUFDQSxTQUFRQyxnQkFBUixFQUEwQkMsY0FBMUIsUUFBK0MsOEJBQS9DO0FBQ0EsU0FBUUMsaUJBQVIsUUFBZ0MsOEJBQWhDO0FBQ0EsU0FBUUMsYUFBUixRQUE0QixzQkFBNUI7O0FBRUEsU0FBU0MsR0FBVCxHQUFlLENBQUU7O0FBRWpCLElBQU1DLGVBQWU7QUFDbkI7QUFDQUMsZUFBYSxJQUZNO0FBR25CQyxjQUFZTCxpQkFITztBQUluQk0saUJBQWU7QUFBQSxXQUFVQyxPQUFPQyxNQUFqQjtBQUFBLEdBSkk7QUFLbkJDLG1CQUFpQixDQUxFO0FBTW5CQyxtQkFBaUIsR0FORTtBQU9uQkMsb0JBQWtCVCxHQVBDOztBQVNuQjtBQUNBVSxtQkFBaUIsSUFWRTtBQVduQkMsa0JBQWdCLENBQUMsQ0FBRCxFQUFJLElBQUosQ0FYRztBQVluQkMscUJBQW1CO0FBQUEsV0FBVVAsT0FBT0MsTUFBakI7QUFBQSxHQVpBO0FBYW5CTyw0QkFBMEIsQ0FiUDtBQWNuQkMsNEJBQTBCLEdBZFA7QUFlbkJDLGtCQUFnQixDQWZHO0FBZ0JuQkMsd0JBQXNCaEIsR0FoQkg7O0FBa0JuQmlCLFVBQVEsSUFsQlc7QUFtQm5CQyxZQUFVLENBbkJTO0FBb0JuQkMsWUFBVSxLQXBCUztBQXFCbkJDLHFCQUFtQnJCLGFBckJBO0FBc0JuQnNCLGVBQWE7QUFBQSxXQUFLQyxFQUFFQyxRQUFQO0FBQUEsR0F0Qk07QUF1Qm5CQyxRQUFNLEtBdkJhO0FBd0JuQjtBQUNBQyxpQkFBZTtBQUNiQyxvQkFBZ0IsQ0FBQyxDQUFDLE1BQUYsRUFBVSxLQUFWLEVBQWlCLElBQWpCLEVBQXVCLENBQUMsS0FBeEIsRUFBK0IsS0FBL0IsRUFBc0MsSUFBdEMsQ0FESDtBQUViQyxrQkFBYyxJQUZEO0FBR2JDLGtCQUFjLEdBSEQ7QUFJYkMsbUJBQWUsR0FKRjtBQUtiQyxvQkFBZ0IsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsR0FBaEIsQ0FMSDtBQU1iQyxvQkFBZ0I7QUFOSDtBQXpCSSxDQUFyQjs7SUFtQ3FCQyxZOzs7QUFDbkIsd0JBQVlDLEtBQVosRUFBbUI7QUFBQTs7QUFDakIsUUFBSSxDQUFDQSxNQUFNYixpQkFBUCxJQUE0QixDQUFDYSxNQUFNaEIsTUFBdkMsRUFBK0M7QUFDN0N2QixVQUFJd0MsSUFBSixDQUFTLENBQVQsRUFBWSw2RUFDVixpQ0FERjs7QUFHQUQsWUFBTWhCLE1BQU4sR0FBZWhCLGFBQWFnQixNQUE1QjtBQUNEOztBQUVELFFBQUlrQixPQUFPQyxRQUFQLENBQWdCSCxNQUFNekIsZUFBdEIsTUFDRHlCLE1BQU16QixlQUFOLEdBQXdCLEdBQXhCLElBQStCeUIsTUFBTXpCLGVBQU4sR0FBd0IsQ0FEdEQsQ0FBSixFQUM4RDtBQUM1RGQsVUFBSXdDLElBQUosQ0FBUyxDQUFULEVBQVksZ0VBQ1YsMEJBREY7O0FBR0FELFlBQU16QixlQUFOLEdBQXdCUCxhQUFhTyxlQUFyQztBQUNEOztBQUVELFFBQUkyQixPQUFPQyxRQUFQLENBQWdCSCxNQUFNMUIsZUFBdEIsTUFDRDBCLE1BQU0xQixlQUFOLEdBQXdCLEdBQXhCLElBQStCMEIsTUFBTTFCLGVBQU4sR0FBd0IsQ0FEdEQsQ0FBSixFQUM4RDtBQUM1RGIsVUFBSXdDLElBQUosQ0FBUyxDQUFULEVBQVksZ0VBQ1Ysd0JBREY7O0FBR0FELFlBQU0xQixlQUFOLEdBQXdCTixhQUFhTyxlQUFyQztBQUNEOztBQUVELFFBQUl5QixNQUFNMUIsZUFBTixJQUF5QjBCLE1BQU16QixlQUFuQyxFQUFvRDtBQUNsRGQsVUFBSXdDLElBQUosQ0FBUyxDQUFULEVBQVksNkRBQ1YseUNBREY7O0FBR0FELFlBQU0xQixlQUFOLEdBQXdCTixhQUFhTSxlQUFyQztBQUNEOztBQTdCZ0IsdUhBK0JYMEIsS0EvQlc7QUFnQ2xCOzs7O3NDQUVpQjtBQUNoQixXQUFLSSxLQUFMLEdBQWE7QUFDWEMsa0JBQVUsRUFEQztBQUVYQyx5QkFBaUIsSUFGTjtBQUdYQyx5QkFBaUIsSUFITjtBQUlYQyw2QkFBcUIsSUFKVjtBQUtYQywwQkFBa0IsSUFMUDtBQU1YQyw4QkFBc0IsSUFOWDtBQU9YQyx3QkFBZ0I1QyxHQVBMO0FBUVg2Qyw0QkFBb0I3QyxHQVJUO0FBU1g4QywyQkFBbUIsS0FBS0Msb0JBQUw7QUFUUixPQUFiO0FBV0Q7Ozs0Q0FFZ0M7QUFBQSxVQUFkQyxXQUFjLFFBQWRBLFdBQWM7O0FBQy9CLGFBQU9BLFlBQVlDLGdCQUFuQjtBQUNEOzs7dUNBRTJDO0FBQUE7O0FBQUEsVUFBL0JDLFFBQStCLFNBQS9CQSxRQUErQjtBQUFBLFVBQXJCakIsS0FBcUIsU0FBckJBLEtBQXFCO0FBQUEsVUFBZGUsV0FBYyxTQUFkQSxXQUFjOztBQUMxQyxVQUFNRyxtQkFBbUIsS0FBS0MsbUJBQUwsQ0FBeUJGLFFBQXpCLEVBQW1DakIsS0FBbkMsQ0FBekI7O0FBRUEsVUFBSWUsWUFBWUssV0FBWixJQUEyQixLQUFLQyxvQkFBTCxDQUEwQkosUUFBMUIsRUFBb0NqQixLQUFwQyxDQUEvQixFQUEyRTtBQUN6RTtBQUNBLGFBQUtzQixXQUFMO0FBRUQsT0FKRCxNQUlPLElBQUlKLGdCQUFKLEVBQXNCO0FBQzNCQSx5QkFBaUJLLE9BQWpCLENBQXlCO0FBQUEsaUJBQUssT0FBT0MsQ0FBUCxLQUFhLFVBQWIsSUFBMkJBLEVBQUVDLEtBQUYsUUFBaEM7QUFBQSxTQUF6QjtBQUNEO0FBQ0Y7Ozt5Q0FFb0JSLFEsRUFBVWpCLEssRUFBTztBQUNwQyxhQUFPaUIsU0FBU2pDLE1BQVQsS0FBb0JnQixNQUFNaEIsTUFBMUIsSUFDTGlDLFNBQVM5QixpQkFBVCxLQUErQmEsTUFBTWIsaUJBRHZDO0FBRUQ7OzsyQ0FFc0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFPO0FBQ0x1QyxrQkFBVSxDQUNSO0FBQ0VDLGNBQUksT0FETjtBQUVFQyxvQkFBVSxDQUFDLGVBQUQsQ0FGWjtBQUdFQyxtQkFBUyxLQUFLQztBQUhoQixTQURRLEVBS0w7QUFDREgsY0FBSSxRQURIO0FBRURDLG9CQUFVLENBQUMsaUJBQUQsRUFBb0IsaUJBQXBCLENBRlQ7QUFHREMsbUJBQVMsS0FBS0U7QUFIYixTQUxLLEVBU0w7QUFDREosY0FBSSxXQURIO0FBRURDLG9CQUFVLENBQUMsYUFBRCxFQUFnQixZQUFoQixDQUZUO0FBR0RDLG1CQUFTLEtBQUtHO0FBSGIsU0FUSyxDQURMO0FBZ0JMQyxzQkFBYyxDQUNaO0FBQ0VOLGNBQUksT0FETjtBQUVFQyxvQkFBVSxDQUFDLG1CQUFELENBRlo7QUFHRUMsbUJBQVMsS0FBS0s7QUFIaEIsU0FEWSxFQUtUO0FBQ0RQLGNBQUksUUFESDtBQUVEQyxvQkFBVSxDQUFDLDBCQUFELEVBQTZCLDBCQUE3QixDQUZUO0FBR0RDLG1CQUFTLEtBQUtNO0FBSGIsU0FMUyxFQVNUO0FBQ0RSLGNBQUksV0FESDtBQUVEQyxvQkFBVSxDQUFDLGlCQUFELEVBQW9CLGdCQUFwQixDQUZUO0FBR0RDLG1CQUFTLEtBQUtPO0FBSGIsU0FUUztBQWhCVCxPQUFQO0FBZ0NEOzs7d0NBRW1CbkIsUSxFQUFVakIsSyxFQUFPO0FBQUEsVUFDNUJhLGlCQUQ0QixHQUNQLEtBQUtULEtBREUsQ0FDNUJTLGlCQUQ0Qjs7QUFFbkMsVUFBTXdCLFdBQVcsRUFBakI7O0FBRUE7QUFDQSxXQUFLLElBQU1DLFlBQVgsSUFBMkJ6QixpQkFBM0IsRUFBOEM7O0FBRTVDO0FBQ0EsWUFBTTBCLGFBQWExQixrQkFBa0J5QixZQUFsQixFQUNoQkUsSUFEZ0IsQ0FDWDtBQUFBLGlCQUFRQyxLQUFLYixRQUFMLENBQWNjLElBQWQsQ0FBbUI7QUFBQSxtQkFBS3pCLFNBQVMwQixDQUFULE1BQWdCM0MsTUFBTTJDLENBQU4sQ0FBckI7QUFBQSxXQUFuQixDQUFSO0FBQUEsU0FEVyxDQUFuQjs7QUFHQSxZQUFJSixVQUFKLEVBQWdCO0FBQ2RGLG1CQUFTTyxJQUFULENBQWNMLFdBQVdWLE9BQXpCO0FBQ0Q7QUFDRjs7QUFFRCxhQUFPUSxTQUFTaEUsTUFBVCxHQUFrQmdFLFFBQWxCLEdBQTZCLElBQXBDO0FBQ0Q7OztrQ0FFYTtBQUFBLFVBQ0xsRCxpQkFESyxHQUNnQixLQUFLYSxLQURyQixDQUNMYixpQkFESztBQUFBLFVBRUwwRCxRQUZLLEdBRU8sS0FBS0MsT0FGWixDQUVMRCxRQUZLOztBQUFBLCtCQUd3QjFELGtCQUFrQixLQUFLYSxLQUF2QixFQUE4QjZDLFFBQTlCLENBSHhCO0FBQUEsVUFHTHhDLFFBSEssc0JBR0xBLFFBSEs7QUFBQSxVQUdLQyxlQUhMLHNCQUdLQSxlQUhMOztBQUlaLFdBQUt5QyxRQUFMLENBQWMsRUFBQzFDLGtCQUFELEVBQVdDLGdDQUFYLEVBQWQ7QUFDQSxXQUFLMEMsYUFBTDtBQUNEOzs7MENBRXNCO0FBQUEsVUFBUEMsSUFBTyxTQUFQQSxJQUFPO0FBQUEsbUJBQzBCLEtBQUs3QyxLQUQvQjtBQUFBLFVBQ2RHLGVBRGMsVUFDZEEsZUFEYztBQUFBLFVBQ0dDLG1CQURILFVBQ0dBLG1CQURIOztBQUVyQixVQUFNMEMsV0FBV0QsS0FBS0UsTUFBTCxJQUFlRixLQUFLRyxLQUFMLEdBQWEsQ0FBQyxDQUE5Qzs7QUFFQSxVQUFJQyxTQUFTLElBQWI7QUFDQSxVQUFJSCxRQUFKLEVBQWM7O0FBRVosWUFBTUksT0FBTyxLQUFLbEQsS0FBTCxDQUFXQyxRQUFYLENBQW9CNEMsS0FBS0csS0FBekIsQ0FBYjs7QUFFQSxZQUFNRyxhQUFhaEQsZ0JBQWdCaUQsTUFBaEIsQ0FBdUJGLEtBQUtGLEtBQTVCLEtBQ2pCN0MsZ0JBQWdCaUQsTUFBaEIsQ0FBdUJGLEtBQUtGLEtBQTVCLEVBQW1DSyxLQURyQztBQUVBLFlBQU1DLGlCQUFpQmxELG9CQUFvQmdELE1BQXBCLENBQTJCRixLQUFLRixLQUFoQyxLQUNyQjVDLG9CQUFvQmdELE1BQXBCLENBQTJCRixLQUFLRixLQUFoQyxFQUF1Q0ssS0FEekM7O0FBR0FKLGlCQUFTTSxPQUFPQyxNQUFQLENBQWM7QUFDckJMLGdDQURxQjtBQUVyQkc7QUFGcUIsU0FBZCxFQUdOSixJQUhNLENBQVQ7QUFJRDs7QUFFRDtBQUNBLGFBQU9LLE9BQU9DLE1BQVAsQ0FBY1gsSUFBZCxFQUFvQjtBQUN6QkUsZ0JBQVFVLFFBQVFSLE1BQVIsQ0FEaUI7QUFFekI7QUFDQUE7QUFIeUIsT0FBcEIsQ0FBUDtBQUtEOzs7d0NBRW1CO0FBQUE7O0FBQUEsVUFDWHhDLGlCQURXLEdBQ1UsS0FBS1QsS0FEZixDQUNYUyxpQkFEVzs7QUFHbEI7O0FBQ0EsVUFBTWlELGlCQUFpQixFQUF2Qjs7QUFKa0IsaUNBTVB4QixZQU5POztBQVFoQndCLHVCQUFleEIsWUFBZixJQUErQixFQUEvQjs7QUFSZ0I7QUFBQTtBQUFBOztBQUFBO0FBVWhCLCtCQUFtQnpCLGtCQUFrQnlCLFlBQWxCLENBQW5CLDhIQUFvRDtBQUFBLGdCQUF6Q3lCLElBQXlDOzs7QUFFbERBLGlCQUFLbkMsUUFBTCxDQUFjTCxPQUFkLENBQXNCLGdCQUFRO0FBQzVCdUMsNkJBQWV4QixZQUFmLEVBQTZCMEIsSUFBN0IsSUFBcUMsT0FBS2hFLEtBQUwsQ0FBV2dFLElBQVgsQ0FBckM7QUFDRCxhQUZEO0FBSUQ7QUFoQmU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU1sQixXQUFLLElBQU0xQixZQUFYLElBQTJCekIsaUJBQTNCLEVBQThDO0FBQUEsY0FBbkN5QixZQUFtQztBQVc3Qzs7QUFFRCxhQUFPd0IsY0FBUDtBQUNEOzs7cUNBRWdCO0FBQ2YsV0FBSy9CLG1CQUFMO0FBQ0EsV0FBS0ksdUJBQUw7QUFDRDs7O29DQUVlO0FBQ2QsV0FBS0wsa0JBQUw7QUFDQSxXQUFLSSxzQkFBTDtBQUNEOzs7eUNBRW9CO0FBQUEsVUFDWi9ELGFBRFksR0FDSyxLQUFLNkIsS0FEVixDQUNaN0IsYUFEWTs7QUFFbkIsVUFBTW9DLGtCQUFrQixJQUFJN0MsU0FBSixDQUFjLEtBQUswQyxLQUFMLENBQVdDLFFBQVgsSUFBdUIsRUFBckMsRUFBeUNsQyxhQUF6QyxDQUF4Qjs7QUFFQSxXQUFLNEUsUUFBTCxDQUFjLEVBQUN4QyxnQ0FBRCxFQUFkO0FBQ0EsV0FBS3dCLG1CQUFMO0FBQ0Q7Ozs2Q0FFd0I7QUFBQSxVQUNoQnBELGlCQURnQixHQUNLLEtBQUtxQixLQURWLENBQ2hCckIsaUJBRGdCOztBQUV2QixVQUFNNkIsc0JBQXNCLElBQUk5QyxTQUFKLENBQWMsS0FBSzBDLEtBQUwsQ0FBV0MsUUFBWCxJQUF1QixFQUFyQyxFQUF5QzFCLGlCQUF6QyxDQUE1QjtBQUNBLFdBQUtvRSxRQUFMLENBQWMsRUFBQ3ZDLHdDQUFELEVBQWQ7QUFDQSxXQUFLMkIsdUJBQUw7QUFDRDs7OzBDQUVxQjtBQUFBLG1CQUN5QyxLQUFLbkMsS0FEOUM7QUFBQSxVQUNiMUIsZUFEYSxVQUNiQSxlQURhO0FBQUEsVUFDSUMsZUFESixVQUNJQSxlQURKO0FBQUEsVUFDcUJDLGdCQURyQixVQUNxQkEsZ0JBRHJCOzs7QUFHcEIsV0FBSzRCLEtBQUwsQ0FBV0ssZ0JBQVgsR0FBOEIsS0FBS0wsS0FBTCxDQUFXRyxlQUFYLENBQzNCMEQsYUFEMkIsQ0FDYixDQUFDM0YsZUFBRCxFQUFrQkMsZUFBbEIsQ0FEYSxDQUE5Qjs7QUFHQSxVQUFJLE9BQU9DLGdCQUFQLEtBQTRCLFVBQWhDLEVBQTRDO0FBQzFDQSx5QkFBaUIsS0FBSzRCLEtBQUwsQ0FBV0ssZ0JBQTVCO0FBQ0Q7O0FBRUQsV0FBS3VCLGFBQUw7QUFDRDs7OzhDQUV5QjtBQUFBLG9CQUMyRCxLQUFLaEMsS0FEaEU7QUFBQSxVQUNqQnBCLHdCQURpQixXQUNqQkEsd0JBRGlCO0FBQUEsVUFDU0Msd0JBRFQsV0FDU0Esd0JBRFQ7QUFBQSxVQUNtQ0Usb0JBRG5DLFdBQ21DQSxvQkFEbkM7OztBQUd4QixXQUFLcUIsS0FBTCxDQUFXTSxvQkFBWCxHQUFrQyxLQUFLTixLQUFMLENBQVdJLG1CQUFYLENBQy9CeUQsYUFEK0IsQ0FDakIsQ0FBQ3JGLHdCQUFELEVBQTJCQyx3QkFBM0IsQ0FEaUIsQ0FBbEM7O0FBR0EsVUFBSSxPQUFPRSxvQkFBUCxLQUFnQyxVQUFwQyxFQUFnRDtBQUM5Q0EsNkJBQXFCLEtBQUtxQixLQUFMLENBQVdNLG9CQUFoQztBQUNEOztBQUVELFdBQUswQixpQkFBTDtBQUNEOzs7b0NBRWU7QUFBQSxVQUNQbEUsVUFETyxHQUNPLEtBQUs4QixLQURaLENBQ1A5QixVQURPOztBQUVkLFVBQU1ELGNBQWMsS0FBSytCLEtBQUwsQ0FBVy9CLFdBQVgsSUFBMEIsS0FBS21DLEtBQUwsQ0FBV0ssZ0JBQXpEOztBQUVBLFdBQUtMLEtBQUwsQ0FBV08sY0FBWCxHQUE0QmhELGlCQUFpQk0sV0FBakIsRUFBOEJDLFVBQTlCLENBQTVCO0FBQ0Q7Ozt3Q0FFbUI7QUFBQSxVQUNYUSxjQURXLEdBQ08sS0FBS3NCLEtBRFosQ0FDWHRCLGNBRFc7O0FBRWxCLFVBQU1ELGtCQUFrQixLQUFLdUIsS0FBTCxDQUFXdkIsZUFBWCxJQUE4QixLQUFLMkIsS0FBTCxDQUFXTSxvQkFBakU7O0FBRUEsV0FBS04sS0FBTCxDQUFXUSxrQkFBWCxHQUFnQ2hELGVBQWVhLGVBQWYsRUFBZ0NDLGNBQWhDLENBQWhDO0FBQ0Q7Ozt3Q0FFbUI0RSxJLEVBQU07QUFBQSxvQkFDb0MsS0FBS2xELEtBRHpDO0FBQUEsVUFDakJHLGVBRGlCLFdBQ2pCQSxlQURpQjtBQUFBLFVBQ0FJLGNBREEsV0FDQUEsY0FEQTtBQUFBLFVBQ2dCRixnQkFEaEIsV0FDZ0JBLGdCQURoQjs7O0FBR3hCLFVBQU15RCxLQUFLM0QsZ0JBQWdCaUQsTUFBaEIsQ0FBdUJGLEtBQUtGLEtBQTVCLEtBQXNDN0MsZ0JBQWdCaUQsTUFBaEIsQ0FBdUJGLEtBQUtGLEtBQTVCLEVBQW1DSyxLQUFwRjtBQUNBLFVBQU14RixjQUFjLEtBQUsrQixLQUFMLENBQVcvQixXQUFYLElBQTBCd0MsZ0JBQTlDOztBQUVBLFVBQU0wRCx1QkFBdUJELE1BQU1qRyxZQUFZLENBQVosQ0FBTixJQUF3QmlHLE1BQU1qRyxZQUFZQSxZQUFZSSxNQUFaLEdBQXFCLENBQWpDLENBQTNEOztBQUVBO0FBQ0EsVUFBTStGLFFBQVFELHVCQUF1QnhELGVBQWV1RCxFQUFmLENBQXZCLEdBQTRDLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQUExRDs7QUFFQTtBQUNBRSxZQUFNLENBQU4sSUFBV2xFLE9BQU9DLFFBQVAsQ0FBZ0JpRSxNQUFNLENBQU4sQ0FBaEIsSUFBNEJBLE1BQU0sQ0FBTixDQUE1QixHQUF1QyxHQUFsRDs7QUFFQSxhQUFPQSxLQUFQO0FBQ0Q7Ozs0Q0FFdUJkLEksRUFBTTtBQUFBLG9CQUM0QyxLQUFLbEQsS0FEakQ7QUFBQSxVQUNyQkksbUJBRHFCLFdBQ3JCQSxtQkFEcUI7QUFBQSxVQUNBSSxrQkFEQSxXQUNBQSxrQkFEQTtBQUFBLFVBQ29CRixvQkFEcEIsV0FDb0JBLG9CQURwQjs7QUFFNUIsVUFBTTJELEtBQUs3RCxvQkFBb0JnRCxNQUFwQixDQUEyQkYsS0FBS0YsS0FBaEMsS0FDVDVDLG9CQUFvQmdELE1BQXBCLENBQTJCRixLQUFLRixLQUFoQyxFQUF1Q0ssS0FEekM7O0FBR0EsVUFBTWhGLGtCQUFrQixLQUFLdUIsS0FBTCxDQUFXdkIsZUFBWCxJQUE4QmlDLG9CQUF0RDs7QUFFQSxVQUFNNEQsMkJBQTJCRCxNQUFNNUYsZ0JBQWdCLENBQWhCLENBQU4sSUFDL0I0RixNQUFNNUYsZ0JBQWdCQSxnQkFBZ0JKLE1BQWhCLEdBQXlCLENBQXpDLENBRFI7O0FBR0E7QUFDQSxhQUFPaUcsMkJBQTJCMUQsbUJBQW1CeUQsRUFBbkIsQ0FBM0IsR0FBb0QsQ0FBQyxDQUE1RDtBQUNEOztBQUVEO0FBQ0E7Ozs7dUNBQ21CO0FBQUEsb0JBQzZELEtBQUtyRSxLQURsRTtBQUFBLFVBQ1YyQixFQURVLFdBQ1ZBLEVBRFU7QUFBQSxVQUNOM0MsTUFETSxXQUNOQSxNQURNO0FBQUEsVUFDRUYsY0FERixXQUNFQSxjQURGO0FBQUEsVUFDa0JJLFFBRGxCLFdBQ2tCQSxRQURsQjtBQUFBLFVBQzRCRCxRQUQ1QixXQUM0QkEsUUFENUI7QUFBQSxVQUNzQ08sYUFEdEMsV0FDc0NBLGFBRHRDO0FBQUEsVUFDcURELElBRHJELFdBQ3FEQSxJQURyRDs7O0FBR2pCLFVBQU1nRixlQUFlLEtBQUtDLGlCQUFMLEVBQXJCOztBQUVBO0FBQ0EsYUFBT2IsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JXLFlBQWxCLEVBQWdDO0FBQ3JDNUMsWUFBT0EsRUFBUCxrQkFEcUM7QUFFckM4QyxjQUFNLEtBQUtyRSxLQUFMLENBQVdDLFFBRm9COztBQUlyQ2Qsa0JBSnFDO0FBS3JDZSx5QkFBaUIsS0FBS0YsS0FBTCxDQUFXRSxlQUxTO0FBTXJDdEIsc0JBTnFDO0FBT3JDRixzQ0FQcUM7QUFRckM0RixlQUFPQyxLQUFLQyxFQVJ5QjtBQVNyQzFGLDBCQVRxQztBQVVyQ0QsMEJBVnFDO0FBV3JDTyxvQ0FYcUM7O0FBYXJDa0Msa0JBQVUsS0FBS21ELG1CQUFMLENBQXlCQyxJQUF6QixDQUE4QixJQUE5QixDQWIyQjtBQWNyQzdDLHNCQUFjLEtBQUs4Qyx1QkFBTCxDQUE2QkQsSUFBN0IsQ0FBa0MsSUFBbEMsQ0FkdUI7QUFlckNoQix3QkFBZ0IsS0FBS2tCLGlCQUFMO0FBZnFCLE9BQWhDLENBQVA7QUFpQkQ7O0FBRUQ7QUFDQTs7Ozt1Q0FDbUI7QUFDakIsYUFBT3hILGdCQUFQO0FBQ0Q7OzttQ0FFYztBQUNiLFVBQU15SCxnQkFBZ0IsS0FBS0MsZ0JBQUwsRUFBdEI7O0FBRUEsYUFBTyxJQUFJRCxhQUFKLENBQ0wsS0FBS0UsZ0JBQUwsRUFESyxDQUFQO0FBR0Q7Ozs7RUFqVXVDNUgsYzs7ZUFBckJ3QyxZOzs7QUFvVXJCQSxhQUFhcUYsU0FBYixHQUF5QixjQUF6QjtBQUNBckYsYUFBYS9CLFlBQWIsR0FBNEJBLFlBQTVCIiwiZmlsZSI6ImhleGFnb24tbGF5ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtDb21wb3NpdGVMYXllcn0gZnJvbSAnLi4vLi4vY29yZSc7XG5pbXBvcnQgSGV4YWdvbkNlbGxMYXllciBmcm9tICcuLi9oZXhhZ29uLWNlbGwtbGF5ZXIvaGV4YWdvbi1jZWxsLWxheWVyJztcbmltcG9ydCB7bG9nfSBmcm9tICcuLi8uLi9jb3JlL2xpYi91dGlscyc7XG5cbmltcG9ydCBCaW5Tb3J0ZXIgZnJvbSAnLi4vLi4vY29yZS91dGlscy9iaW4tc29ydGVyJztcbmltcG9ydCB7Z2V0UXVhbnRpemVTY2FsZSwgZ2V0TGluZWFyU2NhbGV9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMvc2NhbGUtdXRpbHMnO1xuaW1wb3J0IHtkZWZhdWx0Q29sb3JSYW5nZX0gZnJvbSAnLi4vLi4vY29yZS91dGlscy9jb2xvci11dGlscyc7XG5pbXBvcnQge3BvaW50VG9IZXhiaW59IGZyb20gJy4vaGV4YWdvbi1hZ2dyZWdhdG9yJztcblxuZnVuY3Rpb24gbm9wKCkge31cblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICAvLyBjb2xvclxuICBjb2xvckRvbWFpbjogbnVsbCxcbiAgY29sb3JSYW5nZTogZGVmYXVsdENvbG9yUmFuZ2UsXG4gIGdldENvbG9yVmFsdWU6IHBvaW50cyA9PiBwb2ludHMubGVuZ3RoLFxuICBsb3dlclBlcmNlbnRpbGU6IDAsXG4gIHVwcGVyUGVyY2VudGlsZTogMTAwLFxuICBvblNldENvbG9yRG9tYWluOiBub3AsXG5cbiAgLy8gZWxldmF0aW9uXG4gIGVsZXZhdGlvbkRvbWFpbjogbnVsbCxcbiAgZWxldmF0aW9uUmFuZ2U6IFswLCAxMDAwXSxcbiAgZ2V0RWxldmF0aW9uVmFsdWU6IHBvaW50cyA9PiBwb2ludHMubGVuZ3RoLFxuICBlbGV2YXRpb25Mb3dlclBlcmNlbnRpbGU6IDAsXG4gIGVsZXZhdGlvblVwcGVyUGVyY2VudGlsZTogMTAwLFxuICBlbGV2YXRpb25TY2FsZTogMSxcbiAgb25TZXRFbGV2YXRpb25Eb21haW46IG5vcCxcblxuICByYWRpdXM6IDEwMDAsXG4gIGNvdmVyYWdlOiAxLFxuICBleHRydWRlZDogZmFsc2UsXG4gIGhleGFnb25BZ2dyZWdhdG9yOiBwb2ludFRvSGV4YmluLFxuICBnZXRQb3NpdGlvbjogeCA9PiB4LnBvc2l0aW9uLFxuICBmcDY0OiBmYWxzZSxcbiAgLy8gT3B0aW9uYWwgc2V0dGluZ3MgZm9yICdsaWdodGluZycgc2hhZGVyIG1vZHVsZVxuICBsaWdodFNldHRpbmdzOiB7XG4gICAgbGlnaHRzUG9zaXRpb246IFstMTIyLjQ1LCAzNy43NSwgODAwMCwgLTEyMi4wLCAzOC4wMCwgNTAwMF0sXG4gICAgYW1iaWVudFJhdGlvOiAwLjA1LFxuICAgIGRpZmZ1c2VSYXRpbzogMC42LFxuICAgIHNwZWN1bGFyUmF0aW86IDAuOCxcbiAgICBsaWdodHNTdHJlbmd0aDogWzIuMCwgMC4wLCAwLjAsIDAuMF0sXG4gICAgbnVtYmVyT2ZMaWdodHM6IDJcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGV4YWdvbkxheWVyIGV4dGVuZHMgQ29tcG9zaXRlTGF5ZXIge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIGlmICghcHJvcHMuaGV4YWdvbkFnZ3JlZ2F0b3IgJiYgIXByb3BzLnJhZGl1cykge1xuICAgICAgbG9nLm9uY2UoMCwgJ0hleGFnb25MYXllcjogRGVmYXVsdCBoZXhhZ29uQWdncmVnYXRvciByZXF1aXJlcyByYWRpdXMgcHJvcCB0byBiZSBzZXQsICcgK1xuICAgICAgICAnTm93IHVzaW5nIDEwMDAgbWV0ZXIgYXMgZGVmYXVsdCcpO1xuXG4gICAgICBwcm9wcy5yYWRpdXMgPSBkZWZhdWx0UHJvcHMucmFkaXVzO1xuICAgIH1cblxuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUocHJvcHMudXBwZXJQZXJjZW50aWxlKSAmJlxuICAgICAgKHByb3BzLnVwcGVyUGVyY2VudGlsZSA+IDEwMCB8fCBwcm9wcy51cHBlclBlcmNlbnRpbGUgPCAwKSkge1xuICAgICAgbG9nLm9uY2UoMCwgJ0hleGFnb25MYXllcjogdXBwZXJQZXJjZW50aWxlIHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4gJyArXG4gICAgICAgICdBc3NpZ24gdG8gMTAwIGJ5IGRlZmF1bHQnKTtcblxuICAgICAgcHJvcHMudXBwZXJQZXJjZW50aWxlID0gZGVmYXVsdFByb3BzLnVwcGVyUGVyY2VudGlsZTtcbiAgICB9XG5cbiAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHByb3BzLmxvd2VyUGVyY2VudGlsZSkgJiZcbiAgICAgIChwcm9wcy5sb3dlclBlcmNlbnRpbGUgPiAxMDAgfHwgcHJvcHMubG93ZXJQZXJjZW50aWxlIDwgMCkpIHtcbiAgICAgIGxvZy5vbmNlKDAsICdIZXhhZ29uTGF5ZXI6IGxvd2VyUGVyY2VudGlsZSBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAxMDAuICcgK1xuICAgICAgICAnQXNzaWduIHRvIDAgYnkgZGVmYXVsdCcpO1xuXG4gICAgICBwcm9wcy5sb3dlclBlcmNlbnRpbGUgPSBkZWZhdWx0UHJvcHMudXBwZXJQZXJjZW50aWxlO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5sb3dlclBlcmNlbnRpbGUgPj0gcHJvcHMudXBwZXJQZXJjZW50aWxlKSB7XG4gICAgICBsb2cub25jZSgwLCAnSGV4YWdvbkxheWVyOiBsb3dlclBlcmNlbnRpbGUgc2hvdWxkIG5vdCBiZSBiaWdnZXIgdGhhbiAnICtcbiAgICAgICAgJ3VwcGVyUGVyY2VudGlsZS4gQXNzaWduIHRvIDAgYnkgZGVmYXVsdCcpO1xuXG4gICAgICBwcm9wcy5sb3dlclBlcmNlbnRpbGUgPSBkZWZhdWx0UHJvcHMubG93ZXJQZXJjZW50aWxlO1xuICAgIH1cblxuICAgIHN1cGVyKHByb3BzKTtcbiAgfVxuXG4gIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaGV4YWdvbnM6IFtdLFxuICAgICAgaGV4YWdvblZlcnRpY2VzOiBudWxsLFxuICAgICAgc29ydGVkQ29sb3JCaW5zOiBudWxsLFxuICAgICAgc29ydGVkRWxldmF0aW9uQmluczogbnVsbCxcbiAgICAgIGNvbG9yVmFsdWVEb21haW46IG51bGwsXG4gICAgICBlbGV2YXRpb25WYWx1ZURvbWFpbjogbnVsbCxcbiAgICAgIGNvbG9yU2NhbGVGdW5jOiBub3AsXG4gICAgICBlbGV2YXRpb25TY2FsZUZ1bmM6IG5vcCxcbiAgICAgIGRpbWVuc2lvblVwZGF0ZXJzOiB0aGlzLmdldERpbWVuc2lvblVwZGF0ZXJzKClcbiAgICB9O1xuICB9XG5cbiAgc2hvdWxkVXBkYXRlU3RhdGUoe2NoYW5nZUZsYWdzfSkge1xuICAgIHJldHVybiBjaGFuZ2VGbGFncy5zb21ldGhpbmdDaGFuZ2VkO1xuICB9XG5cbiAgdXBkYXRlU3RhdGUoe29sZFByb3BzLCBwcm9wcywgY2hhbmdlRmxhZ3N9KSB7XG4gICAgY29uc3QgZGltZW5zaW9uQ2hhbmdlcyA9IHRoaXMuZ2V0RGltZW5zaW9uQ2hhbmdlcyhvbGRQcm9wcywgcHJvcHMpO1xuXG4gICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkIHx8IHRoaXMubmVlZHNSZVByb2plY3RQb2ludHMob2xkUHJvcHMsIHByb3BzKSkge1xuICAgICAgLy8gcHJvamVjdCBkYXRhIGludG8gaGV4YWdvbnMsIGFuZCBnZXQgc29ydGVkQ29sb3JCaW5zXG4gICAgICB0aGlzLmdldEhleGFnb25zKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRpbWVuc2lvbkNoYW5nZXMpIHtcbiAgICAgIGRpbWVuc2lvbkNoYW5nZXMuZm9yRWFjaChmID0+IHR5cGVvZiBmID09PSAnZnVuY3Rpb24nICYmIGYuYXBwbHkodGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIG5lZWRzUmVQcm9qZWN0UG9pbnRzKG9sZFByb3BzLCBwcm9wcykge1xuICAgIHJldHVybiBvbGRQcm9wcy5yYWRpdXMgIT09IHByb3BzLnJhZGl1cyB8fFxuICAgICAgb2xkUHJvcHMuaGV4YWdvbkFnZ3JlZ2F0b3IgIT09IHByb3BzLmhleGFnb25BZ2dyZWdhdG9yO1xuICB9XG5cbiAgZ2V0RGltZW5zaW9uVXBkYXRlcnMoKSB7XG4gICAgLy8gZGltZW5zaW9uIHVwZGF0ZXJzIGFyZSBzZXF1ZW50aWFsLFxuICAgIC8vIGlmIHRoZSBmaXJzdCBvbmUgbmVlZHMgdG8gYmUgY2FsbGVkLCB0aGUgMm5kIGFuZCAzcmQgb25lIHdpbGwgYXV0b21hdGljYWxseVxuICAgIC8vIGJlIGNhbGxlZC4gZS5nLiBpZiBDb2xvclZhbHVlIG5lZWRzIHRvIGJlIHVwZGF0ZWQsIGdldENvbG9yVmFsdWVEb21haW4gYW5kIGdldENvbG9yU2NhbGVcbiAgICAvLyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgY2FsbGVkXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldENvbG9yOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3ZhbHVlJyxcbiAgICAgICAgICB0cmlnZ2VyczogWydnZXRDb2xvclZhbHVlJ10sXG4gICAgICAgICAgdXBkYXRlcjogdGhpcy5nZXRTb3J0ZWRDb2xvckJpbnNcbiAgICAgICAgfSwge1xuICAgICAgICAgIGlkOiAnZG9tYWluJyxcbiAgICAgICAgICB0cmlnZ2VyczogWydsb3dlclBlcmNlbnRpbGUnLCAndXBwZXJQZXJjZW50aWxlJ10sXG4gICAgICAgICAgdXBkYXRlcjogdGhpcy5nZXRDb2xvclZhbHVlRG9tYWluXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBpZDogJ3NjYWxlRnVuYycsXG4gICAgICAgICAgdHJpZ2dlcnM6IFsnY29sb3JEb21haW4nLCAnY29sb3JSYW5nZSddLFxuICAgICAgICAgIHVwZGF0ZXI6IHRoaXMuZ2V0Q29sb3JTY2FsZVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgZ2V0RWxldmF0aW9uOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogJ3ZhbHVlJyxcbiAgICAgICAgICB0cmlnZ2VyczogWydnZXRFbGV2YXRpb25WYWx1ZSddLFxuICAgICAgICAgIHVwZGF0ZXI6IHRoaXMuZ2V0U29ydGVkRWxldmF0aW9uQmluc1xuICAgICAgICB9LCB7XG4gICAgICAgICAgaWQ6ICdkb21haW4nLFxuICAgICAgICAgIHRyaWdnZXJzOiBbJ2VsZXZhdGlvbkxvd2VyUGVyY2VudGlsZScsICdlbGV2YXRpb25VcHBlclBlcmNlbnRpbGUnXSxcbiAgICAgICAgICB1cGRhdGVyOiB0aGlzLmdldEVsZXZhdGlvblZhbHVlRG9tYWluXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBpZDogJ3NjYWxlRnVuYycsXG4gICAgICAgICAgdHJpZ2dlcnM6IFsnZWxldmF0aW9uRG9tYWluJywgJ2VsZXZhdGlvblJhbmdlJ10sXG4gICAgICAgICAgdXBkYXRlcjogdGhpcy5nZXRFbGV2YXRpb25TY2FsZVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuXG4gIGdldERpbWVuc2lvbkNoYW5nZXMob2xkUHJvcHMsIHByb3BzKSB7XG4gICAgY29uc3Qge2RpbWVuc2lvblVwZGF0ZXJzfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgdXBkYXRlcnMgPSBbXTtcblxuICAgIC8vIGdldCBkaW1lbnNpb24gdG8gYmUgdXBkYXRlZFxuICAgIGZvciAoY29uc3QgZGltZW5zaW9uS2V5IGluIGRpbWVuc2lvblVwZGF0ZXJzKSB7XG5cbiAgICAgIC8vIHJldHVybiB0aGUgZmlyc3QgdHJpZ2dlcmVkIHVwZGF0ZXIgZm9yIGVhY2ggZGltZW5zaW9uXG4gICAgICBjb25zdCBuZWVkVXBkYXRlID0gZGltZW5zaW9uVXBkYXRlcnNbZGltZW5zaW9uS2V5XVxuICAgICAgICAuZmluZChpdGVtID0+IGl0ZW0udHJpZ2dlcnMuc29tZSh0ID0+IG9sZFByb3BzW3RdICE9PSBwcm9wc1t0XSkpO1xuXG4gICAgICBpZiAobmVlZFVwZGF0ZSkge1xuICAgICAgICB1cGRhdGVycy5wdXNoKG5lZWRVcGRhdGUudXBkYXRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZXJzLmxlbmd0aCA/IHVwZGF0ZXJzIDogbnVsbDtcbiAgfVxuXG4gIGdldEhleGFnb25zKCkge1xuICAgIGNvbnN0IHtoZXhhZ29uQWdncmVnYXRvcn0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHt2aWV3cG9ydH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3Qge2hleGFnb25zLCBoZXhhZ29uVmVydGljZXN9ID0gaGV4YWdvbkFnZ3JlZ2F0b3IodGhpcy5wcm9wcywgdmlld3BvcnQpO1xuICAgIHRoaXMuc2V0U3RhdGUoe2hleGFnb25zLCBoZXhhZ29uVmVydGljZXN9KTtcbiAgICB0aGlzLmdldFNvcnRlZEJpbnMoKTtcbiAgfVxuXG4gIGdldFBpY2tpbmdJbmZvKHtpbmZvfSkge1xuICAgIGNvbnN0IHtzb3J0ZWRDb2xvckJpbnMsIHNvcnRlZEVsZXZhdGlvbkJpbnN9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBpc1BpY2tlZCA9IGluZm8ucGlja2VkICYmIGluZm8uaW5kZXggPiAtMTtcblxuICAgIGxldCBvYmplY3QgPSBudWxsO1xuICAgIGlmIChpc1BpY2tlZCkge1xuXG4gICAgICBjb25zdCBjZWxsID0gdGhpcy5zdGF0ZS5oZXhhZ29uc1tpbmZvLmluZGV4XTtcblxuICAgICAgY29uc3QgY29sb3JWYWx1ZSA9IHNvcnRlZENvbG9yQmlucy5iaW5NYXBbY2VsbC5pbmRleF0gJiZcbiAgICAgICAgc29ydGVkQ29sb3JCaW5zLmJpbk1hcFtjZWxsLmluZGV4XS52YWx1ZTtcbiAgICAgIGNvbnN0IGVsZXZhdGlvblZhbHVlID0gc29ydGVkRWxldmF0aW9uQmlucy5iaW5NYXBbY2VsbC5pbmRleF0gJiZcbiAgICAgICAgc29ydGVkRWxldmF0aW9uQmlucy5iaW5NYXBbY2VsbC5pbmRleF0udmFsdWU7XG5cbiAgICAgIG9iamVjdCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBjb2xvclZhbHVlLFxuICAgICAgICBlbGV2YXRpb25WYWx1ZVxuICAgICAgfSwgY2VsbCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGJpbiBjb2xvclZhbHVlIGFuZCBlbGV2YXRpb25WYWx1ZSB0byBpbmZvXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oaW5mbywge1xuICAgICAgcGlja2VkOiBCb29sZWFuKG9iamVjdCksXG4gICAgICAvLyBvdmVycmlkZSBvYmplY3Qgd2l0aCBwaWNrZWQgY2VsbFxuICAgICAgb2JqZWN0XG4gICAgfSk7XG4gIH1cblxuICBnZXRVcGRhdGVUcmlnZ2VycygpIHtcbiAgICBjb25zdCB7ZGltZW5zaW9uVXBkYXRlcnN9ID0gdGhpcy5zdGF0ZTtcblxuICAgIC8vIG1lcmdlIGFsbCBkaW1lbnNpb24gdHJpZ2dlcnNcbiAgICBjb25zdCB1cGRhdGVUcmlnZ2VycyA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBkaW1lbnNpb25LZXkgaW4gZGltZW5zaW9uVXBkYXRlcnMpIHtcblxuICAgICAgdXBkYXRlVHJpZ2dlcnNbZGltZW5zaW9uS2V5XSA9IHt9O1xuXG4gICAgICBmb3IgKGNvbnN0IHN0ZXAgb2YgZGltZW5zaW9uVXBkYXRlcnNbZGltZW5zaW9uS2V5XSkge1xuXG4gICAgICAgIHN0ZXAudHJpZ2dlcnMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICB1cGRhdGVUcmlnZ2Vyc1tkaW1lbnNpb25LZXldW3Byb3BdID0gdGhpcy5wcm9wc1twcm9wXTtcbiAgICAgICAgfSk7XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlVHJpZ2dlcnM7XG4gIH1cblxuICBnZXRWYWx1ZURvbWFpbigpIHtcbiAgICB0aGlzLmdldENvbG9yVmFsdWVEb21haW4oKTtcbiAgICB0aGlzLmdldEVsZXZhdGlvblZhbHVlRG9tYWluKCk7XG4gIH1cblxuICBnZXRTb3J0ZWRCaW5zKCkge1xuICAgIHRoaXMuZ2V0U29ydGVkQ29sb3JCaW5zKCk7XG4gICAgdGhpcy5nZXRTb3J0ZWRFbGV2YXRpb25CaW5zKCk7XG4gIH1cblxuICBnZXRTb3J0ZWRDb2xvckJpbnMoKSB7XG4gICAgY29uc3Qge2dldENvbG9yVmFsdWV9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBzb3J0ZWRDb2xvckJpbnMgPSBuZXcgQmluU29ydGVyKHRoaXMuc3RhdGUuaGV4YWdvbnMgfHwgW10sIGdldENvbG9yVmFsdWUpO1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7c29ydGVkQ29sb3JCaW5zfSk7XG4gICAgdGhpcy5nZXRDb2xvclZhbHVlRG9tYWluKCk7XG4gIH1cblxuICBnZXRTb3J0ZWRFbGV2YXRpb25CaW5zKCkge1xuICAgIGNvbnN0IHtnZXRFbGV2YXRpb25WYWx1ZX0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHNvcnRlZEVsZXZhdGlvbkJpbnMgPSBuZXcgQmluU29ydGVyKHRoaXMuc3RhdGUuaGV4YWdvbnMgfHwgW10sIGdldEVsZXZhdGlvblZhbHVlKTtcbiAgICB0aGlzLnNldFN0YXRlKHtzb3J0ZWRFbGV2YXRpb25CaW5zfSk7XG4gICAgdGhpcy5nZXRFbGV2YXRpb25WYWx1ZURvbWFpbigpO1xuICB9XG5cbiAgZ2V0Q29sb3JWYWx1ZURvbWFpbigpIHtcbiAgICBjb25zdCB7bG93ZXJQZXJjZW50aWxlLCB1cHBlclBlcmNlbnRpbGUsIG9uU2V0Q29sb3JEb21haW59ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuc3RhdGUuY29sb3JWYWx1ZURvbWFpbiA9IHRoaXMuc3RhdGUuc29ydGVkQ29sb3JCaW5zXG4gICAgICAuZ2V0VmFsdWVSYW5nZShbbG93ZXJQZXJjZW50aWxlLCB1cHBlclBlcmNlbnRpbGVdKTtcblxuICAgIGlmICh0eXBlb2Ygb25TZXRDb2xvckRvbWFpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25TZXRDb2xvckRvbWFpbih0aGlzLnN0YXRlLmNvbG9yVmFsdWVEb21haW4pO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0Q29sb3JTY2FsZSgpO1xuICB9XG5cbiAgZ2V0RWxldmF0aW9uVmFsdWVEb21haW4oKSB7XG4gICAgY29uc3Qge2VsZXZhdGlvbkxvd2VyUGVyY2VudGlsZSwgZWxldmF0aW9uVXBwZXJQZXJjZW50aWxlLCBvblNldEVsZXZhdGlvbkRvbWFpbn0gPSB0aGlzLnByb3BzO1xuXG4gICAgdGhpcy5zdGF0ZS5lbGV2YXRpb25WYWx1ZURvbWFpbiA9IHRoaXMuc3RhdGUuc29ydGVkRWxldmF0aW9uQmluc1xuICAgICAgLmdldFZhbHVlUmFuZ2UoW2VsZXZhdGlvbkxvd2VyUGVyY2VudGlsZSwgZWxldmF0aW9uVXBwZXJQZXJjZW50aWxlXSk7XG5cbiAgICBpZiAodHlwZW9mIG9uU2V0RWxldmF0aW9uRG9tYWluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvblNldEVsZXZhdGlvbkRvbWFpbih0aGlzLnN0YXRlLmVsZXZhdGlvblZhbHVlRG9tYWluKTtcbiAgICB9XG5cbiAgICB0aGlzLmdldEVsZXZhdGlvblNjYWxlKCk7XG4gIH1cblxuICBnZXRDb2xvclNjYWxlKCkge1xuICAgIGNvbnN0IHtjb2xvclJhbmdlfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgY29sb3JEb21haW4gPSB0aGlzLnByb3BzLmNvbG9yRG9tYWluIHx8IHRoaXMuc3RhdGUuY29sb3JWYWx1ZURvbWFpbjtcblxuICAgIHRoaXMuc3RhdGUuY29sb3JTY2FsZUZ1bmMgPSBnZXRRdWFudGl6ZVNjYWxlKGNvbG9yRG9tYWluLCBjb2xvclJhbmdlKTtcbiAgfVxuXG4gIGdldEVsZXZhdGlvblNjYWxlKCkge1xuICAgIGNvbnN0IHtlbGV2YXRpb25SYW5nZX0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGVsZXZhdGlvbkRvbWFpbiA9IHRoaXMucHJvcHMuZWxldmF0aW9uRG9tYWluIHx8IHRoaXMuc3RhdGUuZWxldmF0aW9uVmFsdWVEb21haW47XG5cbiAgICB0aGlzLnN0YXRlLmVsZXZhdGlvblNjYWxlRnVuYyA9IGdldExpbmVhclNjYWxlKGVsZXZhdGlvbkRvbWFpbiwgZWxldmF0aW9uUmFuZ2UpO1xuICB9XG5cbiAgX29uR2V0U3VibGF5ZXJDb2xvcihjZWxsKSB7XG4gICAgY29uc3Qge3NvcnRlZENvbG9yQmlucywgY29sb3JTY2FsZUZ1bmMsIGNvbG9yVmFsdWVEb21haW59ID0gdGhpcy5zdGF0ZTtcblxuICAgIGNvbnN0IGN2ID0gc29ydGVkQ29sb3JCaW5zLmJpbk1hcFtjZWxsLmluZGV4XSAmJiBzb3J0ZWRDb2xvckJpbnMuYmluTWFwW2NlbGwuaW5kZXhdLnZhbHVlO1xuICAgIGNvbnN0IGNvbG9yRG9tYWluID0gdGhpcy5wcm9wcy5jb2xvckRvbWFpbiB8fCBjb2xvclZhbHVlRG9tYWluO1xuXG4gICAgY29uc3QgaXNDb2xvclZhbHVlSW5Eb21haW4gPSBjdiA+PSBjb2xvckRvbWFpblswXSAmJiBjdiA8PSBjb2xvckRvbWFpbltjb2xvckRvbWFpbi5sZW5ndGggLSAxXTtcblxuICAgIC8vIGlmIGNlbGwgdmFsdWUgaXMgb3V0c2lkZSBkb21haW4sIHNldCBhbHBoYSB0byAwXG4gICAgY29uc3QgY29sb3IgPSBpc0NvbG9yVmFsdWVJbkRvbWFpbiA/IGNvbG9yU2NhbGVGdW5jKGN2KSA6IFswLCAwLCAwLCAwXTtcblxuICAgIC8vIGFkZCBhbHBoYSB0byBjb2xvciBpZiBub3QgZGVmaW5lZCBpbiBjb2xvclJhbmdlXG4gICAgY29sb3JbM10gPSBOdW1iZXIuaXNGaW5pdGUoY29sb3JbM10pID8gY29sb3JbM10gOiAyNTU7XG5cbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICBfb25HZXRTdWJsYXllckVsZXZhdGlvbihjZWxsKSB7XG4gICAgY29uc3Qge3NvcnRlZEVsZXZhdGlvbkJpbnMsIGVsZXZhdGlvblNjYWxlRnVuYywgZWxldmF0aW9uVmFsdWVEb21haW59ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBldiA9IHNvcnRlZEVsZXZhdGlvbkJpbnMuYmluTWFwW2NlbGwuaW5kZXhdICYmXG4gICAgICBzb3J0ZWRFbGV2YXRpb25CaW5zLmJpbk1hcFtjZWxsLmluZGV4XS52YWx1ZTtcblxuICAgIGNvbnN0IGVsZXZhdGlvbkRvbWFpbiA9IHRoaXMucHJvcHMuZWxldmF0aW9uRG9tYWluIHx8IGVsZXZhdGlvblZhbHVlRG9tYWluO1xuXG4gICAgY29uc3QgaXNFbGV2YXRpb25WYWx1ZUluRG9tYWluID0gZXYgPj0gZWxldmF0aW9uRG9tYWluWzBdICYmXG4gICAgICBldiA8PSBlbGV2YXRpb25Eb21haW5bZWxldmF0aW9uRG9tYWluLmxlbmd0aCAtIDFdO1xuXG4gICAgLy8gaWYgY2VsbCB2YWx1ZSBpcyBvdXRzaWRlIGRvbWFpbiwgc2V0IGVsZXZhdGlvbiB0byAtMVxuICAgIHJldHVybiBpc0VsZXZhdGlvblZhbHVlSW5Eb21haW4gPyBlbGV2YXRpb25TY2FsZUZ1bmMoZXYpIDogLTE7XG4gIH1cblxuICAvLyBmb3Igc3ViY2xhc3NpbmcsIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHJldHVyblxuICAvLyBjdXN0b21pemVkIHN1YiBsYXllciBwcm9wc1xuICBnZXRTdWJMYXllclByb3BzKCkge1xuICAgIGNvbnN0IHtpZCwgcmFkaXVzLCBlbGV2YXRpb25TY2FsZSwgZXh0cnVkZWQsIGNvdmVyYWdlLCBsaWdodFNldHRpbmdzLCBmcDY0fSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBmb3J3YXJkUHJvcHMgPSB0aGlzLmdldEJhc2VMYXllclByb3BzKCk7XG5cbiAgICAvLyByZXR1cm4gcHJvcHMgdG8gdGhlIHN1YmxheWVyIGNvbnN0cnVjdG9yXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGZvcndhcmRQcm9wcywge1xuICAgICAgaWQ6IGAke2lkfS1oZXhhZ29uLWNlbGxgLFxuICAgICAgZGF0YTogdGhpcy5zdGF0ZS5oZXhhZ29ucyxcblxuICAgICAgZnA2NCxcbiAgICAgIGhleGFnb25WZXJ0aWNlczogdGhpcy5zdGF0ZS5oZXhhZ29uVmVydGljZXMsXG4gICAgICByYWRpdXMsXG4gICAgICBlbGV2YXRpb25TY2FsZSxcbiAgICAgIGFuZ2xlOiBNYXRoLlBJLFxuICAgICAgZXh0cnVkZWQsXG4gICAgICBjb3ZlcmFnZSxcbiAgICAgIGxpZ2h0U2V0dGluZ3MsXG5cbiAgICAgIGdldENvbG9yOiB0aGlzLl9vbkdldFN1YmxheWVyQ29sb3IuYmluZCh0aGlzKSxcbiAgICAgIGdldEVsZXZhdGlvbjogdGhpcy5fb25HZXRTdWJsYXllckVsZXZhdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgdXBkYXRlVHJpZ2dlcnM6IHRoaXMuZ2V0VXBkYXRlVHJpZ2dlcnMoKVxuICAgIH0pO1xuICB9XG5cbiAgLy8gZm9yIHN1YmNsYXNzaW5nLCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZXR1cm5cbiAgLy8gY3VzdG9taXplZCBzdWIgbGF5ZXIgY2xhc3NcbiAgZ2V0U3ViTGF5ZXJDbGFzcygpIHtcbiAgICByZXR1cm4gSGV4YWdvbkNlbGxMYXllcjtcbiAgfVxuXG4gIHJlbmRlckxheWVycygpIHtcbiAgICBjb25zdCBTdWJMYXllckNsYXNzID0gdGhpcy5nZXRTdWJMYXllckNsYXNzKCk7XG5cbiAgICByZXR1cm4gbmV3IFN1YkxheWVyQ2xhc3MoXG4gICAgICB0aGlzLmdldFN1YkxheWVyUHJvcHMoKVxuICAgICk7XG4gIH1cbn1cblxuSGV4YWdvbkxheWVyLmxheWVyTmFtZSA9ICdIZXhhZ29uTGF5ZXInO1xuSGV4YWdvbkxheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==