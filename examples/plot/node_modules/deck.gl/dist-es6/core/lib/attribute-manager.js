var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* eslint-disable guard-for-in */
import { GL } from 'luma.gl';
import Stats from './stats';
import { log } from './utils';
import assert from 'assert';

var LOG_START_END_PRIORITY = 1;
var LOG_DETAIL_PRIORITY = 2;

function noop() {}

/* eslint-disable complexity */
export function glArrayFromType(glType) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$clamped = _ref.clamped,
      clamped = _ref$clamped === undefined ? true : _ref$clamped;

  // Sorted in some order of likelihood to reduce amount of comparisons
  switch (glType) {
    case GL.FLOAT:
      return Float32Array;
    case GL.UNSIGNED_SHORT:
    case GL.UNSIGNED_SHORT_5_6_5:
    case GL.UNSIGNED_SHORT_4_4_4_4:
    case GL.UNSIGNED_SHORT_5_5_5_1:
      return Uint16Array;
    case GL.UNSIGNED_INT:
      return Uint32Array;
    case GL.UNSIGNED_BYTE:
      return clamped ? Uint8ClampedArray : Uint8Array;
    case GL.BYTE:
      return Int8Array;
    case GL.SHORT:
      return Int16Array;
    case GL.INT:
      return Int32Array;
    default:
      throw new Error('Failed to deduce type from array');
  }
}
/* eslint-enable complexity */

// Default loggers
var logFunctions = {
  onUpdateStart: function onUpdateStart(_ref2) {
    var level = _ref2.level,
        id = _ref2.id,
        numInstances = _ref2.numInstances;

    log.time(level, 'Updated attributes for ' + numInstances + ' instances in ' + id + ' in');
  },
  onLog: function onLog(_ref3) {
    var level = _ref3.level,
        message = _ref3.message;

    log.log(level, message);
  },
  onUpdateEnd: function onUpdateEnd(_ref4) {
    var level = _ref4.level,
        id = _ref4.id,
        numInstances = _ref4.numInstances;

    log.timeEnd(level, 'Updated attributes for ' + numInstances + ' instances in ' + id + ' in');
  }
};

var AttributeManager = function () {
  _createClass(AttributeManager, null, [{
    key: 'setDefaultLogFunctions',

    /**
     * Sets log functions to help trace or time attribute updates.
     * Default logging uses deck logger.
     *
     * `onLog` is called for each attribute.
     *
     * To enable detailed control of timming and e.g. hierarchical logging,
     * hooks are also provided for update start and end.
     *
     * @param {Object} [opts]
     * @param {String} [opts.onLog=] - called to print
     * @param {String} [opts.onUpdateStart=] - called before update() starts
     * @param {String} [opts.onUpdateEnd=] - called after update() ends
     */
    value: function setDefaultLogFunctions() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          onLog = _ref5.onLog,
          onUpdateStart = _ref5.onUpdateStart,
          onUpdateEnd = _ref5.onUpdateEnd;

      if (onLog !== undefined) {
        logFunctions.onLog = onLog || noop;
      }
      if (onUpdateStart !== undefined) {
        logFunctions.onUpdateStart = onUpdateStart || noop;
      }
      if (onUpdateEnd !== undefined) {
        logFunctions.onUpdateEnd = onUpdateEnd || noop;
      }
    }

    /**
     * @classdesc
     * Automated attribute generation and management. Suitable when a set of
     * vertex shader attributes are generated by iteration over a data array,
     * and updates to these attributes are needed either when the data itself
     * changes, or when other data relevant to the calculations change.
     *
     * - First the application registers descriptions of its dynamic vertex
     *   attributes using AttributeManager.add().
     * - Then, when any change that affects attributes is detected by the
     *   application, the app will call AttributeManager.invalidate().
     * - Finally before it renders, it calls AttributeManager.update() to
     *   ensure that attributes are automatically rebuilt if anything has been
     *   invalidated.
     *
     * The application provided update functions describe how attributes
     * should be updated from a data array and are expected to traverse
     * that data array (or iterable) and fill in the attribute's typed array.
     *
     * Note that the attribute manager intentionally does not do advanced
     * change detection, but instead makes it easy to build such detection
     * by offering the ability to "invalidate" each attribute separately.
     *
     * Summary:
     * - keeps track of valid state for each attribute
     * - auto reallocates attributes when needed
     * - auto updates attributes with registered updater functions
     * - allows overriding with application supplied buffers
     *
     * Limitations:
     * - There are currently no provisions for only invalidating a range of
     *   indices in an attribute.
     *
     * @class
     * @param {Object} [props]
     * @param {String} [props.id] - identifier (for debugging)
     */

  }]);

  function AttributeManager() {
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref6$id = _ref6.id,
        id = _ref6$id === undefined ? 'attribute-manager' : _ref6$id;

    _classCallCheck(this, AttributeManager);

    this.id = id;

    this.attributes = {};
    this.updateTriggers = {};
    this.allocedInstances = -1;
    this.needsRedraw = true;

    this.userData = {};
    this.stats = new Stats({ id: 'attr' });

    // For debugging sanity, prevent uninitialized members
    Object.seal(this);
  }

  /**
   * Adds attributes
   * Takes a map of attribute descriptor objects
   * - keys are attribute names
   * - values are objects with attribute fields
   *
   * attribute.size - number of elements per object
   * attribute.updater - number of elements
   * attribute.instanced=0 - is this is an instanced attribute (a.k.a. divisor)
   * attribute.noAlloc=false - if this attribute should not be allocated
   *
   * @example
   * attributeManager.add({
   *   positions: {size: 2, update: calculatePositions}
   *   colors: {size: 3, update: calculateColors}
   * });
   *
   * @param {Object} attributes - attribute map (see above)
   * @param {Object} updaters - separate map of update functions (deprecated)
   */


  _createClass(AttributeManager, [{
    key: 'add',
    value: function add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters);
    }

    /**
      * Removes attributes
      * Takes an array of attribute names and delete them from
      * the attribute map if they exists
      *
      * @example
      * attributeManager.remove(['position']);
      *
      * @param {Object} attributeNameArray - attribute name array (see above)
      */

  }, {
    key: 'remove',
    value: function remove(attributeNameArray) {
      for (var i = 0; i < attributeNameArray.length; i++) {
        var name = attributeNameArray[i];
        if (this.attributes[name] !== undefined) {
          delete this.attributes[name];
        }
      }
    }

    /* Marks an attribute for update
     * @param {string} triggerName: attribute or accessor name
     */

  }, {
    key: 'invalidate',
    value: function invalidate(triggerName) {
      var attributes = this.attributes,
          updateTriggers = this.updateTriggers;

      var attributesToUpdate = updateTriggers[triggerName];

      if (!attributesToUpdate) {
        var message = 'invalidating non-existent attribute ' + triggerName + ' for ' + this.id + '\n';
        message += 'Valid attributes: ' + Object.keys(attributes).join(', ');
        assert(attributesToUpdate, message);
      }
      attributesToUpdate.forEach(function (name) {
        var attribute = attributes[name];
        if (attribute) {
          attribute.needsUpdate = true;
        }
      });
      // For performance tuning
      logFunctions.onLog({
        level: LOG_DETAIL_PRIORITY,
        message: 'invalidated attribute ' + attributesToUpdate + ' for ' + this.id,
        id: this.identifier
      });
    }
  }, {
    key: 'invalidateAll',
    value: function invalidateAll() {
      var attributes = this.attributes;

      for (var attributeName in attributes) {
        this.invalidate(attributeName);
      }
    }

    /**
     * Ensure all attribute buffers are updated from props or data.
     *
     * Note: Any preallocated buffers in "buffers" matching registered attribute
     * names will be used. No update will happen in this case.
     * Note: Calls onUpdateStart and onUpdateEnd log callbacks before and after.
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */

  }, {
    key: 'update',
    value: function update() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          data = _ref7.data,
          numInstances = _ref7.numInstances,
          _ref7$props = _ref7.props,
          props = _ref7$props === undefined ? {} : _ref7$props,
          _ref7$buffers = _ref7.buffers,
          buffers = _ref7$buffers === undefined ? {} : _ref7$buffers,
          _ref7$context = _ref7.context,
          context = _ref7$context === undefined ? {} : _ref7$context,
          _ref7$ignoreUnknownAt = _ref7.ignoreUnknownAttributes,
          ignoreUnknownAttributes = _ref7$ignoreUnknownAt === undefined ? false : _ref7$ignoreUnknownAt;

      // First apply any application provided buffers
      this._checkExternalBuffers({ buffers: buffers, ignoreUnknownAttributes: ignoreUnknownAttributes });
      this._setExternalBuffers(buffers);

      // Only initiate alloc/update (and logging) if actually needed
      if (this._analyzeBuffers({ numInstances: numInstances })) {
        logFunctions.onUpdateStart({ level: LOG_START_END_PRIORITY, id: this.id, numInstances: numInstances });
        this.stats.timeStart();
        this._updateBuffers({ numInstances: numInstances, data: data, props: props, context: context });
        this.stats.timeEnd();
        logFunctions.onUpdateEnd({ level: LOG_START_END_PRIORITY, id: this.id, numInstances: numInstances });
      }
    }

    /**
     * Returns all attribute descriptors
     * Note: Format matches luma.gl Model/Program.setAttributes()
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getAttributes',
    value: function getAttributes() {
      return this.attributes;
    }

    /**
     * Returns changed attribute descriptors
     * This indicates which WebGLBuggers need to be updated
     * @return {Object} attributes - descriptors
     */

  }, {
    key: 'getChangedAttributes',
    value: function getChangedAttributes(_ref8) {
      var _ref8$clearChangedFla = _ref8.clearChangedFlags,
          clearChangedFlags = _ref8$clearChangedFla === undefined ? false : _ref8$clearChangedFla;
      var attributes = this.attributes;

      var changedAttributes = {};
      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (attribute.changed) {
          attribute.changed = attribute.changed && !clearChangedFlags;
          changedAttributes[attributeName] = attribute;
        }
      }
      return changedAttributes;
    }

    /**
     * Returns the redraw flag, optionally clearing it.
     * Redraw flag will be set if any attributes attributes changed since
     * flag was last cleared.
     *
     * @param {Object} [opts]
     * @param {String} [opts.clearRedrawFlags=false] - whether to clear the flag
     * @return {Boolean} - whether a redraw is needed.
     */

  }, {
    key: 'getNeedsRedraw',
    value: function getNeedsRedraw() {
      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref9$clearRedrawFlag = _ref9.clearRedrawFlags,
          clearRedrawFlags = _ref9$clearRedrawFlag === undefined ? false : _ref9$clearRedrawFlag;

      var redraw = this.needsRedraw;
      redraw = redraw || this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
      return redraw;
    }

    /**
     * Sets the redraw flag.
     * @param {Boolean} redraw=true
     * @return {AttributeManager} - for chaining
     */

  }, {
    key: 'setNeedsRedraw',
    value: function setNeedsRedraw() {
      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this.needsRedraw = true;
      return this;
    }

    // DEPRECATED METHODS

    /**
     * @deprecated since version 2.5, use add() instead
     * Adds attributes
     * @param {Object} attributes - attribute map (see above)
     * @param {Object} updaters - separate map of update functions (deprecated)
     */

  }, {
    key: 'addInstanced',
    value: function addInstanced(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._add(attributes, updaters, { instanced: 1 });
    }

    // PRIVATE METHODS

    // Used to register an attribute

  }, {
    key: '_add',
    value: function _add(attributes) {
      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var newAttributes = {};

      for (var attributeName in attributes) {
        // support for separate update function map
        // For now, just copy any attributes from that map into the main map
        // TODO - Attribute maps are a deprecated feature, remove
        if (attributeName in updaters) {
          attributes[attributeName] = Object.assign({}, attributes[attributeName], updaters[attributeName]);
        }

        var attribute = attributes[attributeName];

        var isIndexed = attribute.isIndexed || attribute.elements;
        var size = attribute.elements && 1 || attribute.size;
        var value = attribute.value || null;

        // Initialize the attribute descriptor, with WebGL and metadata fields
        var attributeData = Object.assign({
          // Ensure that fields are present before Object.seal()
          target: undefined,
          userData: {} // Reserved for application
        },
        // Metadata
        attribute, {
          // State
          isExternalBuffer: false,
          needsAlloc: false,
          needsUpdate: false,
          changed: false,

          // Luma fields
          isIndexed: isIndexed,
          size: size,
          value: value
        }, _extraProps);
        // Sanity - no app fields on our attributes. Use userData instead.
        Object.seal(attributeData);

        // Check all fields and generate helpful error messages
        this._validateAttributeDefinition(attributeName, attributeData);

        // Add to both attributes list (for registration with model)
        newAttributes[attributeName] = attributeData;
      }

      Object.assign(this.attributes, newAttributes);

      this._mapUpdateTriggersToAttributes();
    }

    // build updateTrigger name to attribute name mapping

  }, {
    key: '_mapUpdateTriggersToAttributes',
    value: function _mapUpdateTriggersToAttributes() {
      var _this = this;

      var triggers = {};

      var _loop = function _loop(attributeName) {
        var attribute = _this.attributes[attributeName];
        var accessor = attribute.accessor;

        // use attribute name as update trigger key

        triggers[attributeName] = [attributeName];

        // use accessor name as update trigger key
        if (typeof accessor === 'string') {
          accessor = [accessor];
        }
        if (Array.isArray(accessor)) {
          accessor.forEach(function (accessorName) {
            if (!triggers[accessorName]) {
              triggers[accessorName] = [];
            }
            triggers[accessorName].push(attributeName);
          });
        }
      };

      for (var attributeName in this.attributes) {
        _loop(attributeName);
      }

      this.updateTriggers = triggers;
    }
  }, {
    key: '_validateAttributeDefinition',
    value: function _validateAttributeDefinition(attributeName, attribute) {
      assert(attribute.size >= 1 && attribute.size <= 4, 'Attribute definition for ' + attributeName + ' invalid size');

      // Check that either 'accessor' or 'update' is a valid function
      var hasUpdater = attribute.noAlloc || typeof attribute.update === 'function' || typeof attribute.accessor === 'string';
      if (!hasUpdater) {
        throw new Error('Attribute ' + attributeName + ' missing update or accessor');
      }
    }

    // Checks that any attribute buffers in props are valid
    // Note: This is just to help app catch mistakes

  }, {
    key: '_checkExternalBuffers',
    value: function _checkExternalBuffers() {
      var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref10$buffers = _ref10.buffers,
          buffers = _ref10$buffers === undefined ? {} : _ref10$buffers,
          _ref10$ignoreUnknownA = _ref10.ignoreUnknownAttributes,
          ignoreUnknownAttributes = _ref10$ignoreUnknownA === undefined ? false : _ref10$ignoreUnknownA;

      var attributes = this.attributes;

      for (var attributeName in buffers) {
        var attribute = attributes[attributeName];
        if (!attribute && !ignoreUnknownAttributes) {
          throw new Error('Unknown attribute prop ' + attributeName);
        }
        // const buffer = buffers[attributeName];
        // TODO - check buffer type
      }
    }

    // Set the buffers for the supplied attributes
    // Update attribute buffers from any attributes in props
    // Detach any previously set buffers, marking all
    // Attributes for auto allocation
    /* eslint-disable max-statements */

  }, {
    key: '_setExternalBuffers',
    value: function _setExternalBuffers(bufferMap) {
      var attributes = this.attributes,
          numInstances = this.numInstances;

      // Copy the refs of any supplied buffers in the props

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        var buffer = bufferMap[attributeName];
        attribute.isExternalBuffer = false;
        if (buffer) {
          var ArrayType = glArrayFromType(attribute.type || GL.FLOAT);
          if (!(buffer instanceof ArrayType)) {
            throw new Error('Attribute ' + attributeName + ' must be of type ' + ArrayType.name);
          }
          if (attribute.auto && buffer.length <= numInstances * attribute.size) {
            throw new Error('Attribute prop array must match length and size');
          }

          attribute.isExternalBuffer = true;
          attribute.needsUpdate = false;
          if (attribute.value !== buffer) {
            attribute.value = buffer;
            attribute.changed = true;
            this.needsRedraw = true;
          }
        }
      }
    }
    /* eslint-enable max-statements */

    /* Checks that typed arrays for attributes are big enough
     * sets alloc flag if not
     * @return {Boolean} whether any updates are needed
     */

  }, {
    key: '_analyzeBuffers',
    value: function _analyzeBuffers(_ref11) {
      var numInstances = _ref11.numInstances;
      var attributes = this.attributes;

      assert(numInstances !== undefined, 'numInstances not defined');

      // Track whether any allocations or updates are needed
      var needsUpdate = false;

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];
        if (!attribute.isExternalBuffer) {
          // Do we need to reallocate the attribute's typed array?
          var needsAlloc = attribute.value === null || attribute.value.length / attribute.size < numInstances;
          if (needsAlloc && (attribute.update || attribute.accessor)) {
            attribute.needsAlloc = true;
            needsUpdate = true;
          }
          if (attribute.needsUpdate) {
            needsUpdate = true;
          }
        }
      }

      return needsUpdate;
    }

    /**
     * @private
     * Calls update on any buffers that need update
     * TODO? - If app supplied all attributes, no need to iterate over data
     *
     * @param {Object} opts - options
     * @param {Object} opts.data - data (iterable object)
     * @param {Object} opts.numInstances - count of data
     * @param {Object} opts.buffers = {} - pre-allocated buffers
     * @param {Object} opts.props - passed to updaters
     * @param {Object} opts.context - Used as "this" context for updaters
     */
    /* eslint-disable max-statements, complexity */

  }, {
    key: '_updateBuffers',
    value: function _updateBuffers(_ref12) {
      var numInstances = _ref12.numInstances,
          data = _ref12.data,
          props = _ref12.props,
          context = _ref12.context;
      var attributes = this.attributes;

      // Allocate at least one element to ensure a valid buffer

      var allocCount = Math.max(numInstances, 1);

      for (var attributeName in attributes) {
        var attribute = attributes[attributeName];

        // Allocate a new typed array if needed
        if (attribute.needsAlloc) {
          var ArrayType = glArrayFromType(attribute.type || GL.FLOAT);
          attribute.value = new ArrayType(attribute.size * allocCount);
          logFunctions.onLog({
            level: LOG_DETAIL_PRIORITY,
            message: this.id + ':' + attributeName + ' allocated ' + allocCount,
            id: this.id
          });
          attribute.needsAlloc = false;
          attribute.needsUpdate = true;
        }

        // Call updater function if needed
        if (attribute.needsUpdate) {
          this._updateBuffer({ attribute: attribute, attributeName: attributeName, numInstances: numInstances, data: data, props: props, context: context });
        }
      }

      this.allocedInstances = allocCount;
    }
  }, {
    key: '_updateBuffer',
    value: function _updateBuffer(_ref13) {
      var attribute = _ref13.attribute,
          attributeName = _ref13.attributeName,
          numInstances = _ref13.numInstances,
          data = _ref13.data,
          props = _ref13.props,
          context = _ref13.context;
      var update = attribute.update,
          accessor = attribute.accessor;

      if (update) {
        // Custom updater - typically for non-instanced layers
        logFunctions.onLog({
          level: LOG_DETAIL_PRIORITY,
          message: this.id + ':' + attributeName + ' updating ' + numInstances,
          id: this.id
        });
        update.call(context, attribute, { data: data, props: props, numInstances: numInstances });
        this._checkAttributeArray(attribute, attributeName);
      } else if (accessor) {
        // Standard updater
        this._updateBufferViaStandardAccessor({ attribute: attribute, data: data, props: props });
        this._checkAttributeArray(attribute, attributeName);
      } else {
        logFunctions.onLog({
          level: LOG_DETAIL_PRIORITY,
          message: this.id + ':' + attributeName + ' missing update function',
          id: this.id
        });
      }

      attribute.needsUpdate = false;
      attribute.changed = true;
      this.needsRedraw = true;
    }
    /* eslint-enable max-statements */

  }, {
    key: '_updateBufferViaStandardAccessor',
    value: function _updateBufferViaStandardAccessor(_ref14) {
      var attribute = _ref14.attribute,
          data = _ref14.data,
          props = _ref14.props;
      var accessor = attribute.accessor,
          value = attribute.value,
          size = attribute.size;

      var accessorFunc = props[accessor];

      assert(typeof accessorFunc === 'function', 'accessor "' + accessor + '" is not a function');

      var _attribute$defaultVal = attribute.defaultValue,
          defaultValue = _attribute$defaultVal === undefined ? [0, 0, 0, 0] : _attribute$defaultVal;

      defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];
      var i = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var object = _step.value;

          var objectValue = accessorFunc(object);
          objectValue = Array.isArray(objectValue) ? objectValue : [objectValue];
          /* eslint-disable no-fallthrough, default-case */
          switch (size) {
            case 4:
              value[i + 3] = Number.isFinite(objectValue[3]) ? objectValue[3] : defaultValue[3];
            case 3:
              value[i + 2] = Number.isFinite(objectValue[2]) ? objectValue[2] : defaultValue[2];
            case 2:
              value[i + 1] = Number.isFinite(objectValue[1]) ? objectValue[1] : defaultValue[1];
            case 1:
              value[i + 0] = Number.isFinite(objectValue[0]) ? objectValue[0] : defaultValue[0];
          }
          i += size;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: '_checkAttributeArray',
    value: function _checkAttributeArray(attribute, attributeName) {
      var value = attribute.value;

      if (value && value.length >= 4) {
        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);
        if (!valid) {
          throw new Error('Illegal attribute generated for ' + attributeName);
        }
      }
    }
  }]);

  return AttributeManager;
}();

export default AttributeManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9hdHRyaWJ1dGUtbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJHTCIsIlN0YXRzIiwibG9nIiwiYXNzZXJ0IiwiTE9HX1NUQVJUX0VORF9QUklPUklUWSIsIkxPR19ERVRBSUxfUFJJT1JJVFkiLCJub29wIiwiZ2xBcnJheUZyb21UeXBlIiwiZ2xUeXBlIiwiY2xhbXBlZCIsIkZMT0FUIiwiRmxvYXQzMkFycmF5IiwiVU5TSUdORURfU0hPUlQiLCJVTlNJR05FRF9TSE9SVF81XzZfNSIsIlVOU0lHTkVEX1NIT1JUXzRfNF80XzQiLCJVTlNJR05FRF9TSE9SVF81XzVfNV8xIiwiVWludDE2QXJyYXkiLCJVTlNJR05FRF9JTlQiLCJVaW50MzJBcnJheSIsIlVOU0lHTkVEX0JZVEUiLCJVaW50OENsYW1wZWRBcnJheSIsIlVpbnQ4QXJyYXkiLCJCWVRFIiwiSW50OEFycmF5IiwiU0hPUlQiLCJJbnQxNkFycmF5IiwiSU5UIiwiSW50MzJBcnJheSIsIkVycm9yIiwibG9nRnVuY3Rpb25zIiwib25VcGRhdGVTdGFydCIsImxldmVsIiwiaWQiLCJudW1JbnN0YW5jZXMiLCJ0aW1lIiwib25Mb2ciLCJtZXNzYWdlIiwib25VcGRhdGVFbmQiLCJ0aW1lRW5kIiwiQXR0cmlidXRlTWFuYWdlciIsInVuZGVmaW5lZCIsImF0dHJpYnV0ZXMiLCJ1cGRhdGVUcmlnZ2VycyIsImFsbG9jZWRJbnN0YW5jZXMiLCJuZWVkc1JlZHJhdyIsInVzZXJEYXRhIiwic3RhdHMiLCJPYmplY3QiLCJzZWFsIiwidXBkYXRlcnMiLCJfYWRkIiwiYXR0cmlidXRlTmFtZUFycmF5IiwiaSIsImxlbmd0aCIsIm5hbWUiLCJ0cmlnZ2VyTmFtZSIsImF0dHJpYnV0ZXNUb1VwZGF0ZSIsImtleXMiLCJqb2luIiwiZm9yRWFjaCIsImF0dHJpYnV0ZSIsIm5lZWRzVXBkYXRlIiwiaWRlbnRpZmllciIsImF0dHJpYnV0ZU5hbWUiLCJpbnZhbGlkYXRlIiwiZGF0YSIsInByb3BzIiwiYnVmZmVycyIsImNvbnRleHQiLCJpZ25vcmVVbmtub3duQXR0cmlidXRlcyIsIl9jaGVja0V4dGVybmFsQnVmZmVycyIsIl9zZXRFeHRlcm5hbEJ1ZmZlcnMiLCJfYW5hbHl6ZUJ1ZmZlcnMiLCJ0aW1lU3RhcnQiLCJfdXBkYXRlQnVmZmVycyIsImNsZWFyQ2hhbmdlZEZsYWdzIiwiY2hhbmdlZEF0dHJpYnV0ZXMiLCJjaGFuZ2VkIiwiY2xlYXJSZWRyYXdGbGFncyIsInJlZHJhdyIsImluc3RhbmNlZCIsIl9leHRyYVByb3BzIiwibmV3QXR0cmlidXRlcyIsImFzc2lnbiIsImlzSW5kZXhlZCIsImVsZW1lbnRzIiwic2l6ZSIsInZhbHVlIiwiYXR0cmlidXRlRGF0YSIsInRhcmdldCIsImlzRXh0ZXJuYWxCdWZmZXIiLCJuZWVkc0FsbG9jIiwiX3ZhbGlkYXRlQXR0cmlidXRlRGVmaW5pdGlvbiIsIl9tYXBVcGRhdGVUcmlnZ2Vyc1RvQXR0cmlidXRlcyIsInRyaWdnZXJzIiwiYWNjZXNzb3IiLCJBcnJheSIsImlzQXJyYXkiLCJhY2Nlc3Nvck5hbWUiLCJwdXNoIiwiaGFzVXBkYXRlciIsIm5vQWxsb2MiLCJ1cGRhdGUiLCJidWZmZXJNYXAiLCJidWZmZXIiLCJBcnJheVR5cGUiLCJ0eXBlIiwiYXV0byIsImFsbG9jQ291bnQiLCJNYXRoIiwibWF4IiwiX3VwZGF0ZUJ1ZmZlciIsImNhbGwiLCJfY2hlY2tBdHRyaWJ1dGVBcnJheSIsIl91cGRhdGVCdWZmZXJWaWFTdGFuZGFyZEFjY2Vzc29yIiwiYWNjZXNzb3JGdW5jIiwiZGVmYXVsdFZhbHVlIiwib2JqZWN0Iiwib2JqZWN0VmFsdWUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInZhbGlkIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFRQSxFQUFSLFFB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QUE7QUFxQjFEOzs7eUNBRW9CMUIsUyxFQUFXRyxhLEVBQWU7QUFBQSxVQUN0Q3dCLEtBRHNDLEdBQzdCM0IsU0FENkIsQ0FDdEMyQixLQURzQzs7QUFFN0MsVUFBSUEsU0FBU0EsTUFBTWxDLE1BQU4sSUFBZ0IsQ0FBN0IsRUFBZ0M7QUFDOUIsWUFBTW9FLFFBQ0pGLE9BQU9DLFFBQVAsQ0FBZ0JqQyxNQUFNLENBQU4sQ0FBaEIsS0FBNkJnQyxPQUFPQyxRQUFQLENBQWdCakMsTUFBTSxDQUFOLENBQWhCLENBQTdCLElBQ0FnQyxPQUFPQyxRQUFQLENBQWdCakMsTUFBTSxDQUFOLENBQWhCLENBREEsSUFDNkJnQyxPQUFPQyxRQUFQLENBQWdCakMsTUFBTSxDQUFOLENBQWhCLENBRi9CO0FBR0EsWUFBSSxDQUFDa0MsS0FBTCxFQUFZO0FBQ1YsZ0JBQU0sSUFBSTdGLEtBQUosc0NBQTZDbUMsYUFBN0MsQ0FBTjtBQUNEO0FBQ0Y7QUFDRjs7Ozs7O2VBdGlCa0J4QixnQiIsImZpbGUiOiJhdHRyaWJ1dGUtbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbmltcG9ydCB7R0x9IGZyb20gJ2x1bWEuZ2wnO1xuaW1wb3J0IFN0YXRzIGZyb20gJy4vc3RhdHMnO1xuaW1wb3J0IHtsb2d9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBMT0dfU1RBUlRfRU5EX1BSSU9SSVRZID0gMTtcbmNvbnN0IExPR19ERVRBSUxfUFJJT1JJVFkgPSAyO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdsQXJyYXlGcm9tVHlwZShnbFR5cGUsIHtjbGFtcGVkID0gdHJ1ZX0gPSB7fSkge1xuICAvLyBTb3J0ZWQgaW4gc29tZSBvcmRlciBvZiBsaWtlbGlob29kIHRvIHJlZHVjZSBhbW91bnQgb2YgY29tcGFyaXNvbnNcbiAgc3dpdGNoIChnbFR5cGUpIHtcbiAgY2FzZSBHTC5GTE9BVDpcbiAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xuICBjYXNlIEdMLlVOU0lHTkVEX1NIT1JUOlxuICBjYXNlIEdMLlVOU0lHTkVEX1NIT1JUXzVfNl81OlxuICBjYXNlIEdMLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ6XG4gIGNhc2UgR0wuVU5TSUdORURfU0hPUlRfNV81XzVfMTpcbiAgICByZXR1cm4gVWludDE2QXJyYXk7XG4gIGNhc2UgR0wuVU5TSUdORURfSU5UOlxuICAgIHJldHVybiBVaW50MzJBcnJheTtcbiAgY2FzZSBHTC5VTlNJR05FRF9CWVRFOlxuICAgIHJldHVybiBjbGFtcGVkID8gVWludDhDbGFtcGVkQXJyYXkgOiBVaW50OEFycmF5O1xuICBjYXNlIEdMLkJZVEU6XG4gICAgcmV0dXJuIEludDhBcnJheTtcbiAgY2FzZSBHTC5TSE9SVDpcbiAgICByZXR1cm4gSW50MTZBcnJheTtcbiAgY2FzZSBHTC5JTlQ6XG4gICAgcmV0dXJuIEludDMyQXJyYXk7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVkdWNlIHR5cGUgZnJvbSBhcnJheScpO1xuICB9XG59XG4vKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi9cblxuLy8gRGVmYXVsdCBsb2dnZXJzXG5jb25zdCBsb2dGdW5jdGlvbnMgPSB7XG4gIG9uVXBkYXRlU3RhcnQ6ICh7bGV2ZWwsIGlkLCBudW1JbnN0YW5jZXN9KSA9PiB7XG4gICAgbG9nLnRpbWUobGV2ZWwsIGBVcGRhdGVkIGF0dHJpYnV0ZXMgZm9yICR7bnVtSW5zdGFuY2VzfSBpbnN0YW5jZXMgaW4gJHtpZH0gaW5gKTtcbiAgfSxcbiAgb25Mb2c6ICh7bGV2ZWwsIG1lc3NhZ2V9KSA9PiB7XG4gICAgbG9nLmxvZyhsZXZlbCwgbWVzc2FnZSk7XG4gIH0sXG4gIG9uVXBkYXRlRW5kOiAoe2xldmVsLCBpZCwgbnVtSW5zdGFuY2VzfSkgPT4ge1xuICAgIGxvZy50aW1lRW5kKGxldmVsLCBgVXBkYXRlZCBhdHRyaWJ1dGVzIGZvciAke251bUluc3RhbmNlc30gaW5zdGFuY2VzIGluICR7aWR9IGluYCk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF0dHJpYnV0ZU1hbmFnZXIge1xuICAvKipcbiAgICogU2V0cyBsb2cgZnVuY3Rpb25zIHRvIGhlbHAgdHJhY2Ugb3IgdGltZSBhdHRyaWJ1dGUgdXBkYXRlcy5cbiAgICogRGVmYXVsdCBsb2dnaW5nIHVzZXMgZGVjayBsb2dnZXIuXG4gICAqXG4gICAqIGBvbkxvZ2AgaXMgY2FsbGVkIGZvciBlYWNoIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogVG8gZW5hYmxlIGRldGFpbGVkIGNvbnRyb2wgb2YgdGltbWluZyBhbmQgZS5nLiBoaWVyYXJjaGljYWwgbG9nZ2luZyxcbiAgICogaG9va3MgYXJlIGFsc28gcHJvdmlkZWQgZm9yIHVwZGF0ZSBzdGFydCBhbmQgZW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5vbkxvZz1dIC0gY2FsbGVkIHRvIHByaW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5vblVwZGF0ZVN0YXJ0PV0gLSBjYWxsZWQgYmVmb3JlIHVwZGF0ZSgpIHN0YXJ0c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMub25VcGRhdGVFbmQ9XSAtIGNhbGxlZCBhZnRlciB1cGRhdGUoKSBlbmRzXG4gICAqL1xuICBzdGF0aWMgc2V0RGVmYXVsdExvZ0Z1bmN0aW9ucyh7XG4gICAgb25Mb2csXG4gICAgb25VcGRhdGVTdGFydCxcbiAgICBvblVwZGF0ZUVuZFxuICB9ID0ge30pIHtcbiAgICBpZiAob25Mb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbG9nRnVuY3Rpb25zLm9uTG9nID0gb25Mb2cgfHwgbm9vcDtcbiAgICB9XG4gICAgaWYgKG9uVXBkYXRlU3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbG9nRnVuY3Rpb25zLm9uVXBkYXRlU3RhcnQgPSBvblVwZGF0ZVN0YXJ0IHx8IG5vb3A7XG4gICAgfVxuICAgIGlmIChvblVwZGF0ZUVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsb2dGdW5jdGlvbnMub25VcGRhdGVFbmQgPSBvblVwZGF0ZUVuZCB8fCBub29wO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIEF1dG9tYXRlZCBhdHRyaWJ1dGUgZ2VuZXJhdGlvbiBhbmQgbWFuYWdlbWVudC4gU3VpdGFibGUgd2hlbiBhIHNldCBvZlxuICAgKiB2ZXJ0ZXggc2hhZGVyIGF0dHJpYnV0ZXMgYXJlIGdlbmVyYXRlZCBieSBpdGVyYXRpb24gb3ZlciBhIGRhdGEgYXJyYXksXG4gICAqIGFuZCB1cGRhdGVzIHRvIHRoZXNlIGF0dHJpYnV0ZXMgYXJlIG5lZWRlZCBlaXRoZXIgd2hlbiB0aGUgZGF0YSBpdHNlbGZcbiAgICogY2hhbmdlcywgb3Igd2hlbiBvdGhlciBkYXRhIHJlbGV2YW50IHRvIHRoZSBjYWxjdWxhdGlvbnMgY2hhbmdlLlxuICAgKlxuICAgKiAtIEZpcnN0IHRoZSBhcHBsaWNhdGlvbiByZWdpc3RlcnMgZGVzY3JpcHRpb25zIG9mIGl0cyBkeW5hbWljIHZlcnRleFxuICAgKiAgIGF0dHJpYnV0ZXMgdXNpbmcgQXR0cmlidXRlTWFuYWdlci5hZGQoKS5cbiAgICogLSBUaGVuLCB3aGVuIGFueSBjaGFuZ2UgdGhhdCBhZmZlY3RzIGF0dHJpYnV0ZXMgaXMgZGV0ZWN0ZWQgYnkgdGhlXG4gICAqICAgYXBwbGljYXRpb24sIHRoZSBhcHAgd2lsbCBjYWxsIEF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZSgpLlxuICAgKiAtIEZpbmFsbHkgYmVmb3JlIGl0IHJlbmRlcnMsIGl0IGNhbGxzIEF0dHJpYnV0ZU1hbmFnZXIudXBkYXRlKCkgdG9cbiAgICogICBlbnN1cmUgdGhhdCBhdHRyaWJ1dGVzIGFyZSBhdXRvbWF0aWNhbGx5IHJlYnVpbHQgaWYgYW55dGhpbmcgaGFzIGJlZW5cbiAgICogICBpbnZhbGlkYXRlZC5cbiAgICpcbiAgICogVGhlIGFwcGxpY2F0aW9uIHByb3ZpZGVkIHVwZGF0ZSBmdW5jdGlvbnMgZGVzY3JpYmUgaG93IGF0dHJpYnV0ZXNcbiAgICogc2hvdWxkIGJlIHVwZGF0ZWQgZnJvbSBhIGRhdGEgYXJyYXkgYW5kIGFyZSBleHBlY3RlZCB0byB0cmF2ZXJzZVxuICAgKiB0aGF0IGRhdGEgYXJyYXkgKG9yIGl0ZXJhYmxlKSBhbmQgZmlsbCBpbiB0aGUgYXR0cmlidXRlJ3MgdHlwZWQgYXJyYXkuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgYXR0cmlidXRlIG1hbmFnZXIgaW50ZW50aW9uYWxseSBkb2VzIG5vdCBkbyBhZHZhbmNlZFxuICAgKiBjaGFuZ2UgZGV0ZWN0aW9uLCBidXQgaW5zdGVhZCBtYWtlcyBpdCBlYXN5IHRvIGJ1aWxkIHN1Y2ggZGV0ZWN0aW9uXG4gICAqIGJ5IG9mZmVyaW5nIHRoZSBhYmlsaXR5IHRvIFwiaW52YWxpZGF0ZVwiIGVhY2ggYXR0cmlidXRlIHNlcGFyYXRlbHkuXG4gICAqXG4gICAqIFN1bW1hcnk6XG4gICAqIC0ga2VlcHMgdHJhY2sgb2YgdmFsaWQgc3RhdGUgZm9yIGVhY2ggYXR0cmlidXRlXG4gICAqIC0gYXV0byByZWFsbG9jYXRlcyBhdHRyaWJ1dGVzIHdoZW4gbmVlZGVkXG4gICAqIC0gYXV0byB1cGRhdGVzIGF0dHJpYnV0ZXMgd2l0aCByZWdpc3RlcmVkIHVwZGF0ZXIgZnVuY3Rpb25zXG4gICAqIC0gYWxsb3dzIG92ZXJyaWRpbmcgd2l0aCBhcHBsaWNhdGlvbiBzdXBwbGllZCBidWZmZXJzXG4gICAqXG4gICAqIExpbWl0YXRpb25zOlxuICAgKiAtIFRoZXJlIGFyZSBjdXJyZW50bHkgbm8gcHJvdmlzaW9ucyBmb3Igb25seSBpbnZhbGlkYXRpbmcgYSByYW5nZSBvZlxuICAgKiAgIGluZGljZXMgaW4gYW4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wcy5pZF0gLSBpZGVudGlmaWVyIChmb3IgZGVidWdnaW5nKVxuICAgKi9cbiAgY29uc3RydWN0b3Ioe2lkID0gJ2F0dHJpYnV0ZS1tYW5hZ2VyJ30gPSB7fSkge1xuICAgIHRoaXMuaWQgPSBpZDtcblxuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMudXBkYXRlVHJpZ2dlcnMgPSB7fTtcbiAgICB0aGlzLmFsbG9jZWRJbnN0YW5jZXMgPSAtMTtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcblxuICAgIHRoaXMudXNlckRhdGEgPSB7fTtcbiAgICB0aGlzLnN0YXRzID0gbmV3IFN0YXRzKHtpZDogJ2F0dHInfSk7XG5cbiAgICAvLyBGb3IgZGVidWdnaW5nIHNhbml0eSwgcHJldmVudCB1bmluaXRpYWxpemVkIG1lbWJlcnNcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGF0dHJpYnV0ZXNcbiAgICogVGFrZXMgYSBtYXAgb2YgYXR0cmlidXRlIGRlc2NyaXB0b3Igb2JqZWN0c1xuICAgKiAtIGtleXMgYXJlIGF0dHJpYnV0ZSBuYW1lc1xuICAgKiAtIHZhbHVlcyBhcmUgb2JqZWN0cyB3aXRoIGF0dHJpYnV0ZSBmaWVsZHNcbiAgICpcbiAgICogYXR0cmlidXRlLnNpemUgLSBudW1iZXIgb2YgZWxlbWVudHMgcGVyIG9iamVjdFxuICAgKiBhdHRyaWJ1dGUudXBkYXRlciAtIG51bWJlciBvZiBlbGVtZW50c1xuICAgKiBhdHRyaWJ1dGUuaW5zdGFuY2VkPTAgLSBpcyB0aGlzIGlzIGFuIGluc3RhbmNlZCBhdHRyaWJ1dGUgKGEuay5hLiBkaXZpc29yKVxuICAgKiBhdHRyaWJ1dGUubm9BbGxvYz1mYWxzZSAtIGlmIHRoaXMgYXR0cmlidXRlIHNob3VsZCBub3QgYmUgYWxsb2NhdGVkXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGF0dHJpYnV0ZU1hbmFnZXIuYWRkKHtcbiAgICogICBwb3NpdGlvbnM6IHtzaXplOiAyLCB1cGRhdGU6IGNhbGN1bGF0ZVBvc2l0aW9uc31cbiAgICogICBjb2xvcnM6IHtzaXplOiAzLCB1cGRhdGU6IGNhbGN1bGF0ZUNvbG9yc31cbiAgICogfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gYXR0cmlidXRlIG1hcCAoc2VlIGFib3ZlKVxuICAgKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlcnMgLSBzZXBhcmF0ZSBtYXAgb2YgdXBkYXRlIGZ1bmN0aW9ucyAoZGVwcmVjYXRlZClcbiAgICovXG4gIGFkZChhdHRyaWJ1dGVzLCB1cGRhdGVycyA9IHt9KSB7XG4gICAgdGhpcy5fYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzKTtcbiAgfVxuXG4gLyoqXG4gICAqIFJlbW92ZXMgYXR0cmlidXRlc1xuICAgKiBUYWtlcyBhbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZXMgYW5kIGRlbGV0ZSB0aGVtIGZyb21cbiAgICogdGhlIGF0dHJpYnV0ZSBtYXAgaWYgdGhleSBleGlzdHNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoWydwb3NpdGlvbiddKTtcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZU5hbWVBcnJheSAtIGF0dHJpYnV0ZSBuYW1lIGFycmF5IChzZWUgYWJvdmUpXG4gICAqL1xuICByZW1vdmUoYXR0cmlidXRlTmFtZUFycmF5KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVOYW1lQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lQXJyYXlbaV07XG4gICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiBNYXJrcyBhbiBhdHRyaWJ1dGUgZm9yIHVwZGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJpZ2dlck5hbWU6IGF0dHJpYnV0ZSBvciBhY2Nlc3NvciBuYW1lXG4gICAqL1xuICBpbnZhbGlkYXRlKHRyaWdnZXJOYW1lKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXMsIHVwZGF0ZVRyaWdnZXJzfSA9IHRoaXM7XG4gICAgY29uc3QgYXR0cmlidXRlc1RvVXBkYXRlID0gdXBkYXRlVHJpZ2dlcnNbdHJpZ2dlck5hbWVdO1xuXG4gICAgaWYgKCFhdHRyaWJ1dGVzVG9VcGRhdGUpIHtcbiAgICAgIGxldCBtZXNzYWdlID1cbiAgICAgICAgYGludmFsaWRhdGluZyBub24tZXhpc3RlbnQgYXR0cmlidXRlICR7dHJpZ2dlck5hbWV9IGZvciAke3RoaXMuaWR9XFxuYDtcbiAgICAgIG1lc3NhZ2UgKz0gYFZhbGlkIGF0dHJpYnV0ZXM6ICR7T2JqZWN0LmtleXMoYXR0cmlidXRlcykuam9pbignLCAnKX1gO1xuICAgICAgYXNzZXJ0KGF0dHJpYnV0ZXNUb1VwZGF0ZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIGF0dHJpYnV0ZXNUb1VwZGF0ZS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIGlmIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBGb3IgcGVyZm9ybWFuY2UgdHVuaW5nXG4gICAgbG9nRnVuY3Rpb25zLm9uTG9nKHtcbiAgICAgIGxldmVsOiBMT0dfREVUQUlMX1BSSU9SSVRZLFxuICAgICAgbWVzc2FnZTogYGludmFsaWRhdGVkIGF0dHJpYnV0ZSAke2F0dHJpYnV0ZXNUb1VwZGF0ZX0gZm9yICR7dGhpcy5pZH1gLFxuICAgICAgaWQ6IHRoaXMuaWRlbnRpZmllclxuICAgIH0pO1xuICB9XG5cbiAgaW52YWxpZGF0ZUFsbCgpIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUoYXR0cmlidXRlTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSBhbGwgYXR0cmlidXRlIGJ1ZmZlcnMgYXJlIHVwZGF0ZWQgZnJvbSBwcm9wcyBvciBkYXRhLlxuICAgKlxuICAgKiBOb3RlOiBBbnkgcHJlYWxsb2NhdGVkIGJ1ZmZlcnMgaW4gXCJidWZmZXJzXCIgbWF0Y2hpbmcgcmVnaXN0ZXJlZCBhdHRyaWJ1dGVcbiAgICogbmFtZXMgd2lsbCBiZSB1c2VkLiBObyB1cGRhdGUgd2lsbCBoYXBwZW4gaW4gdGhpcyBjYXNlLlxuICAgKiBOb3RlOiBDYWxscyBvblVwZGF0ZVN0YXJ0IGFuZCBvblVwZGF0ZUVuZCBsb2cgY2FsbGJhY2tzIGJlZm9yZSBhbmQgYWZ0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIC0gZGF0YSAoaXRlcmFibGUgb2JqZWN0KVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5udW1JbnN0YW5jZXMgLSBjb3VudCBvZiBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmJ1ZmZlcnMgPSB7fSAtIHByZS1hbGxvY2F0ZWQgYnVmZmVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5wcm9wcyAtIHBhc3NlZCB0byB1cGRhdGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5jb250ZXh0IC0gVXNlZCBhcyBcInRoaXNcIiBjb250ZXh0IGZvciB1cGRhdGVyc1xuICAgKi9cbiAgdXBkYXRlKHtcbiAgICBkYXRhLFxuICAgIG51bUluc3RhbmNlcyxcbiAgICBwcm9wcyA9IHt9LFxuICAgIGJ1ZmZlcnMgPSB7fSxcbiAgICBjb250ZXh0ID0ge30sXG4gICAgaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICAvLyBGaXJzdCBhcHBseSBhbnkgYXBwbGljYXRpb24gcHJvdmlkZWQgYnVmZmVyc1xuICAgIHRoaXMuX2NoZWNrRXh0ZXJuYWxCdWZmZXJzKHtidWZmZXJzLCBpZ25vcmVVbmtub3duQXR0cmlidXRlc30pO1xuICAgIHRoaXMuX3NldEV4dGVybmFsQnVmZmVycyhidWZmZXJzKTtcblxuICAgIC8vIE9ubHkgaW5pdGlhdGUgYWxsb2MvdXBkYXRlIChhbmQgbG9nZ2luZykgaWYgYWN0dWFsbHkgbmVlZGVkXG4gICAgaWYgKHRoaXMuX2FuYWx5emVCdWZmZXJzKHtudW1JbnN0YW5jZXN9KSkge1xuICAgICAgbG9nRnVuY3Rpb25zLm9uVXBkYXRlU3RhcnQoe2xldmVsOiBMT0dfU1RBUlRfRU5EX1BSSU9SSVRZLCBpZDogdGhpcy5pZCwgbnVtSW5zdGFuY2VzfSk7XG4gICAgICB0aGlzLnN0YXRzLnRpbWVTdGFydCgpO1xuICAgICAgdGhpcy5fdXBkYXRlQnVmZmVycyh7bnVtSW5zdGFuY2VzLCBkYXRhLCBwcm9wcywgY29udGV4dH0pO1xuICAgICAgdGhpcy5zdGF0cy50aW1lRW5kKCk7XG4gICAgICBsb2dGdW5jdGlvbnMub25VcGRhdGVFbmQoe2xldmVsOiBMT0dfU1RBUlRfRU5EX1BSSU9SSVRZLCBpZDogdGhpcy5pZCwgbnVtSW5zdGFuY2VzfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGF0dHJpYnV0ZSBkZXNjcmlwdG9yc1xuICAgKiBOb3RlOiBGb3JtYXQgbWF0Y2hlcyBsdW1hLmdsIE1vZGVsL1Byb2dyYW0uc2V0QXR0cmlidXRlcygpXG4gICAqIEByZXR1cm4ge09iamVjdH0gYXR0cmlidXRlcyAtIGRlc2NyaXB0b3JzXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjaGFuZ2VkIGF0dHJpYnV0ZSBkZXNjcmlwdG9yc1xuICAgKiBUaGlzIGluZGljYXRlcyB3aGljaCBXZWJHTEJ1Z2dlcnMgbmVlZCB0byBiZSB1cGRhdGVkXG4gICAqIEByZXR1cm4ge09iamVjdH0gYXR0cmlidXRlcyAtIGRlc2NyaXB0b3JzXG4gICAqL1xuICBnZXRDaGFuZ2VkQXR0cmlidXRlcyh7Y2xlYXJDaGFuZ2VkRmxhZ3MgPSBmYWxzZX0pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuICAgIGNvbnN0IGNoYW5nZWRBdHRyaWJ1dGVzID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAoYXR0cmlidXRlLmNoYW5nZWQpIHtcbiAgICAgICAgYXR0cmlidXRlLmNoYW5nZWQgPSBhdHRyaWJ1dGUuY2hhbmdlZCAmJiAhY2xlYXJDaGFuZ2VkRmxhZ3M7XG4gICAgICAgIGNoYW5nZWRBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gYXR0cmlidXRlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZEF0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVkcmF3IGZsYWcsIG9wdGlvbmFsbHkgY2xlYXJpbmcgaXQuXG4gICAqIFJlZHJhdyBmbGFnIHdpbGwgYmUgc2V0IGlmIGFueSBhdHRyaWJ1dGVzIGF0dHJpYnV0ZXMgY2hhbmdlZCBzaW5jZVxuICAgKiBmbGFnIHdhcyBsYXN0IGNsZWFyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmNsZWFyUmVkcmF3RmxhZ3M9ZmFsc2VdIC0gd2hldGhlciB0byBjbGVhciB0aGUgZmxhZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSAtIHdoZXRoZXIgYSByZWRyYXcgaXMgbmVlZGVkLlxuICAgKi9cbiAgZ2V0TmVlZHNSZWRyYXcoe2NsZWFyUmVkcmF3RmxhZ3MgPSBmYWxzZX0gPSB7fSkge1xuICAgIGxldCByZWRyYXcgPSB0aGlzLm5lZWRzUmVkcmF3O1xuICAgIHJlZHJhdyA9IHJlZHJhdyB8fCB0aGlzLm5lZWRzUmVkcmF3O1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0aGlzLm5lZWRzUmVkcmF3ICYmICFjbGVhclJlZHJhd0ZsYWdzO1xuICAgIHJldHVybiByZWRyYXc7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcmVkcmF3IGZsYWcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVkcmF3PXRydWVcbiAgICogQHJldHVybiB7QXR0cmlidXRlTWFuYWdlcn0gLSBmb3IgY2hhaW5pbmdcbiAgICovXG4gIHNldE5lZWRzUmVkcmF3KHJlZHJhdyA9IHRydWUpIHtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIERFUFJFQ0FURUQgTUVUSE9EU1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNSwgdXNlIGFkZCgpIGluc3RlYWRcbiAgICogQWRkcyBhdHRyaWJ1dGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIC0gYXR0cmlidXRlIG1hcCAoc2VlIGFib3ZlKVxuICAgKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlcnMgLSBzZXBhcmF0ZSBtYXAgb2YgdXBkYXRlIGZ1bmN0aW9ucyAoZGVwcmVjYXRlZClcbiAgICovXG4gIGFkZEluc3RhbmNlZChhdHRyaWJ1dGVzLCB1cGRhdGVycyA9IHt9KSB7XG4gICAgdGhpcy5fYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzLCB7aW5zdGFuY2VkOiAxfSk7XG4gIH1cblxuICAvLyBQUklWQVRFIE1FVEhPRFNcblxuICAvLyBVc2VkIHRvIHJlZ2lzdGVyIGFuIGF0dHJpYnV0ZVxuICBfYWRkKGF0dHJpYnV0ZXMsIHVwZGF0ZXJzID0ge30sIF9leHRyYVByb3BzID0ge30pIHtcblxuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7fTtcblxuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAvLyBzdXBwb3J0IGZvciBzZXBhcmF0ZSB1cGRhdGUgZnVuY3Rpb24gbWFwXG4gICAgICAvLyBGb3Igbm93LCBqdXN0IGNvcHkgYW55IGF0dHJpYnV0ZXMgZnJvbSB0aGF0IG1hcCBpbnRvIHRoZSBtYWluIG1hcFxuICAgICAgLy8gVE9ETyAtIEF0dHJpYnV0ZSBtYXBzIGFyZSBhIGRlcHJlY2F0ZWQgZmVhdHVyZSwgcmVtb3ZlXG4gICAgICBpZiAoYXR0cmlidXRlTmFtZSBpbiB1cGRhdGVycykge1xuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID1cbiAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdLCB1cGRhdGVyc1thdHRyaWJ1dGVOYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG5cbiAgICAgIGNvbnN0IGlzSW5kZXhlZCA9IGF0dHJpYnV0ZS5pc0luZGV4ZWQgfHwgYXR0cmlidXRlLmVsZW1lbnRzO1xuICAgICAgY29uc3Qgc2l6ZSA9IChhdHRyaWJ1dGUuZWxlbWVudHMgJiYgMSkgfHwgYXR0cmlidXRlLnNpemU7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZSB8fCBudWxsO1xuXG4gICAgICAvLyBJbml0aWFsaXplIHRoZSBhdHRyaWJ1dGUgZGVzY3JpcHRvciwgd2l0aCBXZWJHTCBhbmQgbWV0YWRhdGEgZmllbGRzXG4gICAgICBjb25zdCBhdHRyaWJ1dGVEYXRhID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge1xuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IGZpZWxkcyBhcmUgcHJlc2VudCBiZWZvcmUgT2JqZWN0LnNlYWwoKVxuICAgICAgICAgIHRhcmdldDogdW5kZWZpbmVkLFxuICAgICAgICAgIHVzZXJEYXRhOiB7fSAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIGFwcGxpY2F0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1ldGFkYXRhXG4gICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAge1xuICAgICAgICAgIC8vIFN0YXRlXG4gICAgICAgICAgaXNFeHRlcm5hbEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgbmVlZHNBbGxvYzogZmFsc2UsXG4gICAgICAgICAgbmVlZHNVcGRhdGU6IGZhbHNlLFxuICAgICAgICAgIGNoYW5nZWQ6IGZhbHNlLFxuXG4gICAgICAgICAgLy8gTHVtYSBmaWVsZHNcbiAgICAgICAgICBpc0luZGV4ZWQsXG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9LFxuICAgICAgICBfZXh0cmFQcm9wc1xuICAgICAgKTtcbiAgICAgIC8vIFNhbml0eSAtIG5vIGFwcCBmaWVsZHMgb24gb3VyIGF0dHJpYnV0ZXMuIFVzZSB1c2VyRGF0YSBpbnN0ZWFkLlxuICAgICAgT2JqZWN0LnNlYWwoYXR0cmlidXRlRGF0YSk7XG5cbiAgICAgIC8vIENoZWNrIGFsbCBmaWVsZHMgYW5kIGdlbmVyYXRlIGhlbHBmdWwgZXJyb3IgbWVzc2FnZXNcbiAgICAgIHRoaXMuX3ZhbGlkYXRlQXR0cmlidXRlRGVmaW5pdGlvbihhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVEYXRhKTtcblxuICAgICAgLy8gQWRkIHRvIGJvdGggYXR0cmlidXRlcyBsaXN0IChmb3IgcmVnaXN0cmF0aW9uIHdpdGggbW9kZWwpXG4gICAgICBuZXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdID0gYXR0cmlidXRlRGF0YTtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMuYXR0cmlidXRlcywgbmV3QXR0cmlidXRlcyk7XG5cbiAgICB0aGlzLl9tYXBVcGRhdGVUcmlnZ2Vyc1RvQXR0cmlidXRlcygpO1xuICB9XG5cbiAgLy8gYnVpbGQgdXBkYXRlVHJpZ2dlciBuYW1lIHRvIGF0dHJpYnV0ZSBuYW1lIG1hcHBpbmdcbiAgX21hcFVwZGF0ZVRyaWdnZXJzVG9BdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IHRyaWdnZXJzID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBsZXQge2FjY2Vzc29yfSA9IGF0dHJpYnV0ZTtcblxuICAgICAgLy8gdXNlIGF0dHJpYnV0ZSBuYW1lIGFzIHVwZGF0ZSB0cmlnZ2VyIGtleVxuICAgICAgdHJpZ2dlcnNbYXR0cmlidXRlTmFtZV0gPSBbYXR0cmlidXRlTmFtZV07XG5cbiAgICAgIC8vIHVzZSBhY2Nlc3NvciBuYW1lIGFzIHVwZGF0ZSB0cmlnZ2VyIGtleVxuICAgICAgaWYgKHR5cGVvZiBhY2Nlc3NvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYWNjZXNzb3IgPSBbYWNjZXNzb3JdO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWNjZXNzb3IpKSB7XG4gICAgICAgIGFjY2Vzc29yLmZvckVhY2goYWNjZXNzb3JOYW1lID0+IHtcbiAgICAgICAgICBpZiAoIXRyaWdnZXJzW2FjY2Vzc29yTmFtZV0pIHtcbiAgICAgICAgICAgIHRyaWdnZXJzW2FjY2Vzc29yTmFtZV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJpZ2dlcnNbYWNjZXNzb3JOYW1lXS5wdXNoKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVRyaWdnZXJzID0gdHJpZ2dlcnM7XG4gIH1cblxuICBfdmFsaWRhdGVBdHRyaWJ1dGVEZWZpbml0aW9uKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZSkge1xuICAgIGFzc2VydChhdHRyaWJ1dGUuc2l6ZSA+PSAxICYmIGF0dHJpYnV0ZS5zaXplIDw9IDQsXG4gICAgICBgQXR0cmlidXRlIGRlZmluaXRpb24gZm9yICR7YXR0cmlidXRlTmFtZX0gaW52YWxpZCBzaXplYCk7XG5cbiAgICAvLyBDaGVjayB0aGF0IGVpdGhlciAnYWNjZXNzb3InIG9yICd1cGRhdGUnIGlzIGEgdmFsaWQgZnVuY3Rpb25cbiAgICBjb25zdCBoYXNVcGRhdGVyID0gYXR0cmlidXRlLm5vQWxsb2MgfHxcbiAgICAgIHR5cGVvZiBhdHRyaWJ1dGUudXBkYXRlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXR0cmlidXRlLmFjY2Vzc29yID09PSAnc3RyaW5nJztcbiAgICBpZiAoIWhhc1VwZGF0ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0cmlidXRlICR7YXR0cmlidXRlTmFtZX0gbWlzc2luZyB1cGRhdGUgb3IgYWNjZXNzb3JgKTtcbiAgICB9XG4gIH1cblxuICAvLyBDaGVja3MgdGhhdCBhbnkgYXR0cmlidXRlIGJ1ZmZlcnMgaW4gcHJvcHMgYXJlIHZhbGlkXG4gIC8vIE5vdGU6IFRoaXMgaXMganVzdCB0byBoZWxwIGFwcCBjYXRjaCBtaXN0YWtlc1xuICBfY2hlY2tFeHRlcm5hbEJ1ZmZlcnMoe1xuICAgIGJ1ZmZlcnMgPSB7fSxcbiAgICBpZ25vcmVVbmtub3duQXR0cmlidXRlcyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVzfSA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGJ1ZmZlcnMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAoIWF0dHJpYnV0ZSAmJiAhaWdub3JlVW5rbm93bkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGF0dHJpYnV0ZSBwcm9wICR7YXR0cmlidXRlTmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIC8vIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlcnNbYXR0cmlidXRlTmFtZV07XG4gICAgICAvLyBUT0RPIC0gY2hlY2sgYnVmZmVyIHR5cGVcbiAgICB9XG4gIH1cblxuICAvLyBTZXQgdGhlIGJ1ZmZlcnMgZm9yIHRoZSBzdXBwbGllZCBhdHRyaWJ1dGVzXG4gIC8vIFVwZGF0ZSBhdHRyaWJ1dGUgYnVmZmVycyBmcm9tIGFueSBhdHRyaWJ1dGVzIGluIHByb3BzXG4gIC8vIERldGFjaCBhbnkgcHJldmlvdXNseSBzZXQgYnVmZmVycywgbWFya2luZyBhbGxcbiAgLy8gQXR0cmlidXRlcyBmb3IgYXV0byBhbGxvY2F0aW9uXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG4gIF9zZXRFeHRlcm5hbEJ1ZmZlcnMoYnVmZmVyTWFwKSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXMsIG51bUluc3RhbmNlc30gPSB0aGlzO1xuXG4gICAgLy8gQ29weSB0aGUgcmVmcyBvZiBhbnkgc3VwcGxpZWQgYnVmZmVycyBpbiB0aGUgcHJvcHNcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlck1hcFthdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGF0dHJpYnV0ZS5pc0V4dGVybmFsQnVmZmVyID0gZmFsc2U7XG4gICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IEFycmF5VHlwZSA9IGdsQXJyYXlGcm9tVHlwZShhdHRyaWJ1dGUudHlwZSB8fCBHTC5GTE9BVCk7XG4gICAgICAgIGlmICghKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5VHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dHJpYnV0ZSAke2F0dHJpYnV0ZU5hbWV9IG11c3QgYmUgb2YgdHlwZSAke0FycmF5VHlwZS5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuYXV0byAmJiBidWZmZXIubGVuZ3RoIDw9IG51bUluc3RhbmNlcyAqIGF0dHJpYnV0ZS5zaXplKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRyaWJ1dGUgcHJvcCBhcnJheSBtdXN0IG1hdGNoIGxlbmd0aCBhbmQgc2l6ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0cmlidXRlLmlzRXh0ZXJuYWxCdWZmZXIgPSB0cnVlO1xuICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS52YWx1ZSAhPT0gYnVmZmVyKSB7XG4gICAgICAgICAgYXR0cmlidXRlLnZhbHVlID0gYnVmZmVyO1xuICAgICAgICAgIGF0dHJpYnV0ZS5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgLyogQ2hlY2tzIHRoYXQgdHlwZWQgYXJyYXlzIGZvciBhdHRyaWJ1dGVzIGFyZSBiaWcgZW5vdWdoXG4gICAqIHNldHMgYWxsb2MgZmxhZyBpZiBub3RcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBhbnkgdXBkYXRlcyBhcmUgbmVlZGVkXG4gICAqL1xuICBfYW5hbHl6ZUJ1ZmZlcnMoe251bUluc3RhbmNlc30pIHtcbiAgICBjb25zdCB7YXR0cmlidXRlc30gPSB0aGlzO1xuICAgIGFzc2VydChudW1JbnN0YW5jZXMgIT09IHVuZGVmaW5lZCwgJ251bUluc3RhbmNlcyBub3QgZGVmaW5lZCcpO1xuXG4gICAgLy8gVHJhY2sgd2hldGhlciBhbnkgYWxsb2NhdGlvbnMgb3IgdXBkYXRlcyBhcmUgbmVlZGVkXG4gICAgbGV0IG5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmICghYXR0cmlidXRlLmlzRXh0ZXJuYWxCdWZmZXIpIHtcbiAgICAgICAgLy8gRG8gd2UgbmVlZCB0byByZWFsbG9jYXRlIHRoZSBhdHRyaWJ1dGUncyB0eXBlZCBhcnJheT9cbiAgICAgICAgY29uc3QgbmVlZHNBbGxvYyA9XG4gICAgICAgICAgYXR0cmlidXRlLnZhbHVlID09PSBudWxsIHx8XG4gICAgICAgICAgYXR0cmlidXRlLnZhbHVlLmxlbmd0aCAvIGF0dHJpYnV0ZS5zaXplIDwgbnVtSW5zdGFuY2VzO1xuICAgICAgICBpZiAobmVlZHNBbGxvYyAmJiAoYXR0cmlidXRlLnVwZGF0ZSB8fCBhdHRyaWJ1dGUuYWNjZXNzb3IpKSB7XG4gICAgICAgICAgYXR0cmlidXRlLm5lZWRzQWxsb2MgPSB0cnVlO1xuICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlLm5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5lZWRzVXBkYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIENhbGxzIHVwZGF0ZSBvbiBhbnkgYnVmZmVycyB0aGF0IG5lZWQgdXBkYXRlXG4gICAqIFRPRE8/IC0gSWYgYXBwIHN1cHBsaWVkIGFsbCBhdHRyaWJ1dGVzLCBubyBuZWVkIHRvIGl0ZXJhdGUgb3ZlciBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5kYXRhIC0gZGF0YSAoaXRlcmFibGUgb2JqZWN0KVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5udW1JbnN0YW5jZXMgLSBjb3VudCBvZiBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmJ1ZmZlcnMgPSB7fSAtIHByZS1hbGxvY2F0ZWQgYnVmZmVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5wcm9wcyAtIHBhc3NlZCB0byB1cGRhdGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5jb250ZXh0IC0gVXNlZCBhcyBcInRoaXNcIiBjb250ZXh0IGZvciB1cGRhdGVyc1xuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgbWF4LXN0YXRlbWVudHMsIGNvbXBsZXhpdHkgKi9cbiAgX3VwZGF0ZUJ1ZmZlcnMoe251bUluc3RhbmNlcywgZGF0YSwgcHJvcHMsIGNvbnRleHR9KSB7XG4gICAgY29uc3Qge2F0dHJpYnV0ZXN9ID0gdGhpcztcblxuICAgIC8vIEFsbG9jYXRlIGF0IGxlYXN0IG9uZSBlbGVtZW50IHRvIGVuc3VyZSBhIHZhbGlkIGJ1ZmZlclxuICAgIGNvbnN0IGFsbG9jQ291bnQgPSBNYXRoLm1heChudW1JbnN0YW5jZXMsIDEpO1xuXG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG5cbiAgICAgIC8vIEFsbG9jYXRlIGEgbmV3IHR5cGVkIGFycmF5IGlmIG5lZWRlZFxuICAgICAgaWYgKGF0dHJpYnV0ZS5uZWVkc0FsbG9jKSB7XG4gICAgICAgIGNvbnN0IEFycmF5VHlwZSA9IGdsQXJyYXlGcm9tVHlwZShhdHRyaWJ1dGUudHlwZSB8fCBHTC5GTE9BVCk7XG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBBcnJheVR5cGUoYXR0cmlidXRlLnNpemUgKiBhbGxvY0NvdW50KTtcbiAgICAgICAgbG9nRnVuY3Rpb25zLm9uTG9nKHtcbiAgICAgICAgICBsZXZlbDogTE9HX0RFVEFJTF9QUklPUklUWSxcbiAgICAgICAgICBtZXNzYWdlOiBgJHt0aGlzLmlkfToke2F0dHJpYnV0ZU5hbWV9IGFsbG9jYXRlZCAke2FsbG9jQ291bnR9YCxcbiAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICB9KTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzQWxsb2MgPSBmYWxzZTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FsbCB1cGRhdGVyIGZ1bmN0aW9uIGlmIG5lZWRlZFxuICAgICAgaWYgKGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl91cGRhdGVCdWZmZXIoe2F0dHJpYnV0ZSwgYXR0cmlidXRlTmFtZSwgbnVtSW5zdGFuY2VzLCBkYXRhLCBwcm9wcywgY29udGV4dH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWxsb2NlZEluc3RhbmNlcyA9IGFsbG9jQ291bnQ7XG4gIH1cblxuICBfdXBkYXRlQnVmZmVyKHthdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUsIG51bUluc3RhbmNlcywgZGF0YSwgcHJvcHMsIGNvbnRleHR9KSB7XG4gICAgY29uc3Qge3VwZGF0ZSwgYWNjZXNzb3J9ID0gYXR0cmlidXRlO1xuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIC8vIEN1c3RvbSB1cGRhdGVyIC0gdHlwaWNhbGx5IGZvciBub24taW5zdGFuY2VkIGxheWVyc1xuICAgICAgbG9nRnVuY3Rpb25zLm9uTG9nKHtcbiAgICAgICAgbGV2ZWw6IExPR19ERVRBSUxfUFJJT1JJVFksXG4gICAgICAgIG1lc3NhZ2U6IGAke3RoaXMuaWR9OiR7YXR0cmlidXRlTmFtZX0gdXBkYXRpbmcgJHtudW1JbnN0YW5jZXN9YCxcbiAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgIH0pO1xuICAgICAgdXBkYXRlLmNhbGwoY29udGV4dCwgYXR0cmlidXRlLCB7ZGF0YSwgcHJvcHMsIG51bUluc3RhbmNlc30pO1xuICAgICAgdGhpcy5fY2hlY2tBdHRyaWJ1dGVBcnJheShhdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYWNjZXNzb3IpIHtcbiAgICAgIC8vIFN0YW5kYXJkIHVwZGF0ZXJcbiAgICAgIHRoaXMuX3VwZGF0ZUJ1ZmZlclZpYVN0YW5kYXJkQWNjZXNzb3Ioe2F0dHJpYnV0ZSwgZGF0YSwgcHJvcHN9KTtcbiAgICAgIHRoaXMuX2NoZWNrQXR0cmlidXRlQXJyYXkoYXR0cmlidXRlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nRnVuY3Rpb25zLm9uTG9nKHtcbiAgICAgICAgbGV2ZWw6IExPR19ERVRBSUxfUFJJT1JJVFksXG4gICAgICAgIG1lc3NhZ2U6IGAke3RoaXMuaWR9OiR7YXR0cmlidXRlTmFtZX0gbWlzc2luZyB1cGRhdGUgZnVuY3Rpb25gLFxuICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgYXR0cmlidXRlLmNoYW5nZWQgPSB0cnVlO1xuICAgIHRoaXMubmVlZHNSZWRyYXcgPSB0cnVlO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMgKi9cblxuICBfdXBkYXRlQnVmZmVyVmlhU3RhbmRhcmRBY2Nlc3Nvcih7YXR0cmlidXRlLCBkYXRhLCBwcm9wc30pIHtcbiAgICBjb25zdCB7YWNjZXNzb3IsIHZhbHVlLCBzaXplfSA9IGF0dHJpYnV0ZTtcbiAgICBjb25zdCBhY2Nlc3NvckZ1bmMgPSBwcm9wc1thY2Nlc3Nvcl07XG5cbiAgICBhc3NlcnQodHlwZW9mIGFjY2Vzc29yRnVuYyA9PT0gJ2Z1bmN0aW9uJywgYGFjY2Vzc29yIFwiJHthY2Nlc3Nvcn1cIiBpcyBub3QgYSBmdW5jdGlvbmApO1xuXG4gICAgbGV0IHtkZWZhdWx0VmFsdWUgPSBbMCwgMCwgMCwgMF19ID0gYXR0cmlidXRlO1xuICAgIGRlZmF1bHRWYWx1ZSA9IEFycmF5LmlzQXJyYXkoZGVmYXVsdFZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IFtkZWZhdWx0VmFsdWVdO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBkYXRhKSB7XG4gICAgICBsZXQgb2JqZWN0VmFsdWUgPSBhY2Nlc3NvckZ1bmMob2JqZWN0KTtcbiAgICAgIG9iamVjdFZhbHVlID0gQXJyYXkuaXNBcnJheShvYmplY3RWYWx1ZSkgPyBvYmplY3RWYWx1ZSA6IFtvYmplY3RWYWx1ZV07XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1mYWxsdGhyb3VnaCwgZGVmYXVsdC1jYXNlICovXG4gICAgICBzd2l0Y2ggKHNpemUpIHtcbiAgICAgIGNhc2UgNDogdmFsdWVbaSArIDNdID0gTnVtYmVyLmlzRmluaXRlKG9iamVjdFZhbHVlWzNdKSA/IG9iamVjdFZhbHVlWzNdIDogZGVmYXVsdFZhbHVlWzNdO1xuICAgICAgY2FzZSAzOiB2YWx1ZVtpICsgMl0gPSBOdW1iZXIuaXNGaW5pdGUob2JqZWN0VmFsdWVbMl0pID8gb2JqZWN0VmFsdWVbMl0gOiBkZWZhdWx0VmFsdWVbMl07XG4gICAgICBjYXNlIDI6IHZhbHVlW2kgKyAxXSA9IE51bWJlci5pc0Zpbml0ZShvYmplY3RWYWx1ZVsxXSkgPyBvYmplY3RWYWx1ZVsxXSA6IGRlZmF1bHRWYWx1ZVsxXTtcbiAgICAgIGNhc2UgMTogdmFsdWVbaSArIDBdID0gTnVtYmVyLmlzRmluaXRlKG9iamVjdFZhbHVlWzBdKSA/IG9iamVjdFZhbHVlWzBdIDogZGVmYXVsdFZhbHVlWzBdO1xuICAgICAgfVxuICAgICAgaSArPSBzaXplO1xuICAgIH1cbiAgfVxuXG4gIF9jaGVja0F0dHJpYnV0ZUFycmF5KGF0dHJpYnV0ZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHt2YWx1ZX0gPSBhdHRyaWJ1dGU7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+PSA0KSB7XG4gICAgICBjb25zdCB2YWxpZCA9XG4gICAgICAgIE51bWJlci5pc0Zpbml0ZSh2YWx1ZVswXSkgJiYgTnVtYmVyLmlzRmluaXRlKHZhbHVlWzFdKSAmJlxuICAgICAgICBOdW1iZXIuaXNGaW5pdGUodmFsdWVbMl0pICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZVszXSk7XG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSWxsZWdhbCBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGZvciAke2F0dHJpYnV0ZU5hbWV9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXX0=