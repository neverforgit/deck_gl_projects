var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import assert from 'assert';
import { Framebuffer, ShaderCache } from 'luma.gl';
import seer from 'seer';
import Layer from './layer';
import { log } from './utils';
import { flatten } from './utils/flatten';
import { drawLayers as _drawLayers } from './draw-layers';
import { pickObject as _pickObject, pickVisibleObjects as _pickVisibleObjects } from './pick-layers';
import { LIFECYCLE } from './constants';
import Viewport from '../viewports/viewport';
import { setPropOverrides, layerEditListener, seerInitListener, initLayerInSeer, updateLayerInSeer } from './seer-integration';

var LOG_PRIORITY_LIFECYCLE = 2;
var LOG_PRIORITY_LIFECYCLE_MINOR = 4;

var layerName = function layerName(layer) {
  return layer instanceof Layer ? '' + layer : !layer ? 'null layer' : 'invalid layer';
};

var LayerManager = function () {
  function LayerManager(_ref) {
    var gl = _ref.gl;

    _classCallCheck(this, LayerManager);

    // Currently deck.gl expects the DeckGL.layers array to be different
    // whenever React rerenders. If the same layers array is used, the
    // LayerManager's diffing algorithm will generate a fatal error and
    // break the rendering.

    // `this.lastRenderedLayers` stores the UNFILTERED layers sent
    // down to LayerManager, so that `layers` reference can be compared.
    // If it's the same across two React render calls, the diffing logic
    // will be skipped.
    this.lastRenderedLayers = [];

    this.prevLayers = [];
    this.layers = [];
    this.oldContext = {};
    this.screenCleared = false;
    this._needsRedraw = true;

    this._eventManager = null;
    this._pickingRadius = 0;
    this._onLayerClick = null;
    this._onLayerHover = null;
    this._onClick = this._onClick.bind(this);
    this._onPointerMove = this._onPointerMove.bind(this);
    this._onPointerLeave = this._onPointerLeave.bind(this);
    this._pickAndCallback = this._pickAndCallback.bind(this);

    this._initSeer = this._initSeer.bind(this);
    this._editSeer = this._editSeer.bind(this);

    this.context = {
      gl: gl,
      uniforms: {},
      viewports: [],
      viewport: null,
      viewportChanged: true,
      pickingFBO: null,
      useDevicePixelRatio: true,
      lastPickedInfo: {
        index: -1,
        layerId: null
      },
      shaderCache: new ShaderCache({ gl: gl })
    };

    seerInitListener(this._initSeer);
    layerEditListener(this._editSeer);

    Object.seal(this.context);
    Object.seal(this);
  }

  /**
   * Method to call when the layer manager is not needed anymore.
   *
   * Currently used in the <DeckGL> componentWillUnmount lifecycle to unbind Seer listeners.
   */


  _createClass(LayerManager, [{
    key: 'finalize',
    value: function finalize() {
      seer.removeListener(this._initSeer);
      seer.removeListener(this._editSeer);
    }

    // Gets an (optionally) filtered list of layers

  }, {
    key: 'getLayers',
    value: function getLayers() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === undefined ? null : _ref2$layerIds;

      // Filtering by layerId compares beginning of strings, so that sublayers will be included
      // Dependes on the convention of adding suffixes to the parent's layer name
      return layerIds ? this.layers.filter(function (layer) {
        return layerIds.find(function (layerId) {
          return layer.id.indexOf(layerId) === 0;
        });
      }) : this.layers;
    }
  }, {
    key: 'getViewports',
    value: function getViewports() {
      return this.context.viewports;
    }

    /**
     * Set parameters needed for layer rendering and picking.
     * Parameters are to be passed as a single object, with the following values:
     * @param {Boolean} useDevicePixelRatio
     */

  }, {
    key: 'setParameters',
    value: function setParameters(parameters) {
      if ('eventManager' in parameters) {
        this.initEventHandling(parameters.eventManager);
      }

      if ('pickingRadius' in parameters || 'onLayerClick' in parameters || 'onLayerHover' in parameters) {
        this.setEventHandlingParameters(parameters);
      }

      if ('viewports' in parameters) {
        this.setViewports(parameters.viewports);
      }

      if ('layers' in parameters) {
        this.updateLayers({ newLayers: parameters.layers });
      }

      this.context = Object.assign({}, this.context, parameters);
    }
  }, {
    key: 'setViewports',
    value: function setViewports(viewports) {
      viewports = flatten(viewports, { filter: Boolean });

      // Viewports are "immutable", so we can shallow compare
      var oldViewports = this.context.viewports;
      var viewportsChanged = viewports.length !== oldViewports.length || viewports.some(function (_, i) {
        return viewports[i] !== oldViewports[i];
      });

      if (viewportsChanged) {
        this._needsRedraw = true;

        // Need to ensure one viewport is activated
        var viewport = viewports[0];
        assert(viewport instanceof Viewport, 'Invalid viewport');

        this.context.viewports = viewports;
        this._activateViewport(viewport);
      }
    }

    /**
     * @param {Object} eventManager   A source of DOM input events
     */

  }, {
    key: 'initEventHandling',
    value: function initEventHandling(eventManager) {
      this._eventManager = eventManager;

      // TODO: add/remove handlers on demand at runtime, not all at once on init.
      // Consider both top-level handlers like onLayerClick/Hover
      // and per-layer handlers attached to individual layers.
      // https://github.com/uber/deck.gl/issues/634
      this._eventManager.on({
        click: this._onClick,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerLeave
      });
    }

    // Set parameters for input event handling.

  }, {
    key: 'setEventHandlingParameters',
    value: function setEventHandlingParameters(_ref3) {
      var pickingRadius = _ref3.pickingRadius,
          onLayerClick = _ref3.onLayerClick,
          onLayerHover = _ref3.onLayerHover;

      if (!isNaN(pickingRadius)) {
        this._pickingRadius = pickingRadius;
      }
      if (typeof onLayerClick !== 'undefined') {
        this._onLayerClick = onLayerClick;
      }
      if (typeof onLayerHover !== 'undefined') {
        this._onLayerHover = onLayerHover;
      }
      this._validateEventHandling();
    }
  }, {
    key: 'updateLayers',
    value: function updateLayers(_ref4) {
      var newLayers = _ref4.newLayers;

      // TODO - something is generating state updates that cause rerender of the same
      if (newLayers === this.lastRenderedLayers) {
        log.log(3, 'Ignoring layer update due to layer array not changed');
        return this;
      }
      this.lastRenderedLayers = newLayers;

      assert(this.context.viewport, 'LayerManager.updateLayers: viewport not set');

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return newLayer !== null;
      });

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = newLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var layer = _step.value;

          layer.context = this.context;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.prevLayers = this.layers;

      var _updateLayers2 = this._updateLayers({
        oldLayers: this.prevLayers,
        newLayers: newLayers
      }),
          error = _updateLayers2.error,
          generatedLayers = _updateLayers2.generatedLayers;

      this.layers = generatedLayers;
      // Throw first error found, if any
      if (error) {
        throw error;
      }
      return this;
    }
  }, {
    key: 'drawLayers',
    value: function drawLayers(_ref5) {
      var _ref5$pass = _ref5.pass,
          pass = _ref5$pass === undefined ? 'render to screen' : _ref5$pass;
      var _context = this.context,
          gl = _context.gl,
          useDevicePixelRatio = _context.useDevicePixelRatio,
          drawPickingColors = _context.drawPickingColors;

      // render this viewport

      _drawLayers(gl, {
        pass: pass,
        layers: this.layers,
        viewports: this.context.viewports,
        onViewportActive: this._activateViewport.bind(this),
        useDevicePixelRatio: useDevicePixelRatio,
        drawPickingColors: drawPickingColors
      });

      return this;
    }

    // Pick the closest info at given coordinate

  }, {
    key: 'pickObject',
    value: function pickObject(_ref6) {
      var x = _ref6.x,
          y = _ref6.y,
          mode = _ref6.mode,
          _ref6$radius = _ref6.radius,
          radius = _ref6$radius === undefined ? 0 : _ref6$radius,
          layerIds = _ref6.layerIds;
      var _context2 = this.context,
          gl = _context2.gl,
          useDevicePixelRatio = _context2.useDevicePixelRatio;


      var layers = this.getLayers({ layerIds: layerIds });

      return _pickObject(gl, {
        x: x,
        y: y,
        radius: radius,
        layers: layers,
        mode: mode,
        viewports: this.context.viewports,
        onViewportActive: this._activateViewport.bind(this),
        pickingFBO: this._getPickingBuffer(),
        lastPickedInfo: this.context.lastPickedInfo,
        useDevicePixelRatio: useDevicePixelRatio
      });
    }

    // Get all unique infos within a bounding box

  }, {
    key: 'pickVisibleObjects',
    value: function pickVisibleObjects(_ref7) {
      var x = _ref7.x,
          y = _ref7.y,
          width = _ref7.width,
          height = _ref7.height,
          layerIds = _ref7.layerIds;
      var _context3 = this.context,
          gl = _context3.gl,
          useDevicePixelRatio = _context3.useDevicePixelRatio;


      var layers = this.getLayers({ layerIds: layerIds });

      return _pickVisibleObjects(gl, {
        x: x,
        y: y,
        width: width,
        height: height,
        layers: layers,
        mode: 'query',
        // TODO - how does this interact with multiple viewports?
        viewport: this.context.viewport,
        viewports: this.context.viewports,
        onViewportActive: this._activateViewport.bind(this),
        pickingFBO: this._getPickingBuffer(),
        useDevicePixelRatio: useDevicePixelRatio
      });
    }
  }, {
    key: 'needsRedraw',
    value: function needsRedraw() {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref8$clearRedrawFlag = _ref8.clearRedrawFlags,
          clearRedrawFlags = _ref8$clearRedrawFlag === undefined ? false : _ref8$clearRedrawFlag;

      if (!this.context.viewport) {
        return false;
      }

      var redraw = this._needsRedraw;
      if (clearRedrawFlags) {
        this._needsRedraw = false;
      }

      // Make sure that buffer is cleared once when layer list becomes empty
      if (this.layers.length === 0) {
        if (this.screenCleared === false) {
          redraw = true;
          this.screenCleared = true;
          return true;
        }
      } else if (this.screenCleared === true) {
        this.screenCleared = false;
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var layer = _step2.value;

          redraw = redraw || layer.getNeedsRedraw({ clearRedrawFlags: clearRedrawFlags });
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return redraw;
    }

    //
    // DEPRECATED METHODS
    //

  }, {
    key: 'setViewport',
    value: function setViewport(viewport) {
      log.deprecated('setViewport', 'setViewports');
      this.setViewports([viewport]);
      return this;
    }

    //
    // PRIVATE METHODS
    //

    // Make a viewport "current" in layer context, primed for draw

  }, {
    key: '_activateViewport',
    value: function _activateViewport(viewport) {
      // TODO - viewport change detection breaks METER_OFFSETS mode
      // const oldViewport = this.context.viewport;
      // const viewportChanged = !oldViewport || !viewport.equals(oldViewport);
      var viewportChanged = true;

      if (viewportChanged) {
        Object.assign(this.oldContext, this.context);
        this.context.viewport = viewport;
        this.context.viewportChanged = true;
        this.context.uniforms = {};
        log(4, viewport);

        // Update layers states
        // Let screen space layers update their state based on viewport
        // TODO - reimplement viewport change detection (single viewport optimization)
        // TODO - don't set viewportChanged during setViewports?
        if (this.context.viewportChanged) {
          this._updateLayerStates({ viewportChanged: true });
        }
      }

      assert(this.context.viewport, 'LayerManager: viewport not set');

      return this;
    }

    // Walk the layers and update their states

  }, {
    key: '_updateLayerStates',
    value: function _updateLayerStates(changeFlags) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.layers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var layer = _step3.value;

          layer.updateLayer({ changeFlags: changeFlags });
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }

    // Get a viewport from a viewport descriptor (which can be a plain viewport)

  }, {
    key: '_getViewportFromDescriptor',
    value: function _getViewportFromDescriptor(viewportOrDescriptor) {
      return viewportOrDescriptor.viewport ? viewportOrDescriptor.viewport : viewportOrDescriptor;
    }
  }, {
    key: '_getPickingBuffer',
    value: function _getPickingBuffer() {
      var gl = this.context.gl;
      // Create a frame buffer if not already available

      this.context.pickingFBO = this.context.pickingFBO || new Framebuffer(gl);
      // Resize it to current canvas size (this is a noop if size hasn't changed)
      this.context.pickingFBO.resize({ width: gl.canvas.width, height: gl.canvas.height });
      return this.context.pickingFBO;
    }

    // Match all layers, checking for caught errors
    // To avoid having an exception in one layer disrupt other layers
    // TODO - mark layers with exceptions as bad and remove from rendering cycle?

  }, {
    key: '_updateLayers',
    value: function _updateLayers(_ref9) {
      var oldLayers = _ref9.oldLayers,
          newLayers = _ref9.newLayers;

      // Create old layer map
      var oldLayerMap = {};
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = oldLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var oldLayer = _step4.value;

          if (oldLayerMap[oldLayer.id]) {
            log.once(0, 'Multiple old layers with same id ' + layerName(oldLayer));
          } else {
            oldLayerMap[oldLayer.id] = oldLayer;
            oldLayer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
          }
        }

        // Allocate array for generated layers
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      var generatedLayers = [];

      // Match sublayers
      var error = this._matchSublayers({
        newLayers: newLayers, oldLayerMap: oldLayerMap, generatedLayers: generatedLayers
      });

      var error2 = this._finalizeOldLayers(oldLayers);
      var firstError = error || error2;
      return { error: firstError, generatedLayers: generatedLayers };
    }

    /* eslint-disable max-statements */

  }, {
    key: '_matchSublayers',
    value: function _matchSublayers(_ref10) {
      var _this = this;

      var newLayers = _ref10.newLayers,
          oldLayerMap = _ref10.oldLayerMap,
          generatedLayers = _ref10.generatedLayers;

      // Filter out any null layers
      newLayers = newLayers.filter(function (newLayer) {
        return newLayer !== null;
      });

      var error = null;
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        var _loop = function _loop() {
          var newLayer = _step5.value;

          newLayer.context = _this.context;

          try {
            // 1. given a new coming layer, find its matching layer
            var oldLayer = oldLayerMap[newLayer.id];
            oldLayerMap[newLayer.id] = null;

            if (oldLayer === null) {
              log.once(0, 'Multiple new layers with same id ' + layerName(newLayer));
            }

            // Only transfer state at this stage. We must not generate exceptions
            // until all layers' state have been transferred
            if (oldLayer) {
              _this._transferLayerState(oldLayer, newLayer);
              _this._updateLayer(newLayer);

              updateLayerInSeer(newLayer); // Initializes layer in seer chrome extension (if connected)
            } else {
              _this._initializeNewLayer(newLayer);

              initLayerInSeer(newLayer); // Initializes layer in seer chrome extension (if connected)
            }
            generatedLayers.push(newLayer);

            // Call layer lifecycle method: render sublayers
            var props = newLayer.props,
                oldProps = newLayer.oldProps;

            var sublayers = newLayer.isComposite ? newLayer._renderLayers({
              oldProps: oldProps,
              props: props,
              context: _this.context,
              oldContext: _this.oldContext,
              changeFlags: newLayer.diffProps(oldProps, props, _this.context)
            }) : null;
            // End layer lifecycle method: render sublayers

            if (sublayers) {
              // Flatten the returned array, removing any null, undefined or false
              // this allows layers to render sublayers conditionally
              // (see CompositeLayer.renderLayers docs)
              sublayers = flatten(sublayers, { filter: Boolean });

              // populate reference to parent layer
              sublayers.forEach(function (layer) {
                layer.parentLayer = newLayer;
              });

              _this._matchSublayers({
                newLayers: sublayers,
                oldLayerMap: oldLayerMap,
                generatedLayers: generatedLayers
              });
            }
          } catch (err) {
            log.once(0, 'error during matching of ' + layerName(newLayer), err);
            // Save first error
            error = error || err;
          }
        };

        for (var _iterator5 = newLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return error;
    }
  }, {
    key: '_transferLayerState',
    value: function _transferLayerState(oldLayer, newLayer) {
      var state = oldLayer.state,
          props = oldLayer.props;

      // sanity check

      assert(state, 'deck.gl sanity check - Matching layer has no state');
      if (newLayer !== oldLayer) {
        log(LOG_PRIORITY_LIFECYCLE_MINOR, 'matched ' + layerName(newLayer), oldLayer, '->', newLayer);

        // Move state
        state.layer = newLayer;
        newLayer.state = state;

        // Update model layer reference
        if (state.model) {
          state.model.userData.layer = newLayer;
        }
        // Keep a temporary ref to the old props, for prop comparison
        newLayer.oldProps = props;
        // oldLayer.state = null;

        newLayer.lifecycle = LIFECYCLE.MATCHED;
        oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
      } else {
        log.log(LOG_PRIORITY_LIFECYCLE_MINOR, 'Matching layer is unchanged ' + newLayer.id);
        newLayer.lifecycle = LIFECYCLE.MATCHED;
        newLayer.oldProps = newLayer.props;
        // TODO - we could avoid prop comparisons in this case
      }
    }

    // Update the old layers that were not matched

  }, {
    key: '_finalizeOldLayers',
    value: function _finalizeOldLayers(oldLayers) {
      var error = null;
      // Matched layers have lifecycle state "outdated"
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = oldLayers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var layer = _step6.value;

          if (layer.lifecycle === LIFECYCLE.AWAITING_FINALIZATION) {
            error = error || this._finalizeLayer(layer);
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return error;
    }

    // Initializes a single layer, calling layer methods

  }, {
    key: '_initializeNewLayer',
    value: function _initializeNewLayer(layer) {
      var error = null;
      // Check if new layer, and initialize it's state
      if (!layer.state) {
        log(LOG_PRIORITY_LIFECYCLE, 'initializing ' + layerName(layer));
        try {

          layer.initializeLayer({
            oldProps: {},
            props: layer.props,
            oldContext: this.oldContext,
            context: this.context,
            changeFlags: layer.diffProps({}, layer.props, this.context)
          });

          layer.lifecycle = LIFECYCLE.INITIALIZED;
        } catch (err) {
          log.once(0, 'error while initializing ' + layerName(layer) + '\n', err);
          // Save first error
          error = error || err;
        }
        // Set back pointer (used in picking)
        if (layer.state) {
          layer.state.layer = layer;
          // Save layer on model for picking purposes
          // TODO - store on model.userData rather than directly on model
        }
        if (layer.state && layer.state.model) {
          layer.state.model.userData.layer = layer;
        }
      }
      return error;
    }

    // Updates a single layer, calling layer methods

  }, {
    key: '_updateLayer',
    value: function _updateLayer(layer) {
      var oldProps = layer.oldProps,
          props = layer.props;

      var error = null;
      if (oldProps) {
        try {
          layer.updateLayer({
            oldProps: oldProps,
            props: props,
            context: this.context,
            oldContext: this.oldContext,
            changeFlags: layer.diffProps(oldProps, layer.props, this.context)
          });
        } catch (err) {
          log.once(0, 'error during update of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        log(LOG_PRIORITY_LIFECYCLE_MINOR, 'updating ' + layerName(layer));
      }
      return error;
    }

    // Finalizes a single layer

  }, {
    key: '_finalizeLayer',
    value: function _finalizeLayer(layer) {
      var error = null;
      var state = layer.state;

      if (state) {
        try {
          layer.finalizeLayer();
        } catch (err) {
          log.once(0, 'error during finalization of ' + layerName(layer), err);
          // Save first error
          error = err;
        }
        // layer.state = null;
        layer.lifecycle = LIFECYCLE.FINALIZED;
        log(LOG_PRIORITY_LIFECYCLE, 'finalizing ' + layerName(layer));
      }
      return error;
    }

    /**
     * Warn if a deck-level mouse event has been specified,
     * but no layers are `pickable`.
     */

  }, {
    key: '_validateEventHandling',
    value: function _validateEventHandling() {
      if (this.onLayerClick || this.onLayerHover) {
        if (this.layers.length && !this.layers.some(function (layer) {
          return layer.props.pickable;
        })) {
          log.warn(1, 'You have supplied a top-level input event handler (e.g. `onLayerClick`), ' + 'but none of your layers have set the `pickable` flag.');
        }
      }
    }

    /**
     * Route click events to layers.
     * `pickLayer` will call the `onClick` prop of any picked layer,
     * and `onLayerClick` is called directly from here
     * with any picking info generated by `pickLayer`.
     * @param {Object} event  An object encapsulating an input event,
     *                        with the following shape:
     *                        {Object: {x, y}} offsetCenter: center of the event
     *                        {Object} srcEvent:             native JS Event object
     */

  }, {
    key: '_onClick',
    value: function _onClick(event) {
      if (!event.offsetCenter) {
        // Do not trigger onHover callbacks when click position is invalid.
        return;
      }
      this._pickAndCallback({
        callback: this._onLayerClick,
        event: event,
        mode: 'click'
      });
    }

    /**
     * Route click events to layers.
     * `pickLayer` will call the `onHover` prop of any picked layer,
     * and `onLayerHover` is called directly from here
     * with any picking info generated by `pickLayer`.
     * @param {Object} event  An object encapsulating an input event,
     *                        with the following shape:
     *                        {Object: {x, y}} offsetCenter: center of the event
     *                        {Object} srcEvent:             native JS Event object
     */

  }, {
    key: '_onPointerMove',
    value: function _onPointerMove(event) {
      if (event.isDown) {
        // Do not trigger onHover callbacks if mouse button is down.
        return;
      }
      this._pickAndCallback({
        callback: this._onLayerHover,
        event: event,
        mode: 'hover'
      });
    }
  }, {
    key: '_onPointerLeave',
    value: function _onPointerLeave(event) {
      this.pickObject({
        x: -1,
        y: -1,
        radius: this._pickingRadius,
        mode: 'hover'
      });
    }
  }, {
    key: '_pickAndCallback',
    value: function _pickAndCallback(options) {
      var pos = options.event.offsetCenter;
      var radius = this._pickingRadius;
      var selectedInfos = this.pickObject({ x: pos.x, y: pos.y, radius: radius, mode: options.mode });
      if (options.callback) {
        var firstInfo = selectedInfos.find(function (info) {
          return info.index >= 0;
        }) || null;
        // As per documentation, send null value when no valid object is picked.
        options.callback(firstInfo, selectedInfos, options.event.srcEvent);
      }
    }

    // SEER INTEGRATION

    /**
     * Called upon Seer initialization, manually sends layers data.
     */

  }, {
    key: '_initSeer',
    value: function _initSeer() {
      this.layers.forEach(function (layer) {
        initLayerInSeer(layer);
        updateLayerInSeer(layer);
      });
    }

    /**
     * On Seer property edition, set override and update layers.
     */

  }, {
    key: '_editSeer',
    value: function _editSeer(payload) {
      if (payload.type !== 'edit' || payload.valuePath[0] !== 'props') {
        return;
      }

      setPropOverrides(payload.itemKey, payload.valuePath.slice(1), payload.value);
      var newLayers = this.layers.map(function (layer) {
        return new layer.constructor(layer.props);
      });
      this.updateLayers({ newLayers: newLayers });
    }
  }]);

  return LayerManager;
}();

export default LayerManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9sYXllci1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbImFzc2VydCIsIkZyYW1lYnVmZmVyIiwiU2hhZGVyQ2FjaGUiLCJzZWVyIiwiTGF5ZXIiLCJsb2ciLCJmbGF0dGVuIiwiZHJhd0xheWVycyIsInBpY2tPYmplY3QiLCJwaWNrVmlzaWJsZU9iamVjdHMiLCJMSUZFQ1lDTEUiLCJWaWV3cG9ydCIsInNldFByb3BPdmVycmlkZXMiLCJsYXllckVkaXRMaXN0ZW5lciIsInNlZXJJbml0TGlzdGVuZXIiLCJpbml0TGF5ZXJJblNlZXIiLCJ1cGRhdGVMYXllckluU2VlciIsIkxPR19QUklPUklUWV9MSUZFQ1lDTEUiLCJMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SIiwibGF5ZXJOYW1lIiwibGF5ZXIiLCJMYXllck1hbmFnZXIiLCJnbCIsImxhc3RSZW5kZXJlZExheWVycyIsInByZXZMYXllcnMiLCJsYXllcnMiLCJvbGRDb250ZXh0Iiwic2NyZWVuQ2xlYXJlZCIsIl9uZWVkc1JlZHJhdyIsIl9ldmVudE1hbmFnZXIiLCJfcGlja2luZ1JhZGl1cyIsIl9vbkxheWVyQ2xpY2siLCJfb25MYXllckhvdmVyIiwiX29uQ2xpY2siLCJiaW5kIiwiX29uUG9pbnRlck1vdmUiLCJfb25Qb2ludGVyTGVhdmUiLCJfcGlja0FuZENhbGxiYWNrIiwiX2luaXRTZWVyIiwiX2VkaXRTZWVyIiwiY29udGV4dCIsInVuaWZvcm1zIiwidmlld3BvcnRzIiwidmlld3BvcnQiLCJ2aWV3cG9ydENoYW5nZWQiLCJwaWNraW5nRkJPIiwidXNlRGV2aWNlUGl4ZWxSYXRpbyIsImxhc3RQaWNrZWRJbmZvIiwiaW5kZXgiLCJsYXllcklkIiwic2hhZGVyQ2FjaGUiLCJPYmplY3QiLCJzZWFsIiwicmVtb3ZlTGlzdGVuZXIiLCJsYXllcklkcyIsImZpbHRlciIsImZpbmQiLCJpZCIsImluZGV4T2YiLCJwYXJhbWV0ZXJzIiwiaW5pdEV2ZW50SGFuZGxpbmciLCJldmVudE1hbmFnZXIiLCJzZXRFdmVudEhhbmRsaW5nUGFyYW1ldGVycyIsInNldFZpZXdwb3J0cyIsInVwZGF0ZUxheWVycyIsIm5ld0xheWVycyIsImFzc2lnbiIsIkJvb2xlYW4iLCJvbGRWaWV3cG9ydHMiLCJ2aWV3cG9ydHNDaGFuZ2VkIiwibGVuZ3RoIiwic29tZSIsIl8iLCJpIiwiX2FjdGl2YXRlVmlld3BvcnQiLCJvbiIsImNsaWNrIiwicG9pbnRlcm1vdmUiLCJwb2ludGVybGVhdmUiLCJwaWNraW5nUmFkaXVzIiwib25MYXllckNsaWNrIiwib25MYXllckhvdmVyIiwiaXNOYU4iLCJfdmFsaWRhdGVFdmVudEhhbmRsaW5nIiwibmV3TGF5ZXIiLCJfdXBkYXRlTGF5ZXJzIiwib2xkTGF5ZXJzIiwiZXJyb3IiLCJnZW5lcmF0ZWRMYXllcnMiLCJwYXNzIiwiZHJhd1BpY2tpbmdDb2xvcnMiLCJvblZpZXdwb3J0QWN0aXZlIiwieCIsInkiLCJtb2RlIiwicmFkaXVzIiwiZ2V0TGF5ZXJzIiwiX2dldFBpY2tpbmdCdWZmZXIiLCJ3aWR0aCIsImhlaWdodCIsImNsZWFyUmVkcmF3RmxhZ3MiLCJyZWRyYXciLCJnZXROZWVkc1JlZHJhdyIsImRlcHJlY2F0ZWQiLCJfdXBkYXRlTGF5ZXJTdGF0ZXMiLCJjaGFuZ2VGbGFncyIsInVwZGF0ZUxheWVyIiwidmlld3BvcnRPckRlc2NyaXB0b3IiLCJyZXNpemUiLCJjYW52YXMiLCJvbGRMYXllck1hcCIsIm9sZExheWVyIiwib25jZSIsImxpZmVjeWNsZSIsIkFXQUlUSU5HX0ZJTkFMSVpBVElPTiIsIl9tYXRjaFN1YmxheWVycyIsImVycm9yMiIsIl9maW5hbGl6ZU9sZExheWVycyIsImZpcnN0RXJyb3IiLCJfdHJhbnNmZXJMYXllclN0YXRlIiwiX3VwZGF0ZUxheWVyIiwiX2luaXRpYWxpemVOZXdMYXllciIsInB1c2giLCJwcm9wcyIsIm9sZFByb3BzIiwic3VibGF5ZXJzIiwiaXNDb21wb3NpdGUiLCJfcmVuZGVyTGF5ZXJzIiwiZGlmZlByb3BzIiwiZm9yRWFjaCIsInBhcmVudExheWVyIiwiZXJyIiwic3RhdGUiLCJtb2RlbCIsInVzZXJEYXRhIiwiTUFUQ0hFRCIsIkFXQUlUSU5HX0dDIiwiX2ZpbmFsaXplTGF5ZXIiLCJpbml0aWFsaXplTGF5ZXIiLCJJTklUSUFMSVpFRCIsImZpbmFsaXplTGF5ZXIiLCJGSU5BTElaRUQiLCJwaWNrYWJsZSIsIndhcm4iLCJldmVudCIsIm9mZnNldENlbnRlciIsImNhbGxiYWNrIiwiaXNEb3duIiwib3B0aW9ucyIsInBvcyIsInNlbGVjdGVkSW5mb3MiLCJmaXJzdEluZm8iLCJpbmZvIiwic3JjRXZlbnQiLCJwYXlsb2FkIiwidHlwZSIsInZhbHVlUGF0aCIsIml0ZW1LZXkiLCJzbGljZSIsInZhbHVlIiwibWFwIiwiY29uc3RydWN0b3IiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxNQUFQLE1BQW1CLFFBQW5CO0FBQ0EsU0FBUUMsV0FBUixFQUFxQkMsV0FBckIsUUFBdUMsU0FBdkM7QUFDQSxPQUFPQyxJQUFQLE1BQWlCLE1BQWpCO0FBQ0EsT0FBT0MsS0FBUCxNQUFrQixTQUFsQjtBQUNBLFNBQVFDLEdBQVIsUUFBa0IsU0FBbEI7QUFDQSxTQUFRQyxPQUFSLFFBQXNCLGlCQUF0QjtBQUNBLFNBQVFDLHlCQUFSLFFBQXlCLGVBQXpCO0FBQ0EsU0FBUUMseUJBQVIsRUFBb0JDLHlDQUFwQixRQUE2QyxlQUE3QztBQUNBLFNBQVFDLFNBQVIsUUFBd0IsYUFBeEI7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLHVCQUFyQjtBQUNBLFNBQ0VDLGdCQURGLEVBRUVDLGlCQUZGLEVBR0VDLGdCQUhGLEVBSUVDLGVBSkYsRUFLRUMsaUJBTEYsUUFNTyxvQkFOUDs7QUFRQSxJQUFNQyx5QkFBeUIsQ0FBL0I7QUFDQSxJQUFN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LElBQUk1SSxNQUFNNkksV0FBVixDQUFzQjdJLE1BQU11RyxLQUE1QixDQUFUO0FBQUEsT0FBaEIsQ0FBbEI7QUFDQSxXQUFLM0QsWUFBTCxDQUFrQixFQUFDQyxvQkFBRCxFQUFsQjtBQUNEOzs7Ozs7ZUFwcEJrQjVDLFkiLCJmaWxlIjoibGF5ZXItbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge0ZyYW1lYnVmZmVyLCBTaGFkZXJDYWNoZX0gZnJvbSAnbHVtYS5nbCc7XG5pbXBvcnQgc2VlciBmcm9tICdzZWVyJztcbmltcG9ydCBMYXllciBmcm9tICcuL2xheWVyJztcbmltcG9ydCB7bG9nfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7ZmxhdHRlbn0gZnJvbSAnLi91dGlscy9mbGF0dGVuJztcbmltcG9ydCB7ZHJhd0xheWVyc30gZnJvbSAnLi9kcmF3LWxheWVycyc7XG5pbXBvcnQge3BpY2tPYmplY3QsIHBpY2tWaXNpYmxlT2JqZWN0c30gZnJvbSAnLi9waWNrLWxheWVycyc7XG5pbXBvcnQge0xJRkVDWUNMRX0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gJy4uL3ZpZXdwb3J0cy92aWV3cG9ydCc7XG5pbXBvcnQge1xuICBzZXRQcm9wT3ZlcnJpZGVzLFxuICBsYXllckVkaXRMaXN0ZW5lcixcbiAgc2VlckluaXRMaXN0ZW5lcixcbiAgaW5pdExheWVySW5TZWVyLFxuICB1cGRhdGVMYXllckluU2VlclxufSBmcm9tICcuL3NlZXItaW50ZWdyYXRpb24nO1xuXG5jb25zdCBMT0dfUFJJT1JJVFlfTElGRUNZQ0xFID0gMjtcbmNvbnN0IExPR19QUklPUklUWV9MSUZFQ1lDTEVfTUlOT1IgPSA0O1xuXG5jb25zdCBsYXllck5hbWUgPSBsYXllciA9PiBsYXllciBpbnN0YW5jZW9mIExheWVyID9cbiAgYCR7bGF5ZXJ9YCA6XG4gICghbGF5ZXIgPyAnbnVsbCBsYXllcicgOiAnaW52YWxpZCBsYXllcicpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXllck1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcih7Z2x9KSB7XG4gICAgIC8vIEN1cnJlbnRseSBkZWNrLmdsIGV4cGVjdHMgdGhlIERlY2tHTC5sYXllcnMgYXJyYXkgdG8gYmUgZGlmZmVyZW50XG4gICAgIC8vIHdoZW5ldmVyIFJlYWN0IHJlcmVuZGVycy4gSWYgdGhlIHNhbWUgbGF5ZXJzIGFycmF5IGlzIHVzZWQsIHRoZVxuICAgICAvLyBMYXllck1hbmFnZXIncyBkaWZmaW5nIGFsZ29yaXRobSB3aWxsIGdlbmVyYXRlIGEgZmF0YWwgZXJyb3IgYW5kXG4gICAgIC8vIGJyZWFrIHRoZSByZW5kZXJpbmcuXG5cbiAgICAgLy8gYHRoaXMubGFzdFJlbmRlcmVkTGF5ZXJzYCBzdG9yZXMgdGhlIFVORklMVEVSRUQgbGF5ZXJzIHNlbnRcbiAgICAgLy8gZG93biB0byBMYXllck1hbmFnZXIsIHNvIHRoYXQgYGxheWVyc2AgcmVmZXJlbmNlIGNhbiBiZSBjb21wYXJlZC5cbiAgICAgLy8gSWYgaXQncyB0aGUgc2FtZSBhY3Jvc3MgdHdvIFJlYWN0IHJlbmRlciBjYWxscywgdGhlIGRpZmZpbmcgbG9naWNcbiAgICAgLy8gd2lsbCBiZSBza2lwcGVkLlxuICAgIHRoaXMubGFzdFJlbmRlcmVkTGF5ZXJzID0gW107XG5cbiAgICB0aGlzLnByZXZMYXllcnMgPSBbXTtcbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgIHRoaXMub2xkQ29udGV4dCA9IHt9O1xuICAgIHRoaXMuc2NyZWVuQ2xlYXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX25lZWRzUmVkcmF3ID0gdHJ1ZTtcblxuICAgIHRoaXMuX2V2ZW50TWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy5fcGlja2luZ1JhZGl1cyA9IDA7XG4gICAgdGhpcy5fb25MYXllckNsaWNrID0gbnVsbDtcbiAgICB0aGlzLl9vbkxheWVySG92ZXIgPSBudWxsO1xuICAgIHRoaXMuX29uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Qb2ludGVyTW92ZSA9IHRoaXMuX29uUG9pbnRlck1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblBvaW50ZXJMZWF2ZSA9IHRoaXMuX29uUG9pbnRlckxlYXZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcGlja0FuZENhbGxiYWNrID0gdGhpcy5fcGlja0FuZENhbGxiYWNrLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9pbml0U2VlciA9IHRoaXMuX2luaXRTZWVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fZWRpdFNlZXIgPSB0aGlzLl9lZGl0U2Vlci5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5jb250ZXh0ID0ge1xuICAgICAgZ2wsXG4gICAgICB1bmlmb3Jtczoge30sXG4gICAgICB2aWV3cG9ydHM6IFtdLFxuICAgICAgdmlld3BvcnQ6IG51bGwsXG4gICAgICB2aWV3cG9ydENoYW5nZWQ6IHRydWUsXG4gICAgICBwaWNraW5nRkJPOiBudWxsLFxuICAgICAgdXNlRGV2aWNlUGl4ZWxSYXRpbzogdHJ1ZSxcbiAgICAgIGxhc3RQaWNrZWRJbmZvOiB7XG4gICAgICAgIGluZGV4OiAtMSxcbiAgICAgICAgbGF5ZXJJZDogbnVsbFxuICAgICAgfSxcbiAgICAgIHNoYWRlckNhY2hlOiBuZXcgU2hhZGVyQ2FjaGUoe2dsfSlcbiAgICB9O1xuXG4gICAgc2VlckluaXRMaXN0ZW5lcih0aGlzLl9pbml0U2Vlcik7XG4gICAgbGF5ZXJFZGl0TGlzdGVuZXIodGhpcy5fZWRpdFNlZXIpO1xuXG4gICAgT2JqZWN0LnNlYWwodGhpcy5jb250ZXh0KTtcbiAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gY2FsbCB3aGVuIHRoZSBsYXllciBtYW5hZ2VyIGlzIG5vdCBuZWVkZWQgYW55bW9yZS5cbiAgICpcbiAgICogQ3VycmVudGx5IHVzZWQgaW4gdGhlIDxEZWNrR0w+IGNvbXBvbmVudFdpbGxVbm1vdW50IGxpZmVjeWNsZSB0byB1bmJpbmQgU2VlciBsaXN0ZW5lcnMuXG4gICAqL1xuICBmaW5hbGl6ZSgpIHtcbiAgICBzZWVyLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2luaXRTZWVyKTtcbiAgICBzZWVyLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2VkaXRTZWVyKTtcbiAgfVxuXG4gIC8vIEdldHMgYW4gKG9wdGlvbmFsbHkpIGZpbHRlcmVkIGxpc3Qgb2YgbGF5ZXJzXG4gIGdldExheWVycyh7bGF5ZXJJZHMgPSBudWxsfSA9IHt9KSB7XG4gICAgLy8gRmlsdGVyaW5nIGJ5IGxheWVySWQgY29tcGFyZXMgYmVnaW5uaW5nIG9mIHN0cmluZ3MsIHNvIHRoYXQgc3VibGF5ZXJzIHdpbGwgYmUgaW5jbHVkZWRcbiAgICAvLyBEZXBlbmRlcyBvbiB0aGUgY29udmVudGlvbiBvZiBhZGRpbmcgc3VmZml4ZXMgdG8gdGhlIHBhcmVudCdzIGxheWVyIG5hbWVcbiAgICByZXR1cm4gbGF5ZXJJZHMgP1xuICAgICAgdGhpcy5sYXllcnMuZmlsdGVyKGxheWVyID0+IGxheWVySWRzLmZpbmQobGF5ZXJJZCA9PiBsYXllci5pZC5pbmRleE9mKGxheWVySWQpID09PSAwKSkgOlxuICAgICAgdGhpcy5sYXllcnM7XG4gIH1cblxuICBnZXRWaWV3cG9ydHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC52aWV3cG9ydHM7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHBhcmFtZXRlcnMgbmVlZGVkIGZvciBsYXllciByZW5kZXJpbmcgYW5kIHBpY2tpbmcuXG4gICAqIFBhcmFtZXRlcnMgYXJlIHRvIGJlIHBhc3NlZCBhcyBhIHNpbmdsZSBvYmplY3QsIHdpdGggdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlRGV2aWNlUGl4ZWxSYXRpb1xuICAgKi9cbiAgc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKSB7XG4gICAgaWYgKCdldmVudE1hbmFnZXInIGluIHBhcmFtZXRlcnMpIHtcbiAgICAgIHRoaXMuaW5pdEV2ZW50SGFuZGxpbmcocGFyYW1ldGVycy5ldmVudE1hbmFnZXIpO1xuICAgIH1cblxuICAgIGlmICgncGlja2luZ1JhZGl1cycgaW4gcGFyYW1ldGVycyB8fFxuICAgICAgJ29uTGF5ZXJDbGljaycgaW4gcGFyYW1ldGVycyB8fFxuICAgICAgJ29uTGF5ZXJIb3ZlcicgaW4gcGFyYW1ldGVycykge1xuICAgICAgdGhpcy5zZXRFdmVudEhhbmRsaW5nUGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoJ3ZpZXdwb3J0cycgaW4gcGFyYW1ldGVycykge1xuICAgICAgdGhpcy5zZXRWaWV3cG9ydHMocGFyYW1ldGVycy52aWV3cG9ydHMpO1xuICAgIH1cblxuICAgIGlmICgnbGF5ZXJzJyBpbiBwYXJhbWV0ZXJzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUxheWVycyh7bmV3TGF5ZXJzOiBwYXJhbWV0ZXJzLmxheWVyc30pO1xuICAgIH1cblxuICAgIHRoaXMuY29udGV4dCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29udGV4dCwgcGFyYW1ldGVycyk7XG4gIH1cblxuICBzZXRWaWV3cG9ydHModmlld3BvcnRzKSB7XG4gICAgdmlld3BvcnRzID0gZmxhdHRlbih2aWV3cG9ydHMsIHtmaWx0ZXI6IEJvb2xlYW59KTtcblxuICAgIC8vIFZpZXdwb3J0cyBhcmUgXCJpbW11dGFibGVcIiwgc28gd2UgY2FuIHNoYWxsb3cgY29tcGFyZVxuICAgIGNvbnN0IG9sZFZpZXdwb3J0cyA9IHRoaXMuY29udGV4dC52aWV3cG9ydHM7XG4gICAgY29uc3Qgdmlld3BvcnRzQ2hhbmdlZCA9IHZpZXdwb3J0cy5sZW5ndGggIT09IG9sZFZpZXdwb3J0cy5sZW5ndGggfHxcbiAgICAgIHZpZXdwb3J0cy5zb21lKChfLCBpKSA9PiB2aWV3cG9ydHNbaV0gIT09IG9sZFZpZXdwb3J0c1tpXSk7XG5cbiAgICBpZiAodmlld3BvcnRzQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fbmVlZHNSZWRyYXcgPSB0cnVlO1xuXG4gICAgICAvLyBOZWVkIHRvIGVuc3VyZSBvbmUgdmlld3BvcnQgaXMgYWN0aXZhdGVkXG4gICAgICBjb25zdCB2aWV3cG9ydCA9IHZpZXdwb3J0c1swXTtcbiAgICAgIGFzc2VydCh2aWV3cG9ydCBpbnN0YW5jZW9mIFZpZXdwb3J0LCAnSW52YWxpZCB2aWV3cG9ydCcpO1xuXG4gICAgICB0aGlzLmNvbnRleHQudmlld3BvcnRzID0gdmlld3BvcnRzO1xuICAgICAgdGhpcy5fYWN0aXZhdGVWaWV3cG9ydCh2aWV3cG9ydCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudE1hbmFnZXIgICBBIHNvdXJjZSBvZiBET00gaW5wdXQgZXZlbnRzXG4gICAqL1xuICBpbml0RXZlbnRIYW5kbGluZyhldmVudE1hbmFnZXIpIHtcbiAgICB0aGlzLl9ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG5cbiAgICAvLyBUT0RPOiBhZGQvcmVtb3ZlIGhhbmRsZXJzIG9uIGRlbWFuZCBhdCBydW50aW1lLCBub3QgYWxsIGF0IG9uY2Ugb24gaW5pdC5cbiAgICAvLyBDb25zaWRlciBib3RoIHRvcC1sZXZlbCBoYW5kbGVycyBsaWtlIG9uTGF5ZXJDbGljay9Ib3ZlclxuICAgIC8vIGFuZCBwZXItbGF5ZXIgaGFuZGxlcnMgYXR0YWNoZWQgdG8gaW5kaXZpZHVhbCBsYXllcnMuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ViZXIvZGVjay5nbC9pc3N1ZXMvNjM0XG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyLm9uKHtcbiAgICAgIGNsaWNrOiB0aGlzLl9vbkNsaWNrLFxuICAgICAgcG9pbnRlcm1vdmU6IHRoaXMuX29uUG9pbnRlck1vdmUsXG4gICAgICBwb2ludGVybGVhdmU6IHRoaXMuX29uUG9pbnRlckxlYXZlXG4gICAgfSk7XG4gIH1cblxuICAvLyBTZXQgcGFyYW1ldGVycyBmb3IgaW5wdXQgZXZlbnQgaGFuZGxpbmcuXG4gIHNldEV2ZW50SGFuZGxpbmdQYXJhbWV0ZXJzKHtcbiAgICBwaWNraW5nUmFkaXVzLFxuICAgIG9uTGF5ZXJDbGljayxcbiAgICBvbkxheWVySG92ZXJcbiAgfSkge1xuICAgIGlmICghaXNOYU4ocGlja2luZ1JhZGl1cykpIHtcbiAgICAgIHRoaXMuX3BpY2tpbmdSYWRpdXMgPSBwaWNraW5nUmFkaXVzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9uTGF5ZXJDbGljayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuX29uTGF5ZXJDbGljayA9IG9uTGF5ZXJDbGljaztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvbkxheWVySG92ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9vbkxheWVySG92ZXIgPSBvbkxheWVySG92ZXI7XG4gICAgfVxuICAgIHRoaXMuX3ZhbGlkYXRlRXZlbnRIYW5kbGluZygpO1xuICB9XG5cbiAgdXBkYXRlTGF5ZXJzKHtuZXdMYXllcnN9KSB7XG4gICAgLy8gVE9ETyAtIHNvbWV0aGluZyBpcyBnZW5lcmF0aW5nIHN0YXRlIHVwZGF0ZXMgdGhhdCBjYXVzZSByZXJlbmRlciBvZiB0aGUgc2FtZVxuICAgIGlmIChuZXdMYXllcnMgPT09IHRoaXMubGFzdFJlbmRlcmVkTGF5ZXJzKSB7XG4gICAgICBsb2cubG9nKDMsICdJZ25vcmluZyBsYXllciB1cGRhdGUgZHVlIHRvIGxheWVyIGFycmF5IG5vdCBjaGFuZ2VkJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5sYXN0UmVuZGVyZWRMYXllcnMgPSBuZXdMYXllcnM7XG5cbiAgICBhc3NlcnQodGhpcy5jb250ZXh0LnZpZXdwb3J0LCAnTGF5ZXJNYW5hZ2VyLnVwZGF0ZUxheWVyczogdmlld3BvcnQgbm90IHNldCcpO1xuXG4gICAgLy8gRmlsdGVyIG91dCBhbnkgbnVsbCBsYXllcnNcbiAgICBuZXdMYXllcnMgPSBuZXdMYXllcnMuZmlsdGVyKG5ld0xheWVyID0+IG5ld0xheWVyICE9PSBudWxsKTtcblxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgbmV3TGF5ZXJzKSB7XG4gICAgICBsYXllci5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIH1cblxuICAgIHRoaXMucHJldkxheWVycyA9IHRoaXMubGF5ZXJzO1xuICAgIGNvbnN0IHtlcnJvciwgZ2VuZXJhdGVkTGF5ZXJzfSA9IHRoaXMuX3VwZGF0ZUxheWVycyh7XG4gICAgICBvbGRMYXllcnM6IHRoaXMucHJldkxheWVycyxcbiAgICAgIG5ld0xheWVyc1xuICAgIH0pO1xuXG4gICAgdGhpcy5sYXllcnMgPSBnZW5lcmF0ZWRMYXllcnM7XG4gICAgLy8gVGhyb3cgZmlyc3QgZXJyb3IgZm91bmQsIGlmIGFueVxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZHJhd0xheWVycyh7cGFzcyA9ICdyZW5kZXIgdG8gc2NyZWVuJ30pIHtcbiAgICBjb25zdCB7Z2wsIHVzZURldmljZVBpeGVsUmF0aW8sIGRyYXdQaWNraW5nQ29sb3JzfSA9IHRoaXMuY29udGV4dDtcblxuICAgIC8vIHJlbmRlciB0aGlzIHZpZXdwb3J0XG4gICAgZHJhd0xheWVycyhnbCwge1xuICAgICAgcGFzcyxcbiAgICAgIGxheWVyczogdGhpcy5sYXllcnMsXG4gICAgICB2aWV3cG9ydHM6IHRoaXMuY29udGV4dC52aWV3cG9ydHMsXG4gICAgICBvblZpZXdwb3J0QWN0aXZlOiB0aGlzLl9hY3RpdmF0ZVZpZXdwb3J0LmJpbmQodGhpcyksXG4gICAgICB1c2VEZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgZHJhd1BpY2tpbmdDb2xvcnNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gUGljayB0aGUgY2xvc2VzdCBpbmZvIGF0IGdpdmVuIGNvb3JkaW5hdGVcbiAgcGlja09iamVjdCh7eCwgeSwgbW9kZSwgcmFkaXVzID0gMCwgbGF5ZXJJZHN9KSB7XG4gICAgY29uc3Qge2dsLCB1c2VEZXZpY2VQaXhlbFJhdGlvfSA9IHRoaXMuY29udGV4dDtcblxuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKHtsYXllcklkc30pO1xuXG4gICAgcmV0dXJuIHBpY2tPYmplY3QoZ2wsIHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcmFkaXVzLFxuICAgICAgbGF5ZXJzLFxuICAgICAgbW9kZSxcbiAgICAgIHZpZXdwb3J0czogdGhpcy5jb250ZXh0LnZpZXdwb3J0cyxcbiAgICAgIG9uVmlld3BvcnRBY3RpdmU6IHRoaXMuX2FjdGl2YXRlVmlld3BvcnQuYmluZCh0aGlzKSxcbiAgICAgIHBpY2tpbmdGQk86IHRoaXMuX2dldFBpY2tpbmdCdWZmZXIoKSxcbiAgICAgIGxhc3RQaWNrZWRJbmZvOiB0aGlzLmNvbnRleHQubGFzdFBpY2tlZEluZm8sXG4gICAgICB1c2VEZXZpY2VQaXhlbFJhdGlvXG4gICAgfSk7XG4gIH1cblxuICAvLyBHZXQgYWxsIHVuaXF1ZSBpbmZvcyB3aXRoaW4gYSBib3VuZGluZyBib3hcbiAgcGlja1Zpc2libGVPYmplY3RzKHt4LCB5LCB3aWR0aCwgaGVpZ2h0LCBsYXllcklkc30pIHtcbiAgICBjb25zdCB7Z2wsIHVzZURldmljZVBpeGVsUmF0aW99ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5nZXRMYXllcnMoe2xheWVySWRzfSk7XG5cbiAgICByZXR1cm4gcGlja1Zpc2libGVPYmplY3RzKGdsLCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbGF5ZXJzLFxuICAgICAgbW9kZTogJ3F1ZXJ5JyxcbiAgICAgIC8vIFRPRE8gLSBob3cgZG9lcyB0aGlzIGludGVyYWN0IHdpdGggbXVsdGlwbGUgdmlld3BvcnRzP1xuICAgICAgdmlld3BvcnQ6IHRoaXMuY29udGV4dC52aWV3cG9ydCxcbiAgICAgIHZpZXdwb3J0czogdGhpcy5jb250ZXh0LnZpZXdwb3J0cyxcbiAgICAgIG9uVmlld3BvcnRBY3RpdmU6IHRoaXMuX2FjdGl2YXRlVmlld3BvcnQuYmluZCh0aGlzKSxcbiAgICAgIHBpY2tpbmdGQk86IHRoaXMuX2dldFBpY2tpbmdCdWZmZXIoKSxcbiAgICAgIHVzZURldmljZVBpeGVsUmF0aW9cbiAgICB9KTtcbiAgfVxuXG4gIG5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzID0gZmFsc2V9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuY29udGV4dC52aWV3cG9ydCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCByZWRyYXcgPSB0aGlzLl9uZWVkc1JlZHJhdztcbiAgICBpZiAoY2xlYXJSZWRyYXdGbGFncykge1xuICAgICAgdGhpcy5fbmVlZHNSZWRyYXcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBidWZmZXIgaXMgY2xlYXJlZCBvbmNlIHdoZW4gbGF5ZXIgbGlzdCBiZWNvbWVzIGVtcHR5XG4gICAgaWYgKHRoaXMubGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHRoaXMuc2NyZWVuQ2xlYXJlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY3JlZW5DbGVhcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnNjcmVlbkNsZWFyZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuc2NyZWVuQ2xlYXJlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIHJlZHJhdyA9IHJlZHJhdyB8fCBsYXllci5nZXROZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFnc30pO1xuICAgIH1cblxuICAgIHJldHVybiByZWRyYXc7XG4gIH1cblxuICAvL1xuICAvLyBERVBSRUNBVEVEIE1FVEhPRFNcbiAgLy9cblxuICBzZXRWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgIGxvZy5kZXByZWNhdGVkKCdzZXRWaWV3cG9ydCcsICdzZXRWaWV3cG9ydHMnKTtcbiAgICB0aGlzLnNldFZpZXdwb3J0cyhbdmlld3BvcnRdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuICAvL1xuXG4gIC8vIE1ha2UgYSB2aWV3cG9ydCBcImN1cnJlbnRcIiBpbiBsYXllciBjb250ZXh0LCBwcmltZWQgZm9yIGRyYXdcbiAgX2FjdGl2YXRlVmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAvLyBUT0RPIC0gdmlld3BvcnQgY2hhbmdlIGRldGVjdGlvbiBicmVha3MgTUVURVJfT0ZGU0VUUyBtb2RlXG4gICAgLy8gY29uc3Qgb2xkVmlld3BvcnQgPSB0aGlzLmNvbnRleHQudmlld3BvcnQ7XG4gICAgLy8gY29uc3Qgdmlld3BvcnRDaGFuZ2VkID0gIW9sZFZpZXdwb3J0IHx8ICF2aWV3cG9ydC5lcXVhbHMob2xkVmlld3BvcnQpO1xuICAgIGNvbnN0IHZpZXdwb3J0Q2hhbmdlZCA9IHRydWU7XG5cbiAgICBpZiAodmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMub2xkQ29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICAgIHRoaXMuY29udGV4dC52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgdGhpcy5jb250ZXh0LnZpZXdwb3J0Q2hhbmdlZCA9IHRydWU7XG4gICAgICB0aGlzLmNvbnRleHQudW5pZm9ybXMgPSB7fTtcbiAgICAgIGxvZyg0LCB2aWV3cG9ydCk7XG5cbiAgICAgIC8vIFVwZGF0ZSBsYXllcnMgc3RhdGVzXG4gICAgICAvLyBMZXQgc2NyZWVuIHNwYWNlIGxheWVycyB1cGRhdGUgdGhlaXIgc3RhdGUgYmFzZWQgb24gdmlld3BvcnRcbiAgICAgIC8vIFRPRE8gLSByZWltcGxlbWVudCB2aWV3cG9ydCBjaGFuZ2UgZGV0ZWN0aW9uIChzaW5nbGUgdmlld3BvcnQgb3B0aW1pemF0aW9uKVxuICAgICAgLy8gVE9ETyAtIGRvbid0IHNldCB2aWV3cG9ydENoYW5nZWQgZHVyaW5nIHNldFZpZXdwb3J0cz9cbiAgICAgIGlmICh0aGlzLmNvbnRleHQudmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxheWVyU3RhdGVzKHt2aWV3cG9ydENoYW5nZWQ6IHRydWV9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5jb250ZXh0LnZpZXdwb3J0LCAnTGF5ZXJNYW5hZ2VyOiB2aWV3cG9ydCBub3Qgc2V0Jyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFdhbGsgdGhlIGxheWVycyBhbmQgdXBkYXRlIHRoZWlyIHN0YXRlc1xuICBfdXBkYXRlTGF5ZXJTdGF0ZXMoY2hhbmdlRmxhZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzKSB7XG4gICAgICBsYXllci51cGRhdGVMYXllcih7Y2hhbmdlRmxhZ3N9KTtcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgYSB2aWV3cG9ydCBmcm9tIGEgdmlld3BvcnQgZGVzY3JpcHRvciAod2hpY2ggY2FuIGJlIGEgcGxhaW4gdmlld3BvcnQpXG4gIF9nZXRWaWV3cG9ydEZyb21EZXNjcmlwdG9yKHZpZXdwb3J0T3JEZXNjcmlwdG9yKSB7XG4gICAgcmV0dXJuIHZpZXdwb3J0T3JEZXNjcmlwdG9yLnZpZXdwb3J0ID8gdmlld3BvcnRPckRlc2NyaXB0b3Iudmlld3BvcnQgOiB2aWV3cG9ydE9yRGVzY3JpcHRvcjtcbiAgfVxuXG4gIF9nZXRQaWNraW5nQnVmZmVyKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgLy8gQ3JlYXRlIGEgZnJhbWUgYnVmZmVyIGlmIG5vdCBhbHJlYWR5IGF2YWlsYWJsZVxuICAgIHRoaXMuY29udGV4dC5waWNraW5nRkJPID0gdGhpcy5jb250ZXh0LnBpY2tpbmdGQk8gfHwgbmV3IEZyYW1lYnVmZmVyKGdsKTtcbiAgICAvLyBSZXNpemUgaXQgdG8gY3VycmVudCBjYW52YXMgc2l6ZSAodGhpcyBpcyBhIG5vb3AgaWYgc2l6ZSBoYXNuJ3QgY2hhbmdlZClcbiAgICB0aGlzLmNvbnRleHQucGlja2luZ0ZCTy5yZXNpemUoe3dpZHRoOiBnbC5jYW52YXMud2lkdGgsIGhlaWdodDogZ2wuY2FudmFzLmhlaWdodH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQucGlja2luZ0ZCTztcbiAgfVxuXG4gIC8vIE1hdGNoIGFsbCBsYXllcnMsIGNoZWNraW5nIGZvciBjYXVnaHQgZXJyb3JzXG4gIC8vIFRvIGF2b2lkIGhhdmluZyBhbiBleGNlcHRpb24gaW4gb25lIGxheWVyIGRpc3J1cHQgb3RoZXIgbGF5ZXJzXG4gIC8vIFRPRE8gLSBtYXJrIGxheWVycyB3aXRoIGV4Y2VwdGlvbnMgYXMgYmFkIGFuZCByZW1vdmUgZnJvbSByZW5kZXJpbmcgY3ljbGU/XG4gIF91cGRhdGVMYXllcnMoe29sZExheWVycywgbmV3TGF5ZXJzfSkge1xuICAgIC8vIENyZWF0ZSBvbGQgbGF5ZXIgbWFwXG4gICAgY29uc3Qgb2xkTGF5ZXJNYXAgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG9sZExheWVyIG9mIG9sZExheWVycykge1xuICAgICAgaWYgKG9sZExheWVyTWFwW29sZExheWVyLmlkXSkge1xuICAgICAgICBsb2cub25jZSgwLCBgTXVsdGlwbGUgb2xkIGxheWVycyB3aXRoIHNhbWUgaWQgJHtsYXllck5hbWUob2xkTGF5ZXIpfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2xkTGF5ZXJNYXBbb2xkTGF5ZXIuaWRdID0gb2xkTGF5ZXI7XG4gICAgICAgIG9sZExheWVyLmxpZmVjeWNsZSA9IExJRkVDWUNMRS5BV0FJVElOR19GSU5BTElaQVRJT047XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsb2NhdGUgYXJyYXkgZm9yIGdlbmVyYXRlZCBsYXllcnNcbiAgICBjb25zdCBnZW5lcmF0ZWRMYXllcnMgPSBbXTtcblxuICAgIC8vIE1hdGNoIHN1YmxheWVyc1xuICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hTdWJsYXllcnMoe1xuICAgICAgbmV3TGF5ZXJzLCBvbGRMYXllck1hcCwgZ2VuZXJhdGVkTGF5ZXJzXG4gICAgfSk7XG5cbiAgICBjb25zdCBlcnJvcjIgPSB0aGlzLl9maW5hbGl6ZU9sZExheWVycyhvbGRMYXllcnMpO1xuICAgIGNvbnN0IGZpcnN0RXJyb3IgPSBlcnJvciB8fCBlcnJvcjI7XG4gICAgcmV0dXJuIHtlcnJvcjogZmlyc3RFcnJvciwgZ2VuZXJhdGVkTGF5ZXJzfTtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzICovXG5cbiAgX21hdGNoU3VibGF5ZXJzKHtuZXdMYXllcnMsIG9sZExheWVyTWFwLCBnZW5lcmF0ZWRMYXllcnN9KSB7XG4gICAgLy8gRmlsdGVyIG91dCBhbnkgbnVsbCBsYXllcnNcbiAgICBuZXdMYXllcnMgPSBuZXdMYXllcnMuZmlsdGVyKG5ld0xheWVyID0+IG5ld0xheWVyICE9PSBudWxsKTtcblxuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgZm9yIChjb25zdCBuZXdMYXllciBvZiBuZXdMYXllcnMpIHtcbiAgICAgIG5ld0xheWVyLmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIDEuIGdpdmVuIGEgbmV3IGNvbWluZyBsYXllciwgZmluZCBpdHMgbWF0Y2hpbmcgbGF5ZXJcbiAgICAgICAgY29uc3Qgb2xkTGF5ZXIgPSBvbGRMYXllck1hcFtuZXdMYXllci5pZF07XG4gICAgICAgIG9sZExheWVyTWFwW25ld0xheWVyLmlkXSA9IG51bGw7XG5cbiAgICAgICAgaWYgKG9sZExheWVyID09PSBudWxsKSB7XG4gICAgICAgICAgbG9nLm9uY2UoMCwgYE11bHRpcGxlIG5ldyBsYXllcnMgd2l0aCBzYW1lIGlkICR7bGF5ZXJOYW1lKG5ld0xheWVyKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgdHJhbnNmZXIgc3RhdGUgYXQgdGhpcyBzdGFnZS4gV2UgbXVzdCBub3QgZ2VuZXJhdGUgZXhjZXB0aW9uc1xuICAgICAgICAvLyB1bnRpbCBhbGwgbGF5ZXJzJyBzdGF0ZSBoYXZlIGJlZW4gdHJhbnNmZXJyZWRcbiAgICAgICAgaWYgKG9sZExheWVyKSB7XG4gICAgICAgICAgdGhpcy5fdHJhbnNmZXJMYXllclN0YXRlKG9sZExheWVyLCBuZXdMYXllcik7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlTGF5ZXIobmV3TGF5ZXIpO1xuXG4gICAgICAgICAgdXBkYXRlTGF5ZXJJblNlZXIobmV3TGF5ZXIpOyAvLyBJbml0aWFsaXplcyBsYXllciBpbiBzZWVyIGNocm9tZSBleHRlbnNpb24gKGlmIGNvbm5lY3RlZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9pbml0aWFsaXplTmV3TGF5ZXIobmV3TGF5ZXIpO1xuXG4gICAgICAgICAgaW5pdExheWVySW5TZWVyKG5ld0xheWVyKTsgLy8gSW5pdGlhbGl6ZXMgbGF5ZXIgaW4gc2VlciBjaHJvbWUgZXh0ZW5zaW9uIChpZiBjb25uZWN0ZWQpXG4gICAgICAgIH1cbiAgICAgICAgZ2VuZXJhdGVkTGF5ZXJzLnB1c2gobmV3TGF5ZXIpO1xuXG4gICAgICAgIC8vIENhbGwgbGF5ZXIgbGlmZWN5Y2xlIG1ldGhvZDogcmVuZGVyIHN1YmxheWVyc1xuICAgICAgICBjb25zdCB7cHJvcHMsIG9sZFByb3BzfSA9IG5ld0xheWVyO1xuICAgICAgICBsZXQgc3VibGF5ZXJzID0gbmV3TGF5ZXIuaXNDb21wb3NpdGUgPyBuZXdMYXllci5fcmVuZGVyTGF5ZXJzKHtcbiAgICAgICAgICBvbGRQcm9wcyxcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgb2xkQ29udGV4dDogdGhpcy5vbGRDb250ZXh0LFxuICAgICAgICAgIGNoYW5nZUZsYWdzOiBuZXdMYXllci5kaWZmUHJvcHMob2xkUHJvcHMsIHByb3BzLCB0aGlzLmNvbnRleHQpXG4gICAgICAgIH0pIDogbnVsbDtcbiAgICAgICAgLy8gRW5kIGxheWVyIGxpZmVjeWNsZSBtZXRob2Q6IHJlbmRlciBzdWJsYXllcnNcblxuICAgICAgICBpZiAoc3VibGF5ZXJzKSB7XG4gICAgICAgICAgLy8gRmxhdHRlbiB0aGUgcmV0dXJuZWQgYXJyYXksIHJlbW92aW5nIGFueSBudWxsLCB1bmRlZmluZWQgb3IgZmFsc2VcbiAgICAgICAgICAvLyB0aGlzIGFsbG93cyBsYXllcnMgdG8gcmVuZGVyIHN1YmxheWVycyBjb25kaXRpb25hbGx5XG4gICAgICAgICAgLy8gKHNlZSBDb21wb3NpdGVMYXllci5yZW5kZXJMYXllcnMgZG9jcylcbiAgICAgICAgICBzdWJsYXllcnMgPSBmbGF0dGVuKHN1YmxheWVycywge2ZpbHRlcjogQm9vbGVhbn0pO1xuXG4gICAgICAgICAgLy8gcG9wdWxhdGUgcmVmZXJlbmNlIHRvIHBhcmVudCBsYXllclxuICAgICAgICAgIHN1YmxheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgICAgICAgIGxheWVyLnBhcmVudExheWVyID0gbmV3TGF5ZXI7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLl9tYXRjaFN1YmxheWVycyh7XG4gICAgICAgICAgICBuZXdMYXllcnM6IHN1YmxheWVycyxcbiAgICAgICAgICAgIG9sZExheWVyTWFwLFxuICAgICAgICAgICAgZ2VuZXJhdGVkTGF5ZXJzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cub25jZSgwLCBgZXJyb3IgZHVyaW5nIG1hdGNoaW5nIG9mICR7bGF5ZXJOYW1lKG5ld0xheWVyKX1gLCBlcnIpO1xuICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgIGVycm9yID0gZXJyb3IgfHwgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICBfdHJhbnNmZXJMYXllclN0YXRlKG9sZExheWVyLCBuZXdMYXllcikge1xuICAgIGNvbnN0IHtzdGF0ZSwgcHJvcHN9ID0gb2xkTGF5ZXI7XG5cbiAgICAvLyBzYW5pdHkgY2hlY2tcbiAgICBhc3NlcnQoc3RhdGUsICdkZWNrLmdsIHNhbml0eSBjaGVjayAtIE1hdGNoaW5nIGxheWVyIGhhcyBubyBzdGF0ZScpO1xuICAgIGlmIChuZXdMYXllciAhPT0gb2xkTGF5ZXIpIHtcbiAgICAgIGxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SLFxuICAgICAgICBgbWF0Y2hlZCAke2xheWVyTmFtZShuZXdMYXllcil9YCwgb2xkTGF5ZXIsICctPicsIG5ld0xheWVyKTtcblxuICAgICAgLy8gTW92ZSBzdGF0ZVxuICAgICAgc3RhdGUubGF5ZXIgPSBuZXdMYXllcjtcbiAgICAgIG5ld0xheWVyLnN0YXRlID0gc3RhdGU7XG5cbiAgICAgIC8vIFVwZGF0ZSBtb2RlbCBsYXllciByZWZlcmVuY2VcbiAgICAgIGlmIChzdGF0ZS5tb2RlbCkge1xuICAgICAgICBzdGF0ZS5tb2RlbC51c2VyRGF0YS5sYXllciA9IG5ld0xheWVyO1xuICAgICAgfVxuICAgICAgLy8gS2VlcCBhIHRlbXBvcmFyeSByZWYgdG8gdGhlIG9sZCBwcm9wcywgZm9yIHByb3AgY29tcGFyaXNvblxuICAgICAgbmV3TGF5ZXIub2xkUHJvcHMgPSBwcm9wcztcbiAgICAgIC8vIG9sZExheWVyLnN0YXRlID0gbnVsbDtcblxuICAgICAgbmV3TGF5ZXIubGlmZWN5Y2xlID0gTElGRUNZQ0xFLk1BVENIRUQ7XG4gICAgICBvbGRMYXllci5saWZlY3ljbGUgPSBMSUZFQ1lDTEUuQVdBSVRJTkdfR0M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5sb2coTE9HX1BSSU9SSVRZX0xJRkVDWUNMRV9NSU5PUiwgYE1hdGNoaW5nIGxheWVyIGlzIHVuY2hhbmdlZCAke25ld0xheWVyLmlkfWApO1xuICAgICAgbmV3TGF5ZXIubGlmZWN5Y2xlID0gTElGRUNZQ0xFLk1BVENIRUQ7XG4gICAgICBuZXdMYXllci5vbGRQcm9wcyA9IG5ld0xheWVyLnByb3BzO1xuICAgICAgLy8gVE9ETyAtIHdlIGNvdWxkIGF2b2lkIHByb3AgY29tcGFyaXNvbnMgaW4gdGhpcyBjYXNlXG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBvbGQgbGF5ZXJzIHRoYXQgd2VyZSBub3QgbWF0Y2hlZFxuICBfZmluYWxpemVPbGRMYXllcnMob2xkTGF5ZXJzKSB7XG4gICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAvLyBNYXRjaGVkIGxheWVycyBoYXZlIGxpZmVjeWNsZSBzdGF0ZSBcIm91dGRhdGVkXCJcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIG9sZExheWVycykge1xuICAgICAgaWYgKGxheWVyLmxpZmVjeWNsZSA9PT0gTElGRUNZQ0xFLkFXQUlUSU5HX0ZJTkFMSVpBVElPTikge1xuICAgICAgICBlcnJvciA9IGVycm9yIHx8IHRoaXMuX2ZpbmFsaXplTGF5ZXIobGF5ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvLyBJbml0aWFsaXplcyBhIHNpbmdsZSBsYXllciwgY2FsbGluZyBsYXllciBtZXRob2RzXG4gIF9pbml0aWFsaXplTmV3TGF5ZXIobGF5ZXIpIHtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIC8vIENoZWNrIGlmIG5ldyBsYXllciwgYW5kIGluaXRpYWxpemUgaXQncyBzdGF0ZVxuICAgIGlmICghbGF5ZXIuc3RhdGUpIHtcbiAgICAgIGxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFLCBgaW5pdGlhbGl6aW5nICR7bGF5ZXJOYW1lKGxheWVyKX1gKTtcbiAgICAgIHRyeSB7XG5cbiAgICAgICAgbGF5ZXIuaW5pdGlhbGl6ZUxheWVyKHtcbiAgICAgICAgICBvbGRQcm9wczoge30sXG4gICAgICAgICAgcHJvcHM6IGxheWVyLnByb3BzLFxuICAgICAgICAgIG9sZENvbnRleHQ6IHRoaXMub2xkQ29udGV4dCxcbiAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgY2hhbmdlRmxhZ3M6IGxheWVyLmRpZmZQcm9wcyh7fSwgbGF5ZXIucHJvcHMsIHRoaXMuY29udGV4dClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGF5ZXIubGlmZWN5Y2xlID0gTElGRUNZQ0xFLklOSVRJQUxJWkVEO1xuXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLm9uY2UoMCwgYGVycm9yIHdoaWxlIGluaXRpYWxpemluZyAke2xheWVyTmFtZShsYXllcil9XFxuYCwgZXJyKTtcbiAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICBlcnJvciA9IGVycm9yIHx8IGVycjtcbiAgICAgIH1cbiAgICAgIC8vIFNldCBiYWNrIHBvaW50ZXIgKHVzZWQgaW4gcGlja2luZylcbiAgICAgIGlmIChsYXllci5zdGF0ZSkge1xuICAgICAgICBsYXllci5zdGF0ZS5sYXllciA9IGxheWVyO1xuICAgICAgICAvLyBTYXZlIGxheWVyIG9uIG1vZGVsIGZvciBwaWNraW5nIHB1cnBvc2VzXG4gICAgICAgIC8vIFRPRE8gLSBzdG9yZSBvbiBtb2RlbC51c2VyRGF0YSByYXRoZXIgdGhhbiBkaXJlY3RseSBvbiBtb2RlbFxuICAgICAgfVxuICAgICAgaWYgKGxheWVyLnN0YXRlICYmIGxheWVyLnN0YXRlLm1vZGVsKSB7XG4gICAgICAgIGxheWVyLnN0YXRlLm1vZGVsLnVzZXJEYXRhLmxheWVyID0gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8vIFVwZGF0ZXMgYSBzaW5nbGUgbGF5ZXIsIGNhbGxpbmcgbGF5ZXIgbWV0aG9kc1xuICBfdXBkYXRlTGF5ZXIobGF5ZXIpIHtcbiAgICBjb25zdCB7b2xkUHJvcHMsIHByb3BzfSA9IGxheWVyO1xuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgaWYgKG9sZFByb3BzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsYXllci51cGRhdGVMYXllcih7XG4gICAgICAgICAgb2xkUHJvcHMsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgIG9sZENvbnRleHQ6IHRoaXMub2xkQ29udGV4dCxcbiAgICAgICAgICBjaGFuZ2VGbGFnczogbGF5ZXIuZGlmZlByb3BzKG9sZFByb3BzLCBsYXllci5wcm9wcywgdGhpcy5jb250ZXh0KVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cub25jZSgwLCBgZXJyb3IgZHVyaW5nIHVwZGF0ZSBvZiAke2xheWVyTmFtZShsYXllcil9YCwgZXJyKTtcbiAgICAgICAgLy8gU2F2ZSBmaXJzdCBlcnJvclxuICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgIH1cbiAgICAgIGxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFX01JTk9SLCBgdXBkYXRpbmcgJHtsYXllck5hbWUobGF5ZXIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cblxuICAvLyBGaW5hbGl6ZXMgYSBzaW5nbGUgbGF5ZXJcbiAgX2ZpbmFsaXplTGF5ZXIobGF5ZXIpIHtcbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIGNvbnN0IHtzdGF0ZX0gPSBsYXllcjtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxheWVyLmZpbmFsaXplTGF5ZXIoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBsb2cub25jZSgwLFxuICAgICAgICAgIGBlcnJvciBkdXJpbmcgZmluYWxpemF0aW9uIG9mICR7bGF5ZXJOYW1lKGxheWVyKX1gLCBlcnIpO1xuICAgICAgICAvLyBTYXZlIGZpcnN0IGVycm9yXG4gICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgfVxuICAgICAgLy8gbGF5ZXIuc3RhdGUgPSBudWxsO1xuICAgICAgbGF5ZXIubGlmZWN5Y2xlID0gTElGRUNZQ0xFLkZJTkFMSVpFRDtcbiAgICAgIGxvZyhMT0dfUFJJT1JJVFlfTElGRUNZQ0xFLCBgZmluYWxpemluZyAke2xheWVyTmFtZShsYXllcil9YCk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYXJuIGlmIGEgZGVjay1sZXZlbCBtb3VzZSBldmVudCBoYXMgYmVlbiBzcGVjaWZpZWQsXG4gICAqIGJ1dCBubyBsYXllcnMgYXJlIGBwaWNrYWJsZWAuXG4gICAqL1xuICBfdmFsaWRhdGVFdmVudEhhbmRsaW5nKCkge1xuICAgIGlmICh0aGlzLm9uTGF5ZXJDbGljayB8fCB0aGlzLm9uTGF5ZXJIb3Zlcikge1xuICAgICAgaWYgKHRoaXMubGF5ZXJzLmxlbmd0aCAmJiAhdGhpcy5sYXllcnMuc29tZShsYXllciA9PiBsYXllci5wcm9wcy5waWNrYWJsZSkpIHtcbiAgICAgICAgbG9nLndhcm4oMSxcbiAgICAgICAgICAnWW91IGhhdmUgc3VwcGxpZWQgYSB0b3AtbGV2ZWwgaW5wdXQgZXZlbnQgaGFuZGxlciAoZS5nLiBgb25MYXllckNsaWNrYCksICcgK1xuICAgICAgICAgICdidXQgbm9uZSBvZiB5b3VyIGxheWVycyBoYXZlIHNldCB0aGUgYHBpY2thYmxlYCBmbGFnLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUm91dGUgY2xpY2sgZXZlbnRzIHRvIGxheWVycy5cbiAgICogYHBpY2tMYXllcmAgd2lsbCBjYWxsIHRoZSBgb25DbGlja2AgcHJvcCBvZiBhbnkgcGlja2VkIGxheWVyLFxuICAgKiBhbmQgYG9uTGF5ZXJDbGlja2AgaXMgY2FsbGVkIGRpcmVjdGx5IGZyb20gaGVyZVxuICAgKiB3aXRoIGFueSBwaWNraW5nIGluZm8gZ2VuZXJhdGVkIGJ5IGBwaWNrTGF5ZXJgLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgIEFuIG9iamVjdCBlbmNhcHN1bGF0aW5nIGFuIGlucHV0IGV2ZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGZvbGxvd2luZyBzaGFwZTpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0OiB7eCwgeX19IG9mZnNldENlbnRlcjogY2VudGVyIG9mIHRoZSBldmVudFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3R9IHNyY0V2ZW50OiAgICAgICAgICAgICBuYXRpdmUgSlMgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBfb25DbGljayhldmVudCkge1xuICAgIGlmICghZXZlbnQub2Zmc2V0Q2VudGVyKSB7XG4gICAgICAvLyBEbyBub3QgdHJpZ2dlciBvbkhvdmVyIGNhbGxiYWNrcyB3aGVuIGNsaWNrIHBvc2l0aW9uIGlzIGludmFsaWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3BpY2tBbmRDYWxsYmFjayh7XG4gICAgICBjYWxsYmFjazogdGhpcy5fb25MYXllckNsaWNrLFxuICAgICAgZXZlbnQsXG4gICAgICBtb2RlOiAnY2xpY2snXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUm91dGUgY2xpY2sgZXZlbnRzIHRvIGxheWVycy5cbiAgICogYHBpY2tMYXllcmAgd2lsbCBjYWxsIHRoZSBgb25Ib3ZlcmAgcHJvcCBvZiBhbnkgcGlja2VkIGxheWVyLFxuICAgKiBhbmQgYG9uTGF5ZXJIb3ZlcmAgaXMgY2FsbGVkIGRpcmVjdGx5IGZyb20gaGVyZVxuICAgKiB3aXRoIGFueSBwaWNraW5nIGluZm8gZ2VuZXJhdGVkIGJ5IGBwaWNrTGF5ZXJgLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgIEFuIG9iamVjdCBlbmNhcHN1bGF0aW5nIGFuIGlucHV0IGV2ZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdGhlIGZvbGxvd2luZyBzaGFwZTpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0OiB7eCwgeX19IG9mZnNldENlbnRlcjogY2VudGVyIG9mIHRoZSBldmVudFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3R9IHNyY0V2ZW50OiAgICAgICAgICAgICBuYXRpdmUgSlMgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBfb25Qb2ludGVyTW92ZShldmVudCkge1xuICAgIGlmIChldmVudC5pc0Rvd24pIHtcbiAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIG9uSG92ZXIgY2FsbGJhY2tzIGlmIG1vdXNlIGJ1dHRvbiBpcyBkb3duLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9waWNrQW5kQ2FsbGJhY2soe1xuICAgICAgY2FsbGJhY2s6IHRoaXMuX29uTGF5ZXJIb3ZlcixcbiAgICAgIGV2ZW50LFxuICAgICAgbW9kZTogJ2hvdmVyJ1xuICAgIH0pO1xuICB9XG5cbiAgX29uUG9pbnRlckxlYXZlKGV2ZW50KSB7XG4gICAgdGhpcy5waWNrT2JqZWN0KHtcbiAgICAgIHg6IC0xLFxuICAgICAgeTogLTEsXG4gICAgICByYWRpdXM6IHRoaXMuX3BpY2tpbmdSYWRpdXMsXG4gICAgICBtb2RlOiAnaG92ZXInXG4gICAgfSk7XG4gIH1cblxuICBfcGlja0FuZENhbGxiYWNrKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwb3MgPSBvcHRpb25zLmV2ZW50Lm9mZnNldENlbnRlcjtcbiAgICBjb25zdCByYWRpdXMgPSB0aGlzLl9waWNraW5nUmFkaXVzO1xuICAgIGNvbnN0IHNlbGVjdGVkSW5mb3MgPSB0aGlzLnBpY2tPYmplY3Qoe3g6IHBvcy54LCB5OiBwb3MueSwgcmFkaXVzLCBtb2RlOiBvcHRpb25zLm1vZGV9KTtcbiAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgY29uc3QgZmlyc3RJbmZvID0gc2VsZWN0ZWRJbmZvcy5maW5kKGluZm8gPT4gaW5mby5pbmRleCA+PSAwKSB8fCBudWxsO1xuICAgICAgLy8gQXMgcGVyIGRvY3VtZW50YXRpb24sIHNlbmQgbnVsbCB2YWx1ZSB3aGVuIG5vIHZhbGlkIG9iamVjdCBpcyBwaWNrZWQuXG4gICAgICBvcHRpb25zLmNhbGxiYWNrKGZpcnN0SW5mbywgc2VsZWN0ZWRJbmZvcywgb3B0aW9ucy5ldmVudC5zcmNFdmVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gU0VFUiBJTlRFR1JBVElPTlxuXG4gIC8qKlxuICAgKiBDYWxsZWQgdXBvbiBTZWVyIGluaXRpYWxpemF0aW9uLCBtYW51YWxseSBzZW5kcyBsYXllcnMgZGF0YS5cbiAgICovXG4gIF9pbml0U2VlcigpIHtcbiAgICB0aGlzLmxheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgIGluaXRMYXllckluU2VlcihsYXllcik7XG4gICAgICB1cGRhdGVMYXllckluU2VlcihsYXllcik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT24gU2VlciBwcm9wZXJ0eSBlZGl0aW9uLCBzZXQgb3ZlcnJpZGUgYW5kIHVwZGF0ZSBsYXllcnMuXG4gICAqL1xuICBfZWRpdFNlZXIocGF5bG9hZCkge1xuICAgIGlmIChwYXlsb2FkLnR5cGUgIT09ICdlZGl0JyB8fCBwYXlsb2FkLnZhbHVlUGF0aFswXSAhPT0gJ3Byb3BzJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldFByb3BPdmVycmlkZXMocGF5bG9hZC5pdGVtS2V5LCBwYXlsb2FkLnZhbHVlUGF0aC5zbGljZSgxKSwgcGF5bG9hZC52YWx1ZSk7XG4gICAgY29uc3QgbmV3TGF5ZXJzID0gdGhpcy5sYXllcnMubWFwKGxheWVyID0+IG5ldyBsYXllci5jb25zdHJ1Y3RvcihsYXllci5wcm9wcykpO1xuICAgIHRoaXMudXBkYXRlTGF5ZXJzKHtuZXdMYXllcnN9KTtcbiAgfVxufVxuIl19