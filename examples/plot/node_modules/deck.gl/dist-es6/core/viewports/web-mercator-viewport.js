export { _fitBounds as fitBounds };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// View and Projection Matrix calculations for mapbox-js style
// map view properties
import Viewport from './viewport';

import { projectFlat, unprojectFlat, makeProjectionMatrixFromMercatorParams, makeUncenteredViewMatrixFromMercatorParams } from 'viewport-mercator-project';

// TODO - import from viewport-mercator-project
// import {fitBounds} from '../viewport-mercator-project/fit-bounds';

// TODO - import from math.gl
/* eslint-disable camelcase */
import vec2_add from 'gl-vec2/add';
import vec2_negate from 'gl-vec2/negate';

import assert from 'assert';

var DEFAULT_MAP_STATE = {
  latitude: 37,
  longitude: -122,
  zoom: 11,
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

var ERR_ARGUMENT = 'Illegal argument to WebMercatorViewport';

var WebMercatorViewport = function (_Viewport) {
  _inherits(WebMercatorViewport, _Viewport);

  /**
   * @classdesc
   * Creates view/projection matrices from mercator params
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   */
  /* eslint-disable complexity, max-statements */
  function WebMercatorViewport() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, WebMercatorViewport);

    var width = opts.width,
        height = opts.height,
        latitude = opts.latitude,
        longitude = opts.longitude,
        zoom = opts.zoom,
        pitch = opts.pitch,
        bearing = opts.bearing,
        altitude = opts.altitude;
    var _opts$farZMultiplier = opts.farZMultiplier,
        farZMultiplier = _opts$farZMultiplier === undefined ? 10 : _opts$farZMultiplier;

    // Viewport - support undefined arguments

    width = width !== undefined ? width : DEFAULT_MAP_STATE.width;
    height = height !== undefined ? height : DEFAULT_MAP_STATE.height;
    zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;
    latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;
    longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;
    bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;
    pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;
    altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;

    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc
    width = width || 1;
    height = height || 1;

    // Altitude - prevent division by 0
    // TODO - just throw an Error instead?
    altitude = Math.max(0.75, altitude);

    var projectionMatrix = makeProjectionMatrixFromMercatorParams({
      width: width,
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      farZMultiplier: farZMultiplier
    });

    // The uncentered matrix allows us two move the center addition to the
    // shader (cheap) which gives a coordinate system that has its center in
    // the layer's center position. This makes rotations and other modelMatrx
    // transforms much more useful.
    var viewMatrixUncentered = makeUncenteredViewMatrixFromMercatorParams({
      width: width,
      height: height,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude
    });

    // Save parameters
    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, Object.assign({}, opts, {
      // x, y, position, ...
      // TODO / hack - prevent vertical offsets if not FirstPersonViewport
      position: opts.position && [opts.position[0], opts.position[1], 0],
      width: width, height: height,
      viewMatrix: viewMatrixUncentered,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      projectionMatrix: projectionMatrix,
      focalDistance: 1 // Viewport is already carefully set up to "focus" on ground
    })));

    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;

    // Bind methods
    _this.metersToLngLatDelta = _this.metersToLngLatDelta.bind(_this);
    _this.lngLatDeltaToMeters = _this.lngLatDeltaToMeters.bind(_this);
    _this.addMetersToLngLat = _this.addMetersToLngLat.bind(_this);

    Object.freeze(_this);
    return _this;
  }
  /* eslint-enable complexity, max-statements */

  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   *
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */


  _createClass(WebMercatorViewport, [{
    key: '_projectFlat',
    value: function _projectFlat(lngLat) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return projectFlat(lngLat, scale);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xy) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return unprojectFlat(xy, scale);
    }

    /**
     * Converts a meter offset to a lnglat offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas
     */

  }, {
    key: 'metersToLngLatDelta',
    value: function metersToLngLatDelta(xyz) {
      var _xyz = _slicedToArray(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          _xyz$ = _xyz[2],
          z = _xyz$ === undefined ? 0 : _xyz$;

      assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _distanceScales = this.distanceScales,
          pixelsPerMeter = _distanceScales.pixelsPerMeter,
          degreesPerPixel = _distanceScales.degreesPerPixel;

      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }

    /**
     * Converts a lnglat offset to a meter offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas
     */

  }, {
    key: 'lngLatDeltaToMeters',
    value: function lngLatDeltaToMeters(deltaLngLatZ) {
      var _deltaLngLatZ = _slicedToArray(deltaLngLatZ, 3),
          deltaLng = _deltaLngLatZ[0],
          deltaLat = _deltaLngLatZ[1],
          _deltaLngLatZ$ = _deltaLngLatZ[2],
          deltaZ = _deltaLngLatZ$ === undefined ? 0 : _deltaLngLatZ$;

      assert(Number.isFinite(deltaLng) && Number.isFinite(deltaLat) && Number.isFinite(deltaZ), ERR_ARGUMENT);
      var _distanceScales2 = this.distanceScales,
          pixelsPerDegree = _distanceScales2.pixelsPerDegree,
          metersPerPixel = _distanceScales2.metersPerPixel;

      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];
      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];
      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];
    }

    /**
     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
     */

  }, {
    key: 'addMetersToLngLat',
    value: function addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = _slicedToArray(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;

      var _metersToLngLatDelta = this.metersToLngLatDelta(lngLatZ, xyz),
          _metersToLngLatDelta2 = _slicedToArray(_metersToLngLatDelta, 3),
          deltaLng = _metersToLngLatDelta2[0],
          deltaLat = _metersToLngLatDelta2[1],
          _metersToLngLatDelta3 = _metersToLngLatDelta2[2],
          deltaZ = _metersToLngLatDelta3 === undefined ? 0 : _metersToLngLatDelta3;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }

    /**
     * Get the map center that place a given [lng, lat] coordinate at screen
     * point [x, y]
     *
     * @param {Array} lngLat - [lng,lat] coordinates
     *   Specifies a point on the sphere.
     * @param {Array} pos - [x,y] coordinates
     *   Specifies a point on the screen.
     * @return {Array} [lng,lat] new map center.
     */

  }, {
    key: 'getLocationAtPoint',
    value: function getLocationAtPoint(_ref) {
      var lngLat = _ref.lngLat,
          pos = _ref.pos;

      var fromLocation = this.projectFlat(this.unproject(pos));
      var toLocation = this.projectFlat(lngLat);

      var center = this.projectFlat([this.longitude, this.latitude]);

      var translate = vec2_add([], toLocation, vec2_negate([], fromLocation));
      var newCenter = vec2_add([], center, translate);
      return this.unprojectFlat(newCenter);
    }

    /**
     * Returns a new viewport that fit around the given rectangle.
     * Only supports non-perspective mode.
     * @param {Array} bounds - [[lon, lat], [lon, lat]]
     * @param {Number} [options.padding] - The amount of padding in pixels to add to the given bounds.
     * @param {Array} [options.offset] - The center of the given bounds relative to the map's center,
     *    [x, y] measured in pixels.
     * @returns {WebMercatorViewport}
     */

  }, {
    key: 'fitBounds',
    value: function fitBounds(bounds) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var width = this.width,
          height = this.height;

      var _fitBounds2 = _fitBounds(Object.assign({ width: width, height: height, bounds: bounds }, options)),
          longitude = _fitBounds2.longitude,
          latitude = _fitBounds2.latitude,
          zoom = _fitBounds2.zoom;

      return new WebMercatorViewport({ width: width, height: height, longitude: longitude, latitude: latitude, zoom: zoom });
    }

    // TODO - should support user supplied constraints

  }, {
    key: 'isMapSynched',
    value: function isMapSynched() {
      var MAPBOX_LIMITS = {
        pitch: 60,
        zoom: 40
      };

      var pitch = this.pitch,
          zoom = this.zoom;


      return pitch <= MAPBOX_LIMITS.pitch && zoom <= MAPBOX_LIMITS.zoom;
    }
  }]);

  return WebMercatorViewport;
}(Viewport);

// TODO - investigate if we can move this viewport-mercator-project

/**
 * Returns map settings {latitude, longitude, zoom}
 * that will contain the provided corners within the provided width.
 * Only supports non-perspective mode.
 * @param {Number} width - viewport width
 * @param {Number} height - viewport height
 * @param {Array} bounds - [[lon, lat], [lon, lat]]
 * @param {Number} [padding] - The amount of padding in pixels to add to the given bounds.
 * @param {Array} [offset] - The center of the given bounds relative to the map's center,
 *    [x, y] measured in pixels.
 * @returns {Object} - latitude, longitude and zoom
 */


export default WebMercatorViewport;
function _fitBounds(_ref2) {
  var width = _ref2.width,
      height = _ref2.height,
      bounds = _ref2.bounds,
      _ref2$padding = _ref2.padding,
      padding = _ref2$padding === undefined ? 0 : _ref2$padding,
      _ref2$offset = _ref2.offset,
      offset = _ref2$offset === undefined ? [0, 0] : _ref2$offset;

  var _bounds = _slicedToArray(bounds, 2),
      _bounds$ = _slicedToArray(_bounds[0], 2),
      west = _bounds$[0],
      south = _bounds$[1],
      _bounds$2 = _slicedToArray(_bounds[1], 2),
      east = _bounds$2[0],
      north = _bounds$2[1];

  var viewport = new WebMercatorViewport({
    width: width,
    height: height,
    longitude: 0,
    latitude: 0,
    zoom: 0
  });

  var nw = viewport.project([west, north]);
  var se = viewport.project([east, south]);
  var size = [Math.abs(se[0] - nw[0]), Math.abs(se[1] - nw[1])];
  var center = [(se[0] + nw[0]) / 2, (se[1] + nw[1]) / 2];

  var scaleX = (width - padding * 2 - Math.abs(offset[0]) * 2) / size[0];
  var scaleY = (height - padding * 2 - Math.abs(offset[1]) * 2) / size[1];

  var centerLngLat = viewport.unproject(center);
  var zoom = viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY)));

  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom: zoom
  };
}

WebMercatorViewport.displayName = 'WebMercatorViewport';
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL3ZpZXdwb3J0cy93ZWItbWVyY2F0b3Itdmlld3BvcnQuanMiXSwibmFtZXMiOlsiVmlld3BvcnQiLCJwcm9qZWN0RmxhdCIsInVucHJvamVjdEZsYXQiLCJtYWtlUHJvamVjdGlvbk1hdHJpeEZyb21NZXJjYXRvclBhcmFtcyIsIm1ha2VVbmNlbnRlcmVkVmlld01hdHJpeEZyb21NZXJjYXRvclBhcmFtcyIsInZlYzJfYWRkIiwidmVjMl9uZWdhdGUiLCJhc3NlcnQiLCJERUZBVUxUX01BUF9TVEFURSIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInBpdGNoIiwiYmVhcmluZyIsImFsdGl0dWRlIiwiRVJSX0FSR1VNRU5UIiwiV2ViTWVyY2F0b3JWaWV3cG9ydCIsIm9wdHMiLCJ3aWR0aCIsImhlaWdodCIsImZhclpNdWx0aXBsaWVyIiwidW5kZWZpbmVkIiwiTWF0aCIsIm1heCIsInByb2plY3Rpb25NYXRyaXgiLCJ2aWV3TWF0cml4VW5jZW50ZXJlZCIsIk9iamVjdCIsImFzc2lnbiIsInBvc2l0aW9uIiwidmlld01hdHJpeCIsImZvY2FsRGlzdGFuY2UiLCJtZXRlcnNUb0xuZ0xhdERlbHRhIiwiYmluZCIsImxuZ0xhdERlbHRhVG9NZXRlcnMiLCJhZGRNZXRlcnNUb0xuZ0xhdCIsImZyZWV6ZSIsImxuZ0xhdCIsInNjYWxlIiwieHkiLCJ4eXoiLCJ4IiwieSIsInoiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImRpc3RhbmNlU2NhbGVzIiwicGl4ZWxzUGVyTWV0ZXIiLCJkZWdyZWVzUGVyUGl4ZWwiLCJkZWx0YUxuZyIsImRlbHRhTGF0IiwibGVuZ3RoIiwiZGVsdGFMbmdMYXRaIiwiZGVsdGFaIiwicGl4ZWxzUGVyRGVncmVlIiwibWV0ZXJzUGVyUGl4ZWwiLCJkZWx0YVgiLCJkZWx0YVkiLCJsbmdMYXRaIiwibG5nIiwibGF0IiwiWiIsInBvcyIsImZyb21Mb2NhdGlvbiIsInVucHJvamVjdCIsInRvTG9jYXRpb24iLCJjZW50ZXIiLCJ0cmFuc2xhdGUiLCJuZXdDZW50ZXIiLCJib3VuZHMiLCJvcHRpb25zIiwiZml0Qm91bmRzIiwiTUFQQk9YX0xJTUlUUyIsInBhZGRpbmciLCJvZmZzZXQiLCJ3ZXN0Iiwic291dGgiLCJlYXN0Iiwibm9ydGgiLCJ2aWV3cG9ydCIsIm53IiwicHJvamVjdCIsInNlIiwic2l6ZSIsImFicyIsInNjYWxlWCIsInNjYWxlWSIsImNlbnRlckxuZ0xhdCIsImxvZzIiLCJtaW4iLCJkaXNwbGF5TmFtZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU9BLFFBQVAsTUFBcUIsWUFBckI7O0FBRUEsU0FDRUMsV0FERixFQUVFQyxhQUZGLEVBR0VDLHNDQUhGLEVBSUVDLDBDQUpGLFFBS08sMkJBTFA7O0FBT0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBT0MsUUFBUCxNQUFxQixhQUFyQjtBQUNBLE9BQU9DLFdBQVAsTUFBd0IsZ0JBQXhCOztBQUVBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7O0FBRUEsSUFBTUMsb0JBQW9CO0FBQ3hCQyxZQUFVLEVBRGM7QUFFeEJDLGFBQVcsQ0FBQyxHQUZZO0FBR3hCQyxRQUFNLEVBSGtCO0FBSXhCQyxTQUFPLENBSmlCO0FBS3hCQyxXQUFTLENBTGU7QUFNeEJDLFlBQVU7QUFOYyxDQUExQjs7QUFTQSxJQUFNQyxlQUFlLHlDQUFyQjs7SUFFcUJDLG1COzs7QUFDbkI7Ozs7OztBQU1BO0FBQ0EsaUNBQXVCO0FBQUEsUUFBWEMsSUFBVyx1RUFBSixFQUFJOztBQUFBOztBQUFBLFFBRW5CQyxLQUZtQixHQVVqQkQsSUFWaUIsQ0FFbkJDLEtBRm1CO0FBQUEsUUFHbkJDLE1BSG1CLEdBVWpCRixJQVZpQixDQUduQkUsTUFIbUI7QUFBQSxRQUluQlYs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ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBWaWV3IGFuZCBQcm9qZWN0aW9uIE1hdHJpeCBjYWxjdWxhdGlvbnMgZm9yIG1hcGJveC1qcyBzdHlsZVxuLy8gbWFwIHZpZXcgcHJvcGVydGllc1xuaW1wb3J0IFZpZXdwb3J0IGZyb20gJy4vdmlld3BvcnQnO1xuXG5pbXBvcnQge1xuICBwcm9qZWN0RmxhdCxcbiAgdW5wcm9qZWN0RmxhdCxcbiAgbWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMsXG4gIG1ha2VVbmNlbnRlcmVkVmlld01hdHJpeEZyb21NZXJjYXRvclBhcmFtc1xufSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcblxuLy8gVE9ETyAtIGltcG9ydCBmcm9tIHZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3Rcbi8vIGltcG9ydCB7Zml0Qm91bmRzfSBmcm9tICcuLi92aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0L2ZpdC1ib3VuZHMnO1xuXG4vLyBUT0RPIC0gaW1wb3J0IGZyb20gbWF0aC5nbFxuLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG5pbXBvcnQgdmVjMl9hZGQgZnJvbSAnZ2wtdmVjMi9hZGQnO1xuaW1wb3J0IHZlYzJfbmVnYXRlIGZyb20gJ2dsLXZlYzIvbmVnYXRlJztcblxuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBERUZBVUxUX01BUF9TVEFURSA9IHtcbiAgbGF0aXR1ZGU6IDM3LFxuICBsb25naXR1ZGU6IC0xMjIsXG4gIHpvb206IDExLFxuICBwaXRjaDogMCxcbiAgYmVhcmluZzogMCxcbiAgYWx0aXR1ZGU6IDEuNVxufTtcblxuY29uc3QgRVJSX0FSR1VNRU5UID0gJ0lsbGVnYWwgYXJndW1lbnQgdG8gV2ViTWVyY2F0b3JWaWV3cG9ydCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYk1lcmNhdG9yVmlld3BvcnQgZXh0ZW5kcyBWaWV3cG9ydCB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIENyZWF0ZXMgdmlldy9wcm9qZWN0aW9uIG1hdHJpY2VzIGZyb20gbWVyY2F0b3IgcGFyYW1zXG4gICAqIE5vdGU6IFRoZSBWaWV3cG9ydCBpcyBpbW11dGFibGUgaW4gdGhlIHNlbnNlIHRoYXQgaXQgb25seSBoYXMgYWNjZXNzb3JzLlxuICAgKiBBIG5ldyB2aWV3cG9ydCBpbnN0YW5jZSBzaG91bGQgYmUgY3JlYXRlZCBpZiBhbnkgcGFyYW1ldGVycyBoYXZlIGNoYW5nZWQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50cyAqL1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIHpvb20sXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZVxuICAgIH0gPSBvcHRzO1xuXG4gICAgY29uc3Qge1xuICAgICAgLy8geCwgeSwgcG9zaXRpb24sIC4uLlxuICAgICAgZmFyWk11bHRpcGxpZXIgPSAxMFxuICAgIH0gPSBvcHRzO1xuXG4gICAgLy8gVmlld3BvcnQgLSBzdXBwb3J0IHVuZGVmaW5lZCBhcmd1bWVudHNcbiAgICB3aWR0aCA9IHdpZHRoICE9PSB1bmRlZmluZWQgPyB3aWR0aCA6IERFRkFVTFRfTUFQX1NUQVRFLndpZHRoO1xuICAgIGhlaWdodCA9IGhlaWdodCAhPT0gdW5kZWZpbmVkID8gaGVpZ2h0IDogREVGQVVMVF9NQVBfU1RBVEUuaGVpZ2h0O1xuICAgIHpvb20gPSB6b29tICE9PSB1bmRlZmluZWQgPyB6b29tIDogREVGQVVMVF9NQVBfU1RBVEUuem9vbTtcbiAgICBsYXRpdHVkZSA9IGxhdGl0dWRlICE9PSB1bmRlZmluZWQgPyBsYXRpdHVkZSA6IERFRkFVTFRfTUFQX1NUQVRFLmxhdGl0dWRlO1xuICAgIGxvbmdpdHVkZSA9IGxvbmdpdHVkZSAhPT0gdW5kZWZpbmVkID8gbG9uZ2l0dWRlIDogREVGQVVMVF9NQVBfU1RBVEUubG9uZ2l0dWRlO1xuICAgIGJlYXJpbmcgPSBiZWFyaW5nICE9PSB1bmRlZmluZWQgPyBiZWFyaW5nIDogREVGQVVMVF9NQVBfU1RBVEUuYmVhcmluZztcbiAgICBwaXRjaCA9IHBpdGNoICE9PSB1bmRlZmluZWQgPyBwaXRjaCA6IERFRkFVTFRfTUFQX1NUQVRFLnBpdGNoO1xuICAgIGFsdGl0dWRlID0gYWx0aXR1ZGUgIT09IHVuZGVmaW5lZCA/IGFsdGl0dWRlIDogREVGQVVMVF9NQVBfU1RBVEUuYWx0aXR1ZGU7XG5cbiAgICAvLyBTaWxlbnRseSBhbGxvdyBhcHBzIHRvIHNlbmQgaW4gMCwwIHRvIGZhY2lsaXRhdGUgaXNvbW9ycGhpYyByZW5kZXIgZXRjXG4gICAgd2lkdGggPSB3aWR0aCB8fCAxO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCAxO1xuXG4gICAgLy8gQWx0aXR1ZGUgLSBwcmV2ZW50IGRpdmlzaW9uIGJ5IDBcbiAgICAvLyBUT0RPIC0ganVzdCB0aHJvdyBhbiBFcnJvciBpbnN0ZWFkP1xuICAgIGFsdGl0dWRlID0gTWF0aC5tYXgoMC43NSwgYWx0aXR1ZGUpO1xuXG4gICAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IG1ha2VQcm9qZWN0aW9uTWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcGl0Y2gsXG4gICAgICBiZWFyaW5nLFxuICAgICAgYWx0aXR1ZGUsXG4gICAgICBmYXJaTXVsdGlwbGllclxuICAgIH0pO1xuXG4gICAgLy8gVGhlIHVuY2VudGVyZWQgbWF0cml4IGFsbG93cyB1cyB0d28gbW92ZSB0aGUgY2VudGVyIGFkZGl0aW9uIHRvIHRoZVxuICAgIC8vIHNoYWRlciAoY2hlYXApIHdoaWNoIGdpdmVzIGEgY29vcmRpbmF0ZSBzeXN0ZW0gdGhhdCBoYXMgaXRzIGNlbnRlciBpblxuICAgIC8vIHRoZSBsYXllcidzIGNlbnRlciBwb3NpdGlvbi4gVGhpcyBtYWtlcyByb3RhdGlvbnMgYW5kIG90aGVyIG1vZGVsTWF0cnhcbiAgICAvLyB0cmFuc2Zvcm1zIG11Y2ggbW9yZSB1c2VmdWwuXG4gICAgY29uc3Qgdmlld01hdHJpeFVuY2VudGVyZWQgPSBtYWtlVW5jZW50ZXJlZFZpZXdNYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIHpvb20sXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZVxuICAgIH0pO1xuXG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge1xuICAgICAgLy8geCwgeSwgcG9zaXRpb24sIC4uLlxuICAgICAgLy8gVE9ETyAvIGhhY2sgLSBwcmV2ZW50IHZlcnRpY2FsIG9mZnNldHMgaWYgbm90IEZpcnN0UGVyc29uVmlld3BvcnRcbiAgICAgIHBvc2l0aW9uOiBvcHRzLnBvc2l0aW9uICYmIFtvcHRzLnBvc2l0aW9uWzBdLCBvcHRzLnBvc2l0aW9uWzFdLCAwXSxcbiAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICB2aWV3TWF0cml4OiB2aWV3TWF0cml4VW5jZW50ZXJlZCxcbiAgICAgIGxvbmdpdHVkZSxcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgem9vbSxcbiAgICAgIHByb2plY3Rpb25NYXRyaXgsXG4gICAgICBmb2NhbERpc3RhbmNlOiAxIC8vIFZpZXdwb3J0IGlzIGFscmVhZHkgY2FyZWZ1bGx5IHNldCB1cCB0byBcImZvY3VzXCIgb24gZ3JvdW5kXG4gICAgfSkpO1xuXG4gICAgLy8gU2F2ZSBwYXJhbWV0ZXJzXG4gICAgdGhpcy5sYXRpdHVkZSA9IGxhdGl0dWRlO1xuICAgIHRoaXMubG9uZ2l0dWRlID0gbG9uZ2l0dWRlO1xuICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgdGhpcy5waXRjaCA9IHBpdGNoO1xuICAgIHRoaXMuYmVhcmluZyA9IGJlYXJpbmc7XG4gICAgdGhpcy5hbHRpdHVkZSA9IGFsdGl0dWRlO1xuXG4gICAgLy8gQmluZCBtZXRob2RzXG4gICAgdGhpcy5tZXRlcnNUb0xuZ0xhdERlbHRhID0gdGhpcy5tZXRlcnNUb0xuZ0xhdERlbHRhLmJpbmQodGhpcyk7XG4gICAgdGhpcy5sbmdMYXREZWx0YVRvTWV0ZXJzID0gdGhpcy5sbmdMYXREZWx0YVRvTWV0ZXJzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGRNZXRlcnNUb0xuZ0xhdCA9IHRoaXMuYWRkTWV0ZXJzVG9MbmdMYXQuYmluZCh0aGlzKTtcblxuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50cyAqL1xuXG4gIC8qKlxuICAgKiBQcm9qZWN0IFtsbmcsbGF0XSBvbiBzcGhlcmUgb250byBbeCx5XSBvbiA1MTIqNTEyIE1lcmNhdG9yIFpvb20gMCB0aWxlLlxuICAgKiBQZXJmb3JtcyB0aGUgbm9ubGluZWFyIHBhcnQgb2YgdGhlIHdlYiBtZXJjYXRvciBwcm9qZWN0aW9uLlxuICAgKiBSZW1haW5pbmcgcHJvamVjdGlvbiBpcyBkb25lIHdpdGggNHg0IG1hdHJpY2VzIHdoaWNoIGFsc28gaGFuZGxlc1xuICAgKiBwZXJzcGVjdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZywgbGF0XSBjb29yZGluYXRlc1xuICAgKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzcGhlcmUgdG8gcHJvamVjdCBvbnRvIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge0FycmF5fSBbeCx5XSBjb29yZGluYXRlcy5cbiAgICovXG4gIF9wcm9qZWN0RmxhdChsbmdMYXQsIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiBwcm9qZWN0RmxhdChsbmdMYXQsIHNjYWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3Qgd29ybGQgcG9pbnQgW3gseV0gb24gbWFwIG9udG8ge2xhdCwgbG9ufSBvbiBzcGhlcmVcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAgICogIHJlcHJlc2VudGluZyBwb2ludCBvbiBwcm9qZWN0ZWQgbWFwIHBsYW5lXG4gICAqIEByZXR1cm4ge0dlb0Nvb3JkaW5hdGVzfSAtIG9iamVjdCB3aXRoIHtsYXQsbG9ufSBvZiBwb2ludCBvbiBzcGhlcmUuXG4gICAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAgICogICBQZXIgY2FydG9ncmFwaGljIHRyYWRpdGlvbiwgbGF0IGFuZCBsb24gYXJlIHNwZWNpZmllZCBhcyBkZWdyZWVzLlxuICAgKi9cbiAgX3VucHJvamVjdEZsYXQoeHksIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB1bnByb2plY3RGbGF0KHh5LCBzY2FsZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBtZXRlciBvZmZzZXQgdG8gYSBsbmdsYXQgb2Zmc2V0XG4gICAqXG4gICAqIE5vdGU6IFVzZXMgc2ltcGxlIGxpbmVhciBhcHByb3hpbWF0aW9uIGFyb3VuZCB0aGUgdmlld3BvcnQgY2VudGVyXG4gICAqIEVycm9yIGluY3JlYXNlcyB3aXRoIHNpemUgb2Ygb2Zmc2V0IChyb3VnaGx5IDElIHBlciAxMDBrbSlcbiAgICpcbiAgICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgeHl6IC0gYXJyYXkgb2YgbWV0ZXIgZGVsdGFzXG4gICAqIEByZXR1cm4ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSAtIGFycmF5IG9mIFtsbmcsbGF0LHpdIGRlbHRhc1xuICAgKi9cbiAgbWV0ZXJzVG9MbmdMYXREZWx0YSh4eXopIHtcbiAgICBjb25zdCBbeCwgeSwgeiA9IDBdID0geHl6O1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoeCkgJiYgTnVtYmVyLmlzRmluaXRlKHkpICYmIE51bWJlci5pc0Zpbml0ZSh6KSwgRVJSX0FSR1VNRU5UKTtcbiAgICBjb25zdCB7cGl4ZWxzUGVyTWV0ZXIsIGRlZ3JlZXNQZXJQaXhlbH0gPSB0aGlzLmRpc3RhbmNlU2NhbGVzO1xuICAgIGNvbnN0IGRlbHRhTG5nID0geCAqIHBpeGVsc1Blck1ldGVyWzBdICogZGVncmVlc1BlclBpeGVsWzBdO1xuICAgIGNvbnN0IGRlbHRhTGF0ID0geSAqIHBpeGVsc1Blck1ldGVyWzFdICogZGVncmVlc1BlclBpeGVsWzFdO1xuICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gW2RlbHRhTG5nLCBkZWx0YUxhdF0gOiBbZGVsdGFMbmcsIGRlbHRhTGF0LCB6XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIGxuZ2xhdCBvZmZzZXQgdG8gYSBtZXRlciBvZmZzZXRcbiAgICpcbiAgICogTm90ZTogVXNlcyBzaW1wbGUgbGluZWFyIGFwcHJveGltYXRpb24gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcbiAgICogRXJyb3IgaW5jcmVhc2VzIHdpdGggc2l6ZSBvZiBvZmZzZXQgKHJvdWdobHkgMSUgcGVyIDEwMGttKVxuICAgKlxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSBkZWx0YUxuZ0xhdFogLSBhcnJheSBvZiBbbG5nLGxhdCx6XSBkZWx0YXNcbiAgICogQHJldHVybiB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIC0gYXJyYXkgb2YgbWV0ZXIgZGVsdGFzXG4gICAqL1xuICBsbmdMYXREZWx0YVRvTWV0ZXJzKGRlbHRhTG5nTGF0Wikge1xuICAgIGNvbnN0IFtkZWx0YUxuZywgZGVsdGFMYXQsIGRlbHRhWiA9IDBdID0gZGVsdGFMbmdMYXRaO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoZGVsdGFMbmcpICYmIE51bWJlci5pc0Zpbml0ZShkZWx0YUxhdCkgJiYgTnVtYmVyLmlzRmluaXRlKGRlbHRhWiksXG4gICAgICBFUlJfQVJHVU1FTlQpO1xuICAgIGNvbnN0IHtwaXhlbHNQZXJEZWdyZWUsIG1ldGVyc1BlclBpeGVsfSA9IHRoaXMuZGlzdGFuY2VTY2FsZXM7XG4gICAgY29uc3QgZGVsdGFYID0gZGVsdGFMbmcgKiBwaXhlbHNQZXJEZWdyZWVbMF0gKiBtZXRlcnNQZXJQaXhlbFswXTtcbiAgICBjb25zdCBkZWx0YVkgPSBkZWx0YUxhdCAqIHBpeGVsc1BlckRlZ3JlZVsxXSAqIG1ldGVyc1BlclBpeGVsWzFdO1xuICAgIHJldHVybiBkZWx0YUxuZ0xhdFoubGVuZ3RoID09PSAyID8gW2RlbHRhWCwgZGVsdGFZXSA6IFtkZWx0YVgsIGRlbHRhWSwgZGVsdGFaXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBtZXRlciBkZWx0YSB0byBhIGJhc2UgbG5nbGF0IGNvb3JkaW5hdGUsIHJldHVybmluZyBhIG5ldyBsbmdsYXQgYXJyYXlcbiAgICpcbiAgICogTm90ZTogVXNlcyBzaW1wbGUgbGluZWFyIGFwcHJveGltYXRpb24gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcbiAgICogRXJyb3IgaW5jcmVhc2VzIHdpdGggc2l6ZSBvZiBvZmZzZXQgKHJvdWdobHkgMSUgcGVyIDEwMGttKVxuICAgKlxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSBsbmdMYXRaIC0gYmFzZSBjb29yZGluYXRlXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIHh5eiAtIGFycmF5IG9mIG1ldGVyIGRlbHRhc1xuICAgKiBAcmV0dXJuIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgYXJyYXkgb2YgW2xuZyxsYXQsel0gZGVsdGFzXG4gICAqL1xuICBhZGRNZXRlcnNUb0xuZ0xhdChsbmdMYXRaLCB4eXopIHtcbiAgICBjb25zdCBbbG5nLCBsYXQsIFogPSAwXSA9IGxuZ0xhdFo7XG4gICAgY29uc3QgW2RlbHRhTG5nLCBkZWx0YUxhdCwgZGVsdGFaID0gMF0gPSB0aGlzLm1ldGVyc1RvTG5nTGF0RGVsdGEobG5nTGF0WiwgeHl6KTtcbiAgICByZXR1cm4gbG5nTGF0Wi5sZW5ndGggPT09IDIgP1xuICAgICAgW2xuZyArIGRlbHRhTG5nLCBsYXQgKyBkZWx0YUxhdF0gOlxuICAgICAgW2xuZyArIGRlbHRhTG5nLCBsYXQgKyBkZWx0YUxhdCwgWiArIGRlbHRhWl07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgY2VudGVyIHRoYXQgcGxhY2UgYSBnaXZlbiBbbG5nLCBsYXRdIGNvb3JkaW5hdGUgYXQgc2NyZWVuXG4gICAqIHBvaW50IFt4LCB5XVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLGxhdF0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBwb3MgLSBbeCx5XSBjb29yZGluYXRlc1xuICAgKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzY3JlZW4uXG4gICAqIEByZXR1cm4ge0FycmF5fSBbbG5nLGxhdF0gbmV3IG1hcCBjZW50ZXIuXG4gICAqL1xuICBnZXRMb2NhdGlvbkF0UG9pbnQoe2xuZ0xhdCwgcG9zfSkge1xuICAgIGNvbnN0IGZyb21Mb2NhdGlvbiA9IHRoaXMucHJvamVjdEZsYXQodGhpcy51bnByb2plY3QocG9zKSk7XG4gICAgY29uc3QgdG9Mb2NhdGlvbiA9IHRoaXMucHJvamVjdEZsYXQobG5nTGF0KTtcblxuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMucHJvamVjdEZsYXQoW3RoaXMubG9uZ2l0dWRlLCB0aGlzLmxhdGl0dWRlXSk7XG5cbiAgICBjb25zdCB0cmFuc2xhdGUgPSB2ZWMyX2FkZChbXSwgdG9Mb2NhdGlvbiwgdmVjMl9uZWdhdGUoW10sIGZyb21Mb2NhdGlvbikpO1xuICAgIGNvbnN0IG5ld0NlbnRlciA9IHZlYzJfYWRkKFtdLCBjZW50ZXIsIHRyYW5zbGF0ZSk7XG4gICAgcmV0dXJuIHRoaXMudW5wcm9qZWN0RmxhdChuZXdDZW50ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgdmlld3BvcnQgdGhhdCBmaXQgYXJvdW5kIHRoZSBnaXZlbiByZWN0YW5nbGUuXG4gICAqIE9ubHkgc3VwcG9ydHMgbm9uLXBlcnNwZWN0aXZlIG1vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJvdW5kcyAtIFtbbG9uLCBsYXRdLCBbbG9uLCBsYXRdXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGFkZGluZ10gLSBUaGUgYW1vdW50IG9mIHBhZGRpbmcgaW4gcGl4ZWxzIHRvIGFkZCB0byB0aGUgZ2l2ZW4gYm91bmRzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5vZmZzZXRdIC0gVGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gYm91bmRzIHJlbGF0aXZlIHRvIHRoZSBtYXAncyBjZW50ZXIsXG4gICAqICAgIFt4LCB5XSBtZWFzdXJlZCBpbiBwaXhlbHMuXG4gICAqIEByZXR1cm5zIHtXZWJNZXJjYXRvclZpZXdwb3J0fVxuICAgKi9cbiAgZml0Qm91bmRzKGJvdW5kcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcztcbiAgICBjb25zdCB7bG9uZ2l0dWRlLCBsYXRpdHVkZSwgem9vbX0gPSBmaXRCb3VuZHMoT2JqZWN0LmFzc2lnbih7d2lkdGgsIGhlaWdodCwgYm91bmRzfSwgb3B0aW9ucykpO1xuICAgIHJldHVybiBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh7d2lkdGgsIGhlaWdodCwgbG9uZ2l0dWRlLCBsYXRpdHVkZSwgem9vbX0pO1xuICB9XG5cbiAgLy8gVE9ETyAtIHNob3VsZCBzdXBwb3J0IHVzZXIgc3VwcGxpZWQgY29uc3RyYWludHNcbiAgaXNNYXBTeW5jaGVkKCkge1xuICAgIGNvbnN0IE1BUEJPWF9MSU1JVFMgPSB7XG4gICAgICBwaXRjaDogNjAsXG4gICAgICB6b29tOiA0MFxuICAgIH07XG5cbiAgICBjb25zdCB7cGl0Y2gsIHpvb219ID0gdGhpcztcblxuICAgIHJldHVybiBwaXRjaCA8PSBNQVBCT1hfTElNSVRTLnBpdGNoICYmIHpvb20gPD0gTUFQQk9YX0xJTUlUUy56b29tO1xuICB9XG59XG5cbi8vIFRPRE8gLSBpbnZlc3RpZ2F0ZSBpZiB3ZSBjYW4gbW92ZSB0aGlzIHZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3RcblxuLyoqXG4gKiBSZXR1cm5zIG1hcCBzZXR0aW5ncyB7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgem9vbX1cbiAqIHRoYXQgd2lsbCBjb250YWluIHRoZSBwcm92aWRlZCBjb3JuZXJzIHdpdGhpbiB0aGUgcHJvdmlkZWQgd2lkdGguXG4gKiBPbmx5IHN1cHBvcnRzIG5vbi1wZXJzcGVjdGl2ZSBtb2RlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gdmlld3BvcnQgd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSB2aWV3cG9ydCBoZWlnaHRcbiAqIEBwYXJhbSB7QXJyYXl9IGJvdW5kcyAtIFtbbG9uLCBsYXRdLCBbbG9uLCBsYXRdXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtwYWRkaW5nXSAtIFRoZSBhbW91bnQgb2YgcGFkZGluZyBpbiBwaXhlbHMgdG8gYWRkIHRvIHRoZSBnaXZlbiBib3VuZHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbb2Zmc2V0XSAtIFRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIGJvdW5kcyByZWxhdGl2ZSB0byB0aGUgbWFwJ3MgY2VudGVyLFxuICogICAgW3gsIHldIG1lYXN1cmVkIGluIHBpeGVscy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gbGF0aXR1ZGUsIGxvbmdpdHVkZSBhbmQgem9vbVxuICovXG5leHBvcnQgZnVuY3Rpb24gZml0Qm91bmRzKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgYm91bmRzLFxuICAvLyBvcHRpb25zXG4gIHBhZGRpbmcgPSAwLFxuICBvZmZzZXQgPSBbMCwgMF1cbn0pIHtcbiAgY29uc3QgW1t3ZXN0LCBzb3V0aF0sIFtlYXN0LCBub3J0aF1dID0gYm91bmRzO1xuXG4gIGNvbnN0IHZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsb25naXR1ZGU6IDAsXG4gICAgbGF0aXR1ZGU6IDAsXG4gICAgem9vbTogMFxuICB9KTtcblxuICBjb25zdCBudyA9IHZpZXdwb3J0LnByb2plY3QoW3dlc3QsIG5vcnRoXSk7XG4gIGNvbnN0IHNlID0gdmlld3BvcnQucHJvamVjdChbZWFzdCwgc291dGhdKTtcbiAgY29uc3Qgc2l6ZSA9IFtcbiAgICBNYXRoLmFicyhzZVswXSAtIG53WzBdKSxcbiAgICBNYXRoLmFicyhzZVsxXSAtIG53WzFdKVxuICBdO1xuICBjb25zdCBjZW50ZXIgPSBbXG4gICAgKHNlWzBdICsgbndbMF0pIC8gMixcbiAgICAoc2VbMV0gKyBud1sxXSkgLyAyXG4gIF07XG5cbiAgY29uc3Qgc2NhbGVYID0gKHdpZHRoIC0gcGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXRbMF0pICogMikgLyBzaXplWzBdO1xuICBjb25zdCBzY2FsZVkgPSAoaGVpZ2h0IC0gcGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXRbMV0pICogMikgLyBzaXplWzFdO1xuXG4gIGNvbnN0IGNlbnRlckxuZ0xhdCA9IHZpZXdwb3J0LnVucHJvamVjdChjZW50ZXIpO1xuICBjb25zdCB6b29tID0gdmlld3BvcnQuem9vbSArIE1hdGgubG9nMihNYXRoLmFicyhNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSkpKTtcblxuICByZXR1cm4ge1xuICAgIGxvbmdpdHVkZTogY2VudGVyTG5nTGF0WzBdLFxuICAgIGxhdGl0dWRlOiBjZW50ZXJMbmdMYXRbMV0sXG4gICAgem9vbVxuICB9O1xufVxuXG5XZWJNZXJjYXRvclZpZXdwb3J0LmRpc3BsYXlOYW1lID0gJ1dlYk1lcmNhdG9yVmlld3BvcnQnO1xuIl19