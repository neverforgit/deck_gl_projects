var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { createElement } from 'react';
import PropTypes from 'prop-types';
import OrbitViewport from '../../core/viewports/orbit-viewport';
import OrbitState from '../../core/controllers/orbit-state';
import Controls from '../../core/controllers/controls';
import { EventManager } from 'mjolnir.js';

var propTypes = {
  /* Viewport properties */
  lookAt: PropTypes.arrayOf(PropTypes.number), // target position
  distance: PropTypes.number, // distance from camera to the target
  rotationX: PropTypes.number, // rotation around X axis
  rotationY: PropTypes.number, // rotation around Y axis
  translationX: PropTypes.number, // translation x in screen space
  translationY: PropTypes.number, // translation y in screen space
  zoom: PropTypes.number, // scale in screen space
  minZoom: PropTypes.number,
  maxZoom: PropTypes.number,
  fov: PropTypes.number, // field of view
  near: PropTypes.number,
  far: PropTypes.number,
  width: PropTypes.number.isRequired, // viewport width in pixels
  height: PropTypes.number.isRequired, // viewport height in pixels

  /* Model properties */
  bounds: PropTypes.object, // bounds in the shape of {minX, minY, minZ, maxX, maxY, maxZ}

  /* Callbacks */
  onViewportChange: PropTypes.func.isRequired,

  /* Controls */
  orbitControls: PropTypes.object
};

var defaultProps = {
  lookAt: [0, 0, 0],
  rotationX: 0,
  rotationY: 0,
  translationX: 0,
  translationY: 0,
  distance: 10,
  zoom: 1,
  minZoom: 0,
  maxZoom: Infinity,
  fov: 50,
  near: 1,
  far: 1000
};

/*
 * Maps mouse interaction to a deck.gl Viewport
 */

var OrbitController = function (_React$Component) {
  _inherits(OrbitController, _React$Component);

  _createClass(OrbitController, null, [{
    key: 'getViewport',


    // Returns a deck.gl Viewport instance, to be used with the DeckGL component
    value: function getViewport(viewport) {
      return new OrbitViewport(viewport);
    }
  }]);

  function OrbitController(props) {
    _classCallCheck(this, OrbitController);

    var _this = _possibleConstructorReturn(this, (OrbitController.__proto__ || Object.getPrototypeOf(OrbitController)).call(this, props));

    _this.state = {
      // Whether the cursor is down
      isDragging: false
    };

    _this._orbitControls = props.orbitControls || new Controls(OrbitState);
    return _this;
  }

  _createClass(OrbitController, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var eventCanvas = this.refs.eventCanvas;


      var eventManager = new EventManager(eventCanvas);
      this._eventManager = eventManager;

      this._orbitControls.setOptions(Object.assign({}, this.props, {
        onStateChange: this._onInteractiveStateChange.bind(this),
        eventManager: eventManager
      }));
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps) {
      this._orbitControls.setOptions(nextProps);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this._eventManager) {
        // Must destroy because hammer adds event listeners to window
        this._eventManager.destroy();
      }
    }
  }, {
    key: '_onInteractiveStateChange',
    value: function _onInteractiveStateChange(_ref) {
      var _ref$isDragging = _ref.isDragging,
          isDragging = _ref$isDragging === undefined ? false : _ref$isDragging;

      if (isDragging !== this.state.isDragging) {
        this.setState({ isDragging: isDragging });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return createElement('div', {
        ref: 'eventCanvas'
      }, this.props.children);
    }
  }]);

  return OrbitController;
}(React.Component);

export default OrbitController;


OrbitController.propTypes = propTypes;
OrbitController.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFjdC9leHBlcmltZW50YWwvb3JiaXQtY29udHJvbGxlci5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUVsZW1lbnQiLCJQcm9wVHlwZXMiLCJPcmJpdFZpZXdwb3J0IiwiT3JiaXRTdGF0ZSIsIkNvbnRyb2xzIiwiRXZlbnRNYW5hZ2VyIiwicHJvcFR5cGVzIiwibG9va0F0IiwiYXJyYXlPZiIsIm51bWJlciIsImRpc3RhbmNlIiwicm90YXRpb25YIiwicm90YXRpb25ZIiwidHJhbnNsYXRpb25YIiwidHJhbnNsYXRpb25ZIiwiem9vbSIsIm1pblpvb20iLCJtYXhab29tIiwiZm92IiwibmVhciIsImZhciIsIndpZHRoIiwiaXNSZXF1aXJlZCIsImhlaWdodCIsImJvdW5kcyIsIm9iamVjdCIsIm9uVmlld3BvcnRDaGFuZ2UiLCJmdW5jIiwib3JiaXRDb250cm9scyIsImRlZmF1bHRQcm9wcyIsIkluZmluaXR5IiwiT3JiaXRDb250cm9sbGVyIiwidmlld3BvcnQiLCJwcm9wcyIsInN0YXRlIiwiaXNEcmFnZ2luZyIsIl9vcmJpdENvbnRyb2xzIiwiZXZlbnRDYW52YXMiLCJyZWZzIiwiZXZlbnRNYW5hZ2VyIiwiX2V2ZW50TWFuYWdlciIsInNldE9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJvblN0YXRlQ2hhbmdlIiwiX29uSW50ZXJhY3RpdmVTdGF0ZUNoYW5nZSIsImJpbmQiLCJuZXh0UHJvcHMiLCJkZXN0cm95Iiwic2V0U3RhdGUiLCJyZWYiLCJjaGlsZHJlbiIsIkNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxPQUFPQSxLQUFQLElBQWVDLGFBQWYsUUFBbUMsT0FBbkM7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLFlBQXRCO0FBQ0EsT0FBT0MsYUFBUCxNQUEwQixxQ0FBMUI7QUFDQSxPQUFPQyxVQUFQLE1BQXVCLG9DQUF2QjtBQUNBLE9BQU9DLFFBQVAsTUFBcUIsaUNBQXJCO0FBQ0EsU0FB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O0FBRGMsT0FBckIsRUFFRyxLQUFLakIsS0FBTCxDQUFXa0IsUUFGZCxDQURGO0FBS0Q7Ozs7RUFyRDBDcEQsTUFBTXFELFM7O2VBQTlCckIsZTs7O0FBd0RyQkEsZ0JBQWdCekIsU0FBaEIsR0FBNEJBLFNBQTVCO0FBQ0F5QixnQkFBZ0JGLFlBQWhCLEdBQStCQSxZQUEvQiIsImZpbGUiOiJvcmJpdC1jb250cm9sbGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7Y3JlYXRlRWxlbWVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBPcmJpdFZpZXdwb3J0IGZyb20gJy4uLy4uL2NvcmUvdmlld3BvcnRzL29yYml0LXZpZXdwb3J0JztcbmltcG9ydCBPcmJpdFN0YXRlIGZyb20gJy4uLy4uL2NvcmUvY29udHJvbGxlcnMvb3JiaXQtc3RhdGUnO1xuaW1wb3J0IENvbnRyb2xzIGZyb20gJy4uLy4uL2NvcmUvY29udHJvbGxlcnMvY29udHJvbHMnO1xuaW1wb3J0IHtFdmVudE1hbmFnZXJ9IGZyb20gJ21qb2xuaXIuanMnO1xuXG5jb25zdCBwcm9wVHlwZXMgPSB7XG4gIC8qIFZpZXdwb3J0IHByb3BlcnRpZXMgKi9cbiAgbG9va0F0OiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKSwgLy8gdGFyZ2V0IHBvc2l0aW9uXG4gIGRpc3RhbmNlOiBQcm9wVHlwZXMubnVtYmVyLCAvLyBkaXN0YW5jZSBmcm9tIGNhbWVyYSB0byB0aGUgdGFyZ2V0XG4gIHJvdGF0aW9uWDogUHJvcFR5cGVzLm51bWJlciwgLy8gcm90YXRpb24gYXJvdW5kIFggYXhpc1xuICByb3RhdGlvblk6IFByb3BUeXBlcy5udW1iZXIsIC8vIHJvdGF0aW9uIGFyb3VuZCBZIGF4aXNcbiAgdHJhbnNsYXRpb25YOiBQcm9wVHlwZXMubnVtYmVyLCAvLyB0cmFuc2xhdGlvbiB4IGluIHNjcmVlbiBzcGFjZVxuICB0cmFuc2xhdGlvblk6IFByb3BUeXBlcy5udW1iZXIsIC8vIHRyYW5zbGF0aW9uIHkgaW4gc2NyZWVuIHNwYWNlXG4gIHpvb206IFByb3BUeXBlcy5udW1iZXIsIC8vIHNjYWxlIGluIHNjcmVlbiBzcGFjZVxuICBtaW5ab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICBtYXhab29tOiBQcm9wVHlwZXMubnVtYmVyLFxuICBmb3Y6IFByb3BUeXBlcy5udW1iZXIsIC8vIGZpZWxkIG9mIHZpZXdcbiAgbmVhcjogUHJvcFR5cGVzLm51bWJlcixcbiAgZmFyOiBQcm9wVHlwZXMubnVtYmVyLFxuICB3aWR0aDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLCAvLyB2aWV3cG9ydCB3aWR0aCBpbiBwaXhlbHNcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsIC8vIHZpZXdwb3J0IGhlaWdodCBpbiBwaXhlbHNcblxuICAvKiBNb2RlbCBwcm9wZXJ0aWVzICovXG4gIGJvdW5kczogUHJvcFR5cGVzLm9iamVjdCwgLy8gYm91bmRzIGluIHRoZSBzaGFwZSBvZiB7bWluWCwgbWluWSwgbWluWiwgbWF4WCwgbWF4WSwgbWF4Wn1cblxuICAvKiBDYWxsYmFja3MgKi9cbiAgb25WaWV3cG9ydENoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAvKiBDb250cm9scyAqL1xuICBvcmJpdENvbnRyb2xzOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGxvb2tBdDogWzAsIDAsIDBdLFxuICByb3RhdGlvblg6IDAsXG4gIHJvdGF0aW9uWTogMCxcbiAgdHJhbnNsYXRpb25YOiAwLFxuICB0cmFuc2xhdGlvblk6IDAsXG4gIGRpc3RhbmNlOiAxMCxcbiAgem9vbTogMSxcbiAgbWluWm9vbTogMCxcbiAgbWF4Wm9vbTogSW5maW5pdHksXG4gIGZvdjogNTAsXG4gIG5lYXI6IDEsXG4gIGZhcjogMTAwMFxufTtcblxuLypcbiAqIE1hcHMgbW91c2UgaW50ZXJhY3Rpb24gdG8gYSBkZWNrLmdsIFZpZXdwb3J0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9yYml0Q29udHJvbGxlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgLy8gUmV0dXJucyBhIGRlY2suZ2wgVmlld3BvcnQgaW5zdGFuY2UsIHRvIGJlIHVzZWQgd2l0aCB0aGUgRGVja0dMIGNvbXBvbmVudFxuICBzdGF0aWMgZ2V0Vmlld3BvcnQodmlld3BvcnQpIHtcbiAgICByZXR1cm4gbmV3IE9yYml0Vmlld3BvcnQodmlld3BvcnQpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgLy8gV2hldGhlciB0aGUgY3Vyc29yIGlzIGRvd25cbiAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlXG4gICAgfTtcblxuICAgIHRoaXMuX29yYml0Q29udHJvbHMgPSBwcm9wcy5vcmJpdENvbnRyb2xzIHx8IG5ldyBDb250cm9scyhPcmJpdFN0YXRlKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHtldmVudENhbnZhc30gPSB0aGlzLnJlZnM7XG5cbiAgICBjb25zdCBldmVudE1hbmFnZXIgPSBuZXcgRXZlbnRNYW5hZ2VyKGV2ZW50Q2FudmFzKTtcbiAgICB0aGlzLl9ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG5cbiAgICB0aGlzLl9vcmJpdENvbnRyb2xzLnNldE9wdGlvbnMoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgb25TdGF0ZUNoYW5nZTogdGhpcy5fb25JbnRlcmFjdGl2ZVN0YXRlQ2hhbmdlLmJpbmQodGhpcyksXG4gICAgICBldmVudE1hbmFnZXJcbiAgICB9KSk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcykge1xuICAgIHRoaXMuX29yYml0Q29udHJvbHMuc2V0T3B0aW9ucyhuZXh0UHJvcHMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX2V2ZW50TWFuYWdlcikge1xuICAgICAgLy8gTXVzdCBkZXN0cm95IGJlY2F1c2UgaGFtbWVyIGFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHdpbmRvd1xuICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICBfb25JbnRlcmFjdGl2ZVN0YXRlQ2hhbmdlKHtpc0RyYWdnaW5nID0gZmFsc2V9KSB7XG4gICAgaWYgKGlzRHJhZ2dpbmcgIT09IHRoaXMuc3RhdGUuaXNEcmFnZ2luZykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7aXNEcmFnZ2luZ30pO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICByZWY6ICdldmVudENhbnZhcydcbiAgICAgIH0sIHRoaXMucHJvcHMuY2hpbGRyZW4pXG4gICAgKTtcbiAgfVxufVxuXG5PcmJpdENvbnRyb2xsZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuT3JiaXRDb250cm9sbGVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==