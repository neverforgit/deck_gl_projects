var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import { Layer } from '../../core';
import { get, flatten, log } from '../../core/lib/utils';
import { extractPolygons } from './geojson';
import { GL, Model, Geometry } from 'luma.gl';
import earcut from 'earcut';

import choroplethVertex from './choropleth-layer-vertex.glsl';
import choroplethFragment from './choropleth-layer-fragment.glsl';

var DEFAULT_COLOR = [0, 0, 255, 255];

var defaultProps = {
  getColor: function getColor(feature) {
    return get(feature, 'properties.color');
  },
  drawContour: false,
  strokeWidth: 1
};

var ChoroplethLayer = function (_Layer) {
  _inherits(ChoroplethLayer, _Layer);

  function ChoroplethLayer(props) {
    _classCallCheck(this, ChoroplethLayer);

    var _this = _possibleConstructorReturn(this, (ChoroplethLayer.__proto__ || Object.getPrototypeOf(ChoroplethLayer)).call(this, props));

    log.deprecated('ChoroplethLayer', 'GeoJsonLayer');
    return _this;
  }

  _createClass(ChoroplethLayer, [{
    key: 'getShaders',
    value: function getShaders() {
      return {
        vs: choroplethVertex,
        fs: choroplethFragment
      };
    }
  }, {
    key: 'initializeState',
    value: function initializeState() {
      var gl = this.context.gl;
      var attributeManager = this.state.attributeManager;

      attributeManager.add({
        // Primtive attributes
        indices: { size: 1, update: this.calculateIndices, isIndexed: true },
        positions: { size: 3, update: this.calculatePositions },
        colors: { size: 4, type: GL.UNSIGNED_BYTE, update: this.calculateColors },
        // Instanced attributes
        pickingColors: {
          size: 3,
          type: GL.UNSIGNED_BYTE,
          update: this.calculatePickingColors,
          noAlloc: true
        }
      });

      var IndexType = gl.getExtension('OES_element_index_uint') ? Uint32Array : Uint16Array;

      this.setState({
        model: this.getModel(gl),
        numInstances: 0,
        IndexType: IndexType
      });
    }
  }, {
    key: 'updateState',
    value: function updateState(_ref) {
      var oldProps = _ref.oldProps,
          props = _ref.props,
          changeFlags = _ref.changeFlags;
      var attributeManager = this.state.attributeManager;

      if (changeFlags.dataChanged) {
        this.state.choropleths = extractPolygons(props.data);
        attributeManager.invalidateAll();
      }

      if (props.drawContour !== oldProps.drawContour) {
        this.state.model.geometry.drawMode = props.drawContour ? GL.LINES : GL.TRIANGLES;
        attributeManager.invalidateAll();
      }
    }
  }, {
    key: 'draw',
    value: function draw(_ref2) {
      var uniforms = _ref2.uniforms;
      var gl = this.context.gl;

      var lineWidth = this.screenToDevicePixels(this.props.strokeWidth);
      gl.lineWidth(lineWidth);
      this.state.model.render(uniforms);
      // Setting line width back to 1 is here to workaround a Google Chrome bug
      // gl.clear() and gl.isEnabled() will return GL_INVALID_VALUE even with
      // correct parameter
      // This is not happening on Safari and Firefox
      gl.lineWidth(1.0);
    }
  }, {
    key: 'getPickingInfo',
    value: function getPickingInfo(opts) {
      var info = _get(ChoroplethLayer.prototype.__proto__ || Object.getPrototypeOf(ChoroplethLayer.prototype), 'getPickingInfo', this).call(this, opts);
      var index = this.decodePickingColor(info.color);
      var feature = index >= 0 ? get(this.props.data, ['features', index]) : null;
      info.feature = feature;
      info.object = feature;
      return info;
    }
  }, {
    key: 'getModel',
    value: function getModel(gl) {
      return new Model(gl, Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new Geometry({
          drawMode: this.props.drawContour ? GL.LINES : GL.TRIANGLES
        }),
        vertexCount: 0,
        isIndexed: true,
        shaderCache: this.context.shaderCache
      }));
    }
  }, {
    key: 'calculateIndices',
    value: function calculateIndices(attribute) {
      var _this2 = this;

      // adjust index offset for multiple choropleths
      var offsets = this.state.choropleths.reduce(function (acc, choropleth) {
        return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + choropleth.reduce(function (count, polygon) {
          return count + polygon.length;
        }, 0)]);
      }, [0]);
      var IndexType = this.state.IndexType;

      if (IndexType === Uint16Array && offsets[offsets.length - 1] > 65535) {
        throw new Error('Vertex count exceeds browser\'s limit');
      }

      var indices = this.state.choropleths.map(function (choropleth, choroplethIndex) {
        return _this2.props.drawContour ?
        // 1. get sequentially ordered indices of each choropleth contour
        // 2. offset them by the number of indices in previous choropleths
        calculateContourIndices(choropleth).map(function (index) {
          return index + offsets[choroplethIndex];
        }) :
        // 1. get triangulated indices for the internal areas
        // 2. offset them by the number of indices in previous choropleths
        calculateSurfaceIndices(choropleth).map(function (index) {
          return index + offsets[choroplethIndex];
        });
      });

      attribute.value = new IndexType(flatten(indices));
      attribute.target = GL.ELEMENT_ARRAY_BUFFER;
      this.state.model.setVertexCount(attribute.value.length / attribute.size);
    }
  }, {
    key: 'calculatePositions',
    value: function calculatePositions(attribute) {
      var vertices = flatten(this.state.choropleths);
      attribute.value = new Float32Array(vertices);
    }
  }, {
    key: 'calculateColors',
    value: function calculateColors(attribute) {
      var _props = this.props,
          data = _props.data,
          getColor = _props.getColor;

      var features = get(data, 'features');
      var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {
        var feature = get(features, choropleth.featureIndex);
        var color = getColor(feature) || DEFAULT_COLOR;
        // Ensure alpha is set
        if (isNaN(color[3])) {
          color[3] = DEFAULT_COLOR[3];
        }
        return choropleth.map(function (polygon) {
          return polygon.map(function (vertex) {
            return color;
          });
        });
      });

      attribute.value = new Uint8Array(flatten(colors));
    }

    // Override the default picking colors calculation

  }, {
    key: 'calculatePickingColors',
    value: function calculatePickingColors(attribute) {
      var _this3 = this;

      var colors = this.state.choropleths.map(function (choropleth, choroplethIndex) {
        var featureIndex = choropleth.featureIndex;

        var color = _this3.props.drawContour ? [0, 0, 0] : [(featureIndex + 1) % 256, Math.floor((featureIndex + 1) / 256) % 256, Math.floor((featureIndex + 1) / 256 / 256) % 256];
        return choropleth.map(function (polygon) {
          return polygon.map(function (vertex) {
            return color;
          });
        });
      });

      attribute.value = new Uint8Array(flatten(colors));
    }
  }]);

  return ChoroplethLayer;
}(Layer);

export default ChoroplethLayer;


ChoroplethLayer.layerName = 'ChoroplethLayer';
ChoroplethLayer.defaultProps = defaultProps;

/*
 * get vertex indices for drawing choropleth contour
 * @param {[Number,Number,Number][][]} choropleth
 * @returns {[Number]} indices
 */
function calculateContourIndices(choropleth) {
  var offset = 0;

  return choropleth.reduce(function (acc, polygon) {
    var numVertices = polygon.length;

    // use vertex pairs for gl.LINES => [0, 1, 1, 2, 2, ..., n-2, n-2, n-1]
    var indices = [].concat(_toConsumableArray(acc), [offset]);
    for (var i = 1; i < numVertices - 1; i++) {
      indices.push(i + offset, i + offset);
    }
    indices.push(offset + numVertices - 1);

    offset += numVertices;
    return indices;
  }, []);
}

/*
 * get vertex indices for drawing choropleth mesh
 * @param {[Number,Number,Number][][]} choropleth
 * @returns {[Number]} indices
 */
function calculateSurfaceIndices(choropleth) {
  var holes = null;

  if (choropleth.length > 1) {
    holes = choropleth.reduce(function (acc, polygon) {
      return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + polygon.length]);
    }, [0]).slice(1, choropleth.length);
  }

  return earcut(flatten(choropleth), holes, 3);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZXByZWNhdGVkLWxheWVycy9jaG9yb3BsZXRoLWxheWVyL2Nob3JvcGxldGgtbGF5ZXIuanMiXSwibmFtZXMiOlsiTGF5ZXIiLCJnZXQiLCJmbGF0dGVuIiwibG9nIiwiZXh0cmFjdFBvbHlnb25zIiwiR0wiLCJNb2RlbCIsIkdlb21ldHJ5IiwiZWFyY3V0IiwiY2hvcm9wbGV0aFZlcnRleCIsImNob3JvcGxldGhGcmFnbWVudCIsIkRFRkFVTFRfQ09MT1IiLCJkZWZhdWx0UHJvcHMiLCJnZXRDb2xvciIsImZlYXR1cmUiLCJkcmF3Q29udG91ciIsInN0cm9rZVdpZHRoIiwiQ2hvcm9wbGV0aExheWVyIiwicHJvcHMiLCJkZXByZWNhdGVkIiwidnMiLCJmcyIsImdsIiwiY29udGV4dCIsImF0dHJpYnV0ZU1hbmFnZXIiLCJzdGF0ZSIsImFkZCIsImluZGljZXMiLCJzaXplIiwidXBkYXRlIiwiY2FsY3VsYXRlSW5kaWNlcyIsImlzSW5kZXhlZCIsInBvc2l0aW9ucyIsImNhbGN1bGF0ZVBvc2l0aW9ucyIsImNvbG9ycyIsInR5cGUiLCJVTlNJR05FRF9CWVRFIiwiY2FsY3VsYXRlQ29sb3JzIiwicGlja2luZ0NvbG9ycyIsImNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMiLCJub0FsbG9jIiwiSW5kZXhUeXBlIiwiZ2V0RXh0ZW5zaW9uIiwiVWludDMyQXJyYXkiLCJVaW50MTZBcnJheSIsInNldFN0YXRlIiwibW9kZWwiLCJnZXRNb2RlbCIsIm51bUluc3RhbmNlcyIsIm9sZFByb3BzIiwiY2hhbmdlRmxhZ3MiLCJkYXRhQ2hhbmdlZCIsImNob3JvcGxldGhzIiwiZGF0YSIsImludmFsaWRhdGVBbGwiLCJnZW9tZXRyeSIsImRyYXdNb2RlIiwiTElORVMiLCJUUklBTkdMRVMiLCJ1bmlmb3JtcyIsImxpbmVXaWR0aCIsInNjcmVlblRvRGV2aWNlUGl4ZWxzIiwicmVuZGVyIiwib3B0cyIsImluZm8iLCJpbmRleCIsImRlY29kZVBpY2tpbmdDb2xvciIsImNvbG9yIiwib2JqZWN0IiwiT2JqZWN0IiwiYXNzaWduIiwiZ2V0U2hhZGVycyIsImlkIiwidmVydGV4Q291bnQiLCJzaGFkZXJDYWNoZSIsImF0dHJpYnV0ZSIsIm9mZnNldHMiLCJyZWR1Y2UiLCJhY2MiLCJjaG9yb3BsZXRoIiwibGVuZ3RoIiwiY291bnQiLCJwb2x5Z29uIiwiRXJyb3IiLCJtYXAiLCJjaG9yb3BsZXRoSW5kZXgiLCJjYWxjdWxhdGVDb250b3VySW5kaWNlcyIsImNhbGN1bGF0ZVN1cmZhY2VJbmRpY2VzIiwidmFsdWUiLCJ0YXJnZXQiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsInNldFZlcnRleENvdW50IiwidmVydGljZXMiLCJGbG9hdDMyQXJyYXkiLCJmZWF0dXJlcyIsImZlYXR1cmVJbmRleCIsImlzTmFOIiwiVWludDhBcnJheSIsIk1hdGgiLCJmbG9vciIsImxheWVyTmFtZSIsIm9mZnNldCIsIm51bVZlcnRpY2VzIiwiaSIsInB1c2giLCJob2xlcyIsInNsaWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRQSxLQUFSLFFBQW9CLFlBQXBCO0FBQ0EsU0FBUUMsR0FBUixFQUFhQyxPQUFiLEVBQXNCQyxHQUF0QixRQUFnQyxzQkFBaEM7QUFDQSxTQUFRQyxlQUFSLFFBQThCLFdBQTlCO0FBQ0EsU0FBUUMsRUFBUixFQUFZQyxLQUFaLEVBQW1CQyxRQUFuQixRQUFrQyxTQUFsQztBQUNBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7O0FBRUEsT0FBT0MsZ0JBQVAsTUFBNkIsZ0NBQTdCO0FBQ0EsT0FBT0Msa0JBQVAsTUFBK0Isa0NBQS9COztBQUVBLElBQU1DLGdCQUFnQixDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sR0FBUCxFQUFZLEdBQVosQ0FBdEI7O0FBRUEs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O0FBQ3pCeUIsWUFBUTFCLFdBQVdGLE1BQVgsQ0FDTixVQUFDQyxHQUFELEVBQU1JLE9BQU47QUFBQSwwQ0FBc0JKLEdBQXRCLElBQTJCQSxJQUFJQSxJQUFJRSxNQUFKLEdBQWEsQ0FBakIsSUFBc0JFLFFBQVFGLE1BQXpEO0FBQUEsS0FETSxFQUVOLENBQUMsQ0FBRCxDQUZNLEVBR04wQixLQUhNLENBR0EsQ0FIQSxFQUdHM0IsV0FBV0MsTUFIZCxDQUFSO0FBSUQ7O0FBRUQsU0FBT3hFLE9BQU9OLFFBQVE2RSxVQUFSLENBQVAsRUFBNEIwQixLQUE1QixFQUFtQyxDQUFuQyxDQUFQO0FBQ0QiLCJmaWxlIjoiY2hvcm9wbGV0aC1sYXllci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0xheWVyfSBmcm9tICcuLi8uLi9jb3JlJztcbmltcG9ydCB7Z2V0LCBmbGF0dGVuLCBsb2d9IGZyb20gJy4uLy4uL2NvcmUvbGliL3V0aWxzJztcbmltcG9ydCB7ZXh0cmFjdFBvbHlnb25zfSBmcm9tICcuL2dlb2pzb24nO1xuaW1wb3J0IHtHTCwgTW9kZWwsIEdlb21ldHJ5fSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCBlYXJjdXQgZnJvbSAnZWFyY3V0JztcblxuaW1wb3J0IGNob3JvcGxldGhWZXJ0ZXggZnJvbSAnLi9jaG9yb3BsZXRoLWxheWVyLXZlcnRleC5nbHNsJztcbmltcG9ydCBjaG9yb3BsZXRoRnJhZ21lbnQgZnJvbSAnLi9jaG9yb3BsZXRoLWxheWVyLWZyYWdtZW50Lmdsc2wnO1xuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gWzAsIDAsIDI1NSwgMjU1XTtcblxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICBnZXRDb2xvcjogZmVhdHVyZSA9PiBnZXQoZmVhdHVyZSwgJ3Byb3BlcnRpZXMuY29sb3InKSxcbiAgZHJhd0NvbnRvdXI6IGZhbHNlLFxuICBzdHJva2VXaWR0aDogMVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hvcm9wbGV0aExheWVyIGV4dGVuZHMgTGF5ZXIge1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIGxvZy5kZXByZWNhdGVkKCdDaG9yb3BsZXRoTGF5ZXInLCAnR2VvSnNvbkxheWVyJyk7XG4gIH1cblxuICBnZXRTaGFkZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2czogY2hvcm9wbGV0aFZlcnRleCxcbiAgICAgIGZzOiBjaG9yb3BsZXRoRnJhZ21lbnRcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG5cbiAgICBjb25zdCB7YXR0cmlidXRlTWFuYWdlcn0gPSB0aGlzLnN0YXRlO1xuICAgIGF0dHJpYnV0ZU1hbmFnZXIuYWRkKHtcbiAgICAgIC8vIFByaW10aXZlIGF0dHJpYnV0ZXNcbiAgICAgIGluZGljZXM6IHtzaXplOiAxLCB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5kaWNlcywgaXNJbmRleGVkOiB0cnVlfSxcbiAgICAgIHBvc2l0aW9uczoge3NpemU6IDMsIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVQb3NpdGlvbnN9LFxuICAgICAgY29sb3JzOiB7c2l6ZTogNCwgdHlwZTogR0wuVU5TSUdORURfQllURSwgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUNvbG9yc30sXG4gICAgICAvLyBJbnN0YW5jZWQgYXR0cmlidXRlc1xuICAgICAgcGlja2luZ0NvbG9yczoge1xuICAgICAgICBzaXplOiAzLFxuICAgICAgICB0eXBlOiBHTC5VTlNJR05FRF9CWVRFLFxuICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUGlja2luZ0NvbG9ycyxcbiAgICAgICAgbm9BbGxvYzogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgSW5kZXhUeXBlID0gZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfZWxlbWVudF9pbmRleF91aW50JykgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbChnbCksXG4gICAgICBudW1JbnN0YW5jZXM6IDAsXG4gICAgICBJbmRleFR5cGVcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVN0YXRlKHtvbGRQcm9wcywgcHJvcHMsIGNoYW5nZUZsYWdzfSkge1xuICAgIGNvbnN0IHthdHRyaWJ1dGVNYW5hZ2VyfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkKSB7XG4gICAgICB0aGlzLnN0YXRlLmNob3JvcGxldGhzID0gZXh0cmFjdFBvbHlnb25zKHByb3BzLmRhdGEpO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLmRyYXdDb250b3VyICE9PSBvbGRQcm9wcy5kcmF3Q29udG91cikge1xuICAgICAgdGhpcy5zdGF0ZS5tb2RlbC5nZW9tZXRyeS5kcmF3TW9kZSA9IHByb3BzLmRyYXdDb250b3VyID8gR0wuTElORVMgOiBHTC5UUklBTkdMRVM7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICB9XG5cbiAgfVxuXG4gIGRyYXcoe3VuaWZvcm1zfSkge1xuICAgIGNvbnN0IHtnbH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgY29uc3QgbGluZVdpZHRoID0gdGhpcy5zY3JlZW5Ub0RldmljZVBpeGVscyh0aGlzLnByb3BzLnN0cm9rZVdpZHRoKTtcbiAgICBnbC5saW5lV2lkdGgobGluZVdpZHRoKTtcbiAgICB0aGlzLnN0YXRlLm1vZGVsLnJlbmRlcih1bmlmb3Jtcyk7XG4gICAgLy8gU2V0dGluZyBsaW5lIHdpZHRoIGJhY2sgdG8gMSBpcyBoZXJlIHRvIHdvcmthcm91bmQgYSBHb29nbGUgQ2hyb21lIGJ1Z1xuICAgIC8vIGdsLmNsZWFyKCkgYW5kIGdsLmlzRW5hYmxlZCgpIHdpbGwgcmV0dXJuIEdMX0lOVkFMSURfVkFMVUUgZXZlbiB3aXRoXG4gICAgLy8gY29ycmVjdCBwYXJhbWV0ZXJcbiAgICAvLyBUaGlzIGlzIG5vdCBoYXBwZW5pbmcgb24gU2FmYXJpIGFuZCBGaXJlZm94XG4gICAgZ2wubGluZVdpZHRoKDEuMCk7XG4gIH1cblxuICBnZXRQaWNraW5nSW5mbyhvcHRzKSB7XG4gICAgY29uc3QgaW5mbyA9IHN1cGVyLmdldFBpY2tpbmdJbmZvKG9wdHMpO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kZWNvZGVQaWNraW5nQ29sb3IoaW5mby5jb2xvcik7XG4gICAgY29uc3QgZmVhdHVyZSA9IGluZGV4ID49IDAgPyBnZXQodGhpcy5wcm9wcy5kYXRhLCBbJ2ZlYXR1cmVzJywgaW5kZXhdKSA6IG51bGw7XG4gICAgaW5mby5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICBpbmZvLm9iamVjdCA9IGZlYXR1cmU7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBnZXRNb2RlbChnbCkge1xuICAgIHJldHVybiBuZXcgTW9kZWwoZ2wsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0U2hhZGVycygpLCB7XG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICBkcmF3TW9kZTogdGhpcy5wcm9wcy5kcmF3Q29udG91ciA/IEdMLkxJTkVTIDogR0wuVFJJQU5HTEVTXG4gICAgICB9KSxcbiAgICAgIHZlcnRleENvdW50OiAwLFxuICAgICAgaXNJbmRleGVkOiB0cnVlLFxuICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgIH0pKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZUluZGljZXMoYXR0cmlidXRlKSB7XG4gICAgLy8gYWRqdXN0IGluZGV4IG9mZnNldCBmb3IgbXVsdGlwbGUgY2hvcm9wbGV0aHNcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5zdGF0ZS5jaG9yb3BsZXRocy5yZWR1Y2UoXG4gICAgICAoYWNjLCBjaG9yb3BsZXRoKSA9PiBbLi4uYWNjLCBhY2NbYWNjLmxlbmd0aCAtIDFdICtcbiAgICAgICAgY2hvcm9wbGV0aC5yZWR1Y2UoKGNvdW50LCBwb2x5Z29uKSA9PiBjb3VudCArIHBvbHlnb24ubGVuZ3RoLCAwKV0sXG4gICAgICBbMF1cbiAgICApO1xuICAgIGNvbnN0IHtJbmRleFR5cGV9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoSW5kZXhUeXBlID09PSBVaW50MTZBcnJheSAmJiBvZmZzZXRzW29mZnNldHMubGVuZ3RoIC0gMV0gPiA2NTUzNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggY291bnQgZXhjZWVkcyBicm93c2VyXFwncyBsaW1pdCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGljZXMgPSB0aGlzLnN0YXRlLmNob3JvcGxldGhzLm1hcChcbiAgICAgIChjaG9yb3BsZXRoLCBjaG9yb3BsZXRoSW5kZXgpID0+IHRoaXMucHJvcHMuZHJhd0NvbnRvdXIgP1xuICAgICAgICAvLyAxLiBnZXQgc2VxdWVudGlhbGx5IG9yZGVyZWQgaW5kaWNlcyBvZiBlYWNoIGNob3JvcGxldGggY29udG91clxuICAgICAgICAvLyAyLiBvZmZzZXQgdGhlbSBieSB0aGUgbnVtYmVyIG9mIGluZGljZXMgaW4gcHJldmlvdXMgY2hvcm9wbGV0aHNcbiAgICAgICAgY2FsY3VsYXRlQ29udG91ckluZGljZXMoY2hvcm9wbGV0aCkubWFwKGluZGV4ID0+IGluZGV4ICsgb2Zmc2V0c1tjaG9yb3BsZXRoSW5kZXhdKSA6XG4gICAgICAgIC8vIDEuIGdldCB0cmlhbmd1bGF0ZWQgaW5kaWNlcyBmb3IgdGhlIGludGVybmFsIGFyZWFzXG4gICAgICAgIC8vIDIuIG9mZnNldCB0aGVtIGJ5IHRoZSBudW1iZXIgb2YgaW5kaWNlcyBpbiBwcmV2aW91cyBjaG9yb3BsZXRoc1xuICAgICAgICBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyhjaG9yb3BsZXRoKS5tYXAoaW5kZXggPT4gaW5kZXggKyBvZmZzZXRzW2Nob3JvcGxldGhJbmRleF0pXG4gICAgKTtcblxuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBJbmRleFR5cGUoZmxhdHRlbihpbmRpY2VzKSk7XG4gICAgYXR0cmlidXRlLnRhcmdldCA9IEdMLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VmVydGV4Q291bnQoYXR0cmlidXRlLnZhbHVlLmxlbmd0aCAvIGF0dHJpYnV0ZS5zaXplKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IGZsYXR0ZW4odGhpcy5zdGF0ZS5jaG9yb3BsZXRocyk7XG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcyk7XG4gIH1cblxuICBjYWxjdWxhdGVDb2xvcnMoYXR0cmlidXRlKSB7XG4gICAgY29uc3Qge2RhdGEsIGdldENvbG9yfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZmVhdHVyZXMgPSBnZXQoZGF0YSwgJ2ZlYXR1cmVzJyk7XG4gICAgY29uc3QgY29sb3JzID0gdGhpcy5zdGF0ZS5jaG9yb3BsZXRocy5tYXAoXG4gICAgICAoY2hvcm9wbGV0aCwgY2hvcm9wbGV0aEluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmUgPSBnZXQoZmVhdHVyZXMsIGNob3JvcGxldGguZmVhdHVyZUluZGV4KTtcbiAgICAgICAgY29uc3QgY29sb3IgPSBnZXRDb2xvcihmZWF0dXJlKSB8fCBERUZBVUxUX0NPTE9SO1xuICAgICAgICAvLyBFbnN1cmUgYWxwaGEgaXMgc2V0XG4gICAgICAgIGlmIChpc05hTihjb2xvclszXSkpIHtcbiAgICAgICAgICBjb2xvclszXSA9IERFRkFVTFRfQ09MT1JbM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNob3JvcGxldGgubWFwKHBvbHlnb24gPT4gcG9seWdvbi5tYXAodmVydGV4ID0+IGNvbG9yKSk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBVaW50OEFycmF5KGZsYXR0ZW4oY29sb3JzKSk7XG4gIH1cblxuICAvLyBPdmVycmlkZSB0aGUgZGVmYXVsdCBwaWNraW5nIGNvbG9ycyBjYWxjdWxhdGlvblxuICBjYWxjdWxhdGVQaWNraW5nQ29sb3JzKGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuc3RhdGUuY2hvcm9wbGV0aHMubWFwKFxuICAgICAgKGNob3JvcGxldGgsIGNob3JvcGxldGhJbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB7ZmVhdHVyZUluZGV4fSA9IGNob3JvcGxldGg7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5wcm9wcy5kcmF3Q29udG91ciA/IFswLCAwLCAwXSA6IFtcbiAgICAgICAgICAoZmVhdHVyZUluZGV4ICsgMSkgJSAyNTYsXG4gICAgICAgICAgTWF0aC5mbG9vcigoZmVhdHVyZUluZGV4ICsgMSkgLyAyNTYpICUgMjU2LFxuICAgICAgICAgIE1hdGguZmxvb3IoKGZlYXR1cmVJbmRleCArIDEpIC8gMjU2IC8gMjU2KSAlIDI1NlxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gY2hvcm9wbGV0aC5tYXAocG9seWdvbiA9PiBwb2x5Z29uLm1hcCh2ZXJ0ZXggPT4gY29sb3IpKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoZmxhdHRlbihjb2xvcnMpKTtcbiAgfVxufVxuXG5DaG9yb3BsZXRoTGF5ZXIubGF5ZXJOYW1lID0gJ0Nob3JvcGxldGhMYXllcic7XG5DaG9yb3BsZXRoTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG4vKlxuICogZ2V0IHZlcnRleCBpbmRpY2VzIGZvciBkcmF3aW5nIGNob3JvcGxldGggY29udG91clxuICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcixOdW1iZXJdW11bXX0gY2hvcm9wbGV0aFxuICogQHJldHVybnMge1tOdW1iZXJdfSBpbmRpY2VzXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzKGNob3JvcGxldGgpIHtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgcmV0dXJuIGNob3JvcGxldGgucmVkdWNlKChhY2MsIHBvbHlnb24pID0+IHtcbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IHBvbHlnb24ubGVuZ3RoO1xuXG4gICAgLy8gdXNlIHZlcnRleCBwYWlycyBmb3IgZ2wuTElORVMgPT4gWzAsIDEsIDEsIDIsIDIsIC4uLiwgbi0yLCBuLTIsIG4tMV1cbiAgICBjb25zdCBpbmRpY2VzID0gWy4uLmFjYywgb2Zmc2V0XTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICBpbmRpY2VzLnB1c2goaSArIG9mZnNldCwgaSArIG9mZnNldCk7XG4gICAgfVxuICAgIGluZGljZXMucHVzaChvZmZzZXQgKyBudW1WZXJ0aWNlcyAtIDEpO1xuXG4gICAgb2Zmc2V0ICs9IG51bVZlcnRpY2VzO1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9LCBbXSk7XG59XG5cbi8qXG4gKiBnZXQgdmVydGV4IGluZGljZXMgZm9yIGRyYXdpbmcgY2hvcm9wbGV0aCBtZXNoXG4gKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyLE51bWJlcl1bXVtdfSBjaG9yb3BsZXRoXG4gKiBAcmV0dXJucyB7W051bWJlcl19IGluZGljZXNcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU3VyZmFjZUluZGljZXMoY2hvcm9wbGV0aCkge1xuICBsZXQgaG9sZXMgPSBudWxsO1xuXG4gIGlmIChjaG9yb3BsZXRoLmxlbmd0aCA+IDEpIHtcbiAgICBob2xlcyA9IGNob3JvcGxldGgucmVkdWNlKFxuICAgICAgKGFjYywgcG9seWdvbikgPT4gWy4uLmFjYywgYWNjW2FjYy5sZW5ndGggLSAxXSArIHBvbHlnb24ubGVuZ3RoXSxcbiAgICAgIFswXVxuICAgICkuc2xpY2UoMSwgY2hvcm9wbGV0aC5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIGVhcmN1dChmbGF0dGVuKGNob3JvcGxldGgpLCBob2xlcywgMyk7XG59XG4iXX0=