function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
import { get } from '../../core/lib/utils';

/**
 * "Normalizes" complete or partial GeoJSON data into iterable list of features
 * Can accept GeoJSON geometry or "Feature", "FeatureCollection" in addition
 * to plain arrays and iterables.
 * Works by extracting the feature array or wrapping single objects in an array,
 * so that subsequent code can simply iterate over features.
 *
 * @param {object} geojson - geojson data
 * @param {Object|Array} data - geojson object (FeatureCollection, Feature or
 *  Geometry) or array of features
 * @return {Array|"iteratable"} - iterable list of features
 */
export function getGeojsonFeatures(geojson) {
  // If array, assume this is a list of features
  if (Array.isArray(geojson)) {
    return geojson;
  }

  var type = get(geojson, 'type');
  switch (type) {
    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
    case 'Polygon':
    case 'MultiPolygon':
    case 'GeometryCollection':
      // Wrap the geometry object in a 'Feature' object and wrap in an array
      return [{ type: 'Feature', properties: {}, geometry: geojson }];
    case 'Feature':
      // Wrap the feature in a 'Features' array
      return [geojson];
    case 'FeatureCollection':
      // Just return the 'Features' array from the collection
      return get(geojson, 'features');
    default:
      throw new Error('Unknown geojson type');
  }
}

/*
 * converts a GeoJSON "Feature" object to a list of GeoJSON polygon-style coordinates
 * @param {Object | Array} data - geojson object or array of feature
 * @returns {[Number,Number,Number][][][]} array of choropleths
 */
export function featureToPolygons(feature) {
  var geometry = get(feature, 'geometry');
  // If no geometry field, assume that "feature" is the polygon list
  if (geometry === undefined) {
    return feature;
  }

  var type = get(geometry, 'type');
  var coordinates = get(geometry, 'coordinates');

  var polygons = void 0;
  switch (type) {
    case 'MultiPolygon':
      polygons = coordinates;
      break;
    case 'Polygon':
      polygons = [coordinates];
      break;
    case 'LineString':
      // TODO - should lines really be handled in this switch?
      polygons = [[coordinates]];
      break;
    case 'MultiLineString':
      // TODO - should lines really be handled in this switch?
      polygons = coordinates.map(function (coords) {
        return [coords];
      });
      break;
    default:
      polygons = [];
  }
  return polygons;
}

// DEPRECATED - USED BY OLD CHOROPLETH LAYERS

/*
 * converts list of features from a GeoJSON object to a list of GeoJSON
 * polygon-style coordinates
 * @param {Object} data - geojson object
 * @returns {[Number,Number,Number][][][]} array of choropleths
 */
export function extractPolygons(data) {
  var normalizedGeojson = normalizeGeojson(data);
  var features = get(normalizedGeojson, 'features');

  var result = [];
  features.forEach(function (feature, featureIndex) {
    var choropleths = featureToPolygons(feature);

    /* eslint-disable max-nested-callbacks */
    choropleths = choropleths.map(function (choropleth) {
      return choropleth.map(function (polygon) {
        return polygon.map(function (coord) {
          return [get(coord, 0), get(coord, 1), get(coord, 2) || 0];
        });
      });
    });
    /* eslint-enable max-nested-callbacks */

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = choropleths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var choropleth = _step.value;

        choropleth.featureIndex = featureIndex;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    result.push.apply(result, _toConsumableArray(choropleths));
  });
  return result;
}

/**
 * "Normalizes" a GeoJSON geometry or "Feature" into a "FeatureCollection",
 * by wrapping it in an extra object/array.
 *
 * @param {object} geojson - geojson data
 * @return {object} - normalized geojson data
 */
export function normalizeGeojson(geojson) {
  var type = get(geojson, 'type');
  switch (type) {
    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
    case 'Polygon':
    case 'MultiPolygon':
    case 'GeometryCollection':
      // Wrap the geometry object in a "Feature" and add the feature to a "FeatureCollection"
      return {
        type: 'FeatureCollection',
        features: [{ type: 'Feature', properties: {}, geometry: geojson }]
      };
    case 'Feature':
      // Add the feature to a "FeatureCollection"
      return {
        type: 'FeatureCollection',
        features: [geojson]
      };
    case 'FeatureCollection':
      // Just return the feature collection
      return geojson;
    default:
      throw new Error('Unknown geojson type');
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kZXByZWNhdGVkLWxheWVycy9jaG9yb3BsZXRoLWxheWVyL2dlb2pzb24uanMiXSwibmFtZXMiOlsiZ2V0IiwiZ2V0R2VvanNvbkZlYXR1cmVzIiwiZ2VvanNvbiIsIkFycmF5IiwiaXNBcnJheSIsInR5cGUiLCJwcm9wZXJ0aWVzIiwiZ2VvbWV0cnkiLCJFcnJvciIsImZlYXR1cmVUb1BvbHlnb25zIiwiZmVhdHVyZSIsInVuZGVmaW5lZCIsImNvb3JkaW5hdGVzIiwicG9seWdvbnMiLCJtYXAiLCJjb29yZHMiLCJleHRyYWN0UG9seWdvbnMiLCJkYXRhIiwibm9ybWFsaXplZEdlb2pzb24iLCJub3JtYWxpemVHZW9qc29uIiwiZmVhdHVyZXMiLCJyZXN1bHQiLCJmb3JFYWNoIiwiZmVhdHVyZUluZGV4IiwiY2hvcm9wbGV0aHMiLCJjaG9yb3BsZXRoIiwicG9seWdvbiIsImNvb3JkIiwicHVzaCJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVFBLEdBQVIsUUFBa0Isc0JBQWxCOztBQUVBOzs7Ozs7Ozs7Ozs7QUFZQSxPQUFPLFNBQVNDLGtCQUFULENBQTRCQyxPQUE1QixFQUFxQztBQUMxQztBQUNBLE1BQUlDLE1BQU1DLE9BQU4sQ0FBY0YsT0FBZCxDQUFKLEVBQTRCO0FBQzFCLFdBQU9BLE9BQVA7QUFDRDs7QUFFRCxNQUFNRyxPQUFPTCxJQUFJRSxPQUFKLEVBQWEsTUFBYixDQUFiO0FBQ0EsVUFBUUcsSUFBUjtBQUNBLFNBQUssT0FBTDtBQUNBLFNBQUssWUFBTDtBQUNBLFNBQUssWUFBTDtBQUNBLFNBQUssaUJBQUw7QUFDQSxTQUFLLFNBQUw7QUFDQSxTQUFLLGNBQUw7QUFDQSxTQUFLLG9CQUFMO0FBQ0U7QUFDQSxhQUFPLENBQ0wsRUFBQ0EsTUFBTSxT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ZSxrQkFBVSxDQUNSLEVBQUNmLE1BQU0sU0FBUCxFQUFrQkMsWUFBWSxFQUE5QixFQUFrQ0MsVUFBVUwsT0FBNUMsRUFEUTtBQUZMLE9BQVA7QUFNRixTQUFLLFNBQUw7QUFDRTtBQUNBLGFBQU87QUFDTEcsY0FBTSxtQkFERDtBQUVMZSxrQkFBVSxDQUFDbEIsT0FBRDtBQUZMLE9BQVA7QUFJRixTQUFLLG1CQUFMO0FBQ0U7QUFDQSxhQUFPQSxPQUFQO0FBQ0Y7QUFDRSxZQUFNLElBQUlNLEtBQUosQ0FBVSxzQkFBVixDQUFOO0FBekJGO0FBMkJEIiwiZmlsZSI6Imdlb2pzb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cbmltcG9ydCB7Z2V0fSBmcm9tICcuLi8uLi9jb3JlL2xpYi91dGlscyc7XG5cbi8qKlxuICogXCJOb3JtYWxpemVzXCIgY29tcGxldGUgb3IgcGFydGlhbCBHZW9KU09OIGRhdGEgaW50byBpdGVyYWJsZSBsaXN0IG9mIGZlYXR1cmVzXG4gKiBDYW4gYWNjZXB0IEdlb0pTT04gZ2VvbWV0cnkgb3IgXCJGZWF0dXJlXCIsIFwiRmVhdHVyZUNvbGxlY3Rpb25cIiBpbiBhZGRpdGlvblxuICogdG8gcGxhaW4gYXJyYXlzIGFuZCBpdGVyYWJsZXMuXG4gKiBXb3JrcyBieSBleHRyYWN0aW5nIHRoZSBmZWF0dXJlIGFycmF5IG9yIHdyYXBwaW5nIHNpbmdsZSBvYmplY3RzIGluIGFuIGFycmF5LFxuICogc28gdGhhdCBzdWJzZXF1ZW50IGNvZGUgY2FuIHNpbXBseSBpdGVyYXRlIG92ZXIgZmVhdHVyZXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdlb2pzb24gLSBnZW9qc29uIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBkYXRhIC0gZ2VvanNvbiBvYmplY3QgKEZlYXR1cmVDb2xsZWN0aW9uLCBGZWF0dXJlIG9yXG4gKiAgR2VvbWV0cnkpIG9yIGFycmF5IG9mIGZlYXR1cmVzXG4gKiBAcmV0dXJuIHtBcnJheXxcIml0ZXJhdGFibGVcIn0gLSBpdGVyYWJsZSBsaXN0IG9mIGZlYXR1cmVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHZW9qc29uRmVhdHVyZXMoZ2VvanNvbikge1xuICAvLyBJZiBhcnJheSwgYXNzdW1lIHRoaXMgaXMgYSBsaXN0IG9mIGZlYXR1cmVzXG4gIGlmIChBcnJheS5pc0FycmF5KGdlb2pzb24pKSB7XG4gICAgcmV0dXJuIGdlb2pzb247XG4gIH1cblxuICBjb25zdCB0eXBlID0gZ2V0KGdlb2pzb24sICd0eXBlJyk7XG4gIHN3aXRjaCAodHlwZSkge1xuICBjYXNlICdQb2ludCc6XG4gIGNhc2UgJ011bHRpUG9pbnQnOlxuICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgY2FzZSAnUG9seWdvbic6XG4gIGNhc2UgJ011bHRpUG9seWdvbic6XG4gIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgLy8gV3JhcCB0aGUgZ2VvbWV0cnkgb2JqZWN0IGluIGEgJ0ZlYXR1cmUnIG9iamVjdCBhbmQgd3JhcCBpbiBhbiBhcnJheVxuICAgIHJldHVybiBbXG4gICAgICB7dHlwZTogJ0ZlYXR1cmUnLCBwcm9wZXJ0aWVzOiB7fSwgZ2VvbWV0cnk6IGdlb2pzb259XG4gICAgXTtcbiAgY2FzZSAnRmVhdHVyZSc6XG4gICAgLy8gV3JhcCB0aGUgZmVhdHVyZSBpbiBhICdGZWF0dXJlcycgYXJyYXlcbiAgICByZXR1cm4gW2dlb2pzb25dO1xuICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XG4gICAgLy8gSnVzdCByZXR1cm4gdGhlICdGZWF0dXJlcycgYXJyYXkgZnJvbSB0aGUgY29sbGVjdGlvblxuICAgIHJldHVybiBnZXQoZ2VvanNvbiwgJ2ZlYXR1cmVzJyk7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGdlb2pzb24gdHlwZScpO1xuICB9XG59XG5cbi8qXG4gKiBjb252ZXJ0cyBhIEdlb0pTT04gXCJGZWF0dXJlXCIgb2JqZWN0IHRvIGEgbGlzdCBvZiBHZW9KU09OIHBvbHlnb24tc3R5bGUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0IHwgQXJyYXl9IGRhdGEgLSBnZW9qc29uIG9iamVjdCBvciBhcnJheSBvZiBmZWF0dXJlXG4gKiBAcmV0dXJucyB7W051bWJlcixOdW1iZXIsTnVtYmVyXVtdW11bXX0gYXJyYXkgb2YgY2hvcm9wbGV0aHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZlYXR1cmVUb1BvbHlnb25zKGZlYXR1cmUpIHtcbiAgY29uc3QgZ2VvbWV0cnkgPSBnZXQoZmVhdHVyZSwgJ2dlb21ldHJ5Jyk7XG4gIC8vIElmIG5vIGdlb21ldHJ5IGZpZWxkLCBhc3N1bWUgdGhhdCBcImZlYXR1cmVcIiBpcyB0aGUgcG9seWdvbiBsaXN0XG4gIGlmIChnZW9tZXRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZlYXR1cmU7XG4gIH1cblxuICBjb25zdCB0eXBlID0gZ2V0KGdlb21ldHJ5LCAndHlwZScpO1xuICBjb25zdCBjb29yZGluYXRlcyA9IGdldChnZW9tZXRyeSwgJ2Nvb3JkaW5hdGVzJyk7XG5cbiAgbGV0IHBvbHlnb25zO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICBwb2x5Z29ucyA9IGNvb3JkaW5hdGVzO1xuICAgIGJyZWFrO1xuICBjYXNlICdQb2x5Z29uJzpcbiAgICBwb2x5Z29ucyA9IFtjb29yZGluYXRlc107XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgIC8vIFRPRE8gLSBzaG91bGQgbGluZXMgcmVhbGx5IGJlIGhhbmRsZWQgaW4gdGhpcyBzd2l0Y2g/XG4gICAgcG9seWdvbnMgPSBbW2Nvb3JkaW5hdGVzXV07XG4gICAgYnJlYWs7XG4gIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgLy8gVE9ETyAtIHNob3VsZCBsaW5lcyByZWFsbHkgYmUgaGFuZGxlZCBpbiB0aGlzIHN3aXRjaD9cbiAgICBwb2x5Z29ucyA9IGNvb3JkaW5hdGVzLm1hcChjb29yZHMgPT4gW2Nvb3Jkc10pO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHBvbHlnb25zID0gW107XG4gIH1cbiAgcmV0dXJuIHBvbHlnb25zO1xufVxuXG4vLyBERVBSRUNBVEVEIC0gVVNFRCBCWSBPTEQgQ0hPUk9QTEVUSCBMQVlFUlNcblxuLypcbiAqIGNvbnZlcnRzIGxpc3Qgb2YgZmVhdHVyZXMgZnJvbSBhIEdlb0pTT04gb2JqZWN0IHRvIGEgbGlzdCBvZiBHZW9KU09OXG4gKiBwb2x5Z29uLXN0eWxlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIGdlb2pzb24gb2JqZWN0XG4gKiBAcmV0dXJucyB7W051bWJlcixOdW1iZXIsTnVtYmVyXVtdW11bXX0gYXJyYXkgb2YgY2hvcm9wbGV0aHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQb2x5Z29ucyhkYXRhKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRHZW9qc29uID0gbm9ybWFsaXplR2VvanNvbihkYXRhKTtcbiAgY29uc3QgZmVhdHVyZXMgPSBnZXQobm9ybWFsaXplZEdlb2pzb24sICdmZWF0dXJlcycpO1xuXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmZWF0dXJlcy5mb3JFYWNoKChmZWF0dXJlLCBmZWF0dXJlSW5kZXgpID0+IHtcbiAgICBsZXQgY2hvcm9wbGV0aHMgPSBmZWF0dXJlVG9Qb2x5Z29ucyhmZWF0dXJlKTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1uZXN0ZWQtY2FsbGJhY2tzICovXG4gICAgY2hvcm9wbGV0aHMgPSBjaG9yb3BsZXRocy5tYXAoXG4gICAgICBjaG9yb3BsZXRoID0+IGNob3JvcGxldGgubWFwKFxuICAgICAgICBwb2x5Z29uID0+IHBvbHlnb24ubWFwKFxuICAgICAgICAgIGNvb3JkID0+IFtcbiAgICAgICAgICAgIGdldChjb29yZCwgMCksXG4gICAgICAgICAgICBnZXQoY29vcmQsIDEpLFxuICAgICAgICAgICAgZ2V0KGNvb3JkLCAyKSB8fCAwXG4gICAgICAgICAgXVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1uZXN0ZWQtY2FsbGJhY2tzICovXG5cbiAgICBmb3IgKGNvbnN0IGNob3JvcGxldGggb2YgY2hvcm9wbGV0aHMpIHtcbiAgICAgIGNob3JvcGxldGguZmVhdHVyZUluZGV4ID0gZmVhdHVyZUluZGV4O1xuICAgIH1cbiAgICByZXN1bHQucHVzaCguLi5jaG9yb3BsZXRocyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFwiTm9ybWFsaXplc1wiIGEgR2VvSlNPTiBnZW9tZXRyeSBvciBcIkZlYXR1cmVcIiBpbnRvIGEgXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogYnkgd3JhcHBpbmcgaXQgaW4gYW4gZXh0cmEgb2JqZWN0L2FycmF5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBnZW9qc29uIC0gZ2VvanNvbiBkYXRhXG4gKiBAcmV0dXJuIHtvYmplY3R9IC0gbm9ybWFsaXplZCBnZW9qc29uIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUdlb2pzb24oZ2VvanNvbikge1xuICBjb25zdCB0eXBlID0gZ2V0KGdlb2pzb24sICd0eXBlJyk7XG4gIHN3aXRjaCAodHlwZSkge1xuICBjYXNlICdQb2ludCc6XG4gIGNhc2UgJ011bHRpUG9pbnQnOlxuICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgY2FzZSAnUG9seWdvbic6XG4gIGNhc2UgJ011bHRpUG9seWdvbic6XG4gIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgLy8gV3JhcCB0aGUgZ2VvbWV0cnkgb2JqZWN0IGluIGEgXCJGZWF0dXJlXCIgYW5kIGFkZCB0aGUgZmVhdHVyZSB0byBhIFwiRmVhdHVyZUNvbGxlY3Rpb25cIlxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAge3R5cGU6ICdGZWF0dXJlJywgcHJvcGVydGllczoge30sIGdlb21ldHJ5OiBnZW9qc29ufVxuICAgICAgXVxuICAgIH07XG4gIGNhc2UgJ0ZlYXR1cmUnOlxuICAgIC8vIEFkZCB0aGUgZmVhdHVyZSB0byBhIFwiRmVhdHVyZUNvbGxlY3Rpb25cIlxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgZmVhdHVyZXM6IFtnZW9qc29uXVxuICAgIH07XG4gIGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcbiAgICAvLyBKdXN0IHJldHVybiB0aGUgZmVhdHVyZSBjb2xsZWN0aW9uXG4gICAgcmV0dXJuIGdlb2pzb247XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGdlb2pzb24gdHlwZScpO1xuICB9XG59XG4iXX0=