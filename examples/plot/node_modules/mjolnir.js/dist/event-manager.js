'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _hammer = require('./utils/hammer');

var _wheelInput = require('./inputs/wheel-input');

var _wheelInput2 = _interopRequireDefault(_wheelInput);

var _moveInput = require('./inputs/move-input');

var _moveInput2 = _interopRequireDefault(_moveInput);

var _keyInput = require('./inputs/key-input');

var _keyInput2 = _interopRequireDefault(_keyInput);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Unified API for subscribing to events about both
// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
// and gestural input (e.g. 'click', 'tap', 'panstart').
// Delegates gesture related event registration and handling to Hammer.js.
var EventManager = function () {
  function EventManager(element) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, EventManager);

    this.element = element;
    this._onBasicInput = this._onBasicInput.bind(this);

    var ManagerClass = options.Manager || _hammer.Manager;

    this.manager = new ManagerClass(element, { recognizers: options.recognizers || _constants.RECOGNIZERS }).on('hammer.input', this._onBasicInput);

    this.eventHandlers = [];

    // Handle events not handled by Hammer.js:
    // - mouse wheel
    // - pointer/touch/mouse move
    this._onOtherEvent = this._onOtherEvent.bind(this);
    this.wheelInput = new _wheelInput2.default(element, this._onOtherEvent, { enable: false });
    this.moveInput = new _moveInput2.default(element, this._onOtherEvent, { enable: false });
    this.keyInput = new _keyInput2.default(element, this._onOtherEvent, { enable: false });

    // Register all passed events.
    var events = options.events;

    if (events) {
      this.on(events);
    }
  }

  // Tear down internal event management implementations.


  (0, _createClass3.default)(EventManager, [{
    key: 'destroy',
    value: function destroy() {
      this.wheelInput.destroy();
      this.moveInput.destroy();
      this.keyInput.destroy();
      this.manager.destroy();
    }

    // Register an event handler function to be called on `event`.

  }, {
    key: 'on',
    value: function on(event, handler, srcElement) {
      if (typeof event === 'string') {
        this._addEventHandler(event, handler, srcElement);
      } else {
        srcElement = handler;
        // If `event` is a map, call `on()` for each entry.
        for (var eventName in event) {
          this._addEventHandler(eventName, event[eventName], srcElement);
        }
      }
    }

    /**
     * Deregister a previously-registered event handler.
     * @param {string|Object} event   An event name (String) or map of event names to handlers
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: 'off',
    value: function off(event, handler) {
      if (typeof event === 'string') {
        this._removeEventHandler(event, handler);
      } else {
        // If `event` is a map, call `off()` for each entry.
        for (var eventName in event) {
          this._removeEventHandler(eventName, event[eventName]);
        }
      }
    }

    /*
     * Enable/disable recognizer for the given event
     */

  }, {
    key: '_toggleRecognizer',
    value: function _toggleRecognizer(name, enabled) {
      var recognizer = this.manager.get(name);
      if (recognizer) {
        recognizer.set({ enable: enabled });
      }
      this.wheelInput.enableEventType(name, enabled);
      this.moveInput.enableEventType(name, enabled);
      this.keyInput.enableEventType(name, enabled);
    }

    /**
     * Process the event registration for a single event + handler.
     */

  }, {
    key: '_addEventHandler',
    value: function _addEventHandler(event, handler) {
      var _this = this;

      var srcElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      var wrappedHandler = this._wrapEventHandler(event, handler, srcElement);
      // Alias to a recognized gesture as necessary.
      var eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
      // Get recognizer for this event
      var recognizerName = _constants.EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
      // Enable recognizer for this event.
      this._toggleRecognizer(recognizerName, true);

      // Find ancestors
      var ancestorEventHandlers = this.eventHandlers.filter(function (entry) {
        return entry.eventAlias === eventAlias && entry.srcElement !== srcElement && (!entry.srcElement || entry.srcElement.contains(srcElement));
      });

      // Save wrapped handler
      this.eventHandlers.push({ event: event, eventAlias: eventAlias, recognizerName: recognizerName, srcElement: srcElement,
        handler: handler, wrappedHandler: wrappedHandler });

      // Sort handlers by DOM hierarchy
      // So the event will always fire first on child nodes
      ancestorEventHandlers.forEach(function (entry) {
        return _this.manager.off(eventAlias, entry.wrappedHandler);
      });
      this.manager.on(eventAlias, wrappedHandler);
      ancestorEventHandlers.forEach(function (entry) {
        return _this.manager.on(eventAlias, entry.wrappedHandler);
      });
    }

    /**
     * Process the event deregistration for a single event + handler.
     */

  }, {
    key: '_removeEventHandler',
    value: function _removeEventHandler(event, handler) {
      var eventHandlerRemoved = false;

      // Find saved handler if any.
      for (var i = this.eventHandlers.length; i--;) {
        var entry = this.eventHandlers[i];
        if (entry.event === event && entry.handler === handler) {
          // Deregister event handler.
          this.manager.off(entry.eventAlias, entry.wrappedHandler);
          // Delete saved handler
          this.eventHandlers.splice(i, 1);
          eventHandlerRemoved = true;
        }
      }

      if (eventHandlerRemoved) {
        // Alias to a recognized gesture as necessary.
        var eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
        // Get recognizer for this event
        var recognizerName = _constants.EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
        // Disable recognizer if no more handlers are attached to its events
        var isRecognizerUsed = this.eventHandlers.find(function (entry) {
          return entry.recognizerName === recognizerName;
        });
        if (!isRecognizerUsed) {
          this._toggleRecognizer(recognizerName, false);
        }
      }
    }

    /**
     * Returns an event handler that aliases events and add props before passing
     * to the real handler.
     */

  }, {
    key: '_wrapEventHandler',
    value: function _wrapEventHandler(type, handler, srcElement) {
      var _this2 = this;

      return function (event) {
        var mjolnirEvent = event.mjolnirEvent;


        if (!mjolnirEvent) {
          mjolnirEvent = _this2._normalizeEvent(event);
          event.mjolnirEvent = mjolnirEvent;
        }

        var isStopped = mjolnirEvent.handled && mjolnirEvent.handled !== srcElement;

        if (!isStopped) {
          var isFromDecendant = !srcElement || srcElement.contains(event.srcEvent.target);
          if (isFromDecendant) {
            handler((0, _assign2.default)({}, mjolnirEvent, {
              type: type,
              stopPropagation: function stopPropagation() {
                if (!mjolnirEvent.handled) {
                  mjolnirEvent.handled = srcElement;
                }
              }
            }));
          }
        }
      };
    }

    /**
     * Normalizes hammerjs and custom events to have predictable fields.
     */

  }, {
    key: '_normalizeEvent',
    value: function _normalizeEvent(event) {
      var element = this.element;
      var srcEvent = event.srcEvent;


      var center = event.center || {
        x: srcEvent.clientX,
        y: srcEvent.clientY
      };

      // Calculate center relative to the root element
      var rect = element.getBoundingClientRect();

      // Fix scale for map affected by a CSS transform.
      // See https://stackoverflow.com/a/26893663/3528533
      var scaleX = rect.width / element.offsetWidth;
      var scaleY = rect.height / element.offsetHeight;

      // Calculate center relative to the root element
      var offsetCenter = {
        x: (center.x - rect.left - element.clientLeft) / scaleX,
        y: (center.y - rect.top - element.clientTop) / scaleY
      };

      return (0, _assign2.default)({}, event, {
        handled: false,
        center: center,
        offsetCenter: offsetCenter,
        rootElement: element
      });
    }

    /**
     * Handle basic events using the 'hammer.input' Hammer.js API:
     * Before running Recognizers, Hammer emits a 'hammer.input' event
     * with the basic event info. This function emits all basic events
     * aliased to the "class" of event received.
     * See constants.BASIC_EVENT_CLASSES basic event class definitions.
     */

  }, {
    key: '_onBasicInput',
    value: function _onBasicInput(event) {
      var srcEvent = event.srcEvent;

      var alias = _constants.BASIC_EVENT_ALIASES[srcEvent.type];
      if (alias) {
        // fire all events aliased to srcEvent.type
        var emitEvent = (0, _assign2.default)({}, event, { isDown: true });
        this.manager.emit(alias, emitEvent);
      }
    }

    /**
     * Handle events not supported by Hammer.js,
     * and pipe back out through same (Hammer) channel used by other events.
     */

  }, {
    key: '_onOtherEvent',
    value: function _onOtherEvent(event) {
      this.manager.emit(event.type, event);
    }
  }]);
  return EventManager;
}(); // Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

exports.default = EventManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9ldmVudC1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbIkV2ZW50TWFuYWdlciIsImVsZW1lbnQiLCJvcHRpb25zIiwiX29uQmFzaWNJbnB1dCIsImJpbmQiLCJNYW5hZ2VyQ2xhc3MiLCJNYW5hZ2VyIiwibWFuYWdlciIsInJlY29nbml6ZXJzIiwib24iLCJldmVudEhhbmRsZXJzIiwiX29uT3RoZXJFdmVudCIsIndoZWVsSW5wdXQiLCJlbmFibGUiLCJtb3ZlSW5wdXQiLCJrZXlJbnB1dCIsImV2ZW50cyIsImRlc3Ryb3kiLCJldmVudCIsImhhbmRsZXIiLCJzcmNFbGVtZW50IiwiX2FkZEV2ZW50SGFuZGxlciIsImV2ZW50TmFtZSIsIl9yZW1vdmVFdmVudEhhbmRsZXIiLCJuYW1lIiwiZW5hYmxlZCIsInJlY29nbml6ZXIiLCJnZXQiLCJzZXQiLCJlbmFibGVFdmVudFR5cGUiLCJ3cmFwcGVkSGFuZGxlciIsIl93cmFwRXZlbnRIYW5kbGVyIiwiZXZlbnRBbGlhcyIsInJlY29nbml6ZXJOYW1lIiwiX3RvZ2dsZVJlY29nbml6ZXIiLCJhbmNlc3RvckV2ZW50SGFuZGxlcnMiLCJmaWx0ZXIiLCJlbnRyeSIsImNvbnRhaW5zIiwicHVzaCIsImZvckVhY2giLCJvZmYiLCJldmVudEhhbmRsZXJSZW1vdmVkIiwiaSIsImxlbmd0aCIsInNwbGljZSIsImlzUmVjb2duaXplclVzZWQiLCJmaW5kIiwidHlwZSIsIm1qb2xuaXJFdmVudCIsIl9ub3JtYWxpemVFdmVudCIsImlzU3RvcHBlZCIsImhhbmRsZWQiLCJpc0Zyb21EZWNlbmRhbnQiLCJzcmNFdmVudCIsInRhcmdldCIsInN0b3BQcm9wYWdhdGlvbiIsImNlbnRlciIsIngiLCJjbGllbnRYIiwieSIsImNsaWVudFkiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2NhbGVYIiwid2lkdGgiLCJvZmZzZXRXaWR0aCIsInNjYWxlWSIsImhlaWdodCIsIm9mZnNldEhlaWdodCIsIm9mZnNldENlbnRlciIsImxlZnQiLCJjbGllbnRMZWZ0IiwidG9wIiwiY2xpZW50VG9wIiwicm9vdEVsZW1lbnQiLCJhbGlhcyIsImVtaXRFdmVudCIsImlzRG93biIsImVtaXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0lBQ3FCQSxZO0FBQ25CLHdCQUFZQyxPQUFaLEVBQW1DO0FBQUEsUUFBZEMsT0FBYyx1RUFBSixFQUFJO0FBQUE7O0FBQ2pDLFNBQUtELE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtFLGFBQUwsR0FBcUIsS0FBS0EsYUFBTCxDQUFtQkMsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FBckI7O0FBRUEsUUFBTUMsZUFBZUgsUUFBUUksT0FBUixtQkFBckI7O0FBRUEsU0FBS0MsT0FBTCxHQUFlLElBQUlGLFlBQUosQ0FBaUJKLE9BQWpCLEVBQTBCLEVBQUNPLGFBQWFOLFFBQVFNLFdBQVIsMEJBQWQsRUFBMUIsRUFDWkMsRUFEWSxDQUNULGNBRFMsRUFDTyxLQUFLTixhQURaLENBQWY7O0FBR0EsU0FBS08sYUFBTCxHQUFxQixFQUFyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFLQyxhQUFMLEdBQXFCLEtBQUtBLGFBQUwsQ0FBbUJQLElBQW5CLENBQXdCLElBQXhCLENBQXJCO0FBQ0EsU0FBS1EsVUFBTCxHQUFrQix5QkFBZVgsT0FBZixFQUF3QixLQUFLVSxhQUE3QixFQUE0QyxFQUFDRSxRQUFRLEtBQVQsRUFBNUMsQ0FBbEI7QUFDQSxTQUFLQyxTQUFMLEdBQWlCLHdCQUFjYixPQUFkLEVBQXVCLEtBQUtVLGFBQTVCLEVBQTJDLEVBQUNFLFFBQVEsS0FBVCxFQUEzQyxDQUFqQjtBQUNBLFNBQUtFLFFBQUwsR0FBZ0IsdUJBQWFkLE9BQWIsRUFBc0IsS0FBS1UsYUFBM0IsRUFBMEMsRUFBQ0UsUUFBUSxLQUFULEVBQTFDLENBQWhCOztBQUVBO0FBbkJpQyxRQW9CMUJHLE1B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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a0JBbUJxQmxCLFkiLCJmaWxlIjoiZXZlbnQtbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TWFuYWdlcn0gZnJvbSAnLi91dGlscy9oYW1tZXInO1xuXG5pbXBvcnQgV2hlZWxJbnB1dCBmcm9tICcuL2lucHV0cy93aGVlbC1pbnB1dCc7XG5pbXBvcnQgTW92ZUlucHV0IGZyb20gJy4vaW5wdXRzL21vdmUtaW5wdXQnO1xuaW1wb3J0IEtleUlucHV0IGZyb20gJy4vaW5wdXRzL2tleS1pbnB1dCc7XG5cbmltcG9ydCB7XG4gIEJBU0lDX0VWRU5UX0FMSUFTRVMsXG4gIEVWRU5UX1JFQ09HTklaRVJfTUFQLFxuICBHRVNUVVJFX0VWRU5UX0FMSUFTRVMsXG4gIFJFQ09HTklaRVJTXG59IGZyb20gJy4vY29uc3RhbnRzJztcblxuLy8gVW5pZmllZCBBUEkgZm9yIHN1YnNjcmliaW5nIHRvIGV2ZW50cyBhYm91dCBib3RoXG4vLyBiYXNpYyBpbnB1dCBldmVudHMgKGUuZy4gJ21vdXNlbW92ZScsICd0b3VjaHN0YXJ0JywgJ3doZWVsJylcbi8vIGFuZCBnZXN0dXJhbCBpbnB1dCAoZS5nLiAnY2xpY2snLCAndGFwJywgJ3BhbnN0YXJ0JykuXG4vLyBEZWxlZ2F0ZXMgZ2VzdHVyZSByZWxhdGVkIGV2ZW50IHJlZ2lzdHJhdGlvbiBhbmQgaGFuZGxpbmcgdG8gSGFtbWVyLmpzLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9vbkJhc2ljSW5wdXQgPSB0aGlzLl9vbkJhc2ljSW5wdXQuYmluZCh0aGlzKTtcblxuICAgIGNvbnN0IE1hbmFnZXJDbGFzcyA9IG9wdGlvbnMuTWFuYWdlciB8fCBNYW5hZ2VyO1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbmV3IE1hbmFnZXJDbGFzcyhlbGVtZW50LCB7cmVjb2duaXplcnM6IG9wdGlvbnMucmVjb2duaXplcnMgfHwgUkVDT0dOSVpFUlN9KVxuICAgICAgLm9uKCdoYW1tZXIuaW5wdXQnLCB0aGlzLl9vbkJhc2ljSW5wdXQpO1xuXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG5cbiAgICAvLyBIYW5kbGUgZXZlbnRzIG5vdCBoYW5kbGVkIGJ5IEhhbW1lci5qczpcbiAgICAvLyAtIG1vdXNlIHdoZWVsXG4gICAgLy8gLSBwb2ludGVyL3RvdWNoL21vdXNlIG1vdmVcbiAgICB0aGlzLl9vbk90aGVyRXZlbnQgPSB0aGlzLl9vbk90aGVyRXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLndoZWVsSW5wdXQgPSBuZXcgV2hlZWxJbnB1dChlbGVtZW50LCB0aGlzLl9vbk90aGVyRXZlbnQsIHtlbmFibGU6IGZhbHNlfSk7XG4gICAgdGhpcy5tb3ZlSW5wdXQgPSBuZXcgTW92ZUlucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge2VuYWJsZTogZmFsc2V9KTtcbiAgICB0aGlzLmtleUlucHV0ID0gbmV3IEtleUlucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge2VuYWJsZTogZmFsc2V9KTtcblxuICAgIC8vIFJlZ2lzdGVyIGFsbCBwYXNzZWQgZXZlbnRzLlxuICAgIGNvbnN0IHtldmVudHN9ID0gb3B0aW9ucztcbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICB0aGlzLm9uKGV2ZW50cyk7XG4gICAgfVxuICB9XG5cbiAgLy8gVGVhciBkb3duIGludGVybmFsIGV2ZW50IG1hbmFnZW1lbnQgaW1wbGVtZW50YXRpb25zLlxuICBkZXN0cm95KCkge1xuICAgIHRoaXMud2hlZWxJbnB1dC5kZXN0cm95KCk7XG4gICAgdGhpcy5tb3ZlSW5wdXQuZGVzdHJveSgpO1xuICAgIHRoaXMua2V5SW5wdXQuZGVzdHJveSgpO1xuICAgIHRoaXMubWFuYWdlci5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBSZWdpc3RlciBhbiBldmVudCBoYW5kbGVyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBgZXZlbnRgLlxuICBvbihldmVudCwgaGFuZGxlciwgc3JjRWxlbWVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIsIHNyY0VsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcmNFbGVtZW50ID0gaGFuZGxlcjtcbiAgICAgIC8vIElmIGBldmVudGAgaXMgYSBtYXAsIGNhbGwgYG9uKClgIGZvciBlYWNoIGVudHJ5LlxuICAgICAgZm9yIChjb25zdCBldmVudE5hbWUgaW4gZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSwgZXZlbnRbZXZlbnROYW1lXSwgc3JjRWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBwcmV2aW91c2x5LXJlZ2lzdGVyZWQgZXZlbnQgaGFuZGxlci5cbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBldmVudCAgIEFuIGV2ZW50IG5hbWUgKFN0cmluZykgb3IgbWFwIG9mIGV2ZW50IG5hbWVzIHRvIGhhbmRsZXJzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXSAgICBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGBldmVudGAuXG4gICAqL1xuICBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYGV2ZW50YCBpcyBhIG1hcCwgY2FsbCBgb2ZmKClgIGZvciBlYWNoIGVudHJ5LlxuICAgICAgZm9yIChjb25zdCBldmVudE5hbWUgaW4gZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSwgZXZlbnRbZXZlbnROYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogRW5hYmxlL2Rpc2FibGUgcmVjb2duaXplciBmb3IgdGhlIGdpdmVuIGV2ZW50XG4gICAqL1xuICBfdG9nZ2xlUmVjb2duaXplcihuYW1lLCBlbmFibGVkKSB7XG4gICAgY29uc3QgcmVjb2duaXplciA9IHRoaXMubWFuYWdlci5nZXQobmFtZSk7XG4gICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgIHJlY29nbml6ZXIuc2V0KHtlbmFibGU6IGVuYWJsZWR9KTtcbiAgICB9XG4gICAgdGhpcy53aGVlbElucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgICB0aGlzLm1vdmVJbnB1dC5lbmFibGVFdmVudFR5cGUobmFtZSwgZW5hYmxlZCk7XG4gICAgdGhpcy5rZXlJbnB1dC5lbmFibGVFdmVudFR5cGUobmFtZSwgZW5hYmxlZCk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgZXZlbnQgcmVnaXN0cmF0aW9uIGZvciBhIHNpbmdsZSBldmVudCArIGhhbmRsZXIuXG4gICAqL1xuICBfYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBzcmNFbGVtZW50ID0gbnVsbCkge1xuICAgIGNvbnN0IHdyYXBwZWRIYW5kbGVyID0gdGhpcy5fd3JhcEV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlciwgc3JjRWxlbWVudCk7XG4gICAgLy8gQWxpYXMgdG8gYSByZWNvZ25pemVkIGdlc3R1cmUgYXMgbmVjZXNzYXJ5LlxuICAgIGNvbnN0IGV2ZW50QWxpYXMgPSBHRVNUVVJFX0VWRU5UX0FMSUFTRVNbZXZlbnRdIHx8IGV2ZW50O1xuICAgIC8vIEdldCByZWNvZ25pemVyIGZvciB0aGlzIGV2ZW50XG4gICAgY29uc3QgcmVjb2duaXplck5hbWUgPSBFVkVOVF9SRUNPR05JWkVSX01BUFtldmVudEFsaWFzXSB8fCBldmVudEFsaWFzO1xuICAgIC8vIEVuYWJsZSByZWNvZ25pemVyIGZvciB0aGlzIGV2ZW50LlxuICAgIHRoaXMuX3RvZ2dsZVJlY29nbml6ZXIocmVjb2duaXplck5hbWUsIHRydWUpO1xuXG4gICAgLy8gRmluZCBhbmNlc3RvcnNcbiAgICBjb25zdCBhbmNlc3RvckV2ZW50SGFuZGxlcnMgPSB0aGlzLmV2ZW50SGFuZGxlcnMuZmlsdGVyKGVudHJ5ID0+IHtcbiAgICAgIHJldHVybiBlbnRyeS5ldmVudEFsaWFzID09PSBldmVudEFsaWFzICYmXG4gICAgICAgIGVudHJ5LnNyY0VsZW1lbnQgIT09IHNyY0VsZW1lbnQgJiZcbiAgICAgICAgKCFlbnRyeS5zcmNFbGVtZW50IHx8IGVudHJ5LnNyY0VsZW1lbnQuY29udGFpbnMoc3JjRWxlbWVudCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2F2ZSB3cmFwcGVkIGhhbmRsZXJcbiAgICB0aGlzLmV2ZW50SGFuZGxlcnMucHVzaCh7ZXZlbnQsIGV2ZW50QWxpYXMsIHJlY29nbml6ZXJOYW1lLCBzcmNFbGVtZW50LFxuICAgICAgaGFuZGxlciwgd3JhcHBlZEhhbmRsZXJ9KTtcblxuICAgIC8vIFNvcnQgaGFuZGxlcnMgYnkgRE9NIGhpZXJhcmNoeVxuICAgIC8vIFNvIHRoZSBldmVudCB3aWxsIGFsd2F5cyBmaXJlIGZpcnN0IG9uIGNoaWxkIG5vZGVzXG4gICAgYW5jZXN0b3JFdmVudEhhbmRsZXJzLmZvckVhY2goZW50cnkgPT4gdGhpcy5tYW5hZ2VyLm9mZihldmVudEFsaWFzLCBlbnRyeS53cmFwcGVkSGFuZGxlcikpO1xuICAgIHRoaXMubWFuYWdlci5vbihldmVudEFsaWFzLCB3cmFwcGVkSGFuZGxlcik7XG4gICAgYW5jZXN0b3JFdmVudEhhbmRsZXJzLmZvckVhY2goZW50cnkgPT4gdGhpcy5tYW5hZ2VyLm9uKGV2ZW50QWxpYXMsIGVudHJ5LndyYXBwZWRIYW5kbGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgZXZlbnQgZGVyZWdpc3RyYXRpb24gZm9yIGEgc2luZ2xlIGV2ZW50ICsgaGFuZGxlci5cbiAgICovXG4gIF9yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBsZXQgZXZlbnRIYW5kbGVyUmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgLy8gRmluZCBzYXZlZCBoYW5kbGVyIGlmIGFueS5cbiAgICBmb3IgKGxldCBpID0gdGhpcy5ldmVudEhhbmRsZXJzLmxlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmV2ZW50SGFuZGxlcnNbaV07XG4gICAgICBpZiAoZW50cnkuZXZlbnQgPT09IGV2ZW50ICYmIGVudHJ5LmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgLy8gRGVyZWdpc3RlciBldmVudCBoYW5kbGVyLlxuICAgICAgICB0aGlzLm1hbmFnZXIub2ZmKGVudHJ5LmV2ZW50QWxpYXMsIGVudHJ5LndyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgLy8gRGVsZXRlIHNhdmVkIGhhbmRsZXJcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgZXZlbnRIYW5kbGVyUmVtb3ZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50SGFuZGxlclJlbW92ZWQpIHtcbiAgICAgIC8vIEFsaWFzIHRvIGEgcmVjb2duaXplZCBnZXN0dXJlIGFzIG5lY2Vzc2FyeS5cbiAgICAgIGNvbnN0IGV2ZW50QWxpYXMgPSBHRVNUVVJFX0VWRU5UX0FMSUFTRVNbZXZlbnRdIHx8IGV2ZW50O1xuICAgICAgLy8gR2V0IHJlY29nbml6ZXIgZm9yIHRoaXMgZXZlbnRcbiAgICAgIGNvbnN0IHJlY29nbml6ZXJOYW1lID0gRVZFTlRfUkVDT0dOSVpFUl9NQVBbZXZlbnRBbGlhc10gfHwgZXZlbnRBbGlhcztcbiAgICAgIC8vIERpc2FibGUgcmVjb2duaXplciBpZiBubyBtb3JlIGhhbmRsZXJzIGFyZSBhdHRhY2hlZCB0byBpdHMgZXZlbnRzXG4gICAgICBjb25zdCBpc1JlY29nbml6ZXJVc2VkID0gdGhpcy5ldmVudEhhbmRsZXJzLmZpbmQoXG4gICAgICAgIGVudHJ5ID0+IGVudHJ5LnJlY29nbml6ZXJOYW1lID09PSByZWNvZ25pemVyTmFtZVxuICAgICAgKTtcbiAgICAgIGlmICghaXNSZWNvZ25pemVyVXNlZCkge1xuICAgICAgICB0aGlzLl90b2dnbGVSZWNvZ25pemVyKHJlY29nbml6ZXJOYW1lLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXZlbnQgaGFuZGxlciB0aGF0IGFsaWFzZXMgZXZlbnRzIGFuZCBhZGQgcHJvcHMgYmVmb3JlIHBhc3NpbmdcbiAgICogdG8gdGhlIHJlYWwgaGFuZGxlci5cbiAgICovXG4gIF93cmFwRXZlbnRIYW5kbGVyKHR5cGUsIGhhbmRsZXIsIHNyY0VsZW1lbnQpIHtcbiAgICByZXR1cm4gZXZlbnQgPT4ge1xuICAgICAgbGV0IHttam9sbmlyRXZlbnR9ID0gZXZlbnQ7XG5cbiAgICAgIGlmICghbWpvbG5pckV2ZW50KSB7XG4gICAgICAgIG1qb2xuaXJFdmVudCA9IHRoaXMuX25vcm1hbGl6ZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgZXZlbnQubWpvbG5pckV2ZW50ID0gbWpvbG5pckV2ZW50O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc1N0b3BwZWQgPSBtam9sbmlyRXZlbnQuaGFuZGxlZCAmJiBtam9sbmlyRXZlbnQuaGFuZGxlZCAhPT0gc3JjRWxlbWVudDtcblxuICAgICAgaWYgKCFpc1N0b3BwZWQpIHtcbiAgICAgICAgY29uc3QgaXNGcm9tRGVjZW5kYW50ID0gIXNyY0VsZW1lbnQgfHwgc3JjRWxlbWVudC5jb250YWlucyhldmVudC5zcmNFdmVudC50YXJnZXQpO1xuICAgICAgICBpZiAoaXNGcm9tRGVjZW5kYW50KSB7XG4gICAgICAgICAgaGFuZGxlcihPYmplY3QuYXNzaWduKHt9LCBtam9sbmlyRXZlbnQsIHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFtam9sbmlyRXZlbnQuaGFuZGxlZCkge1xuICAgICAgICAgICAgICAgIG1qb2xuaXJFdmVudC5oYW5kbGVkID0gc3JjRWxlbWVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplcyBoYW1tZXJqcyBhbmQgY3VzdG9tIGV2ZW50cyB0byBoYXZlIHByZWRpY3RhYmxlIGZpZWxkcy5cbiAgICovXG4gIF9ub3JtYWxpemVFdmVudChldmVudCkge1xuICAgIGNvbnN0IHtlbGVtZW50fSA9IHRoaXM7XG4gICAgY29uc3Qge3NyY0V2ZW50fSA9IGV2ZW50O1xuXG4gICAgY29uc3QgY2VudGVyID0gZXZlbnQuY2VudGVyIHx8IHtcbiAgICAgIHg6IHNyY0V2ZW50LmNsaWVudFgsXG4gICAgICB5OiBzcmNFdmVudC5jbGllbnRZXG4gICAgfTtcblxuICAgIC8vIENhbGN1bGF0ZSBjZW50ZXIgcmVsYXRpdmUgdG8gdGhlIHJvb3QgZWxlbWVudFxuICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgLy8gRml4IHNjYWxlIGZvciBtYXAgYWZmZWN0ZWQgYnkgYSBDU1MgdHJhbnNmb3JtLlxuICAgIC8vIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY4OTM2NjMvMzUyODUzM1xuICAgIGNvbnN0IHNjYWxlWCA9IHJlY3Qud2lkdGggLyBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIGNvbnN0IHNjYWxlWSA9IHJlY3QuaGVpZ2h0IC8gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAvLyBDYWxjdWxhdGUgY2VudGVyIHJlbGF0aXZlIHRvIHRoZSByb290IGVsZW1lbnRcbiAgICBjb25zdCBvZmZzZXRDZW50ZXIgPSB7XG4gICAgICB4OiAoY2VudGVyLnggLSByZWN0LmxlZnQgLSBlbGVtZW50LmNsaWVudExlZnQpIC8gc2NhbGVYLFxuICAgICAgeTogKGNlbnRlci55IC0gcmVjdC50b3AgLSBlbGVtZW50LmNsaWVudFRvcCkgLyBzY2FsZVlcbiAgICB9O1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGV2ZW50LCB7XG4gICAgICBoYW5kbGVkOiBmYWxzZSxcbiAgICAgIGNlbnRlcixcbiAgICAgIG9mZnNldENlbnRlcixcbiAgICAgIHJvb3RFbGVtZW50OiBlbGVtZW50XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGJhc2ljIGV2ZW50cyB1c2luZyB0aGUgJ2hhbW1lci5pbnB1dCcgSGFtbWVyLmpzIEFQSTpcbiAgICogQmVmb3JlIHJ1bm5pbmcgUmVjb2duaXplcnMsIEhhbW1lciBlbWl0cyBhICdoYW1tZXIuaW5wdXQnIGV2ZW50XG4gICAqIHdpdGggdGhlIGJhc2ljIGV2ZW50IGluZm8uIFRoaXMgZnVuY3Rpb24gZW1pdHMgYWxsIGJhc2ljIGV2ZW50c1xuICAgKiBhbGlhc2VkIHRvIHRoZSBcImNsYXNzXCIgb2YgZXZlbnQgcmVjZWl2ZWQuXG4gICAqIFNlZSBjb25zdGFudHMuQkFTSUNfRVZFTlRfQ0xBU1NFUyBiYXNpYyBldmVudCBjbGFzcyBkZWZpbml0aW9ucy5cbiAgICovXG4gIF9vbkJhc2ljSW5wdXQoZXZlbnQpIHtcbiAgICBjb25zdCB7c3JjRXZlbnR9ID0gZXZlbnQ7XG4gICAgY29uc3QgYWxpYXMgPSBCQVNJQ19FVkVOVF9BTElBU0VTW3NyY0V2ZW50LnR5cGVdO1xuICAgIGlmIChhbGlhcykge1xuICAgICAgLy8gZmlyZSBhbGwgZXZlbnRzIGFsaWFzZWQgdG8gc3JjRXZlbnQudHlwZVxuICAgICAgY29uc3QgZW1pdEV2ZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQsIHtpc0Rvd246IHRydWV9KTtcbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KGFsaWFzLCBlbWl0RXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgZXZlbnRzIG5vdCBzdXBwb3J0ZWQgYnkgSGFtbWVyLmpzLFxuICAgKiBhbmQgcGlwZSBiYWNrIG91dCB0aHJvdWdoIHNhbWUgKEhhbW1lcikgY2hhbm5lbCB1c2VkIGJ5IG90aGVyIGV2ZW50cy5cbiAgICovXG4gIF9vbk90aGVyRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLm1hbmFnZXIuZW1pdChldmVudC50eXBlLCBldmVudCk7XG4gIH1cbn1cbiJdfQ==