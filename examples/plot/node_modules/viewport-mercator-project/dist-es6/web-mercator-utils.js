var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// TODO - THE UTILITIES IN THIS FILE SHOULD BE IMPORTED FROM WEB-MERCATOR-VIEWPORT MODULE

import { Vector3 } from 'math.gl';
import mat4_perspective from 'gl-mat4/perspective';
import mat4_scale from 'gl-mat4/scale';
import mat4_translate from 'gl-mat4/translate';
import mat4_rotateX from 'gl-mat4/rotateX';
import mat4_rotateZ from 'gl-mat4/rotateZ';
import vec2_distance from 'gl-vec2/distance';
import assert from 'assert';

// CONSTANTS
var PI = Math.PI;
var PI_4 = PI / 4;
var DEGREES_TO_RADIANS = PI / 180;
var RADIANS_TO_DEGREES = 180 / PI;
var TILE_SIZE = 512;
var WORLD_SCALE = TILE_SIZE;

// const METERS_PER_DEGREE_AT_EQUATOR = 111000; // Approximately 111km per degree at equator

// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}

/**
 * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
 * Performs the nonlinear part of the web mercator projection.
 * Remaining projection is done with 4x4 matrices which also handles
 * perspective.
 *
 * @param {Array} lngLat - [lng, lat] coordinates
 *   Specifies a point on the sphere to project onto the map.
 * @return {Array} [x,y] coordinates.
 */
export function projectFlat(_ref, scale) {
  var _ref2 = _slicedToArray(_ref, 2),
      lng = _ref2[0],
      lat = _ref2[1];

  scale = scale * WORLD_SCALE;
  var lambda2 = lng * DEGREES_TO_RADIANS;
  var phi2 = lat * DEGREES_TO_RADIANS;
  var x = scale * (lambda2 + PI) / (2 * PI);
  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}

/**
 * Unproject world point [x,y] on map onto {lat, lon} on sphere
 *
 * @param {object|Vector} xy - object with {x,y} members
 *  representing point on projected map plane
 * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
 *   Has toArray method if you need a GeoJSON Array.
 *   Per cartographic tradition, lat and lon are specified as degrees.
 */
export function unprojectFlat(_ref3, scale) {
  var _ref4 = _slicedToArray(_ref3, 2),
      x = _ref4[0],
      y = _ref4[1];

  scale = scale * WORLD_SCALE;
  var lambda2 = x / scale * (2 * PI) - PI;
  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
}

// Returns the zoom level that gives a 1 meter pixel at a certain latitude
// S=C*cos(y)/2^(z+8)
export function getMercatorMeterZoom(_ref5) {
  var latitude = _ref5.latitude;

  assert(latitude);
  var EARTH_CIRCUMFERENCE = 40.075e6;
  var radians = function radians(degrees) {
    return degrees / 180 * Math.PI;
  };
  return Math.log2(EARTH_CIRCUMFERENCE * Math.cos(radians(latitude))) - 8;
}

/**
 * Calculate distance scales in meters around current lat/lon, both for
 * degrees and pixels.
 * In mercator projection mode, the distance scales vary significantly
 * with latitude.
 */
export function getMercatorDistanceScales(_ref6) {
  var latitude = _ref6.latitude,
      longitude = _ref6.longitude,
      zoom = _ref6.zoom,
      scale = _ref6.scale;

  // Calculate scale from zoom if not provided
  scale = scale !== undefined ? scale : Math.pow(2, zoom);

  assert(!isNaN(latitude) && !isNaN(longitude) && !isNaN(scale));

  var latCosine = Math.cos(latitude * Math.PI / 180);

  // const metersPerDegreeX = METERS_PER_DEGREE_AT_EQUATOR * latCosine;
  // const metersPerDegreeY = METERS_PER_DEGREE_AT_EQUATOR;

  // Calculate number of pixels occupied by one degree longitude
  // around current lat/lon
  var pixelsPerDegreeX = vec2_distance(projectFlat([longitude + 0.5, latitude], scale), projectFlat([longitude - 0.5, latitude], scale));
  // Calculate number of pixels occupied by one degree latitude
  // around current lat/lon
  var pixelsPerDegreeY = vec2_distance(projectFlat([longitude, latitude + 0.5], scale), projectFlat([longitude, latitude - 0.5], scale));

  var worldSize = TILE_SIZE * scale;
  var altPixelsPerMeter = worldSize / (4e7 * latCosine);
  var pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
  var metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / altPixelsPerMeter];

  var pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, altPixelsPerMeter];
  var degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];

  // Main results, used for converting meters to latlng deltas and scaling offsets
  return {
    pixelsPerMeter: pixelsPerMeter,
    metersPerPixel: metersPerPixel,
    pixelsPerDegree: pixelsPerDegree,
    degreesPerPixel: degreesPerPixel
  };
}

/**
 * Calculates a mercator world position ("pixels" in given zoom level)
 * from a lng/lat and meterOffset
 */
export function getMercatorWorldPosition(_ref7) {
  var longitude = _ref7.longitude,
      latitude = _ref7.latitude,
      zoom = _ref7.zoom,
      meterOffset = _ref7.meterOffset,
      _ref7$distanceScales = _ref7.distanceScales,
      distanceScales = _ref7$distanceScales === undefined ? null : _ref7$distanceScales;

  var scale = Math.pow(2, zoom);

  // Calculate distance scales if lng/lat/zoom are provided
  distanceScales = distanceScales || getMercatorDistanceScales({ latitude: latitude, longitude: longitude, scale: scale });

  // Make a centered version of the matrix for projection modes without an offset
  var center2d = projectFlat([longitude, latitude], scale);
  var center = new Vector3(center2d[0], center2d[1], 0);

  if (meterOffset) {
    var pixelPosition = new Vector3(meterOffset)
    // Convert to pixels in current zoom
    .scale(distanceScales.pixelsPerMeter)
    // We want positive Y to represent an offset towards north,
    // but web mercator world coordinates is top-left
    .scale([1, -1, 1]);
    center.add(pixelPosition);
  }

  return center;
}

// ATTRIBUTION:
// view and projection matrix creation is intentionally kept compatible with
// mapbox-gl's implementation to ensure that seamless interoperation
// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js

// Variable fov (in radians)
export function getFov(_ref8) {
  var height = _ref8.height,
      altitude = _ref8.altitude;

  return 2 * Math.atan(height / 2 / altitude);
}

export function getClippingPlanes(_ref9) {
  var altitude = _ref9.altitude,
      pitch = _ref9.pitch;

  // Find the distance from the center point to the center top
  // in altitude units using law of sines.
  var pitchRadians = pitch * DEGREES_TO_RADIANS;
  var halfFov = Math.atan(0.5 / altitude);
  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov);

  // Calculate z value of the farthest fragment that should be rendered.
  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;

  return { farZ: farZ, nearZ: 0.1 };
}

// TODO - rename this matrix
export function makeUncenteredViewMatrixFromMercatorParams(_ref10) {
  var width = _ref10.width,
      height = _ref10.height,
      longitude = _ref10.longitude,
      latitude = _ref10.latitude,
      zoom = _ref10.zoom,
      pitch = _ref10.pitch,
      bearing = _ref10.bearing,
      altitude = _ref10.altitude,
      center = _ref10.center;

  // VIEW MATRIX: PROJECTS MERCATOR WORLD COORDINATES
  // Note that mercator world coordinates typically need to be flipped
  //
  // Note: As usual, matrix operation orders should be read in reverse
  // since vectors will be multiplied from the right during transformation
  var vm = createMat4();

  // Move camera to altitude (along the pitch & bearing direction)
  mat4_translate(vm, vm, [0, 0, -altitude]);

  // After the rotateX, z values are in pixel units. Convert them to
  // altitude units. 1 altitude unit = the screen height.
  mat4_scale(vm, vm, [1, 1, 1 / height]);

  // Rotate by bearing, and then by pitch (which tilts the view)
  mat4_rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);
  mat4_rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);

  return vm;
}

export function makeViewMatricesFromMercatorParams(_ref11) {
  var width = _ref11.width,
      height = _ref11.height,
      longitude = _ref11.longitude,
      latitude = _ref11.latitude,
      zoom = _ref11.zoom,
      pitch = _ref11.pitch,
      bearing = _ref11.bearing,
      altitude = _ref11.altitude,
      centerLngLat = _ref11.centerLngLat,
      _ref11$meterOffset = _ref11.meterOffset,
      meterOffset = _ref11$meterOffset === undefined ? null : _ref11$meterOffset;

  var center = getMercatorWorldPosition({ longitude: longitude, latitude: latitude, zoom: zoom, meterOffset: meterOffset });

  // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE
  // Note: As usual, matrix operation orders should be read in reverse
  // since vectors will be multiplied from the right during transformation
  var viewMatrixUncentered = makeUncenteredViewMatrixFromMercatorParams({
    width: width,
    height: height,
    longitude: longitude,
    latitude: latitude,
    zoom: zoom,
    pitch: pitch,
    bearing: bearing,
    altitude: altitude
  });

  var vm = createMat4();
  mat4_scale(vm, viewMatrixUncentered, [1, -1, 1]);
  var viewMatrixCentered = mat4_translate(vm, vm, new Vector3(center).negate());

  return {
    viewMatrixCentered: viewMatrixCentered,
    viewMatrixUncentered: viewMatrixUncentered,
    center: center
  };
}

// PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE
// This is a "Mapbox" projection matrix - matches mapbox exactly if farZMultiplier === 1
export function makeProjectionMatrixFromMercatorParams(_ref12) {
  var width = _ref12.width,
      height = _ref12.height,
      pitch = _ref12.pitch,
      altitude = _ref12.altitude,
      _ref12$farZMultiplier = _ref12.farZMultiplier,
      farZMultiplier = _ref12$farZMultiplier === undefined ? 10 : _ref12$farZMultiplier;

  var _getClippingPlanes = getClippingPlanes({ altitude: altitude, pitch: pitch }),
      nearZ = _getClippingPlanes.nearZ,
      farZ = _getClippingPlanes.farZ;

  var fov = getFov({ height: height, altitude: altitude });

  var projectionMatrix = mat4_perspective(createMat4(), fov, // fov in radians
  width / height, // aspect ratio
  nearZ, // near plane
  farZ * farZMultiplier // far plane
  );

  return projectionMatrix;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy93ZWItbWVyY2F0b3ItdXRpbHMuanMiXSwibmFtZXMiOlsiVmVjdG9yMyIsIm1hdDRfcGVyc3BlY3RpdmUiLCJtYXQ0X3NjYWxlIiwibWF0NF90cmFuc2xhdGUiLCJtYXQ0X3JvdGF0ZVgiLCJtYXQ0X3JvdGF0ZVoiLCJ2ZWMyX2Rpc3RhbmNlIiwiYXNzZXJ0IiwiUEkiLCJNYXRoIiwiUElfNCIsIkRFR1JFRVNfVE9fUkFESUFOUyIsIlJBRElBTlNfVE9fREVHUkVFUyIsIlRJTEVfU0laRSIsIldPUkxEX1NDQUxFIiwiY3JlYXRlTWF0NCIsInByb2plY3RGbGF0Iiwic2NhbGUiLCJsbmciLCJsYXQiLCJsYW1iZGEyIiwicGhpMiIsIngiLCJ5IiwibG9nIiwidGFuIiwidW5wcm9qZWN0RmxhdCIsImF0YW4iLCJleHAiLCJnZXRNZXJjYXRvck1ldGVyWm9vbSIsImxhdGl0dWRlIiwiRUFSVEhfQ0lSQ1VNRkVSRU5DRSIsInJhZGlhbnMiLCJkZWdyZWVzIiwibG9nMiIsImNvcyIsImdldE1lcmNhdG9yRGlzdGFuY2VTY2FsZXMiLCJsb25naXR1ZGUiLCJ6b29tIiwidW5kZWZpbmVkIiwicG93IiwiaXNOYU4iLCJsYXRDb3NpbmUiLCJwaXhlbHNQZXJEZWdyZWVYIiwicGl4ZWxzUGVyRGVncmVlWSIsIndvcmxkU2l6ZSIsImFsdFBpeGVsc1Blck1ldGVyIiwicGl4ZWxzUGVyTWV0ZXIiLCJtZXRlcnNQZXJQaXhlbCIsInBpeGVsc1BlckRlZ3JlZSIsImRlZ3JlZXNQZXJQaXhlbCIsImdldE1lcmNhdG9yV29ybGRQb3NpdGlvbiIsIm1ldGVyT2Zmc2V0IiwiZGlzdGFuY2VTY2FsZXMiLCJjZW50ZXIyZCIsImNlbnRlciIsInBpeGVsUG9zaXRpb24iLCJhZGQiLCJnZXRGb3YiLCJoZWlnaHQiLCJhbHRpdHVkZSIsImdldENsaXBwaW5nUGxhbmVzIiwicGl0Y2giLCJwaXRjaFJhZGlhbnMiLCJoYWxmRm92IiwidG9wSGFsZlN1cmZhY2VEaXN0YW5jZSIsInNpbiIsImZhcloiLCJuZWFyWiIsIm1ha2VVbmNlbnRlcmVkVmlld01hdHJpeEZyb21NZXJjYXRvclBhcmFtcyIsIndpZHRoIiwiYmVhcmluZyIsInZtIiwibWFrZVZpZXdNYXRyaWNlc0Zyb21NZXJjYXRvclBhcmFtcyIsImNlbnRlckxuZ0xhdCIsInZpZXdNYXRyaXhVbmNlbnRlcmVkIiwidmlld01hdHJpeENlbnRlcmVkIiwibmVnYXRlIiwibWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMiLCJmYXJaTXVsdGlwbGllciIsImZvdiIsInByb2plY3Rpb25NYXRyaXgiXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBRUEsU0FBUUEsT0FBUixRQUFzQixTQUF0QjtBQUNBLE9BQU9DLGdCQUFQLE1BQTZCLHFCQUE3QjtBQUNBLE9BQU9DLFVBQVAsTUFBdUIsZUFBdkI7QUFDQSxPQUFPQyxjQUFQLE1BQTJCLG1CQUEzQjtBQUNBLE9BQU9DLFlBQVAsTUFBeUIsaUJBQXpCO0FBQ0EsT0FBT0MsWUFBUCxNQUF5QixpQkFBekI7QUFDQSxPQUFPQyxhQUFQLE1BQTBCLGtCQUExQjtBQUNBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7O0FBRUE7QUFDQSxJQUFNQyxLQUFLQyxLQUFLRCxFQUFoQjtBQUNBLElBQU1FLE9BQU9GLEtBQUssQ0FBbEI7QUFDQSxJQUFNRyxxQkFBcUJILEtBQUssR0FBaEM7QUFDQSxJQUFNSSxxQkFBcUIsTUFBTUosRUFBakM7QUFDQSxJQUFNSyxZQUFZLEdBQWxCO0FBQ0EsSUFBTUMsY0FBY0QsU0FBcEI7O0FBRUE7O0FBRUE7QUFDQSxTQUFTRSxVQUFULEdBQXNCO0FBQ3BCLFNBQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixDQUF6QixFQUE0QixDQUE1QixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQyxFQUF3QyxDQUF4QyxF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QUEsTUFDTU0sS0FETixzQkFDTUEsS0FETjtBQUFBLE1BQ2FELElBRGIsc0JBQ2FBLElBRGI7O0FBRUQsTUFBTWEsTUFBTXRCLE9BQU8sRUFBQ0MsY0FBRCxFQUFTQyxrQkFBVCxFQUFQLENBQVo7O0FBRUEsTUFBTXFCLG1CQUFtQmhGLGlCQUN2QmMsWUFEdUIsRUFFdkJpRSxHQUZ1QixFQUVMO0FBQ2xCVixVQUFRWCxNQUhlLEVBR0w7QUFDbEJTLE9BSnVCLEVBSUw7QUFDbEJELFNBQU9ZLGNBTGdCLENBS0Q7QUFMQyxHQUF6Qjs7QUFRQSxTQUFPRSxnQkFBUDtBQUNEIiwiZmlsZSI6IndlYi1tZXJjYXRvci11dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRPRE8gLSBUSEUgVVRJTElUSUVTIElOIFRISVMgRklMRSBTSE9VTEQgQkUgSU1QT1JURUQgRlJPTSBXRUItTUVSQ0FUT1ItVklFV1BPUlQgTU9EVUxFXG5cbmltcG9ydCB7VmVjdG9yM30gZnJvbSAnbWF0aC5nbCc7XG5pbXBvcnQgbWF0NF9wZXJzcGVjdGl2ZSBmcm9tICdnbC1tYXQ0L3BlcnNwZWN0aXZlJztcbmltcG9ydCBtYXQ0X3NjYWxlIGZyb20gJ2dsLW1hdDQvc2NhbGUnO1xuaW1wb3J0IG1hdDRfdHJhbnNsYXRlIGZyb20gJ2dsLW1hdDQvdHJhbnNsYXRlJztcbmltcG9ydCBtYXQ0X3JvdGF0ZVggZnJvbSAnZ2wtbWF0NC9yb3RhdGVYJztcbmltcG9ydCBtYXQ0X3JvdGF0ZVogZnJvbSAnZ2wtbWF0NC9yb3RhdGVaJztcbmltcG9ydCB2ZWMyX2Rpc3RhbmNlIGZyb20gJ2dsLXZlYzIvZGlzdGFuY2UnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG4vLyBDT05TVEFOVFNcbmNvbnN0IFBJID0gTWF0aC5QSTtcbmNvbnN0IFBJXzQgPSBQSSAvIDQ7XG5jb25zdCBERUdSRUVTX1RPX1JBRElBTlMgPSBQSSAvIDE4MDtcbmNvbnN0IFJBRElBTlNfVE9fREVHUkVFUyA9IDE4MCAvIFBJO1xuY29uc3QgVElMRV9TSVpFID0gNTEyO1xuY29uc3QgV09STERfU0NBTEUgPSBUSUxFX1NJWkU7XG5cbi8vIGNvbnN0IE1FVEVSU19QRVJfREVHUkVFX0FUX0VRVUFUT1IgPSAxMTEwMDA7IC8vIEFwcHJveGltYXRlbHkgMTExa20gcGVyIGRlZ3JlZSBhdCBlcXVhdG9yXG5cbi8vIEhlbHBlciwgYXZvaWRzIGxvdy1wcmVjaXNpb24gMzIgYml0IG1hdHJpY2VzIGZyb20gZ2wtbWF0cml4IG1hdDQuY3JlYXRlKClcbmZ1bmN0aW9uIGNyZWF0ZU1hdDQoKSB7XG4gIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XG59XG5cbi8qKlxuICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gKiBSZW1haW5pbmcgcHJvamVjdGlvbiBpcyBkb25lIHdpdGggNHg0IG1hdHJpY2VzIHdoaWNoIGFsc28gaGFuZGxlc1xuICogcGVyc3BlY3RpdmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZywgbGF0XSBjb29yZGluYXRlc1xuICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvamVjdEZsYXQoW2xuZywgbGF0XSwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSAqIFdPUkxEX1NDQUxFO1xuICBjb25zdCBsYW1iZGEyID0gbG5nICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCBwaGkyID0gbGF0ICogREVHUkVFU19UT19SQURJQU5TO1xuICBjb25zdCB4ID0gc2NhbGUgKiAobGFtYmRhMiArIFBJKSAvICgyICogUEkpO1xuICBjb25zdCB5ID0gc2NhbGUgKiAoUEkgLSBNYXRoLmxvZyhNYXRoLnRhbihQSV80ICsgcGhpMiAqIDAuNSkpKSAvICgyICogUEkpO1xuICByZXR1cm4gW3gsIHldO1xufVxuXG4vKipcbiAqIFVucHJvamVjdCB3b3JsZCBwb2ludCBbeCx5XSBvbiBtYXAgb250byB7bGF0LCBsb259IG9uIHNwaGVyZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fFZlY3Rvcn0geHkgLSBvYmplY3Qgd2l0aCB7eCx5fSBtZW1iZXJzXG4gKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAqIEByZXR1cm4ge0dlb0Nvb3JkaW5hdGVzfSAtIG9iamVjdCB3aXRoIHtsYXQsbG9ufSBvZiBwb2ludCBvbiBzcGhlcmUuXG4gKiAgIEhhcyB0b0FycmF5IG1ldGhvZCBpZiB5b3UgbmVlZCBhIEdlb0pTT04gQXJyYXkuXG4gKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnByb2plY3RGbGF0KFt4LCB5XSwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSAqIFdPUkxEX1NDQUxFO1xuICBjb25zdCBsYW1iZGEyID0gKHggLyBzY2FsZSkgKiAoMiAqIFBJKSAtIFBJO1xuICBjb25zdCBwaGkyID0gMiAqIChNYXRoLmF0YW4oTWF0aC5leHAoUEkgLSAoeSAvIHNjYWxlKSAqICgyICogUEkpKSkgLSBQSV80KTtcbiAgcmV0dXJuIFtsYW1iZGEyICogUkFESUFOU19UT19ERUdSRUVTLCBwaGkyICogUkFESUFOU19UT19ERUdSRUVTXTtcbn1cblxuLy8gUmV0dXJucyB0aGUgem9vbSBsZXZlbCB0aGF0IGdpdmVzIGEgMSBtZXRlciBwaXhlbCBhdCBhIGNlcnRhaW4gbGF0aXR1ZGVcbi8vIFM9Qypjb3MoeSkvMl4oeis4KVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1lcmNhdG9yTWV0ZXJab29tKHtsYXRpdHVkZX0pIHtcbiAgYXNzZXJ0KGxhdGl0dWRlKTtcbiAgY29uc3QgRUFSVEhfQ0lSQ1VNRkVSRU5DRSA9IDQwLjA3NWU2O1xuICBjb25zdCByYWRpYW5zID0gZGVncmVlcyA9PiBkZWdyZWVzIC8gMTgwICogTWF0aC5QSTtcbiAgcmV0dXJuIE1hdGgubG9nMihFQVJUSF9DSVJDVU1GRVJFTkNFICogTWF0aC5jb3MocmFkaWFucyhsYXRpdHVkZSkpKSAtIDg7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRpc3RhbmNlIHNjYWxlcyBpbiBtZXRlcnMgYXJvdW5kIGN1cnJlbnQgbGF0L2xvbiwgYm90aCBmb3JcbiAqIGRlZ3JlZXMgYW5kIHBpeGVscy5cbiAqIEluIG1lcmNhdG9yIHByb2plY3Rpb24gbW9kZSwgdGhlIGRpc3RhbmNlIHNjYWxlcyB2YXJ5IHNpZ25pZmljYW50bHlcbiAqIHdpdGggbGF0aXR1ZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZXJjYXRvckRpc3RhbmNlU2NhbGVzKHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCB6b29tLCBzY2FsZX0pIHtcbiAgLy8gQ2FsY3VsYXRlIHNjYWxlIGZyb20gem9vbSBpZiBub3QgcHJvdmlkZWRcbiAgc2NhbGUgPSBzY2FsZSAhPT0gdW5kZWZpbmVkID8gc2NhbGUgOiBNYXRoLnBvdygyLCB6b29tKTtcblxuICBhc3NlcnQoIWlzTmFOKGxhdGl0dWRlKSAmJiAhaXNOYU4obG9uZ2l0dWRlKSAmJiAhaXNOYU4oc2NhbGUpKTtcblxuICBjb25zdCBsYXRDb3NpbmUgPSBNYXRoLmNvcyhsYXRpdHVkZSAqIE1hdGguUEkgLyAxODApO1xuXG4gIC8vIGNvbnN0IG1ldGVyc1BlckRlZ3JlZVggPSBNRVRFUlNfUEVSX0RFR1JFRV9BVF9FUVVBVE9SICogbGF0Q29zaW5lO1xuICAvLyBjb25zdCBtZXRlcnNQZXJEZWdyZWVZID0gTUVURVJTX1BFUl9ERUdSRUVfQVRfRVFVQVRPUjtcblxuICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIHBpeGVscyBvY2N1cGllZCBieSBvbmUgZGVncmVlIGxvbmdpdHVkZVxuICAvLyBhcm91bmQgY3VycmVudCBsYXQvbG9uXG4gIGNvbnN0IHBpeGVsc1BlckRlZ3JlZVggPSB2ZWMyX2Rpc3RhbmNlKFxuICAgIHByb2plY3RGbGF0KFtsb25naXR1ZGUgKyAwLjUsIGxhdGl0dWRlXSwgc2NhbGUpLFxuICAgIHByb2plY3RGbGF0KFtsb25naXR1ZGUgLSAwLjUsIGxhdGl0dWRlXSwgc2NhbGUpXG4gICk7XG4gIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgcGl4ZWxzIG9jY3VwaWVkIGJ5IG9uZSBkZWdyZWUgbGF0aXR1ZGVcbiAgLy8gYXJvdW5kIGN1cnJlbnQgbGF0L2xvblxuICBjb25zdCBwaXhlbHNQZXJEZWdyZWVZID0gdmVjMl9kaXN0YW5jZShcbiAgICBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZSArIDAuNV0sIHNjYWxlKSxcbiAgICBwcm9qZWN0RmxhdChbbG9uZ2l0dWRlLCBsYXRpdHVkZSAtIDAuNV0sIHNjYWxlKVxuICApO1xuXG4gIGNvbnN0IHdvcmxkU2l6ZSA9IFRJTEVfU0laRSAqIHNjYWxlO1xuICBjb25zdCBhbHRQaXhlbHNQZXJNZXRlciA9IHdvcmxkU2l6ZSAvICg0ZTcgKiBsYXRDb3NpbmUpO1xuICBjb25zdCBwaXhlbHNQZXJNZXRlciA9IFthbHRQaXhlbHNQZXJNZXRlciwgYWx0UGl4ZWxzUGVyTWV0ZXIsIGFsdFBpeGVsc1Blck1ldGVyXTtcbiAgY29uc3QgbWV0ZXJzUGVyUGl4ZWwgPSBbMSAvIGFsdFBpeGVsc1Blck1ldGVyLCAxIC8gYWx0UGl4ZWxzUGVyTWV0ZXIsIDEgLyBhbHRQaXhlbHNQZXJNZXRlcl07XG5cbiAgY29uc3QgcGl4ZWxzUGVyRGVncmVlID0gW3BpeGVsc1BlckRlZ3JlZVgsIHBpeGVsc1BlckRlZ3JlZVksIGFsdFBpeGVsc1Blck1ldGVyXTtcbiAgY29uc3QgZGVncmVlc1BlclBpeGVsID0gWzEgLyBwaXhlbHNQZXJEZWdyZWVYLCAxIC8gcGl4ZWxzUGVyRGVncmVlWSwgMSAvIGFsdFBpeGVsc1Blck1ldGVyXTtcblxuICAvLyBNYWluIHJlc3VsdHMsIHVzZWQgZm9yIGNvbnZlcnRpbmcgbWV0ZXJzIHRvIGxhdGxuZyBkZWx0YXMgYW5kIHNjYWxpbmcgb2Zmc2V0c1xuICByZXR1cm4ge1xuICAgIHBpeGVsc1Blck1ldGVyLFxuICAgIG1ldGVyc1BlclBpeGVsLFxuICAgIHBpeGVsc1BlckRlZ3JlZSxcbiAgICBkZWdyZWVzUGVyUGl4ZWxcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgbWVyY2F0b3Igd29ybGQgcG9zaXRpb24gKFwicGl4ZWxzXCIgaW4gZ2l2ZW4gem9vbSBsZXZlbClcbiAqIGZyb20gYSBsbmcvbGF0IGFuZCBtZXRlck9mZnNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVyY2F0b3JXb3JsZFBvc2l0aW9uKHtcbiAgbG9uZ2l0dWRlLFxuICBsYXRpdHVkZSxcbiAgem9vbSxcbiAgbWV0ZXJPZmZzZXQsXG4gIGRpc3RhbmNlU2NhbGVzID0gbnVsbFxufSkge1xuICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHpvb20pO1xuXG4gIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSBzY2FsZXMgaWYgbG5nL2xhdC96b29tIGFyZSBwcm92aWRlZFxuICBkaXN0YW5jZVNjYWxlcyA9IGRpc3RhbmNlU2NhbGVzIHx8IGdldE1lcmNhdG9yRGlzdGFuY2VTY2FsZXMoe2xhdGl0dWRlLCBsb25naXR1ZGUsIHNjYWxlfSk7XG5cbiAgLy8gTWFrZSBhIGNlbnRlcmVkIHZlcnNpb24gb2YgdGhlIG1hdHJpeCBmb3IgcHJvamVjdGlvbiBtb2RlcyB3aXRob3V0IGFuIG9mZnNldFxuICBjb25zdCBjZW50ZXIyZCA9IHByb2plY3RGbGF0KFtsb25naXR1ZGUsIGxhdGl0dWRlXSwgc2NhbGUpO1xuICBjb25zdCBjZW50ZXIgPSBuZXcgVmVjdG9yMyhjZW50ZXIyZFswXSwgY2VudGVyMmRbMV0sIDApO1xuXG4gIGlmIChtZXRlck9mZnNldCkge1xuICAgIGNvbnN0IHBpeGVsUG9zaXRpb24gPSBuZXcgVmVjdG9yMyhtZXRlck9mZnNldClcbiAgICAgIC8vIENvbnZlcnQgdG8gcGl4ZWxzIGluIGN1cnJlbnQgem9vbVxuICAgICAgLnNjYWxlKGRpc3RhbmNlU2NhbGVzLnBpeGVsc1Blck1ldGVyKVxuICAgICAgLy8gV2Ugd2FudCBwb3NpdGl2ZSBZIHRvIHJlcHJlc2VudCBhbiBvZmZzZXQgdG93YXJkcyBub3J0aCxcbiAgICAgIC8vIGJ1dCB3ZWIgbWVyY2F0b3Igd29ybGQgY29vcmRpbmF0ZXMgaXMgdG9wLWxlZnRcbiAgICAgIC5zY2FsZShbMSwgLTEsIDFdKTtcbiAgICBjZW50ZXIuYWRkKHBpeGVsUG9zaXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIGNlbnRlcjtcbn1cblxuLy8gQVRUUklCVVRJT046XG4vLyB2aWV3IGFuZCBwcm9qZWN0aW9uIG1hdHJpeCBjcmVhdGlvbiBpcyBpbnRlbnRpb25hbGx5IGtlcHQgY29tcGF0aWJsZSB3aXRoXG4vLyBtYXBib3gtZ2wncyBpbXBsZW1lbnRhdGlvbiB0byBlbnN1cmUgdGhhdCBzZWFtbGVzcyBpbnRlcm9wZXJhdGlvblxuLy8gd2l0aCBtYXBib3ggYW5kIHJlYWN0LW1hcC1nbC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC1nbC1qc1xuXG4vLyBWYXJpYWJsZSBmb3YgKGluIHJhZGlhbnMpXG5leHBvcnQgZnVuY3Rpb24gZ2V0Rm92KHtoZWlnaHQsIGFsdGl0dWRlfSkge1xuICByZXR1cm4gMiAqIE1hdGguYXRhbigoaGVpZ2h0IC8gMikgLyBhbHRpdHVkZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGlwcGluZ1BsYW5lcyh7YWx0aXR1ZGUsIHBpdGNofSkge1xuICAvLyBGaW5kIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgcG9pbnQgdG8gdGhlIGNlbnRlciB0b3BcbiAgLy8gaW4gYWx0aXR1ZGUgdW5pdHMgdXNpbmcgbGF3IG9mIHNpbmVzLlxuICBjb25zdCBwaXRjaFJhZGlhbnMgPSBwaXRjaCAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgY29uc3QgaGFsZkZvdiA9IE1hdGguYXRhbigwLjUgLyBhbHRpdHVkZSk7XG4gIGNvbnN0IHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgPVxuICAgIE1hdGguc2luKGhhbGZGb3YpICogYWx0aXR1ZGUgLyBNYXRoLnNpbihNYXRoLlBJIC8gMiAtIHBpdGNoUmFkaWFucyAtIGhhbGZGb3YpO1xuXG4gIC8vIENhbGN1bGF0ZSB6IHZhbHVlIG9mIHRoZSBmYXJ0aGVzdCBmcmFnbWVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZC5cbiAgY29uc3QgZmFyWiA9IE1hdGguY29zKE1hdGguUEkgLyAyIC0gcGl0Y2hSYWRpYW5zKSAqIHRvcEhhbGZTdXJmYWNlRGlzdGFuY2UgKyBhbHRpdHVkZTtcblxuICByZXR1cm4ge2ZhclosIG5lYXJaOiAwLjF9O1xufVxuXG4vLyBUT0RPIC0gcmVuYW1lIHRoaXMgbWF0cml4XG5leHBvcnQgZnVuY3Rpb24gbWFrZVVuY2VudGVyZWRWaWV3TWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgbG9uZ2l0dWRlLFxuICBsYXRpdHVkZSxcbiAgem9vbSxcbiAgcGl0Y2gsXG4gIGJlYXJpbmcsXG4gIGFsdGl0dWRlLFxuICBjZW50ZXJcbn0pIHtcbiAgLy8gVklFVyBNQVRSSVg6IFBST0pFQ1RTIE1FUkNBVE9SIFdPUkxEIENPT1JESU5BVEVTXG4gIC8vIE5vdGUgdGhhdCBtZXJjYXRvciB3b3JsZCBjb29yZGluYXRlcyB0eXBpY2FsbHkgbmVlZCB0byBiZSBmbGlwcGVkXG4gIC8vXG4gIC8vIE5vdGU6IEFzIHVzdWFsLCBtYXRyaXggb3BlcmF0aW9uIG9yZGVycyBzaG91bGQgYmUgcmVhZCBpbiByZXZlcnNlXG4gIC8vIHNpbmNlIHZlY3RvcnMgd2lsbCBiZSBtdWx0aXBsaWVkIGZyb20gdGhlIHJpZ2h0IGR1cmluZyB0cmFuc2Zvcm1hdGlvblxuICBjb25zdCB2bSA9IGNyZWF0ZU1hdDQoKTtcblxuICAvLyBNb3ZlIGNhbWVyYSB0byBhbHRpdHVkZSAoYWxvbmcgdGhlIHBpdGNoICYgYmVhcmluZyBkaXJlY3Rpb24pXG4gIG1hdDRfdHJhbnNsYXRlKHZtLCB2bSwgWzAsIDAsIC1hbHRpdHVkZV0pO1xuXG4gIC8vIEFmdGVyIHRoZSByb3RhdGVYLCB6IHZhbHVlcyBhcmUgaW4gcGl4ZWwgdW5pdHMuIENvbnZlcnQgdGhlbSB0b1xuICAvLyBhbHRpdHVkZSB1bml0cy4gMSBhbHRpdHVkZSB1bml0ID0gdGhlIHNjcmVlbiBoZWlnaHQuXG4gIG1hdDRfc2NhbGUodm0sIHZtLCBbMSwgMSwgMSAvIGhlaWdodF0pO1xuXG4gIC8vIFJvdGF0ZSBieSBiZWFyaW5nLCBhbmQgdGhlbiBieSBwaXRjaCAod2hpY2ggdGlsdHMgdGhlIHZpZXcpXG4gIG1hdDRfcm90YXRlWCh2bSwgdm0sIC1waXRjaCAqIERFR1JFRVNfVE9fUkFESUFOUyk7XG4gIG1hdDRfcm90YXRlWih2bSwgdm0sIGJlYXJpbmcgKiBERUdSRUVTX1RPX1JBRElBTlMpO1xuXG4gIHJldHVybiB2bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VWaWV3TWF0cmljZXNGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBsb25naXR1ZGUsXG4gIGxhdGl0dWRlLFxuICB6b29tLFxuICBwaXRjaCxcbiAgYmVhcmluZyxcbiAgYWx0aXR1ZGUsXG4gIGNlbnRlckxuZ0xhdCxcbiAgbWV0ZXJPZmZzZXQgPSBudWxsXG59KSB7XG4gIGNvbnN0IGNlbnRlciA9IGdldE1lcmNhdG9yV29ybGRQb3NpdGlvbih7bG9uZ2l0dWRlLCBsYXRpdHVkZSwgem9vbSwgbWV0ZXJPZmZzZXR9KTtcblxuICAvLyBWSUVXIE1BVFJJWDogUFJPSkVDVFMgRlJPTSBWSVJUVUFMIFBJWEVMUyBUTyBDQU1FUkEgU1BBQ0VcbiAgLy8gTm90ZTogQXMgdXN1YWwsIG1hdHJpeCBvcGVyYXRpb24gb3JkZXJzIHNob3VsZCBiZSByZWFkIGluIHJldmVyc2VcbiAgLy8gc2luY2UgdmVjdG9ycyB3aWxsIGJlIG11bHRpcGxpZWQgZnJvbSB0aGUgcmlnaHQgZHVyaW5nIHRyYW5zZm9ybWF0aW9uXG4gIGNvbnN0IHZpZXdNYXRyaXhVbmNlbnRlcmVkID0gbWFrZVVuY2VudGVyZWRWaWV3TWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zKHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbG9uZ2l0dWRlLFxuICAgIGxhdGl0dWRlLFxuICAgIHpvb20sXG4gICAgcGl0Y2gsXG4gICAgYmVhcmluZyxcbiAgICBhbHRpdHVkZVxuICB9KTtcblxuICBjb25zdCB2bSA9IGNyZWF0ZU1hdDQoKTtcbiAgbWF0NF9zY2FsZSh2bSwgdmlld01hdHJpeFVuY2VudGVyZWQsIFsxLCAtMSwgMV0pO1xuICBjb25zdCB2aWV3TWF0cml4Q2VudGVyZWQgPSBtYXQ0X3RyYW5zbGF0ZSh2bSwgdm0sIG5ldyBWZWN0b3IzKGNlbnRlcikubmVnYXRlKCkpO1xuXG4gIHJldHVybiB7XG4gICAgdmlld01hdHJpeENlbnRlcmVkLFxuICAgIHZpZXdNYXRyaXhVbmNlbnRlcmVkLFxuICAgIGNlbnRlclxuICB9O1xufVxuXG4vLyBQUk9KRUNUSU9OIE1BVFJJWDogUFJPSkVDVFMgRlJPTSBDQU1FUkEgKFZJRVcpIFNQQUNFIFRPIENMSVBTUEFDRVxuLy8gVGhpcyBpcyBhIFwiTWFwYm94XCIgcHJvamVjdGlvbiBtYXRyaXggLSBtYXRjaGVzIG1hcGJveCBleGFjdGx5IGlmIGZhclpNdWx0aXBsaWVyID09PSAxXG5leHBvcnQgZnVuY3Rpb24gbWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICB3aWR0aCxcbiAgaGVpZ2h0LFxuICBwaXRjaCxcbiAgYWx0aXR1ZGUsXG4gIGZhclpNdWx0aXBsaWVyID0gMTBcbn0pIHtcbiAgY29uc3Qge25lYXJaLCBmYXJafSA9IGdldENsaXBwaW5nUGxhbmVzKHthbHRpdHVkZSwgcGl0Y2h9KTtcbiAgY29uc3QgZm92ID0gZ2V0Rm92KHtoZWlnaHQsIGFsdGl0dWRlfSk7XG5cbiAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IG1hdDRfcGVyc3BlY3RpdmUoXG4gICAgY3JlYXRlTWF0NCgpLFxuICAgIGZvdiwgICAgICAgICAgICAgIC8vIGZvdiBpbiByYWRpYW5zXG4gICAgd2lkdGggLyBoZWlnaHQsICAgLy8gYXNwZWN0IHJhdGlvXG4gICAgbmVhclosICAgICAgICAgICAgLy8gbmVhciBwbGFuZVxuICAgIGZhclogKiBmYXJaTXVsdGlwbGllciAvLyBmYXIgcGxhbmVcbiAgKTtcblxuICByZXR1cm4gcHJvamVjdGlvbk1hdHJpeDtcbn1cbiJdfQ==