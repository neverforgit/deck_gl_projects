export { _fitBounds as fitBounds };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// View and Projection Matrix calculations for mapbox-js style map view properties
import MercatorViewport from './mercator-viewport';
import autobind from './autobind';
import assert from 'assert';

import { projectFlat, unprojectFlat, getMercatorDistanceScales, makeProjectionMatrixFromMercatorParams, makeViewMatricesFromMercatorParams } from './web-mercator-utils';

/* eslint-disable camelcase */
import vec2_add from 'gl-vec2/add';
import vec2_negate from 'gl-vec2/negate';

var DEFAULT_MAP_STATE = {
  latitude: 37,
  longitude: -122,
  zoom: 11,
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

var ERR_ARGUMENT = 'Illegal argument to WebMercatorViewport';

var WebMercatorViewport = function (_MercatorViewport) {
  _inherits(WebMercatorViewport, _MercatorViewport);

  /**
   * @classdesc
   * Creates view/projection matrices from mercator params
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
    * Notes:
   *  - Only one of center or [latitude, longitude] can be specified
   *  - [latitude, longitude] can only be specified when "mercator" is true
   *  - Altitude has a default value that matches assumptions in mapbox-gl
   *  - width and height are forced to 1 if supplied as 0, to avoid
   *    division by zero. This is intended to reduce the burden of apps to
   *    to check values before instantiating a Viewport.
   */
  /* eslint-disable complexity */
  function WebMercatorViewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        pitch = _ref.pitch,
        bearing = _ref.bearing,
        altitude = _ref.altitude,
        _ref$farZMultiplier = _ref.farZMultiplier,
        farZMultiplier = _ref$farZMultiplier === undefined ? 10 : _ref$farZMultiplier;

    _classCallCheck(this, WebMercatorViewport);

    // Viewport - support undefined arguments
    width = width !== undefined ? width : DEFAULT_MAP_STATE.width;
    height = height !== undefined ? height : DEFAULT_MAP_STATE.height;
    zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;
    latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;
    longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;
    bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;
    pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;
    altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;

    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc
    width = width || 1;
    height = height || 1;

    var scale = Math.pow(2, zoom);
    // Altitude - prevent division by 0
    // TODO - just throw an Error instead?
    altitude = Math.max(0.75, altitude);

    var center = projectFlat([longitude, latitude], scale);

    var distanceScales = getMercatorDistanceScales({ latitude: latitude, longitude: longitude, scale: scale });

    var projectionMatrix = makeProjectionMatrixFromMercatorParams({
      width: width,
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      farZMultiplier: farZMultiplier
    });

    var _makeViewMatricesFrom = makeViewMatricesFromMercatorParams({
      width: width,
      height: height,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      distanceScales: distanceScales,
      center: center
    }),
        viewMatrixCentered = _makeViewMatricesFrom.viewMatrixCentered;

    // Save parameters
    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, { width: width, height: height, viewMatrix: viewMatrixCentered, projectionMatrix: projectionMatrix }));

    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;

    _this.scale = scale;
    _this.center = center;

    _this._distanceScales = distanceScales;

    autobind(_this);
    Object.freeze(_this);
    return _this;
  }
  /* eslint-enable complexity */

  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   *
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */


  _createClass(WebMercatorViewport, [{
    key: '_projectFlat',
    value: function _projectFlat(lngLat) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return projectFlat(lngLat, scale);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xy) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return unprojectFlat(xy, scale);
    }

    /**
     * Get the map center that place a given [lng, lat] coordinate at screen
     * point [x, y]
     *
     * @param {Array} lngLat - [lng,lat] coordinates
     *   Specifies a point on the sphere.
     * @param {Array} pos - [x,y] coordinates
     *   Specifies a point on the screen.
     * @return {Array} [lng,lat] new map center.
     */

  }, {
    key: 'getLocationAtPoint',
    value: function getLocationAtPoint(_ref2) {
      var lngLat = _ref2.lngLat,
          pos = _ref2.pos;

      var fromLocation = this.projectFlat(this.unproject(pos));
      var toLocation = this.projectFlat(lngLat);

      var center = this.projectFlat([this.longitude, this.latitude]);

      var translate = vec2_add([], toLocation, vec2_negate([], fromLocation));
      var newCenter = vec2_add([], center, translate);
      return this.unprojectFlat(newCenter);
    }

    /*
    getLngLatAtViewportPosition(lnglat, xy) {
      const c = this.locationCoordinate(lnglat);
      const coordAtPoint = this.pointCoordinate(xy);
      const coordCenter = this.pointCoordinate(this.centerPoint);
      const translate = coordAtPoint._sub(c);
      this.center = this.coordinateLocation(coordCenter._sub(translate));
    }
    */

  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      return this._distanceScales;
    }

    /**
     * Converts a meter offset to a lnglat offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas
     */

  }, {
    key: 'metersToLngLatDelta',
    value: function metersToLngLatDelta(xyz) {
      var _xyz = _slicedToArray(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          _xyz$ = _xyz[2],
          z = _xyz$ === undefined ? 0 : _xyz$;

      assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _distanceScales = this._distanceScales,
          pixelsPerMeter = _distanceScales.pixelsPerMeter,
          degreesPerPixel = _distanceScales.degreesPerPixel;

      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }

    /**
     * Converts a lnglat offset to a meter offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas
     */

  }, {
    key: 'lngLatDeltaToMeters',
    value: function lngLatDeltaToMeters(deltaLngLatZ) {
      var _deltaLngLatZ = _slicedToArray(deltaLngLatZ, 3),
          deltaLng = _deltaLngLatZ[0],
          deltaLat = _deltaLngLatZ[1],
          _deltaLngLatZ$ = _deltaLngLatZ[2],
          deltaZ = _deltaLngLatZ$ === undefined ? 0 : _deltaLngLatZ$;

      assert(Number.isFinite(deltaLng) && Number.isFinite(deltaLat) && Number.isFinite(deltaZ), ERR_ARGUMENT);
      var _distanceScales2 = this._distanceScales,
          pixelsPerDegree = _distanceScales2.pixelsPerDegree,
          metersPerPixel = _distanceScales2.metersPerPixel;

      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];
      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];
      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];
    }

    /**
     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
     */

  }, {
    key: 'addMetersToLngLat',
    value: function addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = _slicedToArray(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;

      var _metersToLngLatDelta = this.metersToLngLatDelta(xyz),
          _metersToLngLatDelta2 = _slicedToArray(_metersToLngLatDelta, 3),
          deltaLng = _metersToLngLatDelta2[0],
          deltaLat = _metersToLngLatDelta2[1],
          _metersToLngLatDelta3 = _metersToLngLatDelta2[2],
          deltaZ = _metersToLngLatDelta3 === undefined ? 0 : _metersToLngLatDelta3;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }

    /**
     * Returns a new viewport that fit around the given rectangle.
     * Only supports non-perspective mode.
     * @param {Array} bounds - [[lon, lat], [lon, lat]]
     * @param {Number} [options.padding] - The amount of padding in pixels to add to the given bounds.
     * @param {Array} [options.offset] - The center of the given bounds relative to the map's center,
     *    [x, y] measured in pixels.
     * @returns {WebMercatorViewport}
     */

  }, {
    key: 'fitBounds',
    value: function fitBounds(bounds) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var width = this.width,
          height = this.height;

      var _fitBounds2 = _fitBounds(Object.assign({ width: width, height: height, bounds: bounds }, options)),
          longitude = _fitBounds2.longitude,
          latitude = _fitBounds2.latitude,
          zoom = _fitBounds2.zoom;

      return new WebMercatorViewport({ width: width, height: height, longitude: longitude, latitude: latitude, zoom: zoom });
    }

    // INTERNAL METHODS

  }, {
    key: '_getParams',
    value: function _getParams() {
      return this._distanceScales;
    }
  }]);

  return WebMercatorViewport;
}(MercatorViewport);

/**
 * Returns map settings {latitude, longitude, zoom}
 * that will contain the provided corners within the provided width.
 * Only supports non-perspective mode.
 * @param {Number} width - viewport width
 * @param {Number} height - viewport height
 * @param {Array} bounds - [[lon, lat], [lon, lat]]
 * @param {Number} [padding] - The amount of padding in pixels to add to the given bounds.
 * @param {Array} [offset] - The center of the given bounds relative to the map's center,
 *    [x, y] measured in pixels.
 * @returns {Object} - latitude, longitude and zoom
 */


export default WebMercatorViewport;
function _fitBounds(_ref3) {
  var width = _ref3.width,
      height = _ref3.height,
      bounds = _ref3.bounds,
      _ref3$padding = _ref3.padding,
      padding = _ref3$padding === undefined ? 0 : _ref3$padding,
      _ref3$offset = _ref3.offset,
      offset = _ref3$offset === undefined ? [0, 0] : _ref3$offset;

  var _bounds = _slicedToArray(bounds, 2),
      _bounds$ = _slicedToArray(_bounds[0], 2),
      west = _bounds$[0],
      south = _bounds$[1],
      _bounds$2 = _slicedToArray(_bounds[1], 2),
      east = _bounds$2[0],
      north = _bounds$2[1];

  var viewport = new WebMercatorViewport({
    width: width,
    height: height,
    longitude: 0,
    latitude: 0,
    zoom: 0
  });

  var nw = viewport.project([west, north]);
  var se = viewport.project([east, south]);
  var size = [Math.abs(se[0] - nw[0]), Math.abs(se[1] - nw[1])];
  var center = [(se[0] + nw[0]) / 2, (se[1] + nw[1]) / 2];

  var scaleX = (width - padding * 2 - Math.abs(offset[0]) * 2) / size[0];
  var scaleY = (height - padding * 2 - Math.abs(offset[1]) * 2) / size[1];

  var centerLngLat = viewport.unproject(center);
  var zoom = viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY)));

  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom: zoom
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wZXJzcGVjdGl2ZS1tZXJjYXRvci12aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJNZXJjYXRvclZpZXdwb3J0IiwiYXV0b2JpbmQiLCJhc3NlcnQiLCJwcm9qZWN0RmxhdCIsInVucHJvamVjdEZsYXQiLCJnZXRNZXJjYXRvckRpc3RhbmNlU2NhbGVzIiwibWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMiLCJtYWtlVmlld01hdHJpY2VzRnJvbU1lcmNhdG9yUGFyYW1zIiwidmVjMl9hZGQiLCJ2ZWMyX25lZ2F0ZSIsIkRFRkFVTFRfTUFQX1NUQVRFIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJ6b29tIiwicGl0Y2giLCJiZWFyaW5nIiwiYWx0aXR1ZGUiLCJFUlJfQVJHVU1FTlQiLCJXZWJNZXJjYXRvclZpZXdwb3J0Iiwid2lkdGgiLCJoZWlnaHQiLCJmYXJaTXVsdGlwbGllciIsInVuZGVmaW5lZCIsInNjYWxlIiwiTWF0aCIsInBvdyIsIm1heCIsImNlbnRlciIsImRpc3RhbmNlU2NhbGVzIiwicHJvamVjdGlvbk1hdHJpeCIsInZpZXdNYXRyaXhDZW50ZXJlZCIsInZpZXdNYXRyaXgiLCJfZGlzdGFuY2VTY2FsZXMiLCJPYmplY3QiLCJmcmVlemUiLCJsbmdMYXQiLCJ4eSIsInBvcyIsImZyb21Mb2NhdGlvbiIsInVucHJvamVjdCIsInRvTG9jYXRpb24iLCJ0cmFuc2xhdGUiLCJuZXdDZW50ZXIiLCJ4eXoiLCJ4IiwieSIsInoiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInBpeGVsc1Blck1ldGVyIiwiZGVncmVlc1BlclBpeGVsIiwiZGVsdGFMbmciLCJkZWx0YUxhdCIsImxlbmd0aCIsImRlbHRhTG5nTGF0WiIsImRlbHRhWiIsInBpeGVsc1BlckRlZ3JlZSIsIm1ldGVyc1BlclBpeGVsIiwiZGVsdGFYIiwiZGVsdGFZIiwibG5nTGF0WiIsImxuZyIsImxhdCIsIloiLCJtZXRlcnNUb0xuZ0xhdERlbHRhIiwiYm91bmRzIiwib3B0aW9ucyIsImZpdEJvdW5kcyIsImFzc2lnbiIsInBhZGRpbmciLCJvZmZzZXQiLCJ3ZXN0Iiwic291dGgiLCJlYXN0Iiwibm9ydGgiLCJ2aWV3cG9ydCIsIm53IiwicHJvamVjdCIsInNlIiwic2l6ZSIsImFicyIsInNjYWxlWCIsInNjYWxlWSIsImNlbnRlckxuZ0xhdCIsImxvZzIiLCJtaW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsT0FBT0EsZ0JBQVAsTUFBNkIscUJBQTdCO0FBQ0EsT0FBT0MsUUFBUCxNQUFxQixZQUFyQjtBQUNBLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7O0FBRUEsU0FDRUMsV0FERixFQUVFQyxhQUZGLEVBR0VDLHlCQUhGLEVBSUVDLHNDQUpGLEVBS0VDLGtDQUxGLFFBTU8sc0JBTlA7O0FBUUE7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLGFBQXJCO0FBQ0EsT0FBT0MsV0FBUCxNQUF3QixnQkFBeEI7O0FBRUEsSUFBTUMsb0JBQW9CO0FBQ3hCQyxZQUFVLEVBRGM7QUFFeEJDLGFBQVcsQ0FBQyxHQUZZO0FBR3hCQyxRQUFNLEVBSGtCO0FBSXhCQyxTQUFPLENBSmlCO0FBS3hCQyxXQUFTLENBTGU7QUFNeEJDLFlBQVU7QUFOYyxDQUExQjs7QUFTQSxJQUFNQyxlQUFlLHlDQUFyQjs7SUFFcUJDLG1COzs7QUFDbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0E7QUFDQSxpQ0FXUTtBQUFBLG1GQUFKLEVBQUk7QUFBQSxRQVROQyxLQVNNLFFBVE5BLEtBU007QUFBQSxRQVJOQyxNQVFNLFFBUk5BLE1BUU07QUFBQSxRQVBOVCxRQU9NLFFBUE5BLFFBT007QUFBQSxRQU5OQyxTQU1NLFFBTk5BLFNBTU07QUFBQSxRQUxOQyxJQUtNLFFBTE5BLElBS007QUFBQSxRQUpOQyxLQUlNLFFBSk5BLEtBSU07QUFBQSxRQUhOQyxPQUdNLFFBSE5BLE9BR007QUFBQSxRQUZOQyxRQUVNLFFBRk5BLFFBRU07QUFBQSxtQ0FETkssY0FDTTtB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VCxJQUFzQixDQUE5QyxJQUFtRFMsS0FBSyxDQUFMLENBQWxFOztBQUVBLE1BQU1JLGVBQWVSLFNBQVNwQyxTQUFULENBQW1CWixNQUFuQixDQUFyQjtBQUNBLE1BQU1kLE9BQU84RCxTQUFTOUQsSUFBVCxHQUFnQlcsS0FBSzRELElBQUwsQ0FBVTVELEtBQUt3RCxHQUFMLENBQVN4RCxLQUFLNkQsR0FBTCxDQUFTSixNQUFULEVBQWlCQyxNQUFqQixDQUFULENBQVYsQ0FBN0I7O0FBRUEsU0FBTztBQUNMdEUsZUFBV3VFLGFBQWEsQ0FBYixDQUROO0FBRUx4RSxjQUFVd0UsYUFBYSxDQUFiLENBRkw7QUFHTHRFO0FBSEssR0FBUDtBQUtEIiwiZmlsZSI6InBlcnNwZWN0aXZlLW1lcmNhdG9yLXZpZXdwb3J0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVmlldyBhbmQgUHJvamVjdGlvbiBNYXRyaXggY2FsY3VsYXRpb25zIGZvciBtYXBib3gtanMgc3R5bGUgbWFwIHZpZXcgcHJvcGVydGllc1xuaW1wb3J0IE1lcmNhdG9yVmlld3BvcnQgZnJvbSAnLi9tZXJjYXRvci12aWV3cG9ydCc7XG5pbXBvcnQgYXV0b2JpbmQgZnJvbSAnLi9hdXRvYmluZCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmltcG9ydCB7XG4gIHByb2plY3RGbGF0LFxuICB1bnByb2plY3RGbGF0LFxuICBnZXRNZXJjYXRvckRpc3RhbmNlU2NhbGVzLFxuICBtYWtlUHJvamVjdGlvbk1hdHJpeEZyb21NZXJjYXRvclBhcmFtcyxcbiAgbWFrZVZpZXdNYXRyaWNlc0Zyb21NZXJjYXRvclBhcmFtc1xufSBmcm9tICcuL3dlYi1tZXJjYXRvci11dGlscyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuaW1wb3J0IHZlYzJfYWRkIGZyb20gJ2dsLXZlYzIvYWRkJztcbmltcG9ydCB2ZWMyX25lZ2F0ZSBmcm9tICdnbC12ZWMyL25lZ2F0ZSc7XG5cbmNvbnN0IERFRkFVTFRfTUFQX1NUQVRFID0ge1xuICBsYXRpdHVkZTogMzcsXG4gIGxvbmdpdHVkZTogLTEyMixcbiAgem9vbTogMTEsXG4gIHBpdGNoOiAwLFxuICBiZWFyaW5nOiAwLFxuICBhbHRpdHVkZTogMS41XG59O1xuXG5jb25zdCBFUlJfQVJHVU1FTlQgPSAnSWxsZWdhbCBhcmd1bWVudCB0byBXZWJNZXJjYXRvclZpZXdwb3J0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViTWVyY2F0b3JWaWV3cG9ydCBleHRlbmRzIE1lcmNhdG9yVmlld3BvcnQge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBDcmVhdGVzIHZpZXcvcHJvamVjdGlvbiBtYXRyaWNlcyBmcm9tIG1lcmNhdG9yIHBhcmFtc1xuICAgKiBOb3RlOiBUaGUgVmlld3BvcnQgaXMgaW1tdXRhYmxlIGluIHRoZSBzZW5zZSB0aGF0IGl0IG9ubHkgaGFzIGFjY2Vzc29ycy5cbiAgICogQSBuZXcgdmlld3BvcnQgaW5zdGFuY2Ugc2hvdWxkIGJlIGNyZWF0ZWQgaWYgYW55IHBhcmFtZXRlcnMgaGF2ZSBjaGFuZ2VkLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdCAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBtZXJjYXRvcj10cnVlIC0gV2hldGhlciB0byB1c2UgbWVyY2F0b3IgcHJvamVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LndpZHRoPTEgLSBXaWR0aCBvZiBcInZpZXdwb3J0XCIgb3Igd2luZG93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuaGVpZ2h0PTEgLSBIZWlnaHQgb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge0FycmF5fSBvcHQuY2VudGVyPVswLCAwXSAtIENlbnRlciBvZiB2aWV3cG9ydFxuICAgKiAgIFtsb25naXR1ZGUsIGxhdGl0dWRlXSBvciBbeCwgeV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5zY2FsZT0xIC0gRWl0aGVyIHVzZSBzY2FsZSBvciB6b29tXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQucGl0Y2g9MCAtIENhbWVyYSBhbmdsZSBpbiBkZWdyZWVzICgwIGlzIHN0cmFpZ2h0IGRvd24pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYmVhcmluZz0wIC0gTWFwIHJvdGF0aW9uIGluIGRlZ3JlZXMgKDAgbWVhbnMgbm9ydGggaXMgdXApXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuYWx0aXR1ZGU9IC0gQWx0aXR1ZGUgb2YgY2FtZXJhIGluIHNjcmVlbiB1bml0c1xuICAgKlxuICAgKiBXZWIgbWVyY2F0b3IgcHJvamVjdGlvbiBzaG9ydC1oYW5kIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC5sYXRpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubG9uZ2l0dWRlIC0gQ2VudGVyIG9mIHZpZXdwb3J0IG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LmNlbnRlcilcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC56b29tIC0gU2NhbGUgPSBNYXRoLnBvdygyLHpvb20pIG9uIG1hcCAoYWx0ZXJuYXRpdmUgdG8gb3B0LnNjYWxlKVxuXG4gICAqIE5vdGVzOlxuICAgKiAgLSBPbmx5IG9uZSBvZiBjZW50ZXIgb3IgW2xhdGl0dWRlLCBsb25naXR1ZGVdIGNhbiBiZSBzcGVjaWZpZWRcbiAgICogIC0gW2xhdGl0dWRlLCBsb25naXR1ZGVdIGNhbiBvbmx5IGJlIHNwZWNpZmllZCB3aGVuIFwibWVyY2F0b3JcIiBpcyB0cnVlXG4gICAqICAtIEFsdGl0dWRlIGhhcyBhIGRlZmF1bHQgdmFsdWUgdGhhdCBtYXRjaGVzIGFzc3VtcHRpb25zIGluIG1hcGJveC1nbFxuICAgKiAgLSB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBmb3JjZWQgdG8gMSBpZiBzdXBwbGllZCBhcyAwLCB0byBhdm9pZFxuICAgKiAgICBkaXZpc2lvbiBieSB6ZXJvLiBUaGlzIGlzIGludGVuZGVkIHRvIHJlZHVjZSB0aGUgYnVyZGVuIG9mIGFwcHMgdG9cbiAgICogICAgdG8gY2hlY2sgdmFsdWVzIGJlZm9yZSBpbnN0YW50aWF0aW5nIGEgVmlld3BvcnQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICAvLyBNYXAgc3RhdGVcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbGF0aXR1ZGUsXG4gICAgbG9uZ2l0dWRlLFxuICAgIHpvb20sXG4gICAgcGl0Y2gsXG4gICAgYmVhcmluZyxcbiAgICBhbHRpdHVkZSxcbiAgICBmYXJaTXVsdGlwbGllciA9IDEwXG4gIH0gPSB7fSkge1xuICAgIC8vIFZpZXdwb3J0IC0gc3VwcG9ydCB1bmRlZmluZWQgYXJndW1lbnRzXG4gICAgd2lkdGggPSB3aWR0aCAhPT0gdW5kZWZpbmVkID8gd2lkdGggOiBERUZBVUxUX01BUF9TVEFURS53aWR0aDtcbiAgICBoZWlnaHQgPSBoZWlnaHQgIT09IHVuZGVmaW5lZCA/IGhlaWdodCA6IERFRkFVTFRfTUFQX1NUQVRFLmhlaWdodDtcbiAgICB6b29tID0gem9vbSAhPT0gdW5kZWZpbmVkID8gem9vbSA6IERFRkFVTFRfTUFQX1NUQVRFLnpvb207XG4gICAgbGF0aXR1ZGUgPSBsYXRpdHVkZSAhPT0gdW5kZWZpbmVkID8gbGF0aXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5sYXRpdHVkZTtcbiAgICBsb25naXR1ZGUgPSBsb25naXR1ZGUgIT09IHVuZGVmaW5lZCA/IGxvbmdpdHVkZSA6IERFRkFVTFRfTUFQX1NUQVRFLmxvbmdpdHVkZTtcbiAgICBiZWFyaW5nID0gYmVhcmluZyAhPT0gdW5kZWZpbmVkID8gYmVhcmluZyA6IERFRkFVTFRfTUFQX1NUQVRFLmJlYXJpbmc7XG4gICAgcGl0Y2ggPSBwaXRjaCAhPT0gdW5kZWZpbmVkID8gcGl0Y2ggOiBERUZBVUxUX01BUF9TVEFURS5waXRjaDtcbiAgICBhbHRpdHVkZSA9IGFsdGl0dWRlICE9PSB1bmRlZmluZWQgPyBhbHRpdHVkZSA6IERFRkFVTFRfTUFQX1NUQVRFLmFsdGl0dWRlO1xuXG4gICAgLy8gU2lsZW50bHkgYWxsb3cgYXBwcyB0byBzZW5kIGluIDAsMCB0byBmYWNpbGl0YXRlIGlzb21vcnBoaWMgcmVuZGVyIGV0Y1xuICAgIHdpZHRoID0gd2lkdGggfHwgMTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgMTtcblxuICAgIGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgem9vbSk7XG4gICAgLy8gQWx0aXR1ZGUgLSBwcmV2ZW50IGRpdmlzaW9uIGJ5IDBcbiAgICAvLyBUT0RPIC0ganVzdCB0aHJvdyBhbiBFcnJvciBpbnN0ZWFkP1xuICAgIGFsdGl0dWRlID0gTWF0aC5tYXgoMC43NSwgYWx0aXR1ZGUpO1xuXG4gICAgY29uc3QgY2VudGVyID0gcHJvamVjdEZsYXQoW2xvbmdpdHVkZSwgbGF0aXR1ZGVdLCBzY2FsZSk7XG5cbiAgICBjb25zdCBkaXN0YW5jZVNjYWxlcyA9IGdldE1lcmNhdG9yRGlzdGFuY2VTY2FsZXMoe2xhdGl0dWRlLCBsb25naXR1ZGUsIHNjYWxlfSk7XG5cbiAgICBjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gbWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZSxcbiAgICAgIGZhclpNdWx0aXBsaWVyXG4gICAgfSk7XG5cbiAgICBjb25zdCB7dmlld01hdHJpeENlbnRlcmVkfSA9IG1ha2VWaWV3TWF0cmljZXNGcm9tTWVyY2F0b3JQYXJhbXMoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIHpvb20sXG4gICAgICBwaXRjaCxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBhbHRpdHVkZSxcbiAgICAgIGRpc3RhbmNlU2NhbGVzLFxuICAgICAgY2VudGVyXG4gICAgfSk7XG5cbiAgICBzdXBlcih7d2lkdGgsIGhlaWdodCwgdmlld01hdHJpeDogdmlld01hdHJpeENlbnRlcmVkLCBwcm9qZWN0aW9uTWF0cml4fSk7XG5cbiAgICAvLyBTYXZlIHBhcmFtZXRlcnNcbiAgICB0aGlzLmxhdGl0dWRlID0gbGF0aXR1ZGU7XG4gICAgdGhpcy5sb25naXR1ZGUgPSBsb25naXR1ZGU7XG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICB0aGlzLnBpdGNoID0gcGl0Y2g7XG4gICAgdGhpcy5iZWFyaW5nID0gYmVhcmluZztcbiAgICB0aGlzLmFsdGl0dWRlID0gYWx0aXR1ZGU7XG5cbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5jZW50ZXIgPSBjZW50ZXI7XG5cbiAgICB0aGlzLl9kaXN0YW5jZVNjYWxlcyA9IGRpc3RhbmNlU2NhbGVzO1xuXG4gICAgYXV0b2JpbmQodGhpcyk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIGNvbXBsZXhpdHkgKi9cblxuICAvKipcbiAgICogUHJvamVjdCBbbG5nLGxhdF0gb24gc3BoZXJlIG9udG8gW3gseV0gb24gNTEyKjUxMiBNZXJjYXRvciBab29tIDAgdGlsZS5cbiAgICogUGVyZm9ybXMgdGhlIG5vbmxpbmVhciBwYXJ0IG9mIHRoZSB3ZWIgbWVyY2F0b3IgcHJvamVjdGlvbi5cbiAgICogUmVtYWluaW5nIHByb2plY3Rpb24gaXMgZG9uZSB3aXRoIDR4NCBtYXRyaWNlcyB3aGljaCBhbHNvIGhhbmRsZXNcbiAgICogcGVyc3BlY3RpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsIGxhdF0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc3BoZXJlIHRvIHByb2plY3Qgb250byB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gW3gseV0gY29vcmRpbmF0ZXMuXG4gICAqL1xuICBfcHJvamVjdEZsYXQobG5nTGF0LCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4gcHJvamVjdEZsYXQobG5nTGF0LCBzY2FsZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wcm9qZWN0IHdvcmxkIHBvaW50IFt4LHldIG9uIG1hcCBvbnRvIHtsYXQsIGxvbn0gb24gc3BoZXJlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fFZlY3Rvcn0geHkgLSBvYmplY3Qgd2l0aCB7eCx5fSBtZW1iZXJzXG4gICAqICByZXByZXNlbnRpbmcgcG9pbnQgb24gcHJvamVjdGVkIG1hcCBwbGFuZVxuICAgKiBAcmV0dXJuIHtHZW9Db29yZGluYXRlc30gLSBvYmplY3Qgd2l0aCB7bGF0LGxvbn0gb2YgcG9pbnQgb24gc3BoZXJlLlxuICAgKiAgIEhhcyB0b0FycmF5IG1ldGhvZCBpZiB5b3UgbmVlZCBhIEdlb0pTT04gQXJyYXkuXG4gICAqICAgUGVyIGNhcnRvZ3JhcGhpYyB0cmFkaXRpb24sIGxhdCBhbmQgbG9uIGFyZSBzcGVjaWZpZWQgYXMgZGVncmVlcy5cbiAgICovXG4gIF91bnByb2plY3RGbGF0KHh5LCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4gdW5wcm9qZWN0RmxhdCh4eSwgc2NhbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIGNlbnRlciB0aGF0IHBsYWNlIGEgZ2l2ZW4gW2xuZywgbGF0XSBjb29yZGluYXRlIGF0IHNjcmVlblxuICAgKiBwb2ludCBbeCwgeV1cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0IC0gW2xuZyxsYXRdIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZS5cbiAgICogQHBhcmFtIHtBcnJheX0gcG9zIC0gW3gseV0gY29vcmRpbmF0ZXNcbiAgICogICBTcGVjaWZpZXMgYSBwb2ludCBvbiB0aGUgc2NyZWVuLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gW2xuZyxsYXRdIG5ldyBtYXAgY2VudGVyLlxuICAgKi9cbiAgZ2V0TG9jYXRpb25BdFBvaW50KHtsbmdMYXQsIHBvc30pIHtcbiAgICBjb25zdCBmcm9tTG9jYXRpb24gPSB0aGlzLnByb2plY3RGbGF0KHRoaXMudW5wcm9qZWN0KHBvcykpO1xuICAgIGNvbnN0IHRvTG9jYXRpb24gPSB0aGlzLnByb2plY3RGbGF0KGxuZ0xhdCk7XG5cbiAgICBjb25zdCBjZW50ZXIgPSB0aGlzLnByb2plY3RGbGF0KFt0aGlzLmxvbmdpdHVkZSwgdGhpcy5sYXRpdHVkZV0pO1xuXG4gICAgY29uc3QgdHJhbnNsYXRlID0gdmVjMl9hZGQoW10sIHRvTG9jYXRpb24sIHZlYzJfbmVnYXRlKFtdLCBmcm9tTG9jYXRpb24pKTtcbiAgICBjb25zdCBuZXdDZW50ZXIgPSB2ZWMyX2FkZChbXSwgY2VudGVyLCB0cmFuc2xhdGUpO1xuICAgIHJldHVybiB0aGlzLnVucHJvamVjdEZsYXQobmV3Q2VudGVyKTtcbiAgfVxuXG4gIC8qXG4gIGdldExuZ0xhdEF0Vmlld3BvcnRQb3NpdGlvbihsbmdsYXQsIHh5KSB7XG4gICAgY29uc3QgYyA9IHRoaXMubG9jYXRpb25Db29yZGluYXRlKGxuZ2xhdCk7XG4gICAgY29uc3QgY29vcmRBdFBvaW50ID0gdGhpcy5wb2ludENvb3JkaW5hdGUoeHkpO1xuICAgIGNvbnN0IGNvb3JkQ2VudGVyID0gdGhpcy5wb2ludENvb3JkaW5hdGUodGhpcy5jZW50ZXJQb2ludCk7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gY29vcmRBdFBvaW50Ll9zdWIoYyk7XG4gICAgdGhpcy5jZW50ZXIgPSB0aGlzLmNvb3JkaW5hdGVMb2NhdGlvbihjb29yZENlbnRlci5fc3ViKHRyYW5zbGF0ZSkpO1xuICB9XG4gICovXG5cbiAgZ2V0RGlzdGFuY2VTY2FsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgbWV0ZXIgb2Zmc2V0IHRvIGEgbG5nbGF0IG9mZnNldFxuICAgKlxuICAgKiBOb3RlOiBVc2VzIHNpbXBsZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBhcm91bmQgdGhlIHZpZXdwb3J0IGNlbnRlclxuICAgKiBFcnJvciBpbmNyZWFzZXMgd2l0aCBzaXplIG9mIG9mZnNldCAocm91Z2hseSAxJSBwZXIgMTAwa20pXG4gICAqXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIHh5eiAtIGFycmF5IG9mIG1ldGVyIGRlbHRhc1xuICAgKiBAcmV0dXJuIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgLSBhcnJheSBvZiBbbG5nLGxhdCx6XSBkZWx0YXNcbiAgICovXG4gIG1ldGVyc1RvTG5nTGF0RGVsdGEoeHl6KSB7XG4gICAgY29uc3QgW3gsIHksIHogPSAwXSA9IHh5ejtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHgpICYmIE51bWJlci5pc0Zpbml0ZSh5KSAmJiBOdW1iZXIuaXNGaW5pdGUoeiksIEVSUl9BUkdVTUVOVCk7XG4gICAgY29uc3Qge3BpeGVsc1Blck1ldGVyLCBkZWdyZWVzUGVyUGl4ZWx9ID0gdGhpcy5fZGlzdGFuY2VTY2FsZXM7XG4gICAgY29uc3QgZGVsdGFMbmcgPSB4ICogcGl4ZWxzUGVyTWV0ZXJbMF0gKiBkZWdyZWVzUGVyUGl4ZWxbMF07XG4gICAgY29uc3QgZGVsdGFMYXQgPSB5ICogcGl4ZWxzUGVyTWV0ZXJbMV0gKiBkZWdyZWVzUGVyUGl4ZWxbMV07XG4gICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyBbZGVsdGFMbmcsIGRlbHRhTGF0XSA6IFtkZWx0YUxuZywgZGVsdGFMYXQsIHpdO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgbG5nbGF0IG9mZnNldCB0byBhIG1ldGVyIG9mZnNldFxuICAgKlxuICAgKiBOb3RlOiBVc2VzIHNpbXBsZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBhcm91bmQgdGhlIHZpZXdwb3J0IGNlbnRlclxuICAgKiBFcnJvciBpbmNyZWFzZXMgd2l0aCBzaXplIG9mIG9mZnNldCAocm91Z2hseSAxJSBwZXIgMTAwa20pXG4gICAqXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIGRlbHRhTG5nTGF0WiAtIGFycmF5IG9mIFtsbmcsbGF0LHpdIGRlbHRhc1xuICAgKiBAcmV0dXJuIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICovXG4gIGxuZ0xhdERlbHRhVG9NZXRlcnMoZGVsdGFMbmdMYXRaKSB7XG4gICAgY29uc3QgW2RlbHRhTG5nLCBkZWx0YUxhdCwgZGVsdGFaID0gMF0gPSBkZWx0YUxuZ0xhdFo7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShkZWx0YUxuZykgJiYgTnVtYmVyLmlzRmluaXRlKGRlbHRhTGF0KSAmJiBOdW1iZXIuaXNGaW5pdGUoZGVsdGFaKSxcbiAgICAgIEVSUl9BUkdVTUVOVCk7XG4gICAgY29uc3Qge3BpeGVsc1BlckRlZ3JlZSwgbWV0ZXJzUGVyUGl4ZWx9ID0gdGhpcy5fZGlzdGFuY2VTY2FsZXM7XG4gICAgY29uc3QgZGVsdGFYID0gZGVsdGFMbmcgKiBwaXhlbHNQZXJEZWdyZWVbMF0gKiBtZXRlcnNQZXJQaXhlbFswXTtcbiAgICBjb25zdCBkZWx0YVkgPSBkZWx0YUxhdCAqIHBpeGVsc1BlckRlZ3JlZVsxXSAqIG1ldGVyc1BlclBpeGVsWzFdO1xuICAgIHJldHVybiBkZWx0YUxuZ0xhdFoubGVuZ3RoID09PSAyID8gW2RlbHRhWCwgZGVsdGFZXSA6IFtkZWx0YVgsIGRlbHRhWSwgZGVsdGFaXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBtZXRlciBkZWx0YSB0byBhIGJhc2UgbG5nbGF0IGNvb3JkaW5hdGUsIHJldHVybmluZyBhIG5ldyBsbmdsYXQgYXJyYXlcbiAgICpcbiAgICogTm90ZTogVXNlcyBzaW1wbGUgbGluZWFyIGFwcHJveGltYXRpb24gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcbiAgICogRXJyb3IgaW5jcmVhc2VzIHdpdGggc2l6ZSBvZiBvZmZzZXQgKHJvdWdobHkgMSUgcGVyIDEwMGttKVxuICAgKlxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSBsbmdMYXRaIC0gYmFzZSBjb29yZGluYXRlXG4gICAqIEBwYXJhbSB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIHh5eiAtIGFycmF5IG9mIG1ldGVyIGRlbHRhc1xuICAgKiBAcmV0dXJuIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgYXJyYXkgb2YgW2xuZyxsYXQsel0gZGVsdGFzXG4gICAqL1xuICBhZGRNZXRlcnNUb0xuZ0xhdChsbmdMYXRaLCB4eXopIHtcbiAgICBjb25zdCBbbG5nLCBsYXQsIFogPSAwXSA9IGxuZ0xhdFo7XG4gICAgY29uc3QgW2RlbHRhTG5nLCBkZWx0YUxhdCwgZGVsdGFaID0gMF0gPSB0aGlzLm1ldGVyc1RvTG5nTGF0RGVsdGEoeHl6KTtcbiAgICByZXR1cm4gbG5nTGF0Wi5sZW5ndGggPT09IDIgP1xuICAgICAgW2xuZyArIGRlbHRhTG5nLCBsYXQgKyBkZWx0YUxhdF0gOlxuICAgICAgW2xuZyArIGRlbHRhTG5nLCBsYXQgKyBkZWx0YUxhdCwgWiArIGRlbHRhWl07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyB2aWV3cG9ydCB0aGF0IGZpdCBhcm91bmQgdGhlIGdpdmVuIHJlY3RhbmdsZS5cbiAgICogT25seSBzdXBwb3J0cyBub24tcGVyc3BlY3RpdmUgbW9kZS5cbiAgICogQHBhcmFtIHtBcnJheX0gYm91bmRzIC0gW1tsb24sIGxhdF0sIFtsb24sIGxhdF1dXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wYWRkaW5nXSAtIFRoZSBhbW91bnQgb2YgcGFkZGluZyBpbiBwaXhlbHMgdG8gYWRkIHRvIHRoZSBnaXZlbiBib3VuZHMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm9mZnNldF0gLSBUaGUgY2VudGVyIG9mIHRoZSBnaXZlbiBib3VuZHMgcmVsYXRpdmUgdG8gdGhlIG1hcCdzIGNlbnRlcixcbiAgICogICAgW3gsIHldIG1lYXN1cmVkIGluIHBpeGVscy5cbiAgICogQHJldHVybnMge1dlYk1lcmNhdG9yVmlld3BvcnR9XG4gICAqL1xuICBmaXRCb3VuZHMoYm91bmRzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzO1xuICAgIGNvbnN0IHtsb25naXR1ZGUsIGxhdGl0dWRlLCB6b29tfSA9IGZpdEJvdW5kcyhPYmplY3QuYXNzaWduKHt3aWR0aCwgaGVpZ2h0LCBib3VuZHN9LCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHt3aWR0aCwgaGVpZ2h0LCBsb25naXR1ZGUsIGxhdGl0dWRlLCB6b29tfSk7XG4gIH1cblxuICAvLyBJTlRFUk5BTCBNRVRIT0RTXG5cbiAgX2dldFBhcmFtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VTY2FsZXM7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIG1hcCBzZXR0aW5ncyB7bGF0aXR1ZGUsIGxvbmdpdHVkZSwgem9vbX1cbiAqIHRoYXQgd2lsbCBjb250YWluIHRoZSBwcm92aWRlZCBjb3JuZXJzIHdpdGhpbiB0aGUgcHJvdmlkZWQgd2lkdGguXG4gKiBPbmx5IHN1cHBvcnRzIG5vbi1wZXJzcGVjdGl2ZSBtb2RlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gdmlld3BvcnQgd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSB2aWV3cG9ydCBoZWlnaHRcbiAqIEBwYXJhbSB7QXJyYXl9IGJvdW5kcyAtIFtbbG9uLCBsYXRdLCBbbG9uLCBsYXRdXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtwYWRkaW5nXSAtIFRoZSBhbW91bnQgb2YgcGFkZGluZyBpbiBwaXhlbHMgdG8gYWRkIHRvIHRoZSBnaXZlbiBib3VuZHMuXG4gKiBAcGFyYW0ge0FycmF5fSBbb2Zmc2V0XSAtIFRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIGJvdW5kcyByZWxhdGl2ZSB0byB0aGUgbWFwJ3MgY2VudGVyLFxuICogICAgW3gsIHldIG1lYXN1cmVkIGluIHBpeGVscy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gbGF0aXR1ZGUsIGxvbmdpdHVkZSBhbmQgem9vbVxuICovXG5leHBvcnQgZnVuY3Rpb24gZml0Qm91bmRzKHtcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgYm91bmRzLFxuICAvLyBvcHRpb25zXG4gIHBhZGRpbmcgPSAwLFxuICBvZmZzZXQgPSBbMCwgMF1cbn0pIHtcbiAgY29uc3QgW1t3ZXN0LCBzb3V0aF0sIFtlYXN0LCBub3J0aF1dID0gYm91bmRzO1xuXG4gIGNvbnN0IHZpZXdwb3J0ID0gbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBsb25naXR1ZGU6IDAsXG4gICAgbGF0aXR1ZGU6IDAsXG4gICAgem9vbTogMFxuICB9KTtcblxuICBjb25zdCBudyA9IHZpZXdwb3J0LnByb2plY3QoW3dlc3QsIG5vcnRoXSk7XG4gIGNvbnN0IHNlID0gdmlld3BvcnQucHJvamVjdChbZWFzdCwgc291dGhdKTtcbiAgY29uc3Qgc2l6ZSA9IFtcbiAgICBNYXRoLmFicyhzZVswXSAtIG53WzBdKSxcbiAgICBNYXRoLmFicyhzZVsxXSAtIG53WzFdKVxuICBdO1xuICBjb25zdCBjZW50ZXIgPSBbXG4gICAgKHNlWzBdICsgbndbMF0pIC8gMixcbiAgICAoc2VbMV0gKyBud1sxXSkgLyAyXG4gIF07XG5cbiAgY29uc3Qgc2NhbGVYID0gKHdpZHRoIC0gcGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXRbMF0pICogMikgLyBzaXplWzBdO1xuICBjb25zdCBzY2FsZVkgPSAoaGVpZ2h0IC0gcGFkZGluZyAqIDIgLSBNYXRoLmFicyhvZmZzZXRbMV0pICogMikgLyBzaXplWzFdO1xuXG4gIGNvbnN0IGNlbnRlckxuZ0xhdCA9IHZpZXdwb3J0LnVucHJvamVjdChjZW50ZXIpO1xuICBjb25zdCB6b29tID0gdmlld3BvcnQuem9vbSArIE1hdGgubG9nMihNYXRoLmFicyhNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSkpKTtcblxuICByZXR1cm4ge1xuICAgIGxvbmdpdHVkZTogY2VudGVyTG5nTGF0WzBdLFxuICAgIGxhdGl0dWRlOiBjZW50ZXJMbmdMYXRbMV0sXG4gICAgem9vbVxuICB9O1xufVxuIl19