'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fitBounds = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _mercatorViewport = require('./mercator-viewport');

var _mercatorViewport2 = _interopRequireDefault(_mercatorViewport);

var _autobind = require('./autobind');

var _autobind2 = _interopRequireDefault(_autobind);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _webMercatorUtils = require('./web-mercator-utils');

var _add = require('gl-vec2/add');

var _add2 = _interopRequireDefault(_add);

var _negate = require('gl-vec2/negate');

var _negate2 = _interopRequireDefault(_negate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // View and Projection Matrix calculations for mapbox-js style map view properties


/* eslint-disable camelcase */


var DEFAULT_MAP_STATE = {
  latitude: 37,
  longitude: -122,
  zoom: 11,
  pitch: 0,
  bearing: 0,
  altitude: 1.5
};

var ERR_ARGUMENT = 'Illegal argument to WebMercatorViewport';

var WebMercatorViewport = function (_MercatorViewport) {
  _inherits(WebMercatorViewport, _MercatorViewport);

  /**
   * @classdesc
   * Creates view/projection matrices from mercator params
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   *
   * @class
   * @param {Object} opt - options
   * @param {Boolean} mercator=true - Whether to use mercator projection
   *
   * @param {Number} opt.width=1 - Width of "viewport" or window
   * @param {Number} opt.height=1 - Height of "viewport" or window
   * @param {Array} opt.center=[0, 0] - Center of viewport
   *   [longitude, latitude] or [x, y]
   * @param {Number} opt.scale=1 - Either use scale or zoom
   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
   * @param {Number} opt.altitude= - Altitude of camera in screen units
   *
   * Web mercator projection short-hand parameters
   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
    * Notes:
   *  - Only one of center or [latitude, longitude] can be specified
   *  - [latitude, longitude] can only be specified when "mercator" is true
   *  - Altitude has a default value that matches assumptions in mapbox-gl
   *  - width and height are forced to 1 if supplied as 0, to avoid
   *    division by zero. This is intended to reduce the burden of apps to
   *    to check values before instantiating a Viewport.
   */
  /* eslint-disable complexity */
  function WebMercatorViewport() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        width = _ref.width,
        height = _ref.height,
        latitude = _ref.latitude,
        longitude = _ref.longitude,
        zoom = _ref.zoom,
        pitch = _ref.pitch,
        bearing = _ref.bearing,
        altitude = _ref.altitude,
        _ref$farZMultiplier = _ref.farZMultiplier,
        farZMultiplier = _ref$farZMultiplier === undefined ? 10 : _ref$farZMultiplier;

    _classCallCheck(this, WebMercatorViewport);

    // Viewport - support undefined arguments
    width = width !== undefined ? width : DEFAULT_MAP_STATE.width;
    height = height !== undefined ? height : DEFAULT_MAP_STATE.height;
    zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;
    latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;
    longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;
    bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;
    pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;
    altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude;

    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc
    width = width || 1;
    height = height || 1;

    var scale = Math.pow(2, zoom);
    // Altitude - prevent division by 0
    // TODO - just throw an Error instead?
    altitude = Math.max(0.75, altitude);

    var center = (0, _webMercatorUtils.projectFlat)([longitude, latitude], scale);

    var distanceScales = (0, _webMercatorUtils.getMercatorDistanceScales)({ latitude: latitude, longitude: longitude, scale: scale });

    var projectionMatrix = (0, _webMercatorUtils.makeProjectionMatrixFromMercatorParams)({
      width: width,
      height: height,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      farZMultiplier: farZMultiplier
    });

    var _makeViewMatricesFrom = (0, _webMercatorUtils.makeViewMatricesFromMercatorParams)({
      width: width,
      height: height,
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      pitch: pitch,
      bearing: bearing,
      altitude: altitude,
      distanceScales: distanceScales,
      center: center
    }),
        viewMatrixCentered = _makeViewMatricesFrom.viewMatrixCentered;

    // Save parameters
    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, { width: width, height: height, viewMatrix: viewMatrixCentered, projectionMatrix: projectionMatrix }));

    _this.latitude = latitude;
    _this.longitude = longitude;
    _this.zoom = zoom;
    _this.pitch = pitch;
    _this.bearing = bearing;
    _this.altitude = altitude;

    _this.scale = scale;
    _this.center = center;

    _this._distanceScales = distanceScales;

    (0, _autobind2.default)(_this);
    Object.freeze(_this);
    return _this;
  }
  /* eslint-enable complexity */

  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   *
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */


  _createClass(WebMercatorViewport, [{
    key: '_projectFlat',
    value: function _projectFlat(lngLat) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return (0, _webMercatorUtils.projectFlat)(lngLat, scale);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     *
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xy) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return (0, _webMercatorUtils.unprojectFlat)(xy, scale);
    }

    /**
     * Get the map center that place a given [lng, lat] coordinate at screen
     * point [x, y]
     *
     * @param {Array} lngLat - [lng,lat] coordinates
     *   Specifies a point on the sphere.
     * @param {Array} pos - [x,y] coordinates
     *   Specifies a point on the screen.
     * @return {Array} [lng,lat] new map center.
     */

  }, {
    key: 'getLocationAtPoint',
    value: function getLocationAtPoint(_ref2) {
      var lngLat = _ref2.lngLat,
          pos = _ref2.pos;

      var fromLocation = this.projectFlat(this.unproject(pos));
      var toLocation = this.projectFlat(lngLat);

      var center = this.projectFlat([this.longitude, this.latitude]);

      var translate = (0, _add2.default)([], toLocation, (0, _negate2.default)([], fromLocation));
      var newCenter = (0, _add2.default)([], center, translate);
      return this.unprojectFlat(newCenter);
    }

    /*
    getLngLatAtViewportPosition(lnglat, xy) {
      const c = this.locationCoordinate(lnglat);
      const coordAtPoint = this.pointCoordinate(xy);
      const coordCenter = this.pointCoordinate(this.centerPoint);
      const translate = coordAtPoint._sub(c);
      this.center = this.coordinateLocation(coordCenter._sub(translate));
    }
    */

  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      return this._distanceScales;
    }

    /**
     * Converts a meter offset to a lnglat offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas
     */

  }, {
    key: 'metersToLngLatDelta',
    value: function metersToLngLatDelta(xyz) {
      var _xyz = _slicedToArray(xyz, 3),
          x = _xyz[0],
          y = _xyz[1],
          _xyz$ = _xyz[2],
          z = _xyz$ === undefined ? 0 : _xyz$;

      (0, _assert2.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _distanceScales = this._distanceScales,
          pixelsPerMeter = _distanceScales.pixelsPerMeter,
          degreesPerPixel = _distanceScales.degreesPerPixel;

      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }

    /**
     * Converts a lnglat offset to a meter offset
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas
     * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas
     */

  }, {
    key: 'lngLatDeltaToMeters',
    value: function lngLatDeltaToMeters(deltaLngLatZ) {
      var _deltaLngLatZ = _slicedToArray(deltaLngLatZ, 3),
          deltaLng = _deltaLngLatZ[0],
          deltaLat = _deltaLngLatZ[1],
          _deltaLngLatZ$ = _deltaLngLatZ[2],
          deltaZ = _deltaLngLatZ$ === undefined ? 0 : _deltaLngLatZ$;

      (0, _assert2.default)(Number.isFinite(deltaLng) && Number.isFinite(deltaLat) && Number.isFinite(deltaZ), ERR_ARGUMENT);
      var _distanceScales2 = this._distanceScales,
          pixelsPerDegree = _distanceScales2.pixelsPerDegree,
          metersPerPixel = _distanceScales2.metersPerPixel;

      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];
      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];
      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];
    }

    /**
     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
     *
     * Note: Uses simple linear approximation around the viewport center
     * Error increases with size of offset (roughly 1% per 100km)
     *
     * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
     * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
     */

  }, {
    key: 'addMetersToLngLat',
    value: function addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = _slicedToArray(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;

      var _metersToLngLatDelta = this.metersToLngLatDelta(xyz),
          _metersToLngLatDelta2 = _slicedToArray(_metersToLngLatDelta, 3),
          deltaLng = _metersToLngLatDelta2[0],
          deltaLat = _metersToLngLatDelta2[1],
          _metersToLngLatDelta3 = _metersToLngLatDelta2[2],
          deltaZ = _metersToLngLatDelta3 === undefined ? 0 : _metersToLngLatDelta3;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }

    /**
     * Returns a new viewport that fit around the given rectangle.
     * Only supports non-perspective mode.
     * @param {Array} bounds - [[lon, lat], [lon, lat]]
     * @param {Number} [options.padding] - The amount of padding in pixels to add to the given bounds.
     * @param {Array} [options.offset] - The center of the given bounds relative to the map's center,
     *    [x, y] measured in pixels.
     * @returns {WebMercatorViewport}
     */

  }, {
    key: 'fitBounds',
    value: function fitBounds(bounds) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var width = this.width,
          height = this.height;

      var _fitBounds2 = _fitBounds(Object.assign({ width: width, height: height, bounds: bounds }, options)),
          longitude = _fitBounds2.longitude,
          latitude = _fitBounds2.latitude,
          zoom = _fitBounds2.zoom;

      return new WebMercatorViewport({ width: width, height: height, longitude: longitude, latitude: latitude, zoom: zoom });
    }

    // INTERNAL METHODS

  }, {
    key: '_getParams',
    value: function _getParams() {
      return this._distanceScales;
    }
  }]);

  return WebMercatorViewport;
}(_mercatorViewport2.default);

/**
 * Returns map settings {latitude, longitude, zoom}
 * that will contain the provided corners within the provided width.
 * Only supports non-perspective mode.
 * @param {Number} width - viewport width
 * @param {Number} height - viewport height
 * @param {Array} bounds - [[lon, lat], [lon, lat]]
 * @param {Number} [padding] - The amount of padding in pixels to add to the given bounds.
 * @param {Array} [offset] - The center of the given bounds relative to the map's center,
 *    [x, y] measured in pixels.
 * @returns {Object} - latitude, longitude and zoom
 */


exports.default = WebMercatorViewport;
function _fitBounds(_ref3) {
  var width = _ref3.width,
      height = _ref3.height,
      bounds = _ref3.bounds,
      _ref3$padding = _ref3.padding,
      padding = _ref3$padding === undefined ? 0 : _ref3$padding,
      _ref3$offset = _ref3.offset,
      offset = _ref3$offset === undefined ? [0, 0] : _ref3$offset;

  var _bounds = _slicedToArray(bounds, 2),
      _bounds$ = _slicedToArray(_bounds[0], 2),
      west = _bounds$[0],
      south = _bounds$[1],
      _bounds$2 = _slicedToArray(_bounds[1], 2),
      east = _bounds$2[0],
      north = _bounds$2[1];

  var viewport = new WebMercatorViewport({
    width: width,
    height: height,
    longitude: 0,
    latitude: 0,
    zoom: 0
  });

  var nw = viewport.project([west, north]);
  var se = viewport.project([east, south]);
  var size = [Math.abs(se[0] - nw[0]), Math.abs(se[1] - nw[1])];
  var center = [(se[0] + nw[0]) / 2, (se[1] + nw[1]) / 2];

  var scaleX = (width - padding * 2 - Math.abs(offset[0]) * 2) / size[0];
  var scaleY = (height - padding * 2 - Math.abs(offset[1]) * 2) / size[1];

  var centerLngLat = viewport.unproject(center);
  var zoom = viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY)));

  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom: zoom
  };
}
exports.fitBounds = _fitBounds;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wZXJzcGVjdGl2ZS1tZXJjYXRvci12aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJERUZBVUxUX01BUF9TVEFURSIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInBpdGNoIiwiYmVhcmluZyIsImFsdGl0dWRlIiwiRVJSX0FSR1VNRU5UIiwiV2ViTWVyY2F0b3JWaWV3cG9ydCIsIndpZHRoIiwiaGVpZ2h0IiwiZmFyWk11bHRpcGxpZXIiLCJ1bmRlZmluZWQiLCJzY2FsZSIsIk1hdGgiLCJwb3ciLCJtYXgiLCJjZW50ZXIiLCJkaXN0YW5jZVNjYWxlcyIsInByb2plY3Rpb25NYXRyaXgiLCJ2aWV3TWF0cml4Q2VudGVyZWQiLCJ2aWV3TWF0cml4IiwiX2Rpc3RhbmNlU2NhbGVzIiwiT2JqZWN0IiwiZnJlZXplIiwibG5nTGF0IiwieHkiLCJwb3MiLCJmcm9tTG9jYXRpb24iLCJwcm9qZWN0RmxhdCIsInVucHJvamVjdCIsInRvTG9jYXRpb24iLCJ0cmFuc2xhdGUiLCJuZXdDZW50ZXIiLCJ1bnByb2plY3RGbGF0IiwieHl6IiwieCIsInkiLCJ6IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJwaXhlbHNQZXJNZXRlciIsImRlZ3JlZXNQZXJQaXhlbCIsImRlbHRhTG5nIiwiZGVsdGFMYXQiLCJsZW5ndGgiLCJkZWx0YUxuZ0xhdFoiLCJkZWx0YVoiLCJwaXhlbHNQZXJEZWdyZWUiLCJtZXRlcnNQZXJQaXhlbCIsImRlbHRhWCIsImRlbHRhWSIsImxuZ0xhdFoiLCJsbmciLCJsYXQiLCJaIiwibWV0ZXJzVG9MbmdMYXREZWx0YSIsImJvdW5kcyIsIm9wdGlvbnMiLCJmaXRCb3VuZHMiLCJhc3NpZ24iLCJwYWRkaW5nIiwib2Zmc2V0Iiwid2VzdCIsInNvdXRoIiwiZWFzdCIsIm5vcnRoIiwidmlld3BvcnQiLCJudyIsInByb2plY3QiLCJzZSIsInNpemUiLCJhYnMiLCJzY2FsZVgiLCJzY2FsZVkiLCJjZW50ZXJMbmdMYXQiLCJsb2cyIiwibWlu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QUtILFNBQVNFLE9BQVQsQ0FBaUIsQ0FBQ0osSUFBRCxFQUFPRCxLQUFQLENBQWpCLENBQVg7QUFDQSxNQUFNTyxPQUFPLENBQ1h6RCxLQUFLMEQsR0FBTCxDQUFTRixHQUFHLENBQUgsSUFBUUYsR0FBRyxDQUFILENBQWpCLENBRFcsRUFFWHRELEtBQUswRCxHQUFMLENBQVNGLEdBQUcsQ0FBSCxJQUFRRixHQUFHLENBQUgsQ0FBakIsQ0FGVyxDQUFiO0FBSUEsTUFBTW5ELFNBQVMsQ0FDYixDQUFDcUQsR0FBRyxDQUFILElBQVFGLEdBQUcsQ0FBSCxDQUFULElBQWtCLENBREwsRUFFYixDQUFDRSxHQUFHLENBQUgsSUFBUUYsR0FBRyxDQUFILENBQVQsSUFBa0IsQ0FGTCxDQUFmOztBQUtBLE1BQU1LLFNBQVMsQ0FBQ2hFLFFBQVFvRCxVQUFVLENBQWxCLEdBQXNCL0MsS0FBSzBELEdBQUwsQ0FBU1YsT0FBTyxDQUFQLENBQVQsSUFBc0IsQ0FBN0MsSUFBa0RTLEtBQUssQ0FBTCxDQUFqRTtBQUNBLE1BQU1HLFNBQVMsQ0FBQ2hFLFNBQVNtRCxVQUFVLENBQW5CLEdBQXVCL0MsS0FBSzBELEdBQUwsQ0FBU1YsT0FBTyxDQUFQLENBQVQsSUFBc0IsQ0FBOUMsSUFBbURTLEtBQUssQ0FBTCxDQUFsRTs7QUFFQSxNQUFNSSxlQUFlUixTQUFTckMsU0FBVCxDQUFtQmIsTUFBbkIsQ0FBckI7QUFDQSxNQUFNZCxPQUFPZ0UsU0FBU2hFLElBQVQsR0FBZ0JXLEtBQUs4RCxJQUFMLENBQVU5RCxLQUFLMEQsR0FBTCxDQUFTMUQsS0FBSytELEdBQUwsQ0FBU0osTUFBVCxFQUFpQkMsTUFBakIsQ0FBVCxDQUFWLENBQTdCOztBQUVBLFNBQU87QUFDTHhFLGVBQVd5RSxhQUFhLENBQWIsQ0FETjtBQUVMMUUsY0FBVTBFLGFBQWEsQ0FBYixDQUZMO0FBR0x4RTtBQUhLLEdBQVA7QUFLRCIsImZpbGUiOiJwZXJzcGVjdGl2ZS1tZXJjYXRvci12aWV3cG9ydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFZpZXcgYW5kIFByb2plY3Rpb24gTWF0cml4IGNhbGN1bGF0aW9ucyBmb3IgbWFwYm94LWpzIHN0eWxlIG1hcCB2aWV3IHByb3BlcnRpZXNcbmltcG9ydCBNZXJjYXRvclZpZXdwb3J0IGZyb20gJy4vbWVyY2F0b3Itdmlld3BvcnQnO1xuaW1wb3J0IGF1dG9iaW5kIGZyb20gJy4vYXV0b2JpbmQnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5pbXBvcnQge1xuICBwcm9qZWN0RmxhdCxcbiAgdW5wcm9qZWN0RmxhdCxcbiAgZ2V0TWVyY2F0b3JEaXN0YW5jZVNjYWxlcyxcbiAgbWFrZVByb2plY3Rpb25NYXRyaXhGcm9tTWVyY2F0b3JQYXJhbXMsXG4gIG1ha2VWaWV3TWF0cmljZXNGcm9tTWVyY2F0b3JQYXJhbXNcbn0gZnJvbSAnLi93ZWItbWVyY2F0b3ItdXRpbHMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbmltcG9ydCB2ZWMyX2FkZCBmcm9tICdnbC12ZWMyL2FkZCc7XG5pbXBvcnQgdmVjMl9uZWdhdGUgZnJvbSAnZ2wtdmVjMi9uZWdhdGUnO1xuXG5jb25zdCBERUZBVUxUX01BUF9TVEFURSA9IHtcbiAgbGF0aXR1ZGU6IDM3LFxuICBsb25naXR1ZGU6IC0xMjIsXG4gIHpvb206IDExLFxuICBwaXRjaDogMCxcbiAgYmVhcmluZzogMCxcbiAgYWx0aXR1ZGU6IDEuNVxufTtcblxuY29uc3QgRVJSX0FSR1VNRU5UID0gJ0lsbGVnYWwgYXJndW1lbnQgdG8gV2ViTWVyY2F0b3JWaWV3cG9ydCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYk1lcmNhdG9yVmlld3BvcnQgZXh0ZW5kcyBNZXJjYXRvclZpZXdwb3J0IHtcbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogQ3JlYXRlcyB2aWV3L3Byb2plY3Rpb24gbWF0cmljZXMgZnJvbSBtZXJjYXRvciBwYXJhbXNcbiAgICogTm90ZTogVGhlIFZpZXdwb3J0IGlzIGltbXV0YWJsZSBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBvbmx5IGhhcyBhY2Nlc3NvcnMuXG4gICAqIEEgbmV3IHZpZXdwb3J0IGluc3RhbmNlIHNob3VsZCBiZSBjcmVhdGVkIGlmIGFueSBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZC5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHQgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWVyY2F0b3I9dHJ1ZSAtIFdoZXRoZXIgdG8gdXNlIG1lcmNhdG9yIHByb2plY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdC53aWR0aD0xIC0gV2lkdGggb2YgXCJ2aWV3cG9ydFwiIG9yIHdpbmRvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmhlaWdodD0xIC0gSGVpZ2h0IG9mIFwidmlld3BvcnRcIiBvciB3aW5kb3dcbiAgICogQHBhcmFtIHtBcnJheX0gb3B0LmNlbnRlcj1bMCwgMF0gLSBDZW50ZXIgb2Ygdmlld3BvcnRcbiAgICogICBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gb3IgW3gsIHldXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuc2NhbGU9MSAtIEVpdGhlciB1c2Ugc2NhbGUgb3Igem9vbVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LnBpdGNoPTAgLSBDYW1lcmEgYW5nbGUgaW4gZGVncmVlcyAoMCBpcyBzdHJhaWdodCBkb3duKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmJlYXJpbmc9MCAtIE1hcCByb3RhdGlvbiBpbiBkZWdyZWVzICgwIG1lYW5zIG5vcnRoIGlzIHVwKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmFsdGl0dWRlPSAtIEFsdGl0dWRlIG9mIGNhbWVyYSBpbiBzY3JlZW4gdW5pdHNcbiAgICpcbiAgICogV2ViIG1lcmNhdG9yIHByb2plY3Rpb24gc2hvcnQtaGFuZCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQubGF0aXR1ZGUgLSBDZW50ZXIgb2Ygdmlld3BvcnQgb24gbWFwIChhbHRlcm5hdGl2ZSB0byBvcHQuY2VudGVyKVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0LmxvbmdpdHVkZSAtIENlbnRlciBvZiB2aWV3cG9ydCBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5jZW50ZXIpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHQuem9vbSAtIFNjYWxlID0gTWF0aC5wb3coMix6b29tKSBvbiBtYXAgKGFsdGVybmF0aXZlIHRvIG9wdC5zY2FsZSlcblxuICAgKiBOb3RlczpcbiAgICogIC0gT25seSBvbmUgb2YgY2VudGVyIG9yIFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSBjYW4gYmUgc3BlY2lmaWVkXG4gICAqICAtIFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSBjYW4gb25seSBiZSBzcGVjaWZpZWQgd2hlbiBcIm1lcmNhdG9yXCIgaXMgdHJ1ZVxuICAgKiAgLSBBbHRpdHVkZSBoYXMgYSBkZWZhdWx0IHZhbHVlIHRoYXQgbWF0Y2hlcyBhc3N1bXB0aW9ucyBpbiBtYXBib3gtZ2xcbiAgICogIC0gd2lkdGggYW5kIGhlaWdodCBhcmUgZm9yY2VkIHRvIDEgaWYgc3VwcGxpZWQgYXMgMCwgdG8gYXZvaWRcbiAgICogICAgZGl2aXNpb24gYnkgemVyby4gVGhpcyBpcyBpbnRlbmRlZCB0byByZWR1Y2UgdGhlIGJ1cmRlbiBvZiBhcHBzIHRvXG4gICAqICAgIHRvIGNoZWNrIHZhbHVlcyBiZWZvcmUgaW5zdGFudGlhdGluZyBhIFZpZXdwb3J0LlxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgLy8gTWFwIHN0YXRlXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGxhdGl0dWRlLFxuICAgIGxvbmdpdHVkZSxcbiAgICB6b29tLFxuICAgIHBpdGNoLFxuICAgIGJlYXJpbmcsXG4gICAgYWx0aXR1ZGUsXG4gICAgZmFyWk11bHRpcGxpZXIgPSAxMFxuICB9ID0ge30pIHtcbiAgICAvLyBWaWV3cG9ydCAtIHN1cHBvcnQgdW5kZWZpbmVkIGFyZ3VtZW50c1xuICAgIHdpZHRoID0gd2lkdGggIT09IHVuZGVmaW5lZCA/IHdpZHRoIDogREVGQVVMVF9NQVBfU1RBVEUud2lkdGg7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiBERUZBVUxUX01BUF9TVEFURS5oZWlnaHQ7XG4gICAgem9vbSA9IHpvb20gIT09IHVuZGVmaW5lZCA/IHpvb20gOiBERUZBVUxUX01BUF9TVEFURS56b29tO1xuICAgIGxhdGl0dWRlID0gbGF0aXR1ZGUgIT09IHVuZGVmaW5lZCA/IGxhdGl0dWRlIDogREVGQVVMVF9NQVBfU1RBVEUubGF0aXR1ZGU7XG4gICAgbG9uZ2l0dWRlID0gbG9uZ2l0dWRlICE9PSB1bmRlZmluZWQgPyBsb25naXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5sb25naXR1ZGU7XG4gICAgYmVhcmluZyA9IGJlYXJpbmcgIT09IHVuZGVmaW5lZCA/IGJlYXJpbmcgOiBERUZBVUxUX01BUF9TVEFURS5iZWFyaW5nO1xuICAgIHBpdGNoID0gcGl0Y2ggIT09IHVuZGVmaW5lZCA/IHBpdGNoIDogREVGQVVMVF9NQVBfU1RBVEUucGl0Y2g7XG4gICAgYWx0aXR1ZGUgPSBhbHRpdHVkZSAhPT0gdW5kZWZpbmVkID8gYWx0aXR1ZGUgOiBERUZBVUxUX01BUF9TVEFURS5hbHRpdHVkZTtcblxuICAgIC8vIFNpbGVudGx5IGFsbG93IGFwcHMgdG8gc2VuZCBpbiAwLDAgdG8gZmFjaWxpdGF0ZSBpc29tb3JwaGljIHJlbmRlciBldGNcbiAgICB3aWR0aCA9IHdpZHRoIHx8IDE7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XG5cbiAgICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIHpvb20pO1xuICAgIC8vIEFsdGl0dWRlIC0gcHJldmVudCBkaXZpc2lvbiBieSAwXG4gICAgLy8gVE9ETyAtIGp1c3QgdGhyb3cgYW4gRXJyb3IgaW5zdGVhZD9cbiAgICBhbHRpdHVkZSA9IE1hdGgubWF4KDAuNzUsIGFsdGl0dWRlKTtcblxuICAgIGNvbnN0IGNlbnRlciA9IHByb2plY3RGbGF0KFtsb25naXR1ZGUsIGxhdGl0dWRlXSwgc2NhbGUpO1xuXG4gICAgY29uc3QgZGlzdGFuY2VTY2FsZXMgPSBnZXRNZXJjYXRvckRpc3RhbmNlU2NhbGVzKHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCBzY2FsZX0pO1xuXG4gICAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IG1ha2VQcm9qZWN0aW9uTWF0cml4RnJvbU1lcmNhdG9yUGFyYW1zKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcGl0Y2gsXG4gICAgICBiZWFyaW5nLFxuICAgICAgYWx0aXR1ZGUsXG4gICAgICBmYXJaTXVsdGlwbGllclxuICAgIH0pO1xuXG4gICAgY29uc3Qge3ZpZXdNYXRyaXhDZW50ZXJlZH0gPSBtYWtlVmlld01hdHJpY2VzRnJvbU1lcmNhdG9yUGFyYW1zKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUsXG4gICAgICB6b29tLFxuICAgICAgcGl0Y2gsXG4gICAgICBiZWFyaW5nLFxuICAgICAgYWx0aXR1ZGUsXG4gICAgICBkaXN0YW5jZVNjYWxlcyxcbiAgICAgIGNlbnRlclxuICAgIH0pO1xuXG4gICAgc3VwZXIoe3dpZHRoLCBoZWlnaHQsIHZpZXdNYXRyaXg6IHZpZXdNYXRyaXhDZW50ZXJlZCwgcHJvamVjdGlvbk1hdHJpeH0pO1xuXG4gICAgLy8gU2F2ZSBwYXJhbWV0ZXJzXG4gICAgdGhpcy5sYXRpdHVkZSA9IGxhdGl0dWRlO1xuICAgIHRoaXMubG9uZ2l0dWRlID0gbG9uZ2l0dWRlO1xuICAgIHRoaXMuem9vbSA9IHpvb207XG4gICAgdGhpcy5waXRjaCA9IHBpdGNoO1xuICAgIHRoaXMuYmVhcmluZyA9IGJlYXJpbmc7XG4gICAgdGhpcy5hbHRpdHVkZSA9IGFsdGl0dWRlO1xuXG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMuY2VudGVyID0gY2VudGVyO1xuXG4gICAgdGhpcy5fZGlzdGFuY2VTY2FsZXMgPSBkaXN0YW5jZVNjYWxlcztcblxuICAgIGF1dG9iaW5kKHRoaXMpO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBjb21wbGV4aXR5ICovXG5cbiAgLyoqXG4gICAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gICAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gICAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gICAqIHBlcnNwZWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAgICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgX3Byb2plY3RGbGF0KGxuZ0xhdCwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHByb2plY3RGbGF0KGxuZ0xhdCwgc2NhbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucHJvamVjdCB3b3JsZCBwb2ludCBbeCx5XSBvbiBtYXAgb250byB7bGF0LCBsb259IG9uIHNwaGVyZVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdHxWZWN0b3J9IHh5IC0gb2JqZWN0IHdpdGgge3gseX0gbWVtYmVyc1xuICAgKiAgcmVwcmVzZW50aW5nIHBvaW50IG9uIHByb2plY3RlZCBtYXAgcGxhbmVcbiAgICogQHJldHVybiB7R2VvQ29vcmRpbmF0ZXN9IC0gb2JqZWN0IHdpdGgge2xhdCxsb259IG9mIHBvaW50IG9uIHNwaGVyZS5cbiAgICogICBIYXMgdG9BcnJheSBtZXRob2QgaWYgeW91IG5lZWQgYSBHZW9KU09OIEFycmF5LlxuICAgKiAgIFBlciBjYXJ0b2dyYXBoaWMgdHJhZGl0aW9uLCBsYXQgYW5kIGxvbiBhcmUgc3BlY2lmaWVkIGFzIGRlZ3JlZXMuXG4gICAqL1xuICBfdW5wcm9qZWN0RmxhdCh4eSwgc2NhbGUgPSB0aGlzLnNjYWxlKSB7XG4gICAgcmV0dXJuIHVucHJvamVjdEZsYXQoeHksIHNjYWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBjZW50ZXIgdGhhdCBwbGFjZSBhIGdpdmVuIFtsbmcsIGxhdF0gY29vcmRpbmF0ZSBhdCBzY3JlZW5cbiAgICogcG9pbnQgW3gsIHldXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxuZ0xhdCAtIFtsbmcsbGF0XSBjb29yZGluYXRlc1xuICAgKiAgIFNwZWNpZmllcyBhIHBvaW50IG9uIHRoZSBzcGhlcmUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvcyAtIFt4LHldIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNjcmVlbi5cbiAgICogQHJldHVybiB7QXJyYXl9IFtsbmcsbGF0XSBuZXcgbWFwIGNlbnRlci5cbiAgICovXG4gIGdldExvY2F0aW9uQXRQb2ludCh7bG5nTGF0LCBwb3N9KSB7XG4gICAgY29uc3QgZnJvbUxvY2F0aW9uID0gdGhpcy5wcm9qZWN0RmxhdCh0aGlzLnVucHJvamVjdChwb3MpKTtcbiAgICBjb25zdCB0b0xvY2F0aW9uID0gdGhpcy5wcm9qZWN0RmxhdChsbmdMYXQpO1xuXG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5wcm9qZWN0RmxhdChbdGhpcy5sb25naXR1ZGUsIHRoaXMubGF0aXR1ZGVdKTtcblxuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHZlYzJfYWRkKFtdLCB0b0xvY2F0aW9uLCB2ZWMyX25lZ2F0ZShbXSwgZnJvbUxvY2F0aW9uKSk7XG4gICAgY29uc3QgbmV3Q2VudGVyID0gdmVjMl9hZGQoW10sIGNlbnRlciwgdHJhbnNsYXRlKTtcbiAgICByZXR1cm4gdGhpcy51bnByb2plY3RGbGF0KG5ld0NlbnRlcik7XG4gIH1cblxuICAvKlxuICBnZXRMbmdMYXRBdFZpZXdwb3J0UG9zaXRpb24obG5nbGF0LCB4eSkge1xuICAgIGNvbnN0IGMgPSB0aGlzLmxvY2F0aW9uQ29vcmRpbmF0ZShsbmdsYXQpO1xuICAgIGNvbnN0IGNvb3JkQXRQb2ludCA9IHRoaXMucG9pbnRDb29yZGluYXRlKHh5KTtcbiAgICBjb25zdCBjb29yZENlbnRlciA9IHRoaXMucG9pbnRDb29yZGluYXRlKHRoaXMuY2VudGVyUG9pbnQpO1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGNvb3JkQXRQb2ludC5fc3ViKGMpO1xuICAgIHRoaXMuY2VudGVyID0gdGhpcy5jb29yZGluYXRlTG9jYXRpb24oY29vcmRDZW50ZXIuX3N1Yih0cmFuc2xhdGUpKTtcbiAgfVxuICAqL1xuXG4gIGdldERpc3RhbmNlU2NhbGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVNjYWxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIG1ldGVyIG9mZnNldCB0byBhIGxuZ2xhdCBvZmZzZXRcbiAgICpcbiAgICogTm90ZTogVXNlcyBzaW1wbGUgbGluZWFyIGFwcHJveGltYXRpb24gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcbiAgICogRXJyb3IgaW5jcmVhc2VzIHdpdGggc2l6ZSBvZiBvZmZzZXQgKHJvdWdobHkgMSUgcGVyIDEwMGttKVxuICAgKlxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSB4eXogLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICogQHJldHVybiB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIC0gYXJyYXkgb2YgW2xuZyxsYXQsel0gZGVsdGFzXG4gICAqL1xuICBtZXRlcnNUb0xuZ0xhdERlbHRhKHh5eikge1xuICAgIGNvbnN0IFt4LCB5LCB6ID0gMF0gPSB4eXo7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh4KSAmJiBOdW1iZXIuaXNGaW5pdGUoeSkgJiYgTnVtYmVyLmlzRmluaXRlKHopLCBFUlJfQVJHVU1FTlQpO1xuICAgIGNvbnN0IHtwaXhlbHNQZXJNZXRlciwgZGVncmVlc1BlclBpeGVsfSA9IHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICAgIGNvbnN0IGRlbHRhTG5nID0geCAqIHBpeGVsc1Blck1ldGVyWzBdICogZGVncmVlc1BlclBpeGVsWzBdO1xuICAgIGNvbnN0IGRlbHRhTGF0ID0geSAqIHBpeGVsc1Blck1ldGVyWzFdICogZGVncmVlc1BlclBpeGVsWzFdO1xuICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gW2RlbHRhTG5nLCBkZWx0YUxhdF0gOiBbZGVsdGFMbmcsIGRlbHRhTGF0LCB6XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIGxuZ2xhdCBvZmZzZXQgdG8gYSBtZXRlciBvZmZzZXRcbiAgICpcbiAgICogTm90ZTogVXNlcyBzaW1wbGUgbGluZWFyIGFwcHJveGltYXRpb24gYXJvdW5kIHRoZSB2aWV3cG9ydCBjZW50ZXJcbiAgICogRXJyb3IgaW5jcmVhc2VzIHdpdGggc2l6ZSBvZiBvZmZzZXQgKHJvdWdobHkgMSUgcGVyIDEwMGttKVxuICAgKlxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSBkZWx0YUxuZ0xhdFogLSBhcnJheSBvZiBbbG5nLGxhdCx6XSBkZWx0YXNcbiAgICogQHJldHVybiB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIC0gYXJyYXkgb2YgbWV0ZXIgZGVsdGFzXG4gICAqL1xuICBsbmdMYXREZWx0YVRvTWV0ZXJzKGRlbHRhTG5nTGF0Wikge1xuICAgIGNvbnN0IFtkZWx0YUxuZywgZGVsdGFMYXQsIGRlbHRhWiA9IDBdID0gZGVsdGFMbmdMYXRaO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoZGVsdGFMbmcpICYmIE51bWJlci5pc0Zpbml0ZShkZWx0YUxhdCkgJiYgTnVtYmVyLmlzRmluaXRlKGRlbHRhWiksXG4gICAgICBFUlJfQVJHVU1FTlQpO1xuICAgIGNvbnN0IHtwaXhlbHNQZXJEZWdyZWUsIG1ldGVyc1BlclBpeGVsfSA9IHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICAgIGNvbnN0IGRlbHRhWCA9IGRlbHRhTG5nICogcGl4ZWxzUGVyRGVncmVlWzBdICogbWV0ZXJzUGVyUGl4ZWxbMF07XG4gICAgY29uc3QgZGVsdGFZID0gZGVsdGFMYXQgKiBwaXhlbHNQZXJEZWdyZWVbMV0gKiBtZXRlcnNQZXJQaXhlbFsxXTtcbiAgICByZXR1cm4gZGVsdGFMbmdMYXRaLmxlbmd0aCA9PT0gMiA/IFtkZWx0YVgsIGRlbHRhWV0gOiBbZGVsdGFYLCBkZWx0YVksIGRlbHRhWl07XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbWV0ZXIgZGVsdGEgdG8gYSBiYXNlIGxuZ2xhdCBjb29yZGluYXRlLCByZXR1cm5pbmcgYSBuZXcgbG5nbGF0IGFycmF5XG4gICAqXG4gICAqIE5vdGU6IFVzZXMgc2ltcGxlIGxpbmVhciBhcHByb3hpbWF0aW9uIGFyb3VuZCB0aGUgdmlld3BvcnQgY2VudGVyXG4gICAqIEVycm9yIGluY3JlYXNlcyB3aXRoIHNpemUgb2Ygb2Zmc2V0IChyb3VnaGx5IDElIHBlciAxMDBrbSlcbiAgICpcbiAgICogQHBhcmFtIHtbTnVtYmVyLE51bWJlcl18W051bWJlcixOdW1iZXIsTnVtYmVyXSkgbG5nTGF0WiAtIGJhc2UgY29vcmRpbmF0ZVxuICAgKiBAcGFyYW0ge1tOdW1iZXIsTnVtYmVyXXxbTnVtYmVyLE51bWJlcixOdW1iZXJdKSB4eXogLSBhcnJheSBvZiBtZXRlciBkZWx0YXNcbiAgICogQHJldHVybiB7W051bWJlcixOdW1iZXJdfFtOdW1iZXIsTnVtYmVyLE51bWJlcl0pIGFycmF5IG9mIFtsbmcsbGF0LHpdIGRlbHRhc1xuICAgKi9cbiAgYWRkTWV0ZXJzVG9MbmdMYXQobG5nTGF0WiwgeHl6KSB7XG4gICAgY29uc3QgW2xuZywgbGF0LCBaID0gMF0gPSBsbmdMYXRaO1xuICAgIGNvbnN0IFtkZWx0YUxuZywgZGVsdGFMYXQsIGRlbHRhWiA9IDBdID0gdGhpcy5tZXRlcnNUb0xuZ0xhdERlbHRhKHh5eik7XG4gICAgcmV0dXJuIGxuZ0xhdFoubGVuZ3RoID09PSAyID9cbiAgICAgIFtsbmcgKyBkZWx0YUxuZywgbGF0ICsgZGVsdGFMYXRdIDpcbiAgICAgIFtsbmcgKyBkZWx0YUxuZywgbGF0ICsgZGVsdGFMYXQsIFogKyBkZWx0YVpdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgdmlld3BvcnQgdGhhdCBmaXQgYXJvdW5kIHRoZSBnaXZlbiByZWN0YW5nbGUuXG4gICAqIE9ubHkgc3VwcG9ydHMgbm9uLXBlcnNwZWN0aXZlIG1vZGUuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGJvdW5kcyAtIFtbbG9uLCBsYXRdLCBbbG9uLCBsYXRdXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGFkZGluZ10gLSBUaGUgYW1vdW50IG9mIHBhZGRpbmcgaW4gcGl4ZWxzIHRvIGFkZCB0byB0aGUgZ2l2ZW4gYm91bmRzLlxuICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5vZmZzZXRdIC0gVGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gYm91bmRzIHJlbGF0aXZlIHRvIHRoZSBtYXAncyBjZW50ZXIsXG4gICAqICAgIFt4LCB5XSBtZWFzdXJlZCBpbiBwaXhlbHMuXG4gICAqIEByZXR1cm5zIHtXZWJNZXJjYXRvclZpZXdwb3J0fVxuICAgKi9cbiAgZml0Qm91bmRzKGJvdW5kcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhpcztcbiAgICBjb25zdCB7bG9uZ2l0dWRlLCBsYXRpdHVkZSwgem9vbX0gPSBmaXRCb3VuZHMoT2JqZWN0LmFzc2lnbih7d2lkdGgsIGhlaWdodCwgYm91bmRzfSwgb3B0aW9ucykpO1xuICAgIHJldHVybiBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh7d2lkdGgsIGhlaWdodCwgbG9uZ2l0dWRlLCBsYXRpdHVkZSwgem9vbX0pO1xuICB9XG5cbiAgLy8gSU5URVJOQUwgTUVUSE9EU1xuXG4gIF9nZXRQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlU2NhbGVzO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBtYXAgc2V0dGluZ3Mge2xhdGl0dWRlLCBsb25naXR1ZGUsIHpvb219XG4gKiB0aGF0IHdpbGwgY29udGFpbiB0aGUgcHJvdmlkZWQgY29ybmVycyB3aXRoaW4gdGhlIHByb3ZpZGVkIHdpZHRoLlxuICogT25seSBzdXBwb3J0cyBub24tcGVyc3BlY3RpdmUgbW9kZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIHZpZXdwb3J0IHdpZHRoXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gdmlld3BvcnQgaGVpZ2h0XG4gKiBAcGFyYW0ge0FycmF5fSBib3VuZHMgLSBbW2xvbiwgbGF0XSwgW2xvbiwgbGF0XV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcGFkZGluZ10gLSBUaGUgYW1vdW50IG9mIHBhZGRpbmcgaW4gcGl4ZWxzIHRvIGFkZCB0byB0aGUgZ2l2ZW4gYm91bmRzLlxuICogQHBhcmFtIHtBcnJheX0gW29mZnNldF0gLSBUaGUgY2VudGVyIG9mIHRoZSBnaXZlbiBib3VuZHMgcmVsYXRpdmUgdG8gdGhlIG1hcCdzIGNlbnRlcixcbiAqICAgIFt4LCB5XSBtZWFzdXJlZCBpbiBwaXhlbHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIGxhdGl0dWRlLCBsb25naXR1ZGUgYW5kIHpvb21cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpdEJvdW5kcyh7XG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIGJvdW5kcyxcbiAgLy8gb3B0aW9uc1xuICBwYWRkaW5nID0gMCxcbiAgb2Zmc2V0ID0gWzAsIDBdXG59KSB7XG4gIGNvbnN0IFtbd2VzdCwgc291dGhdLCBbZWFzdCwgbm9ydGhdXSA9IGJvdW5kcztcblxuICBjb25zdCB2aWV3cG9ydCA9IG5ldyBXZWJNZXJjYXRvclZpZXdwb3J0KHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbG9uZ2l0dWRlOiAwLFxuICAgIGxhdGl0dWRlOiAwLFxuICAgIHpvb206IDBcbiAgfSk7XG5cbiAgY29uc3QgbncgPSB2aWV3cG9ydC5wcm9qZWN0KFt3ZXN0LCBub3J0aF0pO1xuICBjb25zdCBzZSA9IHZpZXdwb3J0LnByb2plY3QoW2Vhc3QsIHNvdXRoXSk7XG4gIGNvbnN0IHNpemUgPSBbXG4gICAgTWF0aC5hYnMoc2VbMF0gLSBud1swXSksXG4gICAgTWF0aC5hYnMoc2VbMV0gLSBud1sxXSlcbiAgXTtcbiAgY29uc3QgY2VudGVyID0gW1xuICAgIChzZVswXSArIG53WzBdKSAvIDIsXG4gICAgKHNlWzFdICsgbndbMV0pIC8gMlxuICBdO1xuXG4gIGNvbnN0IHNjYWxlWCA9ICh3aWR0aCAtIHBhZGRpbmcgKiAyIC0gTWF0aC5hYnMob2Zmc2V0WzBdKSAqIDIpIC8gc2l6ZVswXTtcbiAgY29uc3Qgc2NhbGVZID0gKGhlaWdodCAtIHBhZGRpbmcgKiAyIC0gTWF0aC5hYnMob2Zmc2V0WzFdKSAqIDIpIC8gc2l6ZVsxXTtcblxuICBjb25zdCBjZW50ZXJMbmdMYXQgPSB2aWV3cG9ydC51bnByb2plY3QoY2VudGVyKTtcbiAgY29uc3Qgem9vbSA9IHZpZXdwb3J0Lnpvb20gKyBNYXRoLmxvZzIoTWF0aC5hYnMoTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpKSk7XG5cbiAgcmV0dXJuIHtcbiAgICBsb25naXR1ZGU6IGNlbnRlckxuZ0xhdFswXSxcbiAgICBsYXRpdHVkZTogY2VudGVyTG5nTGF0WzFdLFxuICAgIHpvb21cbiAgfTtcbn1cbiJdfQ==