var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* global setInterval, clearInterval */
import { PureComponent, createElement, cloneElement, Children, isValidElement } from 'react';
import PropTypes from 'prop-types';

import { EventManager } from 'mjolnir.js';
import Controls from '../../core/controllers/controls';
import MapState from '../../core/controllers/map-state';
import { MAPBOX_LIMITS } from '../../core/controllers/map-state';
import CURSOR from '../utils/cursors';

import { viewportLinearInterpolator } from './viewport-animation-utils.js';

var VIEWPORT_ANIMATE_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];
var VIEWPORT_ANIMATE_FREQUENCY = 0.01;
var VIEWPORT_ANIMATION_DURATION = 0;
var VIEWPORT_ANIMATION_EASING_FUNC = function VIEWPORT_ANIMATION_EASING_FUNC(t) {
  return t;
};

export var ANIMATION_EVENTS = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
};

var propTypes = {
  /** The width of the map. */
  width: PropTypes.number.isRequired,
  /** The height of the map. */
  height: PropTypes.number.isRequired,
  /** The longitude of the center of the map. */
  longitude: PropTypes.number.isRequired,
  /** The latitude of the center of the map. */
  latitude: PropTypes.number.isRequired,
  /** The tile zoom level of the map. */
  zoom: PropTypes.number.isRequired,
  /** Specify the bearing of the viewport */
  bearing: PropTypes.number,
  /** Specify the pitch of the viewport */
  pitch: PropTypes.number,
  /** Altitude of the viewport camera. Default 1.5 "screen heights" */
  // Note: Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
  altitude: PropTypes.number,

  /** Viewport constraints */
  // Max zoom level
  maxZoom: PropTypes.number,
  // Min zoom level
  minZoom: PropTypes.number,
  // Max pitch in degrees
  maxPitch: PropTypes.number,
  // Min pitch in degrees
  minPitch: PropTypes.number,

  /**
   * `onViewportChange` callback is fired when the user interacted with the
   * map. The object passed to the callback contains viewport properties
   * such as `longitude`, `latitude`, `zoom` etc.
   */
  onViewportChange: PropTypes.func,

  /** Viewport animation **/
  // animation duration for viewport change
  animaitonDuration: PropTypes.number,
  // function called for each animation step, can be used to perform custom animations.
  animationInterpolator: PropTypes.func,
  // easing function
  viewportAnimationEasingFunc: PropTypes.func,

  /** Enables control event handling */
  // Scroll to zoom
  scrollZoom: PropTypes.bool,
  // Drag to pan
  dragPan: PropTypes.bool,
  // Drag to rotate
  dragRotate: PropTypes.bool,
  // Double click to zoom
  doubleClickZoom: PropTypes.bool,
  // Pinch to zoom / rotate
  touchZoomRotate: PropTypes.bool,

  /** Accessor that returns a cursor style to show interactive state */
  getCursor: PropTypes.func,

  // A map control instance to replace the default map controls
  // The object must expose one property: `events` as an array of subscribed
  // event names; and two methods: `setState(state)` and `handle(event)`
  controls: PropTypes.shape({
    events: PropTypes.arrayOf(PropTypes.string),
    handleEvent: PropTypes.func
  })
};

var getDefaultCursor = function getDefaultCursor(_ref) {
  var isDragging = _ref.isDragging;
  return isDragging ? CURSOR.GRABBING : CURSOR.GRAB;
};

var defaultProps = Object.assign({}, MAPBOX_LIMITS, {
  onViewportChange: null,
  animaitonDuration: VIEWPORT_ANIMATION_DURATION,
  animationInterpolator: viewportLinearInterpolator,
  viewportAnimationEasingFunc: VIEWPORT_ANIMATION_EASING_FUNC,

  scrollZoom: true,
  dragPan: true,
  dragRotate: true,
  doubleClickZoom: true,
  touchZoomRotate: true,

  getCursor: getDefaultCursor
});

var AnimationMapController = function (_PureComponent) {
  _inherits(AnimationMapController, _PureComponent);

  function AnimationMapController(props) {
    _classCallCheck(this, AnimationMapController);

    var _this = _possibleConstructorReturn(this, (AnimationMapController.__proto__ || Object.getPrototypeOf(AnimationMapController)).call(this, props));

    _this.state = {
      isDragging: false // Whether the cursor is down
    };

    // Private animation state
    _this.animationContext = {
      animationT: 0,
      animationInterval: null,
      animationStartState: null,
      animationEndState: null,
      animatedViewport: null
    };

    _this._updateViewport = _this._updateViewport.bind(_this);
    _this._createAnimationInterval = _this._createAnimationInterval.bind(_this);
    _this._isTheUpdateDueToCurrentAnimation = _this._isTheUpdateDueToCurrentAnimation.bind(_this);
    _this._animateViewportProp = _this._animateViewportProp.bind(_this);
    _this._endAnimation = _this._endAnimation.bind(_this);
    _this._recursiveUpdateChildren = _this._recursiveUpdateChildren.bind(_this);
    _this._isViewportAnimationEnabled = _this._isViewportAnimationEnabled.bind(_this);
    _this._isAnimationInProgress = _this._isAnimationInProgress.bind(_this);
    _this._processViewportChange = _this._processViewportChange.bind(_this);
    _this._shouldIgnoreViewportChange = _this._shouldIgnoreViewportChange.bind(_this);
    return _this;
  }

  _createClass(AnimationMapController, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var eventCanvas = this.refs.eventCanvas;


      var eventManager = new EventManager(eventCanvas);

      this._eventManager = eventManager;

      // If props.controls is not provided, fallback to default MapControls instance
      // Cannot use defaultProps here because it needs to be per map instance
      this._controls = this.props.controls || new Controls(MapState);
      this._controls.setOptions(Object.assign({}, this.props, {
        onStateChange: this._onInteractiveStateChange.bind(this),
        eventManager: eventManager
      }));

      this.animationContext = {
        animationT: 0,
        animationInterval: null,
        animationStartState: null,
        animationEndState: null,
        animatedViewport: null
      };
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps) {
      this.someVar = 'componentWillUpdate';
      this._controls.setOptions(nextProps);
      this._processViewportChange(nextProps);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (this.animationEndCallback) {
        this.animationEndCallback({ t: this.animationEndTime });
        this.animationEndCallback = null;
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._eventManager.destroy();
    }

    // Helper methods

  }, {
    key: '_animateViewportProp',
    value: function _animateViewportProp(startViewport, nextProps) {
      var endViewport = this._extractViewportFromProps(nextProps);
      if (this._didViewportAnimatePropChanged(startViewport, endViewport)) {
        var animationInterval = this._createAnimationInterval(nextProps);
        this.animationContext = {
          animationT: 0.0,
          animationStartViewport: startViewport,
          animationEndViewport: endViewport,
          animationInterval: animationInterval,
          animatedViewport: startViewport,
          onAnimationInterruption: nextProps.onAnimationInterruption,
          onAnimationStop: nextProps.onAnimationStop
        };
        this.forceUpdate();
      }
    }
  }, {
    key: '_createAnimationInterval',
    value: function _createAnimationInterval(nextProps) {
      var _this2 = this;

      if (this.animationContext.animationInterval) {
        clearInterval(this.animationContext.animationInterval);
      }
      var updateFrequency = nextProps.animaitonDuration * VIEWPORT_ANIMATE_FREQUENCY;
      return setInterval(function () {
        return _this2._updateViewport();
      }, updateFrequency);
    }
  }, {
    key: '_didViewportAnimatePropChanged',
    value: function _didViewportAnimatePropChanged(startViewport, endViewport) {
      // TODO: also check for `animationDuration` `animationFreeze`
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = VIEWPORT_ANIMATE_PROPS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var p = _step.value;

          if (startViewport[p] !== undefined && endViewport[p] !== undefined && startViewport[p] !== endViewport[p]) {
            return true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return false;
    }
  }, {
    key: '_endAnimation',
    value: function _endAnimation() {
      clearInterval(this.animationContext.animationInterval);
      this.animationEndCallback = this.animationContext.onAnimationStop;
      this.animationEndTime = this.animationContext.animationT;
      // TODO: may be just set animationContext to null
      this.animationContext = {
        animationT: 0,
        animationInterval: null,
        animationStartState: null,
        animationEndState: null,
        animatedViewport: null,
        onAnimationStop: null,
        onAnimationInterruption: null
      };
    }

    // TODO: add viewport or viewportState prop to avoid this extraction.

  }, {
    key: '_extractViewportFromProps',
    value: function _extractViewportFromProps(props) {
      return {
        width: props.width,
        height: props.height,
        latitude: props.latitude,
        longitude: props.longitude,
        zoom: props.zoom,
        bearing: props.bearing,
        pitch: props.pitch,
        minZoom: props.minZoom,
        maxZoom: props.maxZoom
      };
    }
  }, {
    key: '_isAnimationInProgress',
    value: function _isAnimationInProgress() {
      return this.animationContext.animationInterval;
    }
  }, {
    key: '_isViewportAnimationEnabled',
    value: function _isViewportAnimationEnabled(props) {
      return props.animaitonDuration !== 0;
    }
  }, {
    key: '_isTheUpdateDueToCurrentAnimation',
    value: function _isTheUpdateDueToCurrentAnimation(nextProps) {
      if (this.animationContext.animatedViewport) {
        var newViewport = this._extractViewportFromProps(nextProps);
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = VIEWPORT_ANIMATE_PROPS[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var p = _step2.value;

            if (newViewport[p] !== this.animationContext.animatedViewport[p]) {
              return false;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        return true;
      }
      return false;
    }
  }, {
    key: '_onInteractiveStateChange',
    value: function _onInteractiveStateChange(interactiveState) {
      var _interactiveState$isD = interactiveState.isDragging,
          isDragging = _interactiveState$isD === undefined ? false : _interactiveState$isD;

      if (isDragging !== this.state.isDragging) {
        this.setState({ isDragging: isDragging });
      }
    }
  }, {
    key: '_processViewportChange',
    value: function _processViewportChange(nextProps) {

      if (this._shouldIgnoreViewportChange(nextProps)) {
        return;
      }

      var animationEndViewport = this.animationContext ? this.animationContext.animationEndViewport : null;
      var shouldSnapToEnd = this._shouldEndAnimation();
      if (this._isAnimationInProgress()) {
        this._endAnimation();
      }

      if (this._isViewportAnimationEnabled(nextProps)) {
        var startViewport = void 0;
        if (shouldSnapToEnd) {
          startViewport = animationEndViewport || this._extractViewportFromProps(this.props);
        } else {
          startViewport = this._extractViewportFromProps(this.props);
        }
        this._animateViewportProp(startViewport, nextProps);
      }
    }
  }, {
    key: '_recursiveUpdateChildren',
    value: function _recursiveUpdateChildren(children, viewport) {
      var _this3 = this;

      return Children.map(children, function (child) {
        if (!isValidElement(child)) {
          return child;
        }
        // TODO: we need to filter chidren and only update those that require
        // updated viewport prop.
        var childProps = Object.assign({}, viewport, { viewport: viewport });
        childProps.children = _this3._recursiveUpdateChildren(child.props.children, viewport);
        var cloned = cloneElement(child, childProps);
        return cloned;
      });
    }
  }, {
    key: '_shouldEndAnimation',
    value: function _shouldEndAnimation() {
      return this.animationContext && this.animationContext.onAnimationInterruption === ANIMATION_EVENTS.SNAP_TO_END;
    }
  }, {
    key: '_shouldIgnoreViewportChange',
    value: function _shouldIgnoreViewportChange(nextProps) {
      // Ignore update if it is due to current active animation.
      if (this._isTheUpdateDueToCurrentAnimation(nextProps)) {
        return true;
      }

      // Ignore update if it is requested to ignore
      if (this.animationContext && this.animationContext.onAnimationInterruption === ANIMATION_EVENTS.IGNORE) {
        return true;
      }

      // Ignore if none of the viewport props changed.
      var start = this._extractViewportFromProps(this.props);
      var end = this._extractViewportFromProps(nextProps);
      if (!this._didViewportAnimatePropChanged(start, end)) {
        return true;
      }

      return false;
    }
  }, {
    key: '_updateViewport',
    value: function _updateViewport() {
      var t = this.props.viewportAnimationEasingFunc(this.animationContext.animationT);
      var animatedViewport = this.props.animationInterpolator(this.animationContext.animationStartViewport, this.animationContext.animationEndViewport, t);
      var currentTime = this.animationContext.animationT;
      if (currentTime <= 1.0) {
        // console.log(`Controller update pitch: ${animatedViewport.pitch} t: ${t}`);
        this.animationContext.animationT = currentTime + VIEWPORT_ANIMATE_FREQUENCY > 1.0 && currentTime + VIEWPORT_ANIMATE_FREQUENCY < 1.0 + VIEWPORT_ANIMATE_FREQUENCY ? 1.0 : currentTime + VIEWPORT_ANIMATE_FREQUENCY;
        this.animationContext.animatedViewport = Object.assign({}, this.animationContext.animationEndViewport, animatedViewport);
        if (this.props.onViewportChange) {
          this.props.onViewportChange(animatedViewport);
        }
      } else {
        this._endAnimation();
      }
      this.forceUpdate();
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          width = _props.width,
          height = _props.height,
          getCursor = _props.getCursor;


      var eventCanvasStyle = {
        width: width,
        height: height,
        position: 'relative',
        cursor: getCursor(this.state)
      };

      var childrenWithProps = void 0;
      if (this._isAnimationInProgress()) {
        childrenWithProps = this._recursiveUpdateChildren(this.props.children, this.animationContext.animatedViewport);
      } else {
        // console.log('=== AnimationController Render using original props for children');
        childrenWithProps = this._recursiveUpdateChildren(this.props.children, this._extractViewportFromProps(this.props));
      }

      return createElement('div', {
        key: 'map-controls',
        ref: 'eventCanvas',
        style: eventCanvasStyle
      }, childrenWithProps);
    }
  }]);

  return AnimationMapController;
}(PureComponent);

export default AnimationMapController;


AnimationMapController.displayName = 'AnimationMapController';
AnimationMapController.propTypes = propTypes;
AnimationMapController.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZWFjdC9leHBlcmltZW50YWwvYW5pbWF0aW9uLW1hcC1jb250cm9sbGVyLmpzIl0sIm5hbWVzIjpbIlB1cmVDb21wb25lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiQ2hpbGRyZW4iLCJpc1ZhbGlkRWxlbWVudCIsIlByb3BUeXBlcyIsIkV2ZW50TWFuYWdlciIsIkNvbnRyb2xzIiwiTWFwU3RhdGUiLCJNQVBCT1hfTElNSVRTIiwiQ1VSU09SIiwidmlld3BvcnRMaW5lYXJJbnRlcnBvbGF0b3IiLCJWSUVXUE9SVF9BTklNQVRFX1BST1BTIiwiVklFV1BPUlRfQU5JTUFURV9GUkVRVUVOQ1kiLCJWSUVXUE9SVF9BTklNQVRJT05fRFVSQVRJT04iLCJWSUVXUE9SVF9BTklNQVRJT05fRUFTSU5HX0ZVTkMiLCJ0IiwiQU5JTUFUSU9OX0VWRU5UUyIsIkJSRUFLIiwiU05BUF9UT19FTkQiLCJJR05PUkUiLCJwcm9wVHlwZXMiLCJ3aWR0aCIsIm51bWJlciIsImlzUmVxdWlyZWQiLCJoZWlnaHQiLCJsb25naXR1ZGUiLCJsYXRpdHVkZSIsInpvb20iLCJiZWFyaW5nIiwicGl0Y2giLCJhbHRpdHVkZSIsIm1heFpvb20iLCJtaW5ab29tIiwibWF4UGl0Y2giLCJtaW5QaXRjaCIsIm9uVmlld3BvcnRDaGFuZ2UiLCJmdW5jIiwiYW5pbWFpdG9uRHVyYXRpb24iLCJhbmltYXRpb25JbnRlcnBvbGF0b3IiLCJ2aWV3cG9ydEFuaW1hdGlvbkVhc2luZ0Z1bmMiLCJzY3JvbGxab29tIiwiYm9vbCIsImRyYWdQYW4iLCJkcmFnUm90YXRlIiwiZG91YmxlQ2xpY2tab29tIiwidG91Y2hab29tUm90YXRlIiwiZ2V0Q3Vyc29yIiwiY29udHJvbHMiLCJzaGFwZSIsImV2ZW50cyIsImFycmF5T2YiLCJzdHJpbmciLCJoYW5kbGVFdmVudCIsImdldERlZmF1bHRDdXJzb3IiLCJpc0RyYWdnaW5nIiwiR1JBQkJJTkciLCJHUkFCIiwiZGVmYXVsdFByb3BzIiwiT2JqZWN0IiwiYXNzaWduIiwiQW5pbWF0aW9uTWFwQ29udHJvbGxlciIsInByb3BzIiwic3RhdGUiLCJhbmltYXRpb25Db250ZXh0IiwiYW5pbWF0aW9uVCIsImFuaW1hdGlvbkludGVydmFsIiwiYW5pbWF0aW9uU3RhcnRTdGF0ZSIsImFuaW1hdGlvbkVuZFN0YXRlIiwiYW5pbWF0ZWRWaWV3cG9ydCIsIl91cGRhdGVWaWV3cG9ydCIsImJpbmQiLCJfY3JlYXRlQW5pbWF0aW9uSW50ZXJ2YWwiLCJfaXNUaGVVcGRhdGVEdWVUb0N1cnJlbnRBbmltYXRpb24iLCJfYW5pbWF0ZVZpZXdwb3J0UHJvcCIsIl9lbmRBbmltYXRpb24iLCJfcmVjdXJzaXZlVXBkYXRlQ2hpbGRyZW4iLCJfaXNWaWV3cG9ydEFuaW1hdGlvbkVuYWJsZWQiLCJfaXNBbmltYXRpb25JblByb2dyZXNzIiwiX3Byb2Nlc3NWaWV3cG9ydENoYW5nZSIsIl9zaG91bGRJZ25vcmVWaWV3cG9ydENoYW5nZSIsImV2ZW50Q2FudmFzIiwicmVmcyIsImV2ZW50TWFuYWdlciIsIl9ldmVudE1hbmFnZXIiLCJfY29udHJvbHMiLCJzZXRPcHRpb25zIiwib25TdGF0ZUNoYW5nZSIsIl9vbkludGVyYWN0aXZlU3RhdGVDaGFuZ2UiLCJuZXh0UHJvcHMiLCJzb21lVmFyIiwiYW5pbWF0aW9uRW5kQ2FsbGJhY2siLCJhbmltYXRpb25FbmRUaW1lIiwiZGVzdHJveSIsInN0YXJ0Vmlld3BvcnQiLCJlbmRWaWV3cG9ydCIsIl9leHRyYWN0Vmlld3BvcnRGcm9tUHJvcHMiLCJfZGlkVmlld3BvcnRBbmltYXRlUHJvcENoYW5nZWQiLCJhbmltYXRpb25TdGFydFZpZXdwb3J0IiwiYW5pbWF0aW9uRW5kVmlld3BvcnQiLCJvbkFuaW1hdGlvbkludGVycnVwdGlvbiIsIm9uQW5pbWF0aW9uU3RvcCIsImZvcmNlVXBkYXRlIiwiY2xlYXJJbnRlcnZhbCIsInVwZGF0ZUZyZXF1ZW5jeSIsInNldEludGVydmFsIiwicCIsInVuZGVmaW5lZCIsIm5ld1ZpZXdwb3J0IiwiaW50ZXJhY3RpdmVTdGF0ZSIsInNldFN0YXRlIiwic2hvdWxkU25hcFRvRW5kIiwiX3Nob3VsZEVuZEFuaW1hdGlvbiIsImNoaWxkcmVuIiwidmlld3BvcnQiLCJtYXAiLCJjaGlsZCIsImNoaWxkUHJvcHMiLCJjbG9uZWQiLCJzdGFydCIsImVuZCIsImN1cnJlbnRUaW1lIiwiZXZlbnRDYW52YXNTdHlsZSIsInBvc2l0aW9uIiwiY3Vyc29yIiwiY2hpbGRyZW5XaXRoUHJvcHMiLCJrZXkiLCJyZWYiLCJzdHlsZSIsImRpc3BsYXlOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0EsU0FBUUEsYUFBUixFQUF1QkMsYUFBdkIsRUFBc0NDLFlBQXRDLEVBQW9EQyxRQUFwRCxFQUE4REMsY0FBOUQsUUFBbUYsT0FBbkY7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLFlBQXRCOztBQUVBLFNBQVFDLFlBQVIsUUFBMkIsWUFBM0I7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLGlDQUFyQjtBQUNBLE9BQU9DLFFBQVAsTUFBcUIsa0NBQXJCO0FBQ0EsU0FBUUMsYUFBUixRQUE0QixrQ0FBNUI7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLGtCQUFuQjs7QUFFQSxTQUFRQywwQkFBUixRQUF5QywrQkFBekM7O0FBRUEsSUFBTUMseUJBQXlCLENBQUMsV0FBRCxFQUFjLFVBQWQsRUFBMEIsTUFBMUIsRUFBa0MsU0FBbEMsRUFBNkMsT0FBN0MsQ0FBL0I7QUFDQSxJQUFNQyw2QkFBNkIsSUFBbkM7QUFDQSxJQUFNQyw4QkFBOEIsQ0FBcEM7QUFDQSxJQUFNQyxpQ0FBaUMsU0FBakNBLDhCQUFpQztBQUFBLFNBQUtDLENBQUw7QUFBQSxDQUF2Qzs7QUFFQSxPQUFPLElBQU1DLG1CQUFtQjtBQUM5QkMsU0FBTyxDQUR1QjtBQUU5QkMsZUFBYSxDQUZpQjtBQUc5QkMsVUFBUTtBQUhzQixDQUF6Qjs7QUFNUCxJQUFNQyxZQUFZO0FBQ2hCO0FBQ0FDLFNBQU9qQixVQUFVa0IsTUFBVixD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OiJhbmltYXRpb24tbWFwLWNvbnRyb2xsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgc2V0SW50ZXJ2YWwsIGNsZWFySW50ZXJ2YWwgKi9cbmltcG9ydCB7UHVyZUNvbXBvbmVudCwgY3JlYXRlRWxlbWVudCwgY2xvbmVFbGVtZW50LCBDaGlsZHJlbiwgaXNWYWxpZEVsZW1lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmltcG9ydCB7RXZlbnRNYW5hZ2VyfSBmcm9tICdtam9sbmlyLmpzJztcbmltcG9ydCBDb250cm9scyBmcm9tICcuLi8uLi9jb3JlL2NvbnRyb2xsZXJzL2NvbnRyb2xzJztcbmltcG9ydCBNYXBTdGF0ZSBmcm9tICcuLi8uLi9jb3JlL2NvbnRyb2xsZXJzL21hcC1zdGF0ZSc7XG5pbXBvcnQge01BUEJPWF9MSU1JVFN9IGZyb20gJy4uLy4uL2NvcmUvY29udHJvbGxlcnMvbWFwLXN0YXRlJztcbmltcG9ydCBDVVJTT1IgZnJvbSAnLi4vdXRpbHMvY3Vyc29ycyc7XG5cbmltcG9ydCB7dmlld3BvcnRMaW5lYXJJbnRlcnBvbGF0b3J9IGZyb20gJy4vdmlld3BvcnQtYW5pbWF0aW9uLXV0aWxzLmpzJztcblxuY29uc3QgVklFV1BPUlRfQU5JTUFURV9QUk9QUyA9IFsnbG9uZ2l0dWRlJywgJ2xhdGl0dWRlJywgJ3pvb20nLCAnYmVhcmluZycsICdwaXRjaCddO1xuY29uc3QgVklFV1BPUlRfQU5JTUFURV9GUkVRVUVOQ1kgPSAwLjAxO1xuY29uc3QgVklFV1BPUlRfQU5JTUFUSU9OX0RVUkFUSU9OID0gMDtcbmNvbnN0IFZJRVdQT1JUX0FOSU1BVElPTl9FQVNJTkdfRlVOQyA9IHQgPT4gdDtcblxuZXhwb3J0IGNvbnN0IEFOSU1BVElPTl9FVkVOVFMgPSB7XG4gIEJSRUFLOiAxLFxuICBTTkFQX1RPX0VORDogMixcbiAgSUdOT1JFOiAzXG59O1xuXG5jb25zdCBwcm9wVHlwZXMgPSB7XG4gIC8qKiBUaGUgd2lkdGggb2YgdGhlIG1hcC4gKi9cbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgLyoqIFRoZSBoZWlnaHQgb2YgdGhlIG1hcC4gKi9cbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBUaGUgbG9uZ2l0dWRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIG1hcC4gKi9cbiAgbG9uZ2l0dWRlOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBUaGUgbGF0aXR1ZGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgbWFwLiAqL1xuICBsYXRpdHVkZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAvKiogVGhlIHRpbGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLiAqL1xuICB6b29tOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8qKiBTcGVjaWZ5IHRoZSBiZWFyaW5nIG9mIHRoZSB2aWV3cG9ydCAqL1xuICBiZWFyaW5nOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKiogU3BlY2lmeSB0aGUgcGl0Y2ggb2YgdGhlIHZpZXdwb3J0ICovXG4gIHBpdGNoOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKiogQWx0aXR1ZGUgb2YgdGhlIHZpZXdwb3J0IGNhbWVyYS4gRGVmYXVsdCAxLjUgXCJzY3JlZW4gaGVpZ2h0c1wiICovXG4gIC8vIE5vdGU6IE5vbi1wdWJsaWMgQVBJLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvaXNzdWVzLzExMzdcbiAgYWx0aXR1ZGU6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqIFZpZXdwb3J0IGNvbnN0cmFpbnRzICovXG4gIC8vIE1heCB6b29tIGxldmVsXG4gIG1heFpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIE1pbiB6b29tIGxldmVsXG4gIG1pblpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIE1heCBwaXRjaCBpbiBkZWdyZWVzXG4gIG1heFBpdGNoOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBNaW4gcGl0Y2ggaW4gZGVncmVlc1xuICBtaW5QaXRjaDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogYG9uVmlld3BvcnRDaGFuZ2VgIGNhbGxiYWNrIGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIHRoZVxuICAgKiBtYXAuIFRoZSBvYmplY3QgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBjb250YWlucyB2aWV3cG9ydCBwcm9wZXJ0aWVzXG4gICAqIHN1Y2ggYXMgYGxvbmdpdHVkZWAsIGBsYXRpdHVkZWAsIGB6b29tYCBldGMuXG4gICAqL1xuICBvblZpZXdwb3J0Q2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKiogVmlld3BvcnQgYW5pbWF0aW9uICoqL1xuICAvLyBhbmltYXRpb24gZHVyYXRpb24gZm9yIHZpZXdwb3J0IGNoYW5nZVxuICBhbmltYWl0b25EdXJhdGlvbjogUHJvcFR5cGVzLm51bWJlcixcbiAgLy8gZnVuY3Rpb24gY2FsbGVkIGZvciBlYWNoIGFuaW1hdGlvbiBzdGVwLCBjYW4gYmUgdXNlZCB0byBwZXJmb3JtIGN1c3RvbSBhbmltYXRpb25zLlxuICBhbmltYXRpb25JbnRlcnBvbGF0b3I6IFByb3BUeXBlcy5mdW5jLFxuICAvLyBlYXNpbmcgZnVuY3Rpb25cbiAgdmlld3BvcnRBbmltYXRpb25FYXNpbmdGdW5jOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKiogRW5hYmxlcyBjb250cm9sIGV2ZW50IGhhbmRsaW5nICovXG4gIC8vIFNjcm9sbCB0byB6b29tXG4gIHNjcm9sbFpvb206IFByb3BUeXBlcy5ib29sLFxuICAvLyBEcmFnIHRvIHBhblxuICBkcmFnUGFuOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gRHJhZyB0byByb3RhdGVcbiAgZHJhZ1JvdGF0ZTogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIERvdWJsZSBjbGljayB0byB6b29tXG4gIGRvdWJsZUNsaWNrWm9vbTogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIFBpbmNoIHRvIHpvb20gLyByb3RhdGVcbiAgdG91Y2hab29tUm90YXRlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKiogQWNjZXNzb3IgdGhhdCByZXR1cm5zIGEgY3Vyc29yIHN0eWxlIHRvIHNob3cgaW50ZXJhY3RpdmUgc3RhdGUgKi9cbiAgZ2V0Q3Vyc29yOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvLyBBIG1hcCBjb250cm9sIGluc3RhbmNlIHRvIHJlcGxhY2UgdGhlIGRlZmF1bHQgbWFwIGNvbnRyb2xzXG4gIC8vIFRoZSBvYmplY3QgbXVzdCBleHBvc2Ugb25lIHByb3BlcnR5OiBgZXZlbnRzYCBhcyBhbiBhcnJheSBvZiBzdWJzY3JpYmVkXG4gIC8vIGV2ZW50IG5hbWVzOyBhbmQgdHdvIG1ldGhvZHM6IGBzZXRTdGF0ZShzdGF0ZSlgIGFuZCBgaGFuZGxlKGV2ZW50KWBcbiAgY29udHJvbHM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgZXZlbnRzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc3RyaW5nKSxcbiAgICBoYW5kbGVFdmVudDogUHJvcFR5cGVzLmZ1bmNcbiAgfSlcbn07XG5cbmNvbnN0IGdldERlZmF1bHRDdXJzb3IgPSAoe2lzRHJhZ2dpbmd9KSA9PiBpc0RyYWdnaW5nID8gQ1VSU09SLkdSQUJCSU5HIDogQ1VSU09SLkdSQUI7XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIE1BUEJPWF9MSU1JVFMsIHtcbiAgb25WaWV3cG9ydENoYW5nZTogbnVsbCxcbiAgYW5pbWFpdG9uRHVyYXRpb246IFZJRVdQT1JUX0FOSU1BVElPTl9EVVJBVElPTixcbiAgYW5pbWF0aW9uSW50ZXJwb2xhdG9yOiB2aWV3cG9ydExpbmVhckludGVycG9sYXRvcixcbiAgdmlld3BvcnRBbmltYXRpb25FYXNpbmdGdW5jOiBWSUVXUE9SVF9BTklNQVRJT05fRUFTSU5HX0ZVTkMsXG5cbiAgc2Nyb2xsWm9vbTogdHJ1ZSxcbiAgZHJhZ1BhbjogdHJ1ZSxcbiAgZHJhZ1JvdGF0ZTogdHJ1ZSxcbiAgZG91YmxlQ2xpY2tab29tOiB0cnVlLFxuICB0b3VjaFpvb21Sb3RhdGU6IHRydWUsXG5cbiAgZ2V0Q3Vyc29yOiBnZXREZWZhdWx0Q3Vyc29yXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uTWFwQ29udHJvbGxlciBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlICAgICAgLy8gV2hldGhlciB0aGUgY3Vyc29yIGlzIGRvd25cbiAgICB9O1xuXG4gICAgLy8gUHJpdmF0ZSBhbmltYXRpb24gc3RhdGVcbiAgICB0aGlzLmFuaW1hdGlvbkNvbnRleHQgPSB7XG4gICAgICBhbmltYXRpb25UOiAwLFxuICAgICAgYW5pbWF0aW9uSW50ZXJ2YWw6IG51bGwsXG4gICAgICBhbmltYXRpb25TdGFydFN0YXRlOiBudWxsLFxuICAgICAgYW5pbWF0aW9uRW5kU3RhdGU6IG51bGwsXG4gICAgICBhbmltYXRlZFZpZXdwb3J0OiBudWxsXG4gICAgfTtcblxuICAgIHRoaXMuX3VwZGF0ZVZpZXdwb3J0ID0gdGhpcy5fdXBkYXRlVmlld3BvcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9jcmVhdGVBbmltYXRpb25JbnRlcnZhbCA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbkludGVydmFsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5faXNUaGVVcGRhdGVEdWVUb0N1cnJlbnRBbmltYXRpb24gPSB0aGlzLl9pc1RoZVVwZGF0ZUR1ZVRvQ3VycmVudEFuaW1hdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2FuaW1hdGVWaWV3cG9ydFByb3AgPSB0aGlzLl9hbmltYXRlVmlld3BvcnRQcm9wLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fZW5kQW5pbWF0aW9uID0gdGhpcy5fZW5kQW5pbWF0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmVjdXJzaXZlVXBkYXRlQ2hpbGRyZW4gPSB0aGlzLl9yZWN1cnNpdmVVcGRhdGVDaGlsZHJlbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2lzVmlld3BvcnRBbmltYXRpb25FbmFibGVkID0gdGhpcy5faXNWaWV3cG9ydEFuaW1hdGlvbkVuYWJsZWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9pc0FuaW1hdGlvbkluUHJvZ3Jlc3MgPSB0aGlzLl9pc0FuaW1hdGlvbkluUHJvZ3Jlc3MuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9wcm9jZXNzVmlld3BvcnRDaGFuZ2UgPSB0aGlzLl9wcm9jZXNzVmlld3BvcnRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9zaG91bGRJZ25vcmVWaWV3cG9ydENoYW5nZSA9IHRoaXMuX3Nob3VsZElnbm9yZVZpZXdwb3J0Q2hhbmdlLmJpbmQodGhpcyk7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCB7ZXZlbnRDYW52YXN9ID0gdGhpcy5yZWZzO1xuXG4gICAgY29uc3QgZXZlbnRNYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcihldmVudENhbnZhcyk7XG5cbiAgICB0aGlzLl9ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG5cbiAgICAvLyBJZiBwcm9wcy5jb250cm9scyBpcyBub3QgcHJvdmlkZWQsIGZhbGxiYWNrIHRvIGRlZmF1bHQgTWFwQ29udHJvbHMgaW5zdGFuY2VcbiAgICAvLyBDYW5ub3QgdXNlIGRlZmF1bHRQcm9wcyBoZXJlIGJlY2F1c2UgaXQgbmVlZHMgdG8gYmUgcGVyIG1hcCBpbnN0YW5jZVxuICAgIHRoaXMuX2NvbnRyb2xzID0gdGhpcy5wcm9wcy5jb250cm9scyB8fCBuZXcgQ29udHJvbHMoTWFwU3RhdGUpO1xuICAgIHRoaXMuX2NvbnRyb2xzLnNldE9wdGlvbnMoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgb25TdGF0ZUNoYW5nZTogdGhpcy5fb25JbnRlcmFjdGl2ZVN0YXRlQ2hhbmdlLmJpbmQodGhpcyksXG4gICAgICBldmVudE1hbmFnZXJcbiAgICB9KSk7XG5cbiAgICB0aGlzLmFuaW1hdGlvbkNvbnRleHQgPSB7XG4gICAgICBhbmltYXRpb25UOiAwLFxuICAgICAgYW5pbWF0aW9uSW50ZXJ2YWw6IG51bGwsXG4gICAgICBhbmltYXRpb25TdGFydFN0YXRlOiBudWxsLFxuICAgICAgYW5pbWF0aW9uRW5kU3RhdGU6IG51bGwsXG4gICAgICBhbmltYXRlZFZpZXdwb3J0OiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgdGhpcy5zb21lVmFyID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgIHRoaXMuX2NvbnRyb2xzLnNldE9wdGlvbnMobmV4dFByb3BzKTtcbiAgICB0aGlzLl9wcm9jZXNzVmlld3BvcnRDaGFuZ2UobmV4dFByb3BzKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25FbmRDYWxsYmFjaykge1xuICAgICAgdGhpcy5hbmltYXRpb25FbmRDYWxsYmFjayh7dDogdGhpcy5hbmltYXRpb25FbmRUaW1lfSk7XG4gICAgICB0aGlzLmFuaW1hdGlvbkVuZENhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLl9ldmVudE1hbmFnZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gSGVscGVyIG1ldGhvZHNcblxuICBfYW5pbWF0ZVZpZXdwb3J0UHJvcChzdGFydFZpZXdwb3J0LCBuZXh0UHJvcHMpIHtcbiAgICBjb25zdCBlbmRWaWV3cG9ydCA9IHRoaXMuX2V4dHJhY3RWaWV3cG9ydEZyb21Qcm9wcyhuZXh0UHJvcHMpO1xuICAgIGlmICh0aGlzLl9kaWRWaWV3cG9ydEFuaW1hdGVQcm9wQ2hhbmdlZChzdGFydFZpZXdwb3J0LCBlbmRWaWV3cG9ydCkpIHtcbiAgICAgIGNvbnN0IGFuaW1hdGlvbkludGVydmFsID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9uSW50ZXJ2YWwobmV4dFByb3BzKTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgYW5pbWF0aW9uVDogMC4wLFxuICAgICAgICBhbmltYXRpb25TdGFydFZpZXdwb3J0OiBzdGFydFZpZXdwb3J0LFxuICAgICAgICBhbmltYXRpb25FbmRWaWV3cG9ydDogZW5kVmlld3BvcnQsXG4gICAgICAgIGFuaW1hdGlvbkludGVydmFsLFxuICAgICAgICBhbmltYXRlZFZpZXdwb3J0OiBzdGFydFZpZXdwb3J0LFxuICAgICAgICBvbkFuaW1hdGlvbkludGVycnVwdGlvbjogbmV4dFByb3BzLm9uQW5pbWF0aW9uSW50ZXJydXB0aW9uLFxuICAgICAgICBvbkFuaW1hdGlvblN0b3A6IG5leHRQcm9wcy5vbkFuaW1hdGlvblN0b3BcbiAgICAgIH07XG4gICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUFuaW1hdGlvbkludGVydmFsKG5leHRQcm9wcykge1xuICAgIGlmICh0aGlzLmFuaW1hdGlvbkNvbnRleHQuYW5pbWF0aW9uSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5hbmltYXRpb25Db250ZXh0LmFuaW1hdGlvbkludGVydmFsKTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlRnJlcXVlbmN5ID0gbmV4dFByb3BzLmFuaW1haXRvbkR1cmF0aW9uICogVklFV1BPUlRfQU5JTUFURV9GUkVRVUVOQ1k7XG4gICAgcmV0dXJuIHNldEludGVydmFsKCgpID0+IHRoaXMuX3VwZGF0ZVZpZXdwb3J0KCksIHVwZGF0ZUZyZXF1ZW5jeSk7XG4gIH1cblxuICBfZGlkVmlld3BvcnRBbmltYXRlUHJvcENoYW5nZWQoc3RhcnRWaWV3cG9ydCwgZW5kVmlld3BvcnQpIHtcbiAgICAvLyBUT0RPOiBhbHNvIGNoZWNrIGZvciBgYW5pbWF0aW9uRHVyYXRpb25gIGBhbmltYXRpb25GcmVlemVgXG4gICAgZm9yIChjb25zdCBwIG9mIFZJRVdQT1JUX0FOSU1BVEVfUFJPUFMpIHtcbiAgICAgIGlmIChzdGFydFZpZXdwb3J0W3BdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgZW5kVmlld3BvcnRbcF0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBzdGFydFZpZXdwb3J0W3BdICE9PSBlbmRWaWV3cG9ydFtwXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgX2VuZEFuaW1hdGlvbigpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMuYW5pbWF0aW9uQ29udGV4dC5hbmltYXRpb25JbnRlcnZhbCk7XG4gICAgdGhpcy5hbmltYXRpb25FbmRDYWxsYmFjayA9IHRoaXMuYW5pbWF0aW9uQ29udGV4dC5vbkFuaW1hdGlvblN0b3A7XG4gICAgdGhpcy5hbmltYXRpb25FbmRUaW1lID0gdGhpcy5hbmltYXRpb25Db250ZXh0LmFuaW1hdGlvblQ7XG4gICAgLy8gVE9ETzogbWF5IGJlIGp1c3Qgc2V0IGFuaW1hdGlvbkNvbnRleHQgdG8gbnVsbFxuICAgIHRoaXMuYW5pbWF0aW9uQ29udGV4dCA9IHtcbiAgICAgIGFuaW1hdGlvblQ6IDAsXG4gICAgICBhbmltYXRpb25JbnRlcnZhbDogbnVsbCxcbiAgICAgIGFuaW1hdGlvblN0YXJ0U3RhdGU6IG51bGwsXG4gICAgICBhbmltYXRpb25FbmRTdGF0ZTogbnVsbCxcbiAgICAgIGFuaW1hdGVkVmlld3BvcnQ6IG51bGwsXG4gICAgICBvbkFuaW1hdGlvblN0b3A6IG51bGwsXG4gICAgICBvbkFuaW1hdGlvbkludGVycnVwdGlvbjogbnVsbFxuICAgIH07XG4gIH1cblxuICAvLyBUT0RPOiBhZGQgdmlld3BvcnQgb3Igdmlld3BvcnRTdGF0ZSBwcm9wIHRvIGF2b2lkIHRoaXMgZXh0cmFjdGlvbi5cbiAgX2V4dHJhY3RWaWV3cG9ydEZyb21Qcm9wcyhwcm9wcykge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogcHJvcHMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHByb3BzLmhlaWdodCxcbiAgICAgIGxhdGl0dWRlOiBwcm9wcy5sYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZTogcHJvcHMubG9uZ2l0dWRlLFxuICAgICAgem9vbTogcHJvcHMuem9vbSxcbiAgICAgIGJlYXJpbmc6IHByb3BzLmJlYXJpbmcsXG4gICAgICBwaXRjaDogcHJvcHMucGl0Y2gsXG4gICAgICBtaW5ab29tOiBwcm9wcy5taW5ab29tLFxuICAgICAgbWF4Wm9vbTogcHJvcHMubWF4Wm9vbVxuICAgIH07XG4gIH1cblxuICBfaXNBbmltYXRpb25JblByb2dyZXNzKCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbkNvbnRleHQuYW5pbWF0aW9uSW50ZXJ2YWw7XG4gIH1cblxuICBfaXNWaWV3cG9ydEFuaW1hdGlvbkVuYWJsZWQocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuYW5pbWFpdG9uRHVyYXRpb24gIT09IDA7XG4gIH1cblxuICBfaXNUaGVVcGRhdGVEdWVUb0N1cnJlbnRBbmltYXRpb24obmV4dFByb3BzKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uQ29udGV4dC5hbmltYXRlZFZpZXdwb3J0KSB7XG4gICAgICBjb25zdCBuZXdWaWV3cG9ydCA9IHRoaXMuX2V4dHJhY3RWaWV3cG9ydEZyb21Qcm9wcyhuZXh0UHJvcHMpO1xuICAgICAgZm9yIChjb25zdCBwIG9mIFZJRVdQT1JUX0FOSU1BVEVfUFJPUFMpIHtcbiAgICAgICAgaWYgKG5ld1ZpZXdwb3J0W3BdICE9PSB0aGlzLmFuaW1hdGlvbkNvbnRleHQuYW5pbWF0ZWRWaWV3cG9ydFtwXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIF9vbkludGVyYWN0aXZlU3RhdGVDaGFuZ2UoaW50ZXJhY3RpdmVTdGF0ZSkge1xuICAgIGNvbnN0IHtpc0RyYWdnaW5nID0gZmFsc2V9ID0gaW50ZXJhY3RpdmVTdGF0ZTtcbiAgICBpZiAoaXNEcmFnZ2luZyAhPT0gdGhpcy5zdGF0ZS5pc0RyYWdnaW5nKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtpc0RyYWdnaW5nfSk7XG4gICAgfVxuICB9XG5cbiAgX3Byb2Nlc3NWaWV3cG9ydENoYW5nZShuZXh0UHJvcHMpIHtcblxuICAgIGlmICh0aGlzLl9zaG91bGRJZ25vcmVWaWV3cG9ydENoYW5nZShuZXh0UHJvcHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9uRW5kVmlld3BvcnQgPSB0aGlzLmFuaW1hdGlvbkNvbnRleHQgP1xuICAgICAgdGhpcy5hbmltYXRpb25Db250ZXh0LmFuaW1hdGlvbkVuZFZpZXdwb3J0IDogbnVsbDtcbiAgICBjb25zdCBzaG91bGRTbmFwVG9FbmQgPSB0aGlzLl9zaG91bGRFbmRBbmltYXRpb24oKTtcbiAgICBpZiAodGhpcy5faXNBbmltYXRpb25JblByb2dyZXNzKCkpIHtcbiAgICAgIHRoaXMuX2VuZEFuaW1hdGlvbigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc1ZpZXdwb3J0QW5pbWF0aW9uRW5hYmxlZChuZXh0UHJvcHMpKSB7XG4gICAgICBsZXQgc3RhcnRWaWV3cG9ydDtcbiAgICAgIGlmIChzaG91bGRTbmFwVG9FbmQpIHtcbiAgICAgICAgc3RhcnRWaWV3cG9ydCA9IGFuaW1hdGlvbkVuZFZpZXdwb3J0IHx8IHRoaXMuX2V4dHJhY3RWaWV3cG9ydEZyb21Qcm9wcyh0aGlzLnByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0Vmlld3BvcnQgPSB0aGlzLl9leHRyYWN0Vmlld3BvcnRGcm9tUHJvcHModGhpcy5wcm9wcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hbmltYXRlVmlld3BvcnRQcm9wKHN0YXJ0Vmlld3BvcnQsIG5leHRQcm9wcyk7XG4gICAgfVxuICB9XG5cbiAgX3JlY3Vyc2l2ZVVwZGF0ZUNoaWxkcmVuKGNoaWxkcmVuLCB2aWV3cG9ydCkge1xuICAgIHJldHVybiBDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGNoaWxkID0+IHtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IHdlIG5lZWQgdG8gZmlsdGVyIGNoaWRyZW4gYW5kIG9ubHkgdXBkYXRlIHRob3NlIHRoYXQgcmVxdWlyZVxuICAgICAgLy8gdXBkYXRlZCB2aWV3cG9ydCBwcm9wLlxuICAgICAgY29uc3QgY2hpbGRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHZpZXdwb3J0LCB7dmlld3BvcnR9KTtcbiAgICAgIGNoaWxkUHJvcHMuY2hpbGRyZW4gPSB0aGlzLl9yZWN1cnNpdmVVcGRhdGVDaGlsZHJlbihjaGlsZC5wcm9wcy5jaGlsZHJlbiwgdmlld3BvcnQpO1xuICAgICAgY29uc3QgY2xvbmVkID0gY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKTtcbiAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfSk7XG4gIH1cblxuICBfc2hvdWxkRW5kQW5pbWF0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5hbmltYXRpb25Db250ZXh0ICYmXG4gICAgICB0aGlzLmFuaW1hdGlvbkNvbnRleHQub25BbmltYXRpb25JbnRlcnJ1cHRpb24gPT09IEFOSU1BVElPTl9FVkVOVFMuU05BUF9UT19FTkQpO1xuICB9XG5cbiAgX3Nob3VsZElnbm9yZVZpZXdwb3J0Q2hhbmdlKG5leHRQcm9wcykge1xuICAgIC8vIElnbm9yZSB1cGRhdGUgaWYgaXQgaXMgZHVlIHRvIGN1cnJlbnQgYWN0aXZlIGFuaW1hdGlvbi5cbiAgICBpZiAodGhpcy5faXNUaGVVcGRhdGVEdWVUb0N1cnJlbnRBbmltYXRpb24obmV4dFByb3BzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gSWdub3JlIHVwZGF0ZSBpZiBpdCBpcyByZXF1ZXN0ZWQgdG8gaWdub3JlXG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uQ29udGV4dCAmJlxuICAgICAgdGhpcy5hbmltYXRpb25Db250ZXh0Lm9uQW5pbWF0aW9uSW50ZXJydXB0aW9uID09PSBBTklNQVRJT05fRVZFTlRTLklHTk9SRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gSWdub3JlIGlmIG5vbmUgb2YgdGhlIHZpZXdwb3J0IHByb3BzIGNoYW5nZWQuXG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9leHRyYWN0Vmlld3BvcnRGcm9tUHJvcHModGhpcy5wcm9wcyk7XG4gICAgY29uc3QgZW5kID0gdGhpcy5fZXh0cmFjdFZpZXdwb3J0RnJvbVByb3BzKG5leHRQcm9wcyk7XG4gICAgaWYgKCF0aGlzLl9kaWRWaWV3cG9ydEFuaW1hdGVQcm9wQ2hhbmdlZChzdGFydCwgZW5kKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgX3VwZGF0ZVZpZXdwb3J0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnByb3BzLnZpZXdwb3J0QW5pbWF0aW9uRWFzaW5nRnVuYyh0aGlzLmFuaW1hdGlvbkNvbnRleHQuYW5pbWF0aW9uVCk7XG4gICAgY29uc3QgYW5pbWF0ZWRWaWV3cG9ydCA9IHRoaXMucHJvcHMuYW5pbWF0aW9uSW50ZXJwb2xhdG9yKFxuICAgICAgdGhpcy5hbmltYXRpb25Db250ZXh0LmFuaW1hdGlvblN0YXJ0Vmlld3BvcnQsXG4gICAgICB0aGlzLmFuaW1hdGlvbkNvbnRleHQuYW5pbWF0aW9uRW5kVmlld3BvcnQsXG4gICAgICB0XG4gICAgKTtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IHRoaXMuYW5pbWF0aW9uQ29udGV4dC5hbmltYXRpb25UO1xuICAgIGlmIChjdXJyZW50VGltZSA8PSAxLjApIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBDb250cm9sbGVyIHVwZGF0ZSBwaXRjaDogJHthbmltYXRlZFZpZXdwb3J0LnBpdGNofSB0OiAke3R9YCk7XG4gICAgICB0aGlzLmFuaW1hdGlvbkNvbnRleHQuYW5pbWF0aW9uVCA9IChcbiAgICAgICAgY3VycmVudFRpbWUgKyBWSUVXUE9SVF9BTklNQVRFX0ZSRVFVRU5DWSA+IDEuMCAmJlxuICAgICAgICBjdXJyZW50VGltZSArIFZJRVdQT1JUX0FOSU1BVEVfRlJFUVVFTkNZIDwgMS4wICsgVklFV1BPUlRfQU5JTUFURV9GUkVRVUVOQ1lcbiAgICAgICAgKSA/IDEuMCA6IGN1cnJlbnRUaW1lICsgVklFV1BPUlRfQU5JTUFURV9GUkVRVUVOQ1k7XG4gICAgICB0aGlzLmFuaW1hdGlvbkNvbnRleHQuYW5pbWF0ZWRWaWV3cG9ydCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICB0aGlzLmFuaW1hdGlvbkNvbnRleHQuYW5pbWF0aW9uRW5kVmlld3BvcnQsXG4gICAgICAgIGFuaW1hdGVkVmlld3BvcnQpO1xuICAgICAgaWYgKHRoaXMucHJvcHMub25WaWV3cG9ydENoYW5nZSkge1xuICAgICAgICB0aGlzLnByb3BzLm9uVmlld3BvcnRDaGFuZ2UoYW5pbWF0ZWRWaWV3cG9ydCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VuZEFuaW1hdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHQsIGdldEN1cnNvcn0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgZXZlbnRDYW52YXNTdHlsZSA9IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBjdXJzb3I6IGdldEN1cnNvcih0aGlzLnN0YXRlKVxuICAgIH07XG5cbiAgICBsZXQgY2hpbGRyZW5XaXRoUHJvcHM7XG4gICAgaWYgKHRoaXMuX2lzQW5pbWF0aW9uSW5Qcm9ncmVzcygpKSB7XG4gICAgICBjaGlsZHJlbldpdGhQcm9wcyA9IHRoaXMuX3JlY3Vyc2l2ZVVwZGF0ZUNoaWxkcmVuKFxuICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuLFxuICAgICAgICB0aGlzLmFuaW1hdGlvbkNvbnRleHQuYW5pbWF0ZWRWaWV3cG9ydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCc9PT0gQW5pbWF0aW9uQ29udHJvbGxlciBSZW5kZXIgdXNpbmcgb3JpZ2luYWwgcHJvcHMgZm9yIGNoaWxkcmVuJyk7XG4gICAgICBjaGlsZHJlbldpdGhQcm9wcyA9IHRoaXMuX3JlY3Vyc2l2ZVVwZGF0ZUNoaWxkcmVuKFxuICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuLFxuICAgICAgICB0aGlzLl9leHRyYWN0Vmlld3BvcnRGcm9tUHJvcHModGhpcy5wcm9wcykpO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgIGtleTogJ21hcC1jb250cm9scycsXG4gICAgICAgIHJlZjogJ2V2ZW50Q2FudmFzJyxcbiAgICAgICAgc3R5bGU6IGV2ZW50Q2FudmFzU3R5bGVcbiAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuV2l0aFByb3BzXG4gICAgICApXG4gICAgKTtcbiAgfVxufVxuXG5BbmltYXRpb25NYXBDb250cm9sbGVyLmRpc3BsYXlOYW1lID0gJ0FuaW1hdGlvbk1hcENvbnRyb2xsZXInO1xuQW5pbWF0aW9uTWFwQ29udHJvbGxlci5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5BbmltYXRpb25NYXBDb250cm9sbGVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==