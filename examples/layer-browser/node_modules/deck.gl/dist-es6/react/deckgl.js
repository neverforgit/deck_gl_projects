var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import React, { createElement, cloneElement } from 'react';
import autobind from './utils/autobind';
import { experimental } from '../core';
var DeckGLJS = experimental.DeckGLJS;

var DeckGL = function (_React$Component) {
  _inherits(DeckGL, _React$Component);

  function DeckGL(props) {
    _classCallCheck(this, DeckGL);

    var _this = _possibleConstructorReturn(this, (DeckGL.__proto__ || Object.getPrototypeOf(DeckGL)).call(this, props));

    _this.state = {};
    autobind(_this);
    return _this;
  }

  _createClass(DeckGL, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.deck = new DeckGLJS(Object.assign({}, this.props, { canvas: this.refs.overlay }));
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (this.deck) {
        this.deck.setProps(nextProps);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.deck.finalize();
    }

    // Public API

  }, {
    key: 'queryObject',
    value: function queryObject(_ref) {
      var x = _ref.x,
          y = _ref.y,
          _ref$radius = _ref.radius,
          radius = _ref$radius === undefined ? 0 : _ref$radius,
          _ref$layerIds = _ref.layerIds,
          layerIds = _ref$layerIds === undefined ? null : _ref$layerIds;

      return this.deck.queryObject({ x: x, y: y, radius: radius, layerIds: layerIds });
    }
  }, {
    key: 'queryVisibleObjects',
    value: function queryVisibleObjects(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          _ref2$width = _ref2.width,
          width = _ref2$width === undefined ? 1 : _ref2$width,
          _ref2$height = _ref2.height,
          height = _ref2$height === undefined ? 1 : _ref2$height,
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === undefined ? null : _ref2$layerIds;

      return this.deck.queryVisibleObjects({ x: x, y: y, width: width, height: height, layerIds: layerIds });
    }

    // Private Helpers

    // Iterate over viewport descriptors and render children associate with viewports
    // at the specified positions
    // TODO - Can we supply a similar function for the non-React case?

  }, {
    key: '_renderChildrenUnderViewports',
    value: function _renderChildrenUnderViewports() {
      var _this2 = this;

      // Flatten out nested viewports array
      var viewports = this.deck ? this.deck.getViewports() : [];

      // Build a viewport id to viewport index
      var viewportMap = {};
      viewports.forEach(function (viewportDescriptor) {
        var viewport = _this2.deck._getViewportFromDescriptor(viewportDescriptor);
        if (viewport.id) {
          viewportMap[viewport.id] = viewport;
        }
      });

      return React.Children.toArray(this.props.children).map(function (child, i) {
        // If viewportId prop is provided, match with viewport
        var viewportId = child.props.viewportId;

        var viewport = viewportId && viewportMap[viewportId];
        if (viewport) {
          // Resolve potentially relative dimensions using the deck.gl container size
          var _viewport$getDimensio = viewport.getDimensions({ width: _this2.props.width, height: _this2.props.height }),
              x = _viewport$getDimensio.x,
              y = _viewport$getDimensio.y,
              width = _viewport$getDimensio.width,
              height = _viewport$getDimensio.height;

          // Clone the element with width and height set per viewport


          var newProps = Object.assign({}, child.props, {
            width: width,
            height: height
          });

          // Inject map properties
          // TODO - this is too react-map-gl specific
          Object.assign(newProps, viewport.getMercatorParams(), {
            visible: viewport.isMapSynched()
          });

          var clone = cloneElement(child, newProps);

          // Wrap it in an absolutely positioning div
          var style = { position: 'absolute', left: x, top: y, width: width, height: height };
          var key = 'viewport-' + viewportId + '-' + i;
          child = createElement('div', { key: key, id: key, style: style }, clone);
        }

        return child;
      });
    }
  }, {
    key: 'render',
    value: function render() {
      // Render the background elements (typically react-map-gl instances)
      // using the viewport descriptors
      var children = this._renderChildrenUnderViewports();

      // Render deck.gl as last child
      var _props = this.props,
          id = _props.id,
          width = _props.width,
          height = _props.height,
          style = _props.style;

      var deck = createElement('canvas', {
        ref: 'overlay',
        key: 'overlay',
        id: id,
        style: Object.assign({}, style, { position: 'absolute', left: 0, top: 0, width: width, height: height })
      });
      children.push(deck);

      return createElement('div', { id: 'deckgl-wrapper' }, children);
    }
  }]);

  return DeckGL;
}(React.Component);

export default DeckGL;


DeckGL.propTypes = DeckGLJS.propTypes;
DeckGL.defaultProps = DeckGLJS.defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWFjdC9kZWNrZ2wuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiYXV0b2JpbmQiLCJleHBlcmltZW50YWwiLCJEZWNrR0xKUyIsIkRlY2tHTCIsInByb3BzIiwic3RhdGUiLCJkZWNrIiwiT2JqZWN0IiwiYXNzaWduIiwiY2FudmFzIiwicmVmcyIsIm92ZXJsYXkiLCJuZXh0UHJvcHMiLCJzZXRQcm9wcyIsImZpbmFsaXplIiwieCIsInkiLCJyYWRpdXMiLCJsYXllcklkcyIsInF1ZXJ5T2JqZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJxdWVyeVZpc2libGVPYmplY3RzIiwidmlld3BvcnRzIiwiZ2V0Vmlld3BvcnRzIiwidmlld3BvcnRNYXAiLCJmb3JFYWNoIiwidmlld3BvcnQiLCJfZ2V0Vmlld3BvcnRGcm9tRGVzY3JpcHRvciIsInZpZXdwb3J0RGVzY3JpcHRvciIsImlkIiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiY2hpbGRyZW4iLCJtYXAiLCJjaGlsZCIsImkiLCJ2aWV3cG9ydElkIiwiZ2V0RGltZW5zaW9ucyIsIm5ld1Byb3BzIiwiZ2V0TWVyY2F0b3JQYXJhbXMiLCJ2aXNpYmxlIiwiaXNNYXBTeW5jaGVkIiwiY2xvbmUiLCJzdHlsZSIsInBvc2l0aW9uIiwibGVmdCIsInRvcCIsImtleSIsIl9yZW5kZXJDaGlsZHJlblVuZGVyVmlld3BvcnRzIiwicmVmIiwicHVzaCIsIkNvbXBvbmVudCIsInByb3BUeXBlcyIsImRlZmF1bHRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPQSxLQUFQLElBQWVDLGFBQWYsRUFBOEJDLFlBQTlCLFFBQWlELE9BQWpEO0FBQ0EsT0FBT0MsUUFBUCxNQUFx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ZUFBT3JDLE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCb0MsS0FBbEIsRUFBeUIsRUFBQ0MsVUFBVSxVQUFYLEVBQXVCQyxNQUFNLENBQTdCLEVBQWdDQyxLQUFLLENBQXJDLEVBQXdDM0IsWUFBeEMsRUFBK0NDLGNBQS9DLEVBQXpCO0FBSjRCLE9BQXhCLENBQWI7QUFNQVksZUFBU2tCLElBQVQsQ0FBYzdDLElBQWQ7O0FBRUEsYUFBT1IsY0FBYyxLQUFkLEVBQXFCLEVBQUNnQyxJQUFJLGdCQUFMLEVBQXJCLEVBQTZDRyxRQUE3QyxDQUFQO0FBRUQ7Ozs7RUFwR2lDcEMsTUFBTXVELFM7O2VBQXJCakQsTTs7O0FBdUdyQkEsT0FBT2tELFNBQVAsR0FBbUJuRCxTQUFTbUQsU0FBNUI7QUFDQWxELE9BQU9tRCxZQUFQLEdBQXNCcEQsU0FBU29ELFlBQS9CIiwiZmlsZSI6ImRlY2tnbC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgUmVhY3QsIHtjcmVhdGVFbGVtZW50LCBjbG9uZUVsZW1lbnR9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBhdXRvYmluZCBmcm9tICcuL3V0aWxzL2F1dG9iaW5kJztcbmltcG9ydCB7ZXhwZXJpbWVudGFsfSBmcm9tICcuLi9jb3JlJztcbmNvbnN0IHtEZWNrR0xKU30gPSBleHBlcmltZW50YWw7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlY2tHTCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIGF1dG9iaW5kKHRoaXMpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5kZWNrID0gbmV3IERlY2tHTEpTKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHtjYW52YXM6IHRoaXMucmVmcy5vdmVybGF5fSkpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICBpZiAodGhpcy5kZWNrKSB7XG4gICAgICB0aGlzLmRlY2suc2V0UHJvcHMobmV4dFByb3BzKTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmRlY2suZmluYWxpemUoKTtcbiAgfVxuXG4gIC8vIFB1YmxpYyBBUElcblxuICBxdWVyeU9iamVjdCh7eCwgeSwgcmFkaXVzID0gMCwgbGF5ZXJJZHMgPSBudWxsfSkge1xuICAgIHJldHVybiB0aGlzLmRlY2sucXVlcnlPYmplY3Qoe3gsIHksIHJhZGl1cywgbGF5ZXJJZHN9KTtcbiAgfVxuXG4gIHF1ZXJ5VmlzaWJsZU9iamVjdHMoe3gsIHksIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgbGF5ZXJJZHMgPSBudWxsfSkge1xuICAgIHJldHVybiB0aGlzLmRlY2sucXVlcnlWaXNpYmxlT2JqZWN0cyh7eCwgeSwgd2lkdGgsIGhlaWdodCwgbGF5ZXJJZHN9KTtcbiAgfVxuXG4gIC8vIFByaXZhdGUgSGVscGVyc1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB2aWV3cG9ydCBkZXNjcmlwdG9ycyBhbmQgcmVuZGVyIGNoaWxkcmVuIGFzc29jaWF0ZSB3aXRoIHZpZXdwb3J0c1xuICAvLyBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uc1xuICAvLyBUT0RPIC0gQ2FuIHdlIHN1cHBseSBhIHNpbWlsYXIgZnVuY3Rpb24gZm9yIHRoZSBub24tUmVhY3QgY2FzZT9cbiAgX3JlbmRlckNoaWxkcmVuVW5kZXJWaWV3cG9ydHMoKSB7XG4gICAgLy8gRmxhdHRlbiBvdXQgbmVzdGVkIHZpZXdwb3J0cyBhcnJheVxuICAgIGNvbnN0IHZpZXdwb3J0cyA9IHRoaXMuZGVjayA/IHRoaXMuZGVjay5nZXRWaWV3cG9ydHMoKSA6IFtdO1xuXG4gICAgLy8gQnVpbGQgYSB2aWV3cG9ydCBpZCB0byB2aWV3cG9ydCBpbmRleFxuICAgIGNvbnN0IHZpZXdwb3J0TWFwID0ge307XG4gICAgdmlld3BvcnRzLmZvckVhY2godmlld3BvcnREZXNjcmlwdG9yID0+IHtcbiAgICAgIGNvbnN0IHZpZXdwb3J0ID0gdGhpcy5kZWNrLl9nZXRWaWV3cG9ydEZyb21EZXNjcmlwdG9yKHZpZXdwb3J0RGVzY3JpcHRvcik7XG4gICAgICBpZiAodmlld3BvcnQuaWQpIHtcbiAgICAgICAgdmlld3BvcnRNYXBbdmlld3BvcnQuaWRdID0gdmlld3BvcnQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4udG9BcnJheSh0aGlzLnByb3BzLmNoaWxkcmVuKS5tYXAoKGNoaWxkLCBpKSA9PiB7XG4gICAgICAvLyBJZiB2aWV3cG9ydElkIHByb3AgaXMgcHJvdmlkZWQsIG1hdGNoIHdpdGggdmlld3BvcnRcbiAgICAgIGNvbnN0IHt2aWV3cG9ydElkfSA9IGNoaWxkLnByb3BzO1xuICAgICAgY29uc3Qgdmlld3BvcnQgPSB2aWV3cG9ydElkICYmIHZpZXdwb3J0TWFwW3ZpZXdwb3J0SWRdO1xuICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgIC8vIFJlc29sdmUgcG90ZW50aWFsbHkgcmVsYXRpdmUgZGltZW5zaW9ucyB1c2luZyB0aGUgZGVjay5nbCBjb250YWluZXIgc2l6ZVxuICAgICAgICBjb25zdCB7eCwgeSwgd2lkdGgsIGhlaWdodH0gPVxuICAgICAgICAgIHZpZXdwb3J0LmdldERpbWVuc2lvbnMoe3dpZHRoOiB0aGlzLnByb3BzLndpZHRoLCBoZWlnaHQ6IHRoaXMucHJvcHMuaGVpZ2h0fSk7XG5cbiAgICAgICAgLy8gQ2xvbmUgdGhlIGVsZW1lbnQgd2l0aCB3aWR0aCBhbmQgaGVpZ2h0IHNldCBwZXIgdmlld3BvcnRcbiAgICAgICAgY29uc3QgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBjaGlsZC5wcm9wcywge1xuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJbmplY3QgbWFwIHByb3BlcnRpZXNcbiAgICAgICAgLy8gVE9ETyAtIHRoaXMgaXMgdG9vIHJlYWN0LW1hcC1nbCBzcGVjaWZpY1xuICAgICAgICBPYmplY3QuYXNzaWduKG5ld1Byb3BzLCB2aWV3cG9ydC5nZXRNZXJjYXRvclBhcmFtcygpLCB7XG4gICAgICAgICAgdmlzaWJsZTogdmlld3BvcnQuaXNNYXBTeW5jaGVkKClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgY2xvbmUgPSBjbG9uZUVsZW1lbnQoY2hpbGQsIG5ld1Byb3BzKTtcblxuICAgICAgICAvLyBXcmFwIGl0IGluIGFuIGFic29sdXRlbHkgcG9zaXRpb25pbmcgZGl2XG4gICAgICAgIGNvbnN0IHN0eWxlID0ge3Bvc2l0aW9uOiAnYWJzb2x1dGUnLCBsZWZ0OiB4LCB0b3A6IHksIHdpZHRoLCBoZWlnaHR9O1xuICAgICAgICBjb25zdCBrZXkgPSBgdmlld3BvcnQtJHt2aWV3cG9ydElkfS0ke2l9YDtcbiAgICAgICAgY2hpbGQgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCB7a2V5LCBpZDoga2V5LCBzdHlsZX0sIGNsb25lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIC8vIFJlbmRlciB0aGUgYmFja2dyb3VuZCBlbGVtZW50cyAodHlwaWNhbGx5IHJlYWN0LW1hcC1nbCBpbnN0YW5jZXMpXG4gICAgLy8gdXNpbmcgdGhlIHZpZXdwb3J0IGRlc2NyaXB0b3JzXG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJDaGlsZHJlblVuZGVyVmlld3BvcnRzKCk7XG5cbiAgICAvLyBSZW5kZXIgZGVjay5nbCBhcyBsYXN0IGNoaWxkXG4gICAgY29uc3Qge2lkLCB3aWR0aCwgaGVpZ2h0LCBzdHlsZX0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGRlY2sgPSBjcmVhdGVFbGVtZW50KCdjYW52YXMnLCB7XG4gICAgICByZWY6ICdvdmVybGF5JyxcbiAgICAgIGtleTogJ292ZXJsYXknLFxuICAgICAgaWQsXG4gICAgICBzdHlsZTogT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIHtwb3NpdGlvbjogJ2Fic29sdXRlJywgbGVmdDogMCwgdG9wOiAwLCB3aWR0aCwgaGVpZ2h0fSlcbiAgICB9KTtcbiAgICBjaGlsZHJlbi5wdXNoKGRlY2spO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtpZDogJ2RlY2tnbC13cmFwcGVyJ30sIGNoaWxkcmVuKTtcblxuICB9XG59XG5cbkRlY2tHTC5wcm9wVHlwZXMgPSBEZWNrR0xKUy5wcm9wVHlwZXM7XG5EZWNrR0wuZGVmYXVsdFByb3BzID0gRGVja0dMSlMuZGVmYXVsdFByb3BzO1xuIl19