var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import LayerManager from '../lib/layer-manager';
import EffectManager from '../experimental/lib/effect-manager';
import Effect from '../experimental/lib/effect';
import WebMercatorViewport from '../viewports/web-mercator-viewport';

import { EventManager } from 'mjolnir.js';
import { GL, AnimationLoop, createGLContext, setParameters } from 'luma.gl';

import PropTypes from 'prop-types';

/* global document */

function noop() {}

var propTypes = {
  id: PropTypes.string,
  width: PropTypes.number.isRequired,
  height: PropTypes.number.isRequired,
  layers: PropTypes.array.isRequired, // Array can contain falsy values
  viewports: PropTypes.array, // Array can contain falsy values
  effects: PropTypes.arrayOf(PropTypes.instanceOf(Effect)),
  glOptions: PropTypes.object,
  gl: PropTypes.object,
  pickingRadius: PropTypes.number,
  initWebGLParameters: PropTypes.bool,
  onWebGLInitialized: PropTypes.func,
  onBeforeRender: PropTypes.func,
  onAfterRender: PropTypes.func,
  onLayerClick: PropTypes.func,
  onLayerHover: PropTypes.func,
  useDevicePixelRatio: PropTypes.bool,

  // Debug settings
  debug: PropTypes.bool,
  drawPickingColors: PropTypes.bool
};

var defaultProps = {
  id: 'deckgl-overlay',
  pickingRadius: 0,
  glOptions: {},
  gl: null,
  effects: [],
  initWebGLParameters: false, // Will be set to true in next major release
  onWebGLInitialized: noop,
  onBeforeRender: noop,
  onAfterRender: noop,
  onLayerClick: null,
  onLayerHover: null,
  useDevicePixelRatio: false,

  debug: false,
  drawPickingColors: false
};

// TODO - should this class be joined with `LayerManager`?

var DeckGLJS = function () {
  function DeckGLJS(props) {
    var _this = this;

    _classCallCheck(this, DeckGLJS);

    props = Object.assign({}, defaultProps, props);

    this.state = {};
    this.needsRedraw = true;
    this.layerManager = null;
    this.effectManager = null;
    this.viewports = [];

    // Bind methods
    this._onRendererInitialized = this._onRendererInitialized.bind(this);
    this._onRenderFrame = this._onRenderFrame.bind(this);

    this.canvas = this._createCanvas(props);

    var _props = props,
        width = _props.width,
        height = _props.height,
        gl = _props.gl,
        glOptions = _props.glOptions,
        debug = _props.debug;


    this.animationLoop = new AnimationLoop({
      width: width,
      height: height,
      useDevicePixelRatio: false,
      onCreateContext: function onCreateContext(opts) {
        return gl || createGLContext(Object.assign({}, glOptions, { canvas: _this.canvas, debug: debug }));
      },
      onInitialize: this._onRendererInitialized,
      onRender: this._onRenderFrame,
      onBeforeRender: props.onBeforeRender,
      onAfterRender: props.onAfterRender
    });

    this.animationLoop.start();

    this.setProps(props);
  }

  _createClass(DeckGLJS, [{
    key: 'setProps',
    value: function setProps(props) {
      props = Object.assign({}, this.props, props);
      this.props = props;

      if (!this.layerManager) {
        return;
      }

      var _props2 = props,
          pickingRadius = _props2.pickingRadius,
          onLayerClick = _props2.onLayerClick,
          onLayerHover = _props2.onLayerHover,
          useDevicePixelRatio = _props2.useDevicePixelRatio,
          drawPickingColors = _props2.drawPickingColors;

      // If more parameters need to be updated on layerManager add them to this method.

      this.layerManager.setParameters({
        useDevicePixelRatio: useDevicePixelRatio,
        drawPickingColors: drawPickingColors
      });

      this.layerManager.setEventHandlingParameters({
        pickingRadius: pickingRadius,
        onLayerClick: onLayerClick,
        onLayerHover: onLayerHover
      });

      // Update viewports (creating one if not supplied)
      var viewports = props.viewports || props.viewport;
      if (!viewports) {
        var _props3 = props,
            width = _props3.width,
            height = _props3.height,
            latitude = _props3.latitude,
            longitude = _props3.longitude,
            zoom = _props3.zoom,
            pitch = _props3.pitch,
            bearing = _props3.bearing;

        viewports = [new WebMercatorViewport({ width: width, height: height, latitude: latitude, longitude: longitude, zoom: zoom, pitch: pitch, bearing: bearing })];
      }
      this.layerManager.setViewports(viewports);

      // TODO - this is a HACK: UpdateLayers needs one viewport prop set each time
      if (props.layers) {
        this.layerManager.updateLayers({ newLayers: props.layers });
      }
    }
  }, {
    key: 'finalize',
    value: function finalize() {
      this.animationLoop.stop();
      this.animationLoop = null;

      if (this.layerManager) {
        this.layerManager.finalize();
        this.layerManager = null;
      }
    }

    // Public API

  }, {
    key: 'queryObject',
    value: function queryObject(_ref) {
      var x = _ref.x,
          y = _ref.y,
          _ref$radius = _ref.radius,
          radius = _ref$radius === undefined ? 0 : _ref$radius,
          _ref$layerIds = _ref.layerIds,
          layerIds = _ref$layerIds === undefined ? null : _ref$layerIds;

      var selectedInfos = this.layerManager.pickObject({ x: x, y: y, radius: radius, layerIds: layerIds, mode: 'query' });
      return selectedInfos.length ? selectedInfos[0] : null;
    }
  }, {
    key: 'queryVisibleObjects',
    value: function queryVisibleObjects(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          _ref2$width = _ref2.width,
          width = _ref2$width === undefined ? 1 : _ref2$width,
          _ref2$height = _ref2.height,
          height = _ref2$height === undefined ? 1 : _ref2$height,
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === undefined ? null : _ref2$layerIds;

      return this.layerManager.pickVisibleObjects({ x: x, y: y, width: width, height: height, layerIds: layerIds });
    }
  }, {
    key: 'getViewports',
    value: function getViewports() {
      return this.layerManager ? this.layerManager.getViewports() : [];
    }

    // Experimental

    // Gets actual viewport from a viewport "descriptor" object: viewport || {viewport: ..., ...}

  }, {
    key: '_getViewportFromDescriptor',
    value: function _getViewportFromDescriptor(viewportOrDescriptor) {
      return this.layerManager._getViewportFromDescriptor(viewportOrDescriptor);
    }

    // Private Methods

  }, {
    key: '_createCanvas',
    value: function _createCanvas(props) {
      if (props.canvas) {
        return props.canvas;
      }

      var id = props.id,
          width = props.width,
          height = props.height,
          style = props.style;

      var canvas = document.createElement('canvas');
      canvas.id = id;
      canvas.width = width;
      canvas.height = height;
      canvas.style = style;

      var parent = props.parent || document.body;
      parent.appendChild(canvas);

      return canvas;
    }

    // Callbacks

  }, {
    key: '_onRendererInitialized',
    value: function _onRendererInitialized(_ref3) {
      var gl = _ref3.gl,
          canvas = _ref3.canvas;

      setParameters(gl, {
        blend: true,
        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA],
        polygonOffsetFill: true
      });

      // TODO - these should be set by default starting from next major release
      if (this.props.initWebGLParameters) {
        setParameters(gl, {
          depthTest: true,
          depthFunc: GL.LEQUAL
        });
      }

      this.props.onWebGLInitialized(gl);

      // Note: avoid React setState due GL animation loop / setState timing issue
      this.layerManager = new LayerManager({ gl: gl });
      this.layerManager.initEventHandling(new EventManager(canvas));
      this.effectManager = new EffectManager({ gl: gl, layerManager: this.layerManager });

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.props.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;

          this.effectManager.addEffect(effect);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.setProps(this.props);
    }
  }, {
    key: '_onRenderFrame',
    value: function _onRenderFrame(_ref4) {
      var gl = _ref4.gl;

      var redraw = this.layerManager.needsRedraw({ clearRedrawFlags: true });
      if (!redraw) {
        return;
      }

      this.props.onBeforeRender({ gl: gl }); // TODO - should be called by AnimationLoop
      this.layerManager.drawLayers({
        pass: 'render to screen',
        // Helps debug layer picking, especially in framebuffer powered layers
        drawPickingColors: this.props.drawPickingColors
      });
      this.props.onAfterRender({ gl: gl }); // TODO - should be called by AnimationLoop
    }
  }]);

  return DeckGLJS;
}();

export default DeckGLJS;


DeckGLJS.propTypes = propTypes;
DeckGLJS.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL3B1cmUtanMvZGVjay5qcyJdLCJuYW1lcyI6WyJMYXllck1hbmFnZXIiLCJFZmZlY3RNYW5hZ2VyIiwiRWZmZWN0IiwiV2ViTWVyY2F0b3JWaWV3cG9ydCIsIkV2ZW50TWFuYWdlciIsIkdMIiwiQW5pbWF0aW9uTG9vcCIsImNyZWF0ZUdMQ29udGV4dCIsInNldFBhcmFtZXRlcnMiLCJQcm9wVHlwZXMiLCJub29wIiwicHJvcFR5cGVzIiwiaWQiLCJzdHJpbmciLCJ3aWR0aCIsIm51bWJlciIsImlzUmVxdWlyZWQiLCJoZWlnaHQiLCJsYXllcnMiLCJhcnJheSIsInZpZXdwb3J0cyIsImVmZmVjdHMiLCJhcnJheU9mIiwiaW5zdGFuY2VPZiIsImdsT3B0aW9ucyIsIm9iamVjdCIsImdsIiwicGlja2luZ1JhZGl1cyIsImluaXRXZWJHTFBhcmFtZXRlcnMiLCJib29sIiwib25XZWJHTEluaXRpYWxpemVkIiwiZnVuYyIsIm9uQmVmb3JlUmVuZGVyIiwib25BZnRlclJlbmRlciIsIm9uTGF5ZXJDbGljayIsIm9uTGF5ZXJIb3ZlciIsInVzZURldmljZVBpeGVsUmF0aW8iLCJkZWJ1ZyIsImRyYXdQaWNraW5nQ29sb3JzIiwiZGVmYXVsdFByb3BzIiwiRGVja0dMSlMiLCJwcm9wcyIsIk9iamVjdCIsImFzc2lnbiIsInN0YXRlIiwibmVlZHNSZWRyYXciLCJsYXllck1hbmFnZXIiLCJlZmZlY3RNYW5hZ2VyIiwiX29uUmVuZGVyZXJJbml0aWFsaXplZCIsImJpbmQiLCJfb25SZW5kZXJGcmFtZSIsImNhbnZhcyIsIl9jcmVhdGVDYW52YXMiLCJhbmltYXRpb25Mb29wIiwib25DcmVhdGVDb250ZXh0Iiwib25Jbml0aWFsaXplIiwib25SZW5kZXIiLCJzdGFydCIsInNldFByb3BzIiwic2V0RXZlbnRIYW5kbGluZ1BhcmFtZXRlcnMiLCJ2aWV3cG9ydCIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiem9vbSIsInBpdGNoIiwiYmVhcmluZyIsInNldFZpZXdwb3J0cyIsInVwZGF0ZUxheWVycyIsIm5ld0xheWVycyIsInN0b3AiLCJmaW5hbGl6ZSIsIngiLCJ5IiwicmFkaXVzIiwibGF5ZXJJZHMiLCJzZWxlY3RlZEluZm9zIiwicGlja09iamVjdCIsIm1vZGUiLCJsZW5ndGgiLCJwaWNrVmlzaWJsZU9iamVjdHMiLCJnZXRWaWV3cG9ydHMiLCJ2aWV3cG9ydE9yRGVzY3JpcHRvciIsIl9nZXRWaWV3cG9ydEZyb21EZXNjcmlwdG9yIiwic3R5bGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJwYXJlbnQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJibGVuZCIsImJsZW5kRnVuYyIsIlNSQ19BTFBIQSIsIk9ORV9NSU5VU19TUkNfQUxQSEEiLCJwb2x5Z29uT2Zmc2V0RmlsbCIsImRlcHRoVGVzdCIsImRlcHRoRnVuYyIsIkxFUVVBTCIsImluaXRFdmVudEhhbmRsaW5nIiwiZWZmZWN0IiwiYWRkRWZmZWN0IiwicmVkcmF3IiwiY2xlYXJSZWRyYXdGbGFncyIsImRyYXdMYXllcnMiLCJwYXNzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBT0EsWUFBUCxNQUF5QixzQkFBekI7QUFDQSxPQUFPQyxhQUFQLE1BQTBCLG9DQUExQjtBQUNBLE9BQU9DLE1BQVAsTUFBbUIsNEJBQW5CO0FBQ0EsT0FBT0MsbUJBQVAsTUFBZ0Msb0NBQWhDOztBQUVBLFNBQVFDLFlBQVIsUUFBMkIsWUFBM0I7QUFDQSxTQUFRQyxFQUFSLEVBQVlDLGFBQVosRUFBMkJDLGVBQTNCLEVBQTRDQyxhQUE1QyxRQUFnRSxTQUFoRTs7QUFFQSxPQUFPQyxTQUFQLE1BQXNCLFlBQXRCOztBQUVBOztBQUVBLFNBQVNDLElBQVQsR0FBZ0IsQ0FBRTs7QUFFbEIsSUFBTUMsWUFBWTtBQUNoQkMs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QyxRQUFMLENBQWMsS0FBS2pCLEtBQW5CO0FBQ0Q7OzswQ0FFb0I7QUFBQSxVQUFMZixFQUFLLFNBQUxBLEVBQUs7O0FBQ25CLFVBQU0wRSxTQUFTLEtBQUt0RCxZQUFMLENBQWtCRCxXQUFsQixDQUE4QixFQUFDd0Qsa0JBQWtCLElBQW5CLEVBQTlCLENBQWY7QUFDQSxVQUFJLENBQUNELE1BQUwsRUFBYTtBQUNYO0FBQ0Q7O0FBRUQsV0FBSzNELEtBQUwsQ0FBV1QsY0FBWCxDQUEwQixFQUFDTixNQUFELEVBQTFCLEVBTm1CLENBTWM7QUFDakMsV0FBS29CLFlBQUwsQ0FBa0J3RCxVQUFsQixDQUE2QjtBQUMzQkMsY0FBTSxrQkFEcUI7QUFFM0I7QUFDQWpFLDJCQUFtQixLQUFLRyxLQUFMLENBQVdIO0FBSEgsT0FBN0I7QUFLQSxXQUFLRyxLQUFMLENBQVdSLGFBQVgsQ0FBeUIsRUFBQ1AsTUFBRCxFQUF6QixFQVptQixDQVlhO0FBQ2pDOzs7Ozs7ZUFoTGtCYyxROzs7QUFtTHJCQSxTQUFTN0IsU0FBVCxHQUFxQkEsU0FBckI7QUFDQTZCLFNBQVNELFlBQVQsR0FBd0JBLFlBQXhCIiwiZmlsZSI6ImRlY2suanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IExheWVyTWFuYWdlciBmcm9tICcuLi9saWIvbGF5ZXItbWFuYWdlcic7XG5pbXBvcnQgRWZmZWN0TWFuYWdlciBmcm9tICcuLi9leHBlcmltZW50YWwvbGliL2VmZmVjdC1tYW5hZ2VyJztcbmltcG9ydCBFZmZlY3QgZnJvbSAnLi4vZXhwZXJpbWVudGFsL2xpYi9lZmZlY3QnO1xuaW1wb3J0IFdlYk1lcmNhdG9yVmlld3BvcnQgZnJvbSAnLi4vdmlld3BvcnRzL3dlYi1tZXJjYXRvci12aWV3cG9ydCc7XG5cbmltcG9ydCB7RXZlbnRNYW5hZ2VyfSBmcm9tICdtam9sbmlyLmpzJztcbmltcG9ydCB7R0wsIEFuaW1hdGlvbkxvb3AsIGNyZWF0ZUdMQ29udGV4dCwgc2V0UGFyYW1ldGVyc30gZnJvbSAnbHVtYS5nbCc7XG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbi8qIGdsb2JhbCBkb2N1bWVudCAqL1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuY29uc3QgcHJvcFR5cGVzID0ge1xuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGxheWVyczogUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsIC8vIEFycmF5IGNhbiBjb250YWluIGZhbHN5IHZhbHVlc1xuICB2aWV3cG9ydHM6IFByb3BUeXBlcy5hcnJheSwgLy8gQXJyYXkgY2FuIGNvbnRhaW4gZmFsc3kgdmFsdWVzXG4gIGVmZmVjdHM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5pbnN0YW5jZU9mKEVmZmVjdCkpLFxuICBnbE9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGdsOiBQcm9wVHlwZXMub2JqZWN0LFxuICBwaWNraW5nUmFkaXVzOiBQcm9wVHlwZXMubnVtYmVyLFxuICBpbml0V2ViR0xQYXJhbWV0ZXJzOiBQcm9wVHlwZXMuYm9vbCxcbiAgb25XZWJHTEluaXRpYWxpemVkOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25CZWZvcmVSZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICBvbkFmdGVyUmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25MYXllckNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25MYXllckhvdmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgdXNlRGV2aWNlUGl4ZWxSYXRpbzogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLy8gRGVidWcgc2V0dGluZ3NcbiAgZGVidWc6IFByb3BUeXBlcy5ib29sLFxuICBkcmF3UGlja2luZ0NvbG9yczogUHJvcFR5cGVzLmJvb2xcbn07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgaWQ6ICdkZWNrZ2wtb3ZlcmxheScsXG4gIHBpY2tpbmdSYWRpdXM6IDAsXG4gIGdsT3B0aW9uczoge30sXG4gIGdsOiBudWxsLFxuICBlZmZlY3RzOiBbXSxcbiAgaW5pdFdlYkdMUGFyYW1ldGVyczogZmFsc2UsIC8vIFdpbGwgYmUgc2V0IHRvIHRydWUgaW4gbmV4dCBtYWpvciByZWxlYXNlXG4gIG9uV2ViR0xJbml0aWFsaXplZDogbm9vcCxcbiAgb25CZWZvcmVSZW5kZXI6IG5vb3AsXG4gIG9uQWZ0ZXJSZW5kZXI6IG5vb3AsXG4gIG9uTGF5ZXJDbGljazogbnVsbCxcbiAgb25MYXllckhvdmVyOiBudWxsLFxuICB1c2VEZXZpY2VQaXhlbFJhdGlvOiBmYWxzZSxcblxuICBkZWJ1ZzogZmFsc2UsXG4gIGRyYXdQaWNraW5nQ29sb3JzOiBmYWxzZVxufTtcblxuLy8gVE9ETyAtIHNob3VsZCB0aGlzIGNsYXNzIGJlIGpvaW5lZCB3aXRoIGBMYXllck1hbmFnZXJgP1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVja0dMSlMge1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UHJvcHMsIHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICB0aGlzLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICB0aGlzLmxheWVyTWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy5lZmZlY3RNYW5hZ2VyID0gbnVsbDtcbiAgICB0aGlzLnZpZXdwb3J0cyA9IFtdO1xuXG4gICAgLy8gQmluZCBtZXRob2RzXG4gICAgdGhpcy5fb25SZW5kZXJlckluaXRpYWxpemVkID0gdGhpcy5fb25SZW5kZXJlckluaXRpYWxpemVkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25SZW5kZXJGcmFtZSA9IHRoaXMuX29uUmVuZGVyRnJhbWUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuY2FudmFzID0gdGhpcy5fY3JlYXRlQ2FudmFzKHByb3BzKTtcblxuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBnbCwgZ2xPcHRpb25zLCBkZWJ1Z30gPSBwcm9wcztcblxuICAgIHRoaXMuYW5pbWF0aW9uTG9vcCA9IG5ldyBBbmltYXRpb25Mb29wKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdXNlRGV2aWNlUGl4ZWxSYXRpbzogZmFsc2UsXG4gICAgICBvbkNyZWF0ZUNvbnRleHQ6IG9wdHMgPT5cbiAgICAgICAgZ2wgfHwgY3JlYXRlR0xDb250ZXh0KE9iamVjdC5hc3NpZ24oe30sIGdsT3B0aW9ucywge2NhbnZhczogdGhpcy5jYW52YXMsIGRlYnVnfSkpLFxuICAgICAgb25Jbml0aWFsaXplOiB0aGlzLl9vblJlbmRlcmVySW5pdGlhbGl6ZWQsXG4gICAgICBvblJlbmRlcjogdGhpcy5fb25SZW5kZXJGcmFtZSxcbiAgICAgIG9uQmVmb3JlUmVuZGVyOiBwcm9wcy5vbkJlZm9yZVJlbmRlcixcbiAgICAgIG9uQWZ0ZXJSZW5kZXI6IHByb3BzLm9uQWZ0ZXJSZW5kZXJcbiAgICB9KTtcblxuICAgIHRoaXMuYW5pbWF0aW9uTG9vcC5zdGFydCgpO1xuXG4gICAgdGhpcy5zZXRQcm9wcyhwcm9wcyk7XG4gIH1cblxuICBzZXRQcm9wcyhwcm9wcykge1xuICAgIHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywgcHJvcHMpO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcblxuICAgIGlmICghdGhpcy5sYXllck1hbmFnZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBwaWNraW5nUmFkaXVzLFxuICAgICAgb25MYXllckNsaWNrLFxuICAgICAgb25MYXllckhvdmVyLFxuICAgICAgdXNlRGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgIGRyYXdQaWNraW5nQ29sb3JzXG4gICAgfSA9IHByb3BzO1xuXG4gICAgLy8gSWYgbW9yZSBwYXJhbWV0ZXJzIG5lZWQgdG8gYmUgdXBkYXRlZCBvbiBsYXllck1hbmFnZXIgYWRkIHRoZW0gdG8gdGhpcyBtZXRob2QuXG4gICAgdGhpcy5sYXllck1hbmFnZXIuc2V0UGFyYW1ldGVycyh7XG4gICAgICB1c2VEZXZpY2VQaXhlbFJhdGlvLFxuICAgICAgZHJhd1BpY2tpbmdDb2xvcnNcbiAgICB9KTtcblxuICAgIHRoaXMubGF5ZXJNYW5hZ2VyLnNldEV2ZW50SGFuZGxpbmdQYXJhbWV0ZXJzKHtcbiAgICAgIHBpY2tpbmdSYWRpdXMsXG4gICAgICBvbkxheWVyQ2xpY2ssXG4gICAgICBvbkxheWVySG92ZXJcbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSB2aWV3cG9ydHMgKGNyZWF0aW5nIG9uZSBpZiBub3Qgc3VwcGxpZWQpXG4gICAgbGV0IHZpZXdwb3J0cyA9IHByb3BzLnZpZXdwb3J0cyB8fCBwcm9wcy52aWV3cG9ydDtcbiAgICBpZiAoIXZpZXdwb3J0cykge1xuICAgICAgY29uc3Qge3dpZHRoLCBoZWlnaHQsIGxhdGl0dWRlLCBsb25naXR1ZGUsIHpvb20sIHBpdGNoLCBiZWFyaW5nfSA9IHByb3BzO1xuICAgICAgdmlld3BvcnRzID0gW1xuICAgICAgICBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh7d2lkdGgsIGhlaWdodCwgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgem9vbSwgcGl0Y2gsIGJlYXJpbmd9KVxuICAgICAgXTtcbiAgICB9XG4gICAgdGhpcy5sYXllck1hbmFnZXIuc2V0Vmlld3BvcnRzKHZpZXdwb3J0cyk7XG5cbiAgICAvLyBUT0RPIC0gdGhpcyBpcyBhIEhBQ0s6IFVwZGF0ZUxheWVycyBuZWVkcyBvbmUgdmlld3BvcnQgcHJvcCBzZXQgZWFjaCB0aW1lXG4gICAgaWYgKHByb3BzLmxheWVycykge1xuICAgICAgdGhpcy5sYXllck1hbmFnZXIudXBkYXRlTGF5ZXJzKHtuZXdMYXllcnM6IHByb3BzLmxheWVyc30pO1xuICAgIH1cbiAgfVxuXG4gIGZpbmFsaXplKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uTG9vcC5zdG9wKCk7XG4gICAgdGhpcy5hbmltYXRpb25Mb29wID0gbnVsbDtcblxuICAgIGlmICh0aGlzLmxheWVyTWFuYWdlcikge1xuICAgICAgdGhpcy5sYXllck1hbmFnZXIuZmluYWxpemUoKTtcbiAgICAgIHRoaXMubGF5ZXJNYW5hZ2VyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBQdWJsaWMgQVBJXG5cbiAgcXVlcnlPYmplY3Qoe3gsIHksIHJhZGl1cyA9IDAsIGxheWVySWRzID0gbnVsbH0pIHtcbiAgICBjb25zdCBzZWxlY3RlZEluZm9zID0gdGhpcy5sYXllck1hbmFnZXIucGlja09iamVjdCh7eCwgeSwgcmFkaXVzLCBsYXllcklkcywgbW9kZTogJ3F1ZXJ5J30pO1xuICAgIHJldHVybiBzZWxlY3RlZEluZm9zLmxlbmd0aCA/IHNlbGVjdGVkSW5mb3NbMF0gOiBudWxsO1xuICB9XG5cbiAgcXVlcnlWaXNpYmxlT2JqZWN0cyh7eCwgeSwgd2lkdGggPSAxLCBoZWlnaHQgPSAxLCBsYXllcklkcyA9IG51bGx9KSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJNYW5hZ2VyLnBpY2tWaXNpYmxlT2JqZWN0cyh7eCwgeSwgd2lkdGgsIGhlaWdodCwgbGF5ZXJJZHN9KTtcbiAgfVxuXG4gIGdldFZpZXdwb3J0cygpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllck1hbmFnZXIgPyB0aGlzLmxheWVyTWFuYWdlci5nZXRWaWV3cG9ydHMoKSA6IFtdO1xuICB9XG5cbiAgLy8gRXhwZXJpbWVudGFsXG5cbiAgLy8gR2V0cyBhY3R1YWwgdmlld3BvcnQgZnJvbSBhIHZpZXdwb3J0IFwiZGVzY3JpcHRvclwiIG9iamVjdDogdmlld3BvcnQgfHwge3ZpZXdwb3J0OiAuLi4sIC4uLn1cbiAgX2dldFZpZXdwb3J0RnJvbURlc2NyaXB0b3Iodmlld3BvcnRPckRlc2NyaXB0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllck1hbmFnZXIuX2dldFZpZXdwb3J0RnJvbURlc2NyaXB0b3Iodmlld3BvcnRPckRlc2NyaXB0b3IpO1xuICB9XG5cbiAgLy8gUHJpdmF0ZSBNZXRob2RzXG5cbiAgX2NyZWF0ZUNhbnZhcyhwcm9wcykge1xuICAgIGlmIChwcm9wcy5jYW52YXMpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jYW52YXM7XG4gICAgfVxuXG4gICAgY29uc3Qge2lkLCB3aWR0aCwgaGVpZ2h0LCBzdHlsZX0gPSBwcm9wcztcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMuaWQgPSBpZDtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGNhbnZhcy5zdHlsZSA9IHN0eWxlO1xuXG4gICAgY29uc3QgcGFyZW50ID0gcHJvcHMucGFyZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNhbnZhcyk7XG5cbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG5cbiAgLy8gQ2FsbGJhY2tzXG5cbiAgX29uUmVuZGVyZXJJbml0aWFsaXplZCh7Z2wsIGNhbnZhc30pIHtcbiAgICBzZXRQYXJhbWV0ZXJzKGdsLCB7XG4gICAgICBibGVuZDogdHJ1ZSxcbiAgICAgIGJsZW5kRnVuYzogW0dMLlNSQ19BTFBIQSwgR0wuT05FX01JTlVTX1NSQ19BTFBIQV0sXG4gICAgICBwb2x5Z29uT2Zmc2V0RmlsbDogdHJ1ZVxuICAgIH0pO1xuXG4gICAgLy8gVE9ETyAtIHRoZXNlIHNob3VsZCBiZSBzZXQgYnkgZGVmYXVsdCBzdGFydGluZyBmcm9tIG5leHQgbWFqb3IgcmVsZWFzZVxuICAgIGlmICh0aGlzLnByb3BzLmluaXRXZWJHTFBhcmFtZXRlcnMpIHtcbiAgICAgIHNldFBhcmFtZXRlcnMoZ2wsIHtcbiAgICAgICAgZGVwdGhUZXN0OiB0cnVlLFxuICAgICAgICBkZXB0aEZ1bmM6IEdMLkxFUVVBTFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5wcm9wcy5vbldlYkdMSW5pdGlhbGl6ZWQoZ2wpO1xuXG4gICAgLy8gTm90ZTogYXZvaWQgUmVhY3Qgc2V0U3RhdGUgZHVlIEdMIGFuaW1hdGlvbiBsb29wIC8gc2V0U3RhdGUgdGltaW5nIGlzc3VlXG4gICAgdGhpcy5sYXllck1hbmFnZXIgPSBuZXcgTGF5ZXJNYW5hZ2VyKHtnbH0pO1xuICAgIHRoaXMubGF5ZXJNYW5hZ2VyLmluaXRFdmVudEhhbmRsaW5nKG5ldyBFdmVudE1hbmFnZXIoY2FudmFzKSk7XG4gICAgdGhpcy5lZmZlY3RNYW5hZ2VyID0gbmV3IEVmZmVjdE1hbmFnZXIoe2dsLCBsYXllck1hbmFnZXI6IHRoaXMubGF5ZXJNYW5hZ2VyfSk7XG5cbiAgICBmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLnByb3BzLmVmZmVjdHMpIHtcbiAgICAgIHRoaXMuZWZmZWN0TWFuYWdlci5hZGRFZmZlY3QoZWZmZWN0KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFByb3BzKHRoaXMucHJvcHMpO1xuICB9XG5cbiAgX29uUmVuZGVyRnJhbWUoe2dsfSkge1xuICAgIGNvbnN0IHJlZHJhdyA9IHRoaXMubGF5ZXJNYW5hZ2VyLm5lZWRzUmVkcmF3KHtjbGVhclJlZHJhd0ZsYWdzOiB0cnVlfSk7XG4gICAgaWYgKCFyZWRyYXcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLm9uQmVmb3JlUmVuZGVyKHtnbH0pOyAvLyBUT0RPIC0gc2hvdWxkIGJlIGNhbGxlZCBieSBBbmltYXRpb25Mb29wXG4gICAgdGhpcy5sYXllck1hbmFnZXIuZHJhd0xheWVycyh7XG4gICAgICBwYXNzOiAncmVuZGVyIHRvIHNjcmVlbicsXG4gICAgICAvLyBIZWxwcyBkZWJ1ZyBsYXllciBwaWNraW5nLCBlc3BlY2lhbGx5IGluIGZyYW1lYnVmZmVyIHBvd2VyZWQgbGF5ZXJzXG4gICAgICBkcmF3UGlja2luZ0NvbG9yczogdGhpcy5wcm9wcy5kcmF3UGlja2luZ0NvbG9yc1xuICAgIH0pO1xuICAgIHRoaXMucHJvcHMub25BZnRlclJlbmRlcih7Z2x9KTsgLy8gVE9ETyAtIHNob3VsZCBiZSBjYWxsZWQgYnkgQW5pbWF0aW9uTG9vcFxuICB9XG59XG5cbkRlY2tHTEpTLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbkRlY2tHTEpTLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbiJdfQ==