var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import log from '../utils/log';

import { Matrix4, Vector3, equals as _equals } from 'math.gl';
import { transformVector, createMat4, extractCameraVectors } from '../math/utils';
import mat4_scale from 'gl-mat4/scale';
import mat4_translate from 'gl-mat4/translate';
import mat4_multiply from 'gl-mat4/multiply';
import mat4_invert from 'gl-mat4/invert';
import mat4_perspective from 'gl-mat4/perspective';

import vec2_lerp from 'gl-vec2/lerp';

var ZERO_VECTOR = [0, 0, 0];

import { getMercatorDistanceScales, getMercatorWorldPosition, getMercatorMeterZoom } from 'viewport-mercator-project';

import assert from 'assert';

var IDENTITY = createMat4();

var DEFAULT_DISTANCE_SCALES = {
  pixelsPerMeter: [1, 1, 1],
  metersPerPixel: [1, 1, 1],
  pixelsPerDegree: [1, 1, 1],
  degreesPerPixel: [1, 1, 1]
};

var DEFAULT_ZOOM = 0;

var ERR_ARGUMENT = 'Illegal argument to Viewport';

var Viewport = function () {
  /**
   * @classdesc
   * Manages coordinate system transformations for deck.gl.
   *
   * Note: The Viewport is immutable in the sense that it only has accessors.
   * A new viewport instance should be created if any parameters have changed.
   */
  /* eslint-disable complexity, max-statements */
  function Viewport() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Viewport);

    var _opts$id = opts.id,
        id = _opts$id === undefined ? null : _opts$id,
        _opts$x = opts.x,
        x = _opts$x === undefined ? 0 : _opts$x,
        _opts$y = opts.y,
        y = _opts$y === undefined ? 0 : _opts$y,
        _opts$width = opts.width,
        width = _opts$width === undefined ? 1 : _opts$width,
        _opts$height = opts.height,
        height = _opts$height === undefined ? 1 : _opts$height,
        _opts$viewMatrix = opts.viewMatrix,
        viewMatrix = _opts$viewMatrix === undefined ? IDENTITY : _opts$viewMatrix,
        _opts$projectionMatri = opts.projectionMatrix,
        projectionMatrix = _opts$projectionMatri === undefined ? null : _opts$projectionMatri,
        _opts$fovy = opts.fovy,
        fovy = _opts$fovy === undefined ? 75 : _opts$fovy,
        _opts$near = opts.near,
        near = _opts$near === undefined ? 0.1 : _opts$near,
        _opts$far = opts.far,
        far = _opts$far === undefined ? 1000 : _opts$far,
        _opts$longitude = opts.longitude,
        longitude = _opts$longitude === undefined ? null : _opts$longitude,
        _opts$latitude = opts.latitude,
        latitude = _opts$latitude === undefined ? null : _opts$latitude,
        _opts$zoom = opts.zoom,
        zoom = _opts$zoom === undefined ? null : _opts$zoom,
        _opts$position = opts.position,
        position = _opts$position === undefined ? null : _opts$position,
        _opts$modelMatrix = opts.modelMatrix,
        modelMatrix = _opts$modelMatrix === undefined ? null : _opts$modelMatrix,
        _opts$distanceScales = opts.distanceScales,
        distanceScales = _opts$distanceScales === undefined ? null : _opts$distanceScales;


    this.id = id || this.constructor.displayName || 'viewport';

    // Check if we have a geospatial anchor
    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);

    // Silently allow apps to send in w,h = 0,0
    this.x = x;
    this.y = y;
    this.width = width || 1;
    this.height = height || 1;

    this.zoom = zoom;
    if (!Number.isFinite(this.zoom)) {
      this.zoom = this.isGeospatial ? getMercatorMeterZoom({ latitude: latitude }) : DEFAULT_ZOOM;
    }
    this.scale = Math.pow(2, this.zoom);

    // Calculate distance scales if lng/lat/zoom are provided
    this.distanceScales = this.isGeospatial ? getMercatorDistanceScales({ latitude: latitude, longitude: longitude, scale: this.scale }) : distanceScales || DEFAULT_DISTANCE_SCALES;

    this.focalDistance = opts.focalDistance || 1;

    this.distanceScales.metersPerPixel = new Vector3(this.distanceScales.metersPerPixel);
    this.distanceScales.pixelsPerMeter = new Vector3(this.distanceScales.pixelsPerMeter);

    this.position = ZERO_VECTOR;
    this.meterOffset = ZERO_VECTOR;
    if (position) {
      // Apply model matrix if supplied
      this.position = position;
      this.modelMatrix = modelMatrix;
      this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;
    }

    // Determine camera center
    this.center = this.isGeospatial ? getMercatorWorldPosition({
      longitude: longitude, latitude: latitude, zoom: this.zoom, meterOffset: this.meterOffset
    }) : position;

    // console.log(this.scale, this.distanceScales.pixelsPerMeter);

    this.viewMatrixUncentered = viewMatrix;

    // Make a centered version of the matrix for projection modes without an offset
    this.viewMatrix = new Matrix4()
    // Apply the uncentered view matrix
    .multiplyRight(this.viewMatrixUncentered)
    // The Mercator world coordinate system is upper left,
    // but GL expects lower left, so we flip it around the center after all transforms are done
    .scale([1, -1, 1])
    // And center it
    .translate(new Vector3(this.center || ZERO_VECTOR).negate());

    // Create a projection matrix if not supplied
    if (projectionMatrix) {
      this.projectionMatrix = projectionMatrix;
    } else {
      assert(Number.isFinite(fovy));
      var DEGREES_TO_RADIANS = Math.PI / 180;
      var fovyRadians = fovy * DEGREES_TO_RADIANS;
      var aspect = this.width / this.height;
      this.projectionMatrix = mat4_perspective([], fovyRadians, aspect, near, far);
    }

    // Init pixel matrices
    this._initMatrices();

    // Bind methods for easy access
    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
    this.getMatrices = this.getMatrices.bind(this);
  }
  /* eslint-enable complexity, max-statements */

  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.


  _createClass(Viewport, [{
    key: 'equals',
    value: function equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }

      return viewport.width === this.width && viewport.height === this.height && _equals(viewport.projectionMatrix, this.projectionMatrix) && _equals(viewport.viewMatrix, this.viewMatrix);
      // TODO - check distance scales?
    }

    /**
     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
     * using viewport projection parameters
     * - [longitude, latitude] to [x, y]
     * - [longitude, latitude, Z] => [x, y, z]
     * Note: By default, returns top-left coordinates for canvas/SVG type render
     *
     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
     * @param {Object} opts - options
     * @param {Object} opts.topLeft=true - Whether projected coords are top left
     * @return {Array} - [x, y] or [x, y, z] in top left coords
     */

  }, {
    key: 'project',
    value: function project(xyz) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$topLeft = _ref.topLeft,
          topLeft = _ref$topLeft === undefined ? false : _ref$topLeft;

      var _xyz = _slicedToArray(xyz, 3),
          x0 = _xyz[0],
          y0 = _xyz[1],
          _xyz$ = _xyz[2],
          z0 = _xyz$ === undefined ? 0 : _xyz$;

      assert(Number.isFinite(x0) && Number.isFinite(y0) && Number.isFinite(z0), ERR_ARGUMENT);

      var _projectFlat2 = this.projectFlat([x0, y0]),
          _projectFlat3 = _slicedToArray(_projectFlat2, 2),
          X = _projectFlat3[0],
          Y = _projectFlat3[1];

      var v = transformVector(this.pixelProjectionMatrix, [X, Y, z0, 1]);

      var _v = _slicedToArray(v, 2),
          x = _v[0],
          y = _v[1];

      var y2 = topLeft ? this.height - y : y;
      return xyz.length === 2 ? [x, y2] : [x, y2, 0];
    }

    /**
     * Unproject pixel coordinates on screen onto world coordinates,
     * (possibly [lon, lat]) on map.
     * - [x, y] => [lng, lat]
     * - [x, y, z] => [lng, lat, Z]
     * @param {Array} xyz -
     * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
     */

  }, {
    key: 'unproject',
    value: function unproject(xyz) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$topLeft = _ref2.topLeft,
          topLeft = _ref2$topLeft === undefined ? false : _ref2$topLeft;

      var _xyz2 = _slicedToArray(xyz, 3),
          x = _xyz2[0],
          y = _xyz2[1],
          _xyz2$ = _xyz2[2],
          targetZ = _xyz2$ === undefined ? 0 : _xyz2$;

      var y2 = topLeft ? this.height - y : y;

      // since we don't know the correct projected z value for the point,
      // unproject two points to get a line and then find the point on that line with z=0
      var coord0 = transformVector(this.pixelUnprojectionMatrix, [x, y2, 0, 1]);
      var coord1 = transformVector(this.pixelUnprojectionMatrix, [x, y2, 1, 1]);

      if (!coord0 || !coord1) {
        return null;
      }

      var z0 = coord0[2];
      var z1 = coord1[2];

      var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);
      var v = vec2_lerp([], coord0, coord1, t);

      var vUnprojected = this.unprojectFlat(v);
      return xyz.length === 2 ? vUnprojected : [vUnprojected[0], vUnprojected[1], 0];
    }

    // NON_LINEAR PROJECTION HOOKS
    // Used for web meractor projection

    /**
     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
     * Performs the nonlinear part of the web mercator projection.
     * Remaining projection is done with 4x4 matrices which also handles
     * perspective.
     * @param {Array} lngLat - [lng, lat] coordinates
     *   Specifies a point on the sphere to project onto the map.
     * @return {Array} [x,y] coordinates.
     */

  }, {
    key: 'projectFlat',
    value: function projectFlat(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          x = _ref4[0],
          y = _ref4[1];

      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._projectFlat.apply(this, arguments);
    }

    /**
     * Unproject world point [x,y] on map onto {lat, lon} on sphere
     * @param {object|Vector} xy - object with {x,y} members
     *  representing point on projected map plane
     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
     *   Has toArray method if you need a GeoJSON Array.
     *   Per cartographic tradition, lat and lon are specified as degrees.
     */

  }, {
    key: 'unprojectFlat',
    value: function unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return this._unprojectFlat.apply(this, arguments);
    }

    // TODO - why do we need these?

  }, {
    key: '_projectFlat',
    value: function _projectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }
  }, {
    key: '_unprojectFlat',
    value: function _unprojectFlat(xyz) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;

      return xyz;
    }
  }, {
    key: 'getMercatorParams',
    value: function getMercatorParams() {
      var lngLat = this._addMetersToLngLat([this.longitude || 0, this.latitude || 0], this.meterOffset);
      return {
        longitude: lngLat[0],
        latitude: lngLat[1]
      };
    }
  }, {
    key: 'isMapSynched',
    value: function isMapSynched() {
      return false;
    }
  }, {
    key: 'getDistanceScales',
    value: function getDistanceScales() {
      return this.distanceScales;
    }
  }, {
    key: 'getMatrices',
    value: function getMatrices() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$modelMatrix = _ref5.modelMatrix,
          modelMatrix = _ref5$modelMatrix === undefined ? null : _ref5$modelMatrix;

      var modelViewProjectionMatrix = this.viewProjectionMatrix;
      var pixelProjectionMatrix = this.pixelProjectionMatrix;
      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;

      if (modelMatrix) {
        modelViewProjectionMatrix = mat4_multiply([], this.viewProjectionMatrix, modelMatrix);
        pixelProjectionMatrix = mat4_multiply([], this.pixelProjectionMatrix, modelMatrix);
        pixelUnprojectionMatrix = mat4_invert([], pixelProjectionMatrix);
      }

      var matrices = Object.assign({
        modelViewProjectionMatrix: modelViewProjectionMatrix,
        viewProjectionMatrix: this.viewProjectionMatrix,
        viewMatrix: this.viewMatrix,
        projectionMatrix: this.projectionMatrix,

        // project/unproject between pixels and world
        pixelProjectionMatrix: pixelProjectionMatrix,
        pixelUnprojectionMatrix: pixelUnprojectionMatrix,

        width: this.width,
        height: this.height,
        scale: this.scale
      });

      return matrices;
    }

    // EXPERIMENTAL METHODS

    // Support for relative viewport dimensions
    // TODO - parses same strings a number of times

  }, {
    key: 'getDimensions',
    value: function getDimensions(_ref6) {
      var width = _ref6.width,
          height = _ref6.height;

      return {
        /* eslint-disable max-len */
        x: typeof this.x === 'string' ? Math.round(parseFloat(this.x) / 100 * width) : this.x,
        y: typeof this.y === 'string' ? Math.round(parseFloat(this.y) / 100 * height) : this.y,
        width: typeof this.width === 'string' ? Math.round(parseFloat(this.width) / 100 * width) : this.width,
        height: typeof this.height === 'string' ? Math.round(parseFloat(this.x) / 100 * height) : this.height
        /* eslint-enable max-len */
      };
    }
  }, {
    key: 'getCameraPosition',
    value: function getCameraPosition() {
      return this.cameraPosition;
    }
  }, {
    key: 'getCameraDirection',
    value: function getCameraDirection() {
      return this.cameraDirection;
    }
  }, {
    key: 'getCameraUp',
    value: function getCameraUp() {
      return this.cameraUp;
    }

    // TODO - these are duplicating WebMercator methods

  }, {
    key: '_addMetersToLngLat',
    value: function _addMetersToLngLat(lngLatZ, xyz) {
      var _lngLatZ = _slicedToArray(lngLatZ, 3),
          lng = _lngLatZ[0],
          lat = _lngLatZ[1],
          _lngLatZ$ = _lngLatZ[2],
          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;

      var _metersToLngLatDelta2 = this._metersToLngLatDelta(xyz),
          _metersToLngLatDelta3 = _slicedToArray(_metersToLngLatDelta2, 3),
          deltaLng = _metersToLngLatDelta3[0],
          deltaLat = _metersToLngLatDelta3[1],
          _metersToLngLatDelta4 = _metersToLngLatDelta3[2],
          deltaZ = _metersToLngLatDelta4 === undefined ? 0 : _metersToLngLatDelta4;

      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
    }
  }, {
    key: '_metersToLngLatDelta',
    value: function _metersToLngLatDelta(xyz) {
      var _xyz3 = _slicedToArray(xyz, 3),
          x = _xyz3[0],
          y = _xyz3[1],
          _xyz3$ = _xyz3[2],
          z = _xyz3$ === undefined ? 0 : _xyz3$;

      assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
      var _distanceScales = this.distanceScales,
          pixelsPerMeter = _distanceScales.pixelsPerMeter,
          degreesPerPixel = _distanceScales.degreesPerPixel;

      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
    }

    // INTERNAL METHODS

  }, {
    key: '_initMatrices',
    value: function _initMatrices() {
      // Note: As usual, matrix operations should be applied in "reverse" order
      // since vectors will be multiplied in from the right during transformation
      var vpm = createMat4();
      mat4_multiply(vpm, vpm, this.projectionMatrix);
      mat4_multiply(vpm, vpm, this.viewMatrix);
      this.viewProjectionMatrix = vpm;

      // console.log('VPM', this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);

      // Calculate inverse view matrix
      this.viewMatrixInverse = mat4_invert([], this.viewMatrix) || this.viewMatrix;

      // Decompose camera directions

      var _extractCameraVectors = extractCameraVectors({
        viewMatrix: this.viewMatrix,
        viewMatrixInverse: this.viewMatrixInverse
      }),
          eye = _extractCameraVectors.eye,
          direction = _extractCameraVectors.direction,
          up = _extractCameraVectors.up;

      this.cameraPosition = eye;
      this.cameraDirection = direction;
      this.cameraUp = up;

      // console.log(this.cameraPosition, this.cameraDirection, this.cameraUp);

      /*
       * Builds matrices that converts preprojected lngLats to screen pixels
       * and vice versa.
       * Note: Currently returns bottom-left coordinates!
       * Note: Starts with the GL projection matrix and adds steps to the
       *       scale and translate that matrix onto the window.
       * Note: WebGL controls clip space to screen projection with gl.viewport
       *       and does not need this step.
       */

      // matrix for conversion from world location to screen (pixel) coordinates
      var m = createMat4();
      mat4_scale(m, m, [this.width / 2, -this.height / 2, 1]);
      mat4_translate(m, m, [1, -1, 0]);
      mat4_multiply(m, m, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = m;

      this.pixelUnprojectionMatrix = mat4_invert(createMat4(), this.pixelProjectionMatrix);
      if (!this.pixelUnprojectionMatrix) {
        log.warn('Pixel project matrix not invertible');
        // throw new Error('Pixel project matrix not invertible');
      }
    }
  }]);

  return Viewport;
}();

export default Viewport;


Viewport.displayName = 'Viewport';
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL3ZpZXdwb3J0cy92aWV3cG9ydC5qcyJdLCJuYW1lcyI6WyJsb2ciLCJNYXRyaXg0IiwiVmVjdG9yMyIsImVxdWFscyIsInRyYW5zZm9ybVZlY3RvciIsImNyZWF0ZU1hdDQiLCJleHRyYWN0Q2FtZXJhVmVjdG9ycyIsIm1hdDRfc2NhbGUiLCJtYXQ0X3RyYW5zbGF0ZSIsIm1hdDRfbXVsdGlwbHkiLCJtYXQ0X2ludmVydCIsIm1hdDRfcGVyc3BlY3RpdmUiLCJ2ZWMyX2xlcnAiLCJaRVJPX1ZFQ1RPUiIsImdldE1lcmNhdG9yRGlzdGFuY2VTY2FsZXMiLCJnZXRNZXJjYXRvcldvcmxkUG9zaXRpb24iLCJnZXRNZXJjYXRvck1ldGVyWm9vbSIsImFzc2VydCIsIklERU5USVRZIiwiREVGQVVMVF9ESVNUQU5DRV9TQ0FMRVMiLCJwaXhlbHNQZXJNZXRlciIsIm1ldGVyc1BlclBpeGVsIiwicGl4ZWxzUGVyRGVncmVlIiwiZGVncmVlc1BlclBpeGVsIiwiREVGQVVMVF9aT09NIiwiRVJSX0FSR1VNRU5UIiwiVmlld3BvcnQiLCJvcHRzIiwiaWQiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0Iiwidmlld01hdHJpeCIsInByb2plY3Rpb25NYXRyaXgiLCJmb3Z5IiwibmVhciIsImZhciIsImxvbmdpdHVkZSIsImxhdGl0dWRlIiwiem9vbSIsInBvc2l0aW9uIiwibW9kZWxNYXRyaXgiLCJkaXN0YW5jZVNjYWxlcyIsImNvbnN0cnVjdG9yIiwiZGlzcGxheU5hbWUiLCJpc0dlb3NwYXRpYWwiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInNjYWxlIiwiTWF0aCIsInBvdyIsImZvY2FsRGlzdGFuY2UiLCJtZXRlck9mZnNldCIsImNlbnRlciIsInZpZXdNYXRyaXhVbmNlbnRlcmVkIiwibXVsdGlwbHlSaWdodCIsInRyYW5zbGF0ZSIsIm5lZ2F0ZSIsIkRFR1JFRVNfVE9fUkFESUFOUyIsIlBJIiwiZm92eVJhZGlhbnMiLCJhc3BlY3QiLCJfaW5pdE1hdHJpY2VzIiwiYmluZCIsInByb2plY3QiLCJ1bnByb2plY3QiLCJwcm9qZWN0RmxhdCIsInVucHJvamVjdEZsYXQiLCJnZXRNYXRyaWNlcyIsInZpZXdwb3J0IiwieHl6IiwidG9wTGVmdCIsIngwIiwieTAiLCJ6MCIsIlgiLCJZIiwidiIsInBpeGVsUHJvamVjdGlvbk1hdHJpeCIsInkyIiwibGVuZ3RoIiwidGFyZ2V0WiIsImNvb3JkMCIsInBpeGVsVW5wcm9qZWN0aW9uTWF0cml4IiwiY29vcmQxIiwiejEiLCJ0IiwidlVucHJvamVjdGVkIiwiX3Byb2plY3RGbGF0IiwiYXJndW1lbnRzIiwiX3VucHJvamVjdEZsYXQiLCJsbmdMYXQiLCJfYWRkTWV0ZXJzVG9MbmdMYXQiLCJtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4Iiwidmlld1Byb2plY3Rpb25NYXRyaXgiLCJtYXRyaWNlcyIsIk9iamVjdCIsImFzc2lnbiIsInJvdW5kIiwicGFyc2VGbG9hdCIsImNhbWVyYVBvc2l0aW9uIiwiY2FtZXJhRGlyZWN0aW9uIiwiY2FtZXJhVXAiLCJsbmdMYXRaIiwibG5nIiwibGF0IiwiWiIsIl9tZXRlcnNUb0xuZ0xhdERlbHRhIiwiZGVsdGFMbmciLCJkZWx0YUxhdCIsImRlbHRhWiIsInoiLCJ2cG0iLCJ2aWV3TWF0cml4SW52ZXJzZSIsImV5ZSIsImRpcmVjdGlvbiIsInVwIiwibSIsIndhcm4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU9BLEdBQVAsTUFBZ0IsY0FBaEI7O0FBRUEsU0FBUUMsT0FBUixFQUFpQkMsT0FBakIsRUFBMEJDLGlCQUExQixRQUF1QyxTQUF2QztBQUNBLFNBQVFDLGVBQVIsRUFBeUJDLFVBQXpCLEVBQXFDQyxvQkFBckMsUUFBZ0UsZUFBaEU7QUFDQSxPQUFPQyxVQUFQLE1BQXVCLGVB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aEIscUJBQUwsR0FBNkJ1QyxDQUE3Qjs7QUFFQSxXQUFLbEMsdUJBQUwsR0FBK0IxRSxZQUFZTCxZQUFaLEVBQTBCLEtBQUswRSxxQkFBL0IsQ0FBL0I7QUFDQSxVQUFJLENBQUMsS0FBS0ssdUJBQVYsRUFBbUM7QUFDakNwRixZQUFJdUgsSUFBSixDQUFTLHFDQUFUO0FBQ0E7QUFDRDtBQUNGOzs7Ozs7ZUFwWGtCN0YsUTs7O0FBdVhyQkEsU0FBU21CLFdBQVQsR0FBdUIsVUFBdkIiLCJmaWxlIjoidmlld3BvcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IGxvZyBmcm9tICcuLi91dGlscy9sb2cnO1xuXG5pbXBvcnQge01hdHJpeDQsIFZlY3RvcjMsIGVxdWFsc30gZnJvbSAnbWF0aC5nbCc7XG5pbXBvcnQge3RyYW5zZm9ybVZlY3RvciwgY3JlYXRlTWF0NCwgZXh0cmFjdENhbWVyYVZlY3RvcnN9IGZyb20gJy4uL21hdGgvdXRpbHMnO1xuaW1wb3J0IG1hdDRfc2NhbGUgZnJvbSAnZ2wtbWF0NC9zY2FsZSc7XG5pbXBvcnQgbWF0NF90cmFuc2xhdGUgZnJvbSAnZ2wtbWF0NC90cmFuc2xhdGUnO1xuaW1wb3J0IG1hdDRfbXVsdGlwbHkgZnJvbSAnZ2wtbWF0NC9tdWx0aXBseSc7XG5pbXBvcnQgbWF0NF9pbnZlcnQgZnJvbSAnZ2wtbWF0NC9pbnZlcnQnO1xuaW1wb3J0IG1hdDRfcGVyc3BlY3RpdmUgZnJvbSAnZ2wtbWF0NC9wZXJzcGVjdGl2ZSc7XG5cbmltcG9ydCB2ZWMyX2xlcnAgZnJvbSAnZ2wtdmVjMi9sZXJwJztcblxuY29uc3QgWkVST19WRUNUT1IgPSBbMCwgMCwgMF07XG5cbmltcG9ydCB7XG4gIGdldE1lcmNhdG9yRGlzdGFuY2VTY2FsZXMsXG4gIGdldE1lcmNhdG9yV29ybGRQb3NpdGlvbixcbiAgZ2V0TWVyY2F0b3JNZXRlclpvb21cbn0gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuY29uc3QgSURFTlRJVFkgPSBjcmVhdGVNYXQ0KCk7XG5cbmNvbnN0IERFRkFVTFRfRElTVEFOQ0VfU0NBTEVTID0ge1xuICBwaXhlbHNQZXJNZXRlcjogWzEsIDEsIDFdLFxuICBtZXRlcnNQZXJQaXhlbDogWzEsIDEsIDFdLFxuICBwaXhlbHNQZXJEZWdyZWU6IFsxLCAxLCAxXSxcbiAgZGVncmVlc1BlclBpeGVsOiBbMSwgMSwgMV1cbn07XG5cbmNvbnN0IERFRkFVTFRfWk9PTSA9IDA7XG5cbmNvbnN0IEVSUl9BUkdVTUVOVCA9ICdJbGxlZ2FsIGFyZ3VtZW50IHRvIFZpZXdwb3J0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlld3BvcnQge1xuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBNYW5hZ2VzIGNvb3JkaW5hdGUgc3lzdGVtIHRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjay5nbC5cbiAgICpcbiAgICogTm90ZTogVGhlIFZpZXdwb3J0IGlzIGltbXV0YWJsZSBpbiB0aGUgc2Vuc2UgdGhhdCBpdCBvbmx5IGhhcyBhY2Nlc3NvcnMuXG4gICAqIEEgbmV3IHZpZXdwb3J0IGluc3RhbmNlIHNob3VsZCBiZSBjcmVhdGVkIGlmIGFueSBwYXJhbWV0ZXJzIGhhdmUgY2hhbmdlZC5cbiAgICovXG4gIC8qIGVzbGludC1kaXNhYmxlIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzICovXG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkID0gbnVsbCxcblxuICAgICAgLy8gV2luZG93IHdpZHRoL2hlaWdodCBpbiBwaXhlbHMgKGZvciBwaXhlbCBwcm9qZWN0aW9uKVxuICAgICAgeCA9IDAsXG4gICAgICB5ID0gMCxcbiAgICAgIHdpZHRoID0gMSxcbiAgICAgIGhlaWdodCA9IDEsXG5cbiAgICAgIC8vIHZpZXcgbWF0cml4XG4gICAgICB2aWV3TWF0cml4ID0gSURFTlRJVFksXG5cbiAgICAgIC8vIFByb2plY3Rpb24gbWF0cml4XG4gICAgICBwcm9qZWN0aW9uTWF0cml4ID0gbnVsbCxcblxuICAgICAgLy8gUGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggcGFyYW1ldGVycywgdXNlZCBpZiBwcm9qZWN0aW9uTWF0cml4IG5vdCBzdXBwbGllZFxuICAgICAgZm92eSA9IDc1LFxuICAgICAgbmVhciA9IDAuMSwgIC8vIERpc3RhbmNlIG9mIG5lYXIgY2xpcHBpbmcgcGxhbmVcbiAgICAgIGZhciA9IDEwMDAsIC8vIERpc3RhbmNlIG9mIGZhciBjbGlwcGluZyBwbGFuZVxuXG4gICAgICAvLyBBbmNob3I6IGxuZyBsYXQgem9vbSB3aWxsIG1ha2UgdGhpcyB2aWV3cG9ydCB3b3JrIHdpdGggZ2Vvc3BhdGlhbCBjb29yZGluYXRlIHN5c3RlbXNcbiAgICAgIGxvbmdpdHVkZSA9IG51bGwsXG4gICAgICBsYXRpdHVkZSA9IG51bGwsXG4gICAgICB6b29tID0gbnVsbCxcblxuICAgICAgLy8gQW5jaG9yIHBvc2l0aW9uIG9mZnNldCAoaW4gbWV0ZXJzIGZvciBnZW9zcGF0aWFsIHZpZXdwb3J0cylcbiAgICAgIHBvc2l0aW9uID0gbnVsbCxcbiAgICAgIC8vIEEgbW9kZWwgbWF0cml4IHRvIGJlIGFwcGxpZWQgdG8gcG9zaXRpb24sIHRvIG1hdGNoIHRoZSBsYXllciBwcm9wcyBBUElcbiAgICAgIG1vZGVsTWF0cml4ID0gbnVsbCxcblxuICAgICAgZGlzdGFuY2VTY2FsZXMgPSBudWxsXG4gICAgfSA9IG9wdHM7XG5cbiAgICB0aGlzLmlkID0gaWQgfHwgdGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAndmlld3BvcnQnO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIGdlb3NwYXRpYWwgYW5jaG9yXG4gICAgdGhpcy5pc0dlb3NwYXRpYWwgPSBOdW1iZXIuaXNGaW5pdGUobGF0aXR1ZGUpICYmIE51bWJlci5pc0Zpbml0ZShsb25naXR1ZGUpO1xuXG4gICAgLy8gU2lsZW50bHkgYWxsb3cgYXBwcyB0byBzZW5kIGluIHcsaCA9IDAsMFxuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGggfHwgMTtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAxO1xuXG4gICAgdGhpcy56b29tID0gem9vbTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0aGlzLnpvb20pKSB7XG4gICAgICB0aGlzLnpvb20gPSB0aGlzLmlzR2Vvc3BhdGlhbCA/IGdldE1lcmNhdG9yTWV0ZXJab29tKHtsYXRpdHVkZX0pIDogREVGQVVMVF9aT09NO1xuICAgIH1cbiAgICB0aGlzLnNjYWxlID0gTWF0aC5wb3coMiwgdGhpcy56b29tKTtcblxuICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSBzY2FsZXMgaWYgbG5nL2xhdC96b29tIGFyZSBwcm92aWRlZFxuICAgIHRoaXMuZGlzdGFuY2VTY2FsZXMgPSB0aGlzLmlzR2Vvc3BhdGlhbCA/XG4gICAgICBnZXRNZXJjYXRvckRpc3RhbmNlU2NhbGVzKHtsYXRpdHVkZSwgbG9uZ2l0dWRlLCBzY2FsZTogdGhpcy5zY2FsZX0pIDpcbiAgICAgIGRpc3RhbmNlU2NhbGVzIHx8IERFRkFVTFRfRElTVEFOQ0VfU0NBTEVTO1xuXG4gICAgdGhpcy5mb2NhbERpc3RhbmNlID0gb3B0cy5mb2NhbERpc3RhbmNlIHx8IDE7XG5cbiAgICB0aGlzLmRpc3RhbmNlU2NhbGVzLm1ldGVyc1BlclBpeGVsID0gbmV3IFZlY3RvcjModGhpcy5kaXN0YW5jZVNjYWxlcy5tZXRlcnNQZXJQaXhlbCk7XG4gICAgdGhpcy5kaXN0YW5jZVNjYWxlcy5waXhlbHNQZXJNZXRlciA9IG5ldyBWZWN0b3IzKHRoaXMuZGlzdGFuY2VTY2FsZXMucGl4ZWxzUGVyTWV0ZXIpO1xuXG4gICAgdGhpcy5wb3NpdGlvbiA9IFpFUk9fVkVDVE9SO1xuICAgIHRoaXMubWV0ZXJPZmZzZXQgPSBaRVJPX1ZFQ1RPUjtcbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIC8vIEFwcGx5IG1vZGVsIG1hdHJpeCBpZiBzdXBwbGllZFxuICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgdGhpcy5tb2RlbE1hdHJpeCA9IG1vZGVsTWF0cml4O1xuICAgICAgdGhpcy5tZXRlck9mZnNldCA9IG1vZGVsTWF0cml4ID8gbW9kZWxNYXRyaXgudHJhbnNmb3JtVmVjdG9yKHBvc2l0aW9uKSA6IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBjYW1lcmEgY2VudGVyXG4gICAgdGhpcy5jZW50ZXIgPSB0aGlzLmlzR2Vvc3BhdGlhbCA/XG4gICAgICBnZXRNZXJjYXRvcldvcmxkUG9zaXRpb24oe1xuICAgICAgICBsb25naXR1ZGUsIGxhdGl0dWRlLCB6b29tOiB0aGlzLnpvb20sIG1ldGVyT2Zmc2V0OiB0aGlzLm1ldGVyT2Zmc2V0XG4gICAgICB9KSA6XG4gICAgICBwb3NpdGlvbjtcblxuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuc2NhbGUsIHRoaXMuZGlzdGFuY2VTY2FsZXMucGl4ZWxzUGVyTWV0ZXIpO1xuXG4gICAgdGhpcy52aWV3TWF0cml4VW5jZW50ZXJlZCA9IHZpZXdNYXRyaXg7XG5cbiAgICAvLyBNYWtlIGEgY2VudGVyZWQgdmVyc2lvbiBvZiB0aGUgbWF0cml4IGZvciBwcm9qZWN0aW9uIG1vZGVzIHdpdGhvdXQgYW4gb2Zmc2V0XG4gICAgdGhpcy52aWV3TWF0cml4ID0gbmV3IE1hdHJpeDQoKVxuICAgICAgLy8gQXBwbHkgdGhlIHVuY2VudGVyZWQgdmlldyBtYXRyaXhcbiAgICAgIC5tdWx0aXBseVJpZ2h0KHRoaXMudmlld01hdHJpeFVuY2VudGVyZWQpXG4gICAgICAvLyBUaGUgTWVyY2F0b3Igd29ybGQgY29vcmRpbmF0ZSBzeXN0ZW0gaXMgdXBwZXIgbGVmdCxcbiAgICAgIC8vIGJ1dCBHTCBleHBlY3RzIGxvd2VyIGxlZnQsIHNvIHdlIGZsaXAgaXQgYXJvdW5kIHRoZSBjZW50ZXIgYWZ0ZXIgYWxsIHRyYW5zZm9ybXMgYXJlIGRvbmVcbiAgICAgIC5zY2FsZShbMSwgLTEsIDFdKVxuICAgICAgLy8gQW5kIGNlbnRlciBpdFxuICAgICAgLnRyYW5zbGF0ZShuZXcgVmVjdG9yMyh0aGlzLmNlbnRlciB8fCBaRVJPX1ZFQ1RPUikubmVnYXRlKCkpO1xuXG4gICAgLy8gQ3JlYXRlIGEgcHJvamVjdGlvbiBtYXRyaXggaWYgbm90IHN1cHBsaWVkXG4gICAgaWYgKHByb2plY3Rpb25NYXRyaXgpIHtcbiAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IHByb2plY3Rpb25NYXRyaXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoZm92eSkpO1xuICAgICAgY29uc3QgREVHUkVFU19UT19SQURJQU5TID0gTWF0aC5QSSAvIDE4MDtcbiAgICAgIGNvbnN0IGZvdnlSYWRpYW5zID0gZm92eSAqIERFR1JFRVNfVE9fUkFESUFOUztcbiAgICAgIGNvbnN0IGFzcGVjdCA9IHRoaXMud2lkdGggLyB0aGlzLmhlaWdodDtcbiAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG1hdDRfcGVyc3BlY3RpdmUoW10sIGZvdnlSYWRpYW5zLCBhc3BlY3QsIG5lYXIsIGZhcik7XG4gICAgfVxuXG4gICAgLy8gSW5pdCBwaXhlbCBtYXRyaWNlc1xuICAgIHRoaXMuX2luaXRNYXRyaWNlcygpO1xuXG4gICAgLy8gQmluZCBtZXRob2RzIGZvciBlYXN5IGFjY2Vzc1xuICAgIHRoaXMuZXF1YWxzID0gdGhpcy5lcXVhbHMuYmluZCh0aGlzKTtcbiAgICB0aGlzLnByb2plY3QgPSB0aGlzLnByb2plY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLnVucHJvamVjdCA9IHRoaXMudW5wcm9qZWN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5wcm9qZWN0RmxhdCA9IHRoaXMucHJvamVjdEZsYXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnVucHJvamVjdEZsYXQgPSB0aGlzLnVucHJvamVjdEZsYXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldE1hdHJpY2VzID0gdGhpcy5nZXRNYXRyaWNlcy5iaW5kKHRoaXMpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHMgKi9cblxuICAvLyBUd28gdmlld3BvcnRzIGFyZSBlcXVhbCBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBpZGVudGljYWwsIGFuZCBpZlxuICAvLyB0aGVpciB2aWV3IGFuZCBwcm9qZWN0aW9uIG1hdHJpY2VzIGFyZSAoYXBwcm94aW1hdGVseSkgZXF1YWwuXG4gIGVxdWFscyh2aWV3cG9ydCkge1xuICAgIGlmICghKHZpZXdwb3J0IGluc3RhbmNlb2YgVmlld3BvcnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZXdwb3J0LndpZHRoID09PSB0aGlzLndpZHRoICYmXG4gICAgICB2aWV3cG9ydC5oZWlnaHQgPT09IHRoaXMuaGVpZ2h0ICYmXG4gICAgICBlcXVhbHModmlld3BvcnQucHJvamVjdGlvbk1hdHJpeCwgdGhpcy5wcm9qZWN0aW9uTWF0cml4KSAmJlxuICAgICAgZXF1YWxzKHZpZXdwb3J0LnZpZXdNYXRyaXgsIHRoaXMudmlld01hdHJpeCk7XG4gICAgICAvLyBUT0RPIC0gY2hlY2sgZGlzdGFuY2Ugc2NhbGVzP1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2plY3RzIHh5eiAocG9zc2libHkgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSkgdG8gcGl4ZWwgY29vcmRpbmF0ZXMgaW4gd2luZG93XG4gICAqIHVzaW5nIHZpZXdwb3J0IHByb2plY3Rpb24gcGFyYW1ldGVyc1xuICAgKiAtIFtsb25naXR1ZGUsIGxhdGl0dWRlXSB0byBbeCwgeV1cbiAgICogLSBbbG9uZ2l0dWRlLCBsYXRpdHVkZSwgWl0gPT4gW3gsIHksIHpdXG4gICAqIE5vdGU6IEJ5IGRlZmF1bHQsIHJldHVybnMgdG9wLWxlZnQgY29vcmRpbmF0ZXMgZm9yIGNhbnZhcy9TVkcgdHlwZSByZW5kZXJcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gbG5nTGF0WiAtIFtsbmcsIGxhdF0gb3IgW2xuZywgbGF0LCBaXVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMudG9wTGVmdD10cnVlIC0gV2hldGhlciBwcm9qZWN0ZWQgY29vcmRzIGFyZSB0b3AgbGVmdFxuICAgKiBAcmV0dXJuIHtBcnJheX0gLSBbeCwgeV0gb3IgW3gsIHksIHpdIGluIHRvcCBsZWZ0IGNvb3Jkc1xuICAgKi9cbiAgcHJvamVjdCh4eXosIHt0b3BMZWZ0ID0gZmFsc2V9ID0ge30pIHtcbiAgICBjb25zdCBbeDAsIHkwLCB6MCA9IDBdID0geHl6O1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoeDApICYmIE51bWJlci5pc0Zpbml0ZSh5MCkgJiYgTnVtYmVyLmlzRmluaXRlKHowKSwgRVJSX0FSR1VNRU5UKTtcblxuICAgIGNvbnN0IFtYLCBZXSA9IHRoaXMucHJvamVjdEZsYXQoW3gwLCB5MF0pO1xuICAgIGNvbnN0IHYgPSB0cmFuc2Zvcm1WZWN0b3IodGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXgsIFtYLCBZLCB6MCwgMV0pO1xuXG4gICAgY29uc3QgW3gsIHldID0gdjtcbiAgICBjb25zdCB5MiA9IHRvcExlZnQgPyB0aGlzLmhlaWdodCAtIHkgOiB5O1xuICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gW3gsIHkyXSA6IFt4LCB5MiwgMF07XG4gIH1cblxuICAvKipcbiAgICogVW5wcm9qZWN0IHBpeGVsIGNvb3JkaW5hdGVzIG9uIHNjcmVlbiBvbnRvIHdvcmxkIGNvb3JkaW5hdGVzLFxuICAgKiAocG9zc2libHkgW2xvbiwgbGF0XSkgb24gbWFwLlxuICAgKiAtIFt4LCB5XSA9PiBbbG5nLCBsYXRdXG4gICAqIC0gW3gsIHksIHpdID0+IFtsbmcsIGxhdCwgWl1cbiAgICogQHBhcmFtIHtBcnJheX0geHl6IC1cbiAgICogQHJldHVybiB7QXJyYXl8bnVsbH0gLSBbbG5nLCBsYXQsIFpdIG9yIFtYLCBZLCBaXVxuICAgKi9cbiAgdW5wcm9qZWN0KHh5eiwge3RvcExlZnQgPSBmYWxzZX0gPSB7fSkge1xuICAgIGNvbnN0IFt4LCB5LCB0YXJnZXRaID0gMF0gPSB4eXo7XG5cbiAgICBjb25zdCB5MiA9IHRvcExlZnQgPyB0aGlzLmhlaWdodCAtIHkgOiB5O1xuXG4gICAgLy8gc2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgY29ycmVjdCBwcm9qZWN0ZWQgeiB2YWx1ZSBmb3IgdGhlIHBvaW50LFxuICAgIC8vIHVucHJvamVjdCB0d28gcG9pbnRzIHRvIGdldCBhIGxpbmUgYW5kIHRoZW4gZmluZCB0aGUgcG9pbnQgb24gdGhhdCBsaW5lIHdpdGggej0wXG4gICAgY29uc3QgY29vcmQwID0gdHJhbnNmb3JtVmVjdG9yKHRoaXMucGl4ZWxVbnByb2plY3Rpb25NYXRyaXgsIFt4LCB5MiwgMCwgMV0pO1xuICAgIGNvbnN0IGNvb3JkMSA9IHRyYW5zZm9ybVZlY3Rvcih0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4LCBbeCwgeTIsIDEsIDFdKTtcblxuICAgIGlmICghY29vcmQwIHx8ICFjb29yZDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHowID0gY29vcmQwWzJdO1xuICAgIGNvbnN0IHoxID0gY29vcmQxWzJdO1xuXG4gICAgY29uc3QgdCA9IHowID09PSB6MSA/IDAgOiAodGFyZ2V0WiAtIHowKSAvICh6MSAtIHowKTtcbiAgICBjb25zdCB2ID0gdmVjMl9sZXJwKFtdLCBjb29yZDAsIGNvb3JkMSwgdCk7XG5cbiAgICBjb25zdCB2VW5wcm9qZWN0ZWQgPSB0aGlzLnVucHJvamVjdEZsYXQodik7XG4gICAgcmV0dXJuIHh5ei5sZW5ndGggPT09IDIgPyB2VW5wcm9qZWN0ZWQgOiBbdlVucHJvamVjdGVkWzBdLCB2VW5wcm9qZWN0ZWRbMV0sIDBdO1xuICB9XG5cbiAgLy8gTk9OX0xJTkVBUiBQUk9KRUNUSU9OIEhPT0tTXG4gIC8vIFVzZWQgZm9yIHdlYiBtZXJhY3RvciBwcm9qZWN0aW9uXG5cbiAgLyoqXG4gICAqIFByb2plY3QgW2xuZyxsYXRdIG9uIHNwaGVyZSBvbnRvIFt4LHldIG9uIDUxMio1MTIgTWVyY2F0b3IgWm9vbSAwIHRpbGUuXG4gICAqIFBlcmZvcm1zIHRoZSBub25saW5lYXIgcGFydCBvZiB0aGUgd2ViIG1lcmNhdG9yIHByb2plY3Rpb24uXG4gICAqIFJlbWFpbmluZyBwcm9qZWN0aW9uIGlzIGRvbmUgd2l0aCA0eDQgbWF0cmljZXMgd2hpY2ggYWxzbyBoYW5kbGVzXG4gICAqIHBlcnNwZWN0aXZlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBsbmdMYXQgLSBbbG5nLCBsYXRdIGNvb3JkaW5hdGVzXG4gICAqICAgU3BlY2lmaWVzIGEgcG9pbnQgb24gdGhlIHNwaGVyZSB0byBwcm9qZWN0IG9udG8gdGhlIG1hcC5cbiAgICogQHJldHVybiB7QXJyYXl9IFt4LHldIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvamVjdEZsYXQoW3gsIHldLCBzY2FsZSA9IHRoaXMuc2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvamVjdEZsYXQoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnByb2plY3Qgd29ybGQgcG9pbnQgW3gseV0gb24gbWFwIG9udG8ge2xhdCwgbG9ufSBvbiBzcGhlcmVcbiAgICogQHBhcmFtIHtvYmplY3R8VmVjdG9yfSB4eSAtIG9iamVjdCB3aXRoIHt4LHl9IG1lbWJlcnNcbiAgICogIHJlcHJlc2VudGluZyBwb2ludCBvbiBwcm9qZWN0ZWQgbWFwIHBsYW5lXG4gICAqIEByZXR1cm4ge0dlb0Nvb3JkaW5hdGVzfSAtIG9iamVjdCB3aXRoIHtsYXQsbG9ufSBvZiBwb2ludCBvbiBzcGhlcmUuXG4gICAqICAgSGFzIHRvQXJyYXkgbWV0aG9kIGlmIHlvdSBuZWVkIGEgR2VvSlNPTiBBcnJheS5cbiAgICogICBQZXIgY2FydG9ncmFwaGljIHRyYWRpdGlvbiwgbGF0IGFuZCBsb24gYXJlIHNwZWNpZmllZCBhcyBkZWdyZWVzLlxuICAgKi9cbiAgdW5wcm9qZWN0RmxhdCh4eXosIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB0aGlzLl91bnByb2plY3RGbGF0KC4uLmFyZ3VtZW50cyk7XG4gIH1cblxuICAvLyBUT0RPIC0gd2h5IGRvIHdlIG5lZWQgdGhlc2U/XG4gIF9wcm9qZWN0RmxhdCh4eXosIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB4eXo7XG4gIH1cblxuICBfdW5wcm9qZWN0RmxhdCh4eXosIHNjYWxlID0gdGhpcy5zY2FsZSkge1xuICAgIHJldHVybiB4eXo7XG4gIH1cblxuICBnZXRNZXJjYXRvclBhcmFtcygpIHtcbiAgICBjb25zdCBsbmdMYXQgPSB0aGlzLl9hZGRNZXRlcnNUb0xuZ0xhdChcbiAgICAgIFt0aGlzLmxvbmdpdHVkZSB8fCAwLCB0aGlzLmxhdGl0dWRlIHx8IDBdLFxuICAgICAgdGhpcy5tZXRlck9mZnNldFxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvbmdpdHVkZTogbG5nTGF0WzBdLFxuICAgICAgbGF0aXR1ZGU6IGxuZ0xhdFsxXVxuICAgIH07XG4gIH1cblxuICBpc01hcFN5bmNoZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0RGlzdGFuY2VTY2FsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VTY2FsZXM7XG4gIH1cblxuICBnZXRNYXRyaWNlcyh7bW9kZWxNYXRyaXggPSBudWxsfSA9IHt9KSB7XG4gICAgbGV0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4O1xuICAgIGxldCBwaXhlbFByb2plY3Rpb25NYXRyaXggPSB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeDtcbiAgICBsZXQgcGl4ZWxVbnByb2plY3Rpb25NYXRyaXggPSB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4O1xuXG4gICAgaWYgKG1vZGVsTWF0cml4KSB7XG4gICAgICBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ID0gbWF0NF9tdWx0aXBseShbXSwgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCwgbW9kZWxNYXRyaXgpO1xuICAgICAgcGl4ZWxQcm9qZWN0aW9uTWF0cml4ID0gbWF0NF9tdWx0aXBseShbXSwgdGhpcy5waXhlbFByb2plY3Rpb25NYXRyaXgsIG1vZGVsTWF0cml4KTtcbiAgICAgIHBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gbWF0NF9pbnZlcnQoW10sIHBpeGVsUHJvamVjdGlvbk1hdHJpeCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0cmljZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgICB2aWV3UHJvamVjdGlvbk1hdHJpeDogdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCxcbiAgICAgIHZpZXdNYXRyaXg6IHRoaXMudmlld01hdHJpeCxcbiAgICAgIHByb2plY3Rpb25NYXRyaXg6IHRoaXMucHJvamVjdGlvbk1hdHJpeCxcblxuICAgICAgLy8gcHJvamVjdC91bnByb2plY3QgYmV0d2VlbiBwaXhlbHMgYW5kIHdvcmxkXG4gICAgICBwaXhlbFByb2plY3Rpb25NYXRyaXgsXG4gICAgICBwaXhlbFVucHJvamVjdGlvbk1hdHJpeCxcblxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgc2NhbGU6IHRoaXMuc2NhbGVcbiAgICB9KTtcblxuICAgIHJldHVybiBtYXRyaWNlcztcbiAgfVxuXG4gIC8vIEVYUEVSSU1FTlRBTCBNRVRIT0RTXG5cbiAgLy8gU3VwcG9ydCBmb3IgcmVsYXRpdmUgdmlld3BvcnQgZGltZW5zaW9uc1xuICAvLyBUT0RPIC0gcGFyc2VzIHNhbWUgc3RyaW5ncyBhIG51bWJlciBvZiB0aW1lc1xuICBnZXREaW1lbnNpb25zKHt3aWR0aCwgaGVpZ2h0fSkge1xuICAgIHJldHVybiB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgICB4OiB0eXBlb2YgdGhpcy54ID09PSAnc3RyaW5nJyA/IE1hdGgucm91bmQocGFyc2VGbG9hdCh0aGlzLngpIC8gMTAwICogd2lkdGgpIDogdGhpcy54LFxuICAgICAgeTogdHlwZW9mIHRoaXMueSA9PT0gJ3N0cmluZycgPyBNYXRoLnJvdW5kKHBhcnNlRmxvYXQodGhpcy55KSAvIDEwMCAqIGhlaWdodCkgOiB0aGlzLnksXG4gICAgICB3aWR0aDogdHlwZW9mIHRoaXMud2lkdGggPT09ICdzdHJpbmcnID8gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHRoaXMud2lkdGgpIC8gMTAwICogd2lkdGgpIDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdHlwZW9mIHRoaXMuaGVpZ2h0ID09PSAnc3RyaW5nJyA/IE1hdGgucm91bmQocGFyc2VGbG9hdCh0aGlzLngpIC8gMTAwICogaGVpZ2h0KSA6IHRoaXMuaGVpZ2h0XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgICB9O1xuICB9XG5cbiAgZ2V0Q2FtZXJhUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FtZXJhUG9zaXRpb247XG4gIH1cblxuICBnZXRDYW1lcmFEaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FtZXJhRGlyZWN0aW9uO1xuICB9XG5cbiAgZ2V0Q2FtZXJhVXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FtZXJhVXA7XG4gIH1cblxuICAvLyBUT0RPIC0gdGhlc2UgYXJlIGR1cGxpY2F0aW5nIFdlYk1lcmNhdG9yIG1ldGhvZHNcbiAgX2FkZE1ldGVyc1RvTG5nTGF0KGxuZ0xhdFosIHh5eikge1xuICAgIGNvbnN0IFtsbmcsIGxhdCwgWiA9IDBdID0gbG5nTGF0WjtcbiAgICBjb25zdCBbZGVsdGFMbmcsIGRlbHRhTGF0LCBkZWx0YVogPSAwXSA9IHRoaXMuX21ldGVyc1RvTG5nTGF0RGVsdGEoeHl6KTtcbiAgICByZXR1cm4gbG5nTGF0Wi5sZW5ndGggPT09IDIgP1xuICAgICAgW2xuZyArIGRlbHRhTG5nLCBsYXQgKyBkZWx0YUxhdF0gOlxuICAgICAgW2xuZyArIGRlbHRhTG5nLCBsYXQgKyBkZWx0YUxhdCwgWiArIGRlbHRhWl07XG4gIH1cblxuICBfbWV0ZXJzVG9MbmdMYXREZWx0YSh4eXopIHtcbiAgICBjb25zdCBbeCwgeSwgeiA9IDBdID0geHl6O1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoeCkgJiYgTnVtYmVyLmlzRmluaXRlKHkpICYmIE51bWJlci5pc0Zpbml0ZSh6KSwgRVJSX0FSR1VNRU5UKTtcbiAgICBjb25zdCB7cGl4ZWxzUGVyTWV0ZXIsIGRlZ3JlZXNQZXJQaXhlbH0gPSB0aGlzLmRpc3RhbmNlU2NhbGVzO1xuICAgIGNvbnN0IGRlbHRhTG5nID0geCAqIHBpeGVsc1Blck1ldGVyWzBdICogZGVncmVlc1BlclBpeGVsWzBdO1xuICAgIGNvbnN0IGRlbHRhTGF0ID0geSAqIHBpeGVsc1Blck1ldGVyWzFdICogZGVncmVlc1BlclBpeGVsWzFdO1xuICAgIHJldHVybiB4eXoubGVuZ3RoID09PSAyID8gW2RlbHRhTG5nLCBkZWx0YUxhdF0gOiBbZGVsdGFMbmcsIGRlbHRhTGF0LCB6XTtcbiAgfVxuXG4gIC8vIElOVEVSTkFMIE1FVEhPRFNcblxuICBfaW5pdE1hdHJpY2VzKCkge1xuICAgIC8vIE5vdGU6IEFzIHVzdWFsLCBtYXRyaXggb3BlcmF0aW9ucyBzaG91bGQgYmUgYXBwbGllZCBpbiBcInJldmVyc2VcIiBvcmRlclxuICAgIC8vIHNpbmNlIHZlY3RvcnMgd2lsbCBiZSBtdWx0aXBsaWVkIGluIGZyb20gdGhlIHJpZ2h0IGR1cmluZyB0cmFuc2Zvcm1hdGlvblxuICAgIGNvbnN0IHZwbSA9IGNyZWF0ZU1hdDQoKTtcbiAgICBtYXQ0X211bHRpcGx5KHZwbSwgdnBtLCB0aGlzLnByb2plY3Rpb25NYXRyaXgpO1xuICAgIG1hdDRfbXVsdGlwbHkodnBtLCB2cG0sIHRoaXMudmlld01hdHJpeCk7XG4gICAgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCA9IHZwbTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdWUE0nLCB0aGlzLnZpZXdNYXRyaXgsIHRoaXMucHJvamVjdGlvbk1hdHJpeCwgdGhpcy52aWV3UHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgICAvLyBDYWxjdWxhdGUgaW52ZXJzZSB2aWV3IG1hdHJpeFxuICAgIHRoaXMudmlld01hdHJpeEludmVyc2UgPSBtYXQ0X2ludmVydChbXSwgdGhpcy52aWV3TWF0cml4KSB8fCB0aGlzLnZpZXdNYXRyaXg7XG5cbiAgICAvLyBEZWNvbXBvc2UgY2FtZXJhIGRpcmVjdGlvbnNcbiAgICBjb25zdCB7ZXllLCBkaXJlY3Rpb24sIHVwfSA9IGV4dHJhY3RDYW1lcmFWZWN0b3JzKHtcbiAgICAgIHZpZXdNYXRyaXg6IHRoaXMudmlld01hdHJpeCxcbiAgICAgIHZpZXdNYXRyaXhJbnZlcnNlOiB0aGlzLnZpZXdNYXRyaXhJbnZlcnNlXG4gICAgfSk7XG4gICAgdGhpcy5jYW1lcmFQb3NpdGlvbiA9IGV5ZTtcbiAgICB0aGlzLmNhbWVyYURpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICB0aGlzLmNhbWVyYVVwID0gdXA7XG5cbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmNhbWVyYVBvc2l0aW9uLCB0aGlzLmNhbWVyYURpcmVjdGlvbiwgdGhpcy5jYW1lcmFVcCk7XG5cbiAgICAvKlxuICAgICAqIEJ1aWxkcyBtYXRyaWNlcyB0aGF0IGNvbnZlcnRzIHByZXByb2plY3RlZCBsbmdMYXRzIHRvIHNjcmVlbiBwaXhlbHNcbiAgICAgKiBhbmQgdmljZSB2ZXJzYS5cbiAgICAgKiBOb3RlOiBDdXJyZW50bHkgcmV0dXJucyBib3R0b20tbGVmdCBjb29yZGluYXRlcyFcbiAgICAgKiBOb3RlOiBTdGFydHMgd2l0aCB0aGUgR0wgcHJvamVjdGlvbiBtYXRyaXggYW5kIGFkZHMgc3RlcHMgdG8gdGhlXG4gICAgICogICAgICAgc2NhbGUgYW5kIHRyYW5zbGF0ZSB0aGF0IG1hdHJpeCBvbnRvIHRoZSB3aW5kb3cuXG4gICAgICogTm90ZTogV2ViR0wgY29udHJvbHMgY2xpcCBzcGFjZSB0byBzY3JlZW4gcHJvamVjdGlvbiB3aXRoIGdsLnZpZXdwb3J0XG4gICAgICogICAgICAgYW5kIGRvZXMgbm90IG5lZWQgdGhpcyBzdGVwLlxuICAgICAqL1xuXG4gICAgLy8gbWF0cml4IGZvciBjb252ZXJzaW9uIGZyb20gd29ybGQgbG9jYXRpb24gdG8gc2NyZWVuIChwaXhlbCkgY29vcmRpbmF0ZXNcbiAgICBjb25zdCBtID0gY3JlYXRlTWF0NCgpO1xuICAgIG1hdDRfc2NhbGUobSwgbSwgW3RoaXMud2lkdGggLyAyLCAtdGhpcy5oZWlnaHQgLyAyLCAxXSk7XG4gICAgbWF0NF90cmFuc2xhdGUobSwgbSwgWzEsIC0xLCAwXSk7XG4gICAgbWF0NF9tdWx0aXBseShtLCBtLCB0aGlzLnZpZXdQcm9qZWN0aW9uTWF0cml4KTtcbiAgICB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCA9IG07XG5cbiAgICB0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4ID0gbWF0NF9pbnZlcnQoY3JlYXRlTWF0NCgpLCB0aGlzLnBpeGVsUHJvamVjdGlvbk1hdHJpeCk7XG4gICAgaWYgKCF0aGlzLnBpeGVsVW5wcm9qZWN0aW9uTWF0cml4KSB7XG4gICAgICBsb2cud2FybignUGl4ZWwgcHJvamVjdCBtYXRyaXggbm90IGludmVydGlibGUnKTtcbiAgICAgIC8vIHRocm93IG5ldyBFcnJvcignUGl4ZWwgcHJvamVjdCBtYXRyaXggbm90IGludmVydGlibGUnKTtcbiAgICB9XG4gIH1cbn1cblxuVmlld3BvcnQuZGlzcGxheU5hbWUgPSAnVmlld3BvcnQnO1xuIl19