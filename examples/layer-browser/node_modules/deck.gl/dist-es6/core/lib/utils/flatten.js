// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/**
 * Flattens a nested array into a single level array,
 * or a single value into an array with one value
 * @example flatten([[1, [2]], [3], 4]) => [1, 2, 3, 4]
 * @example flatten(1) => [1]
 * @param {Array} array The array to flatten.
 * @param {Function} filter= - Optional predicate called on each `value` to
 *   determine if it should be included (pushed onto) the resulting array.
 * @param {Function} map= - Optional transform applied to each array elements.
 * @param {Array} result=[] - Optional array to push value into
 * @return {Array} Returns the new flattened array (new array or `result` if provided)
 */
export function flatten(array) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$filter = _ref.filter,
      filter = _ref$filter === undefined ? function () {
    return true;
  } : _ref$filter,
      _ref$map = _ref.map,
      map = _ref$map === undefined ? function (x) {
    return x;
  } : _ref$map,
      _ref$result = _ref.result,
      result = _ref$result === undefined ? [] : _ref$result;

  // Wrap single object in array
  if (!Array.isArray(array)) {
    return filter(array) ? [map(array)] : [];
  }
  // Deep flatten and filter the array
  return flattenArray(array, filter, map, result);
}

// Deep flattens an array. Helper to `flatten`, see its parameters
function flattenArray(array, filter, map, result) {
  var index = -1;
  while (++index < array.length) {
    var value = array[index];
    if (Array.isArray(value)) {
      flattenArray(value, filter, map, result);
    } else if (filter(value)) {
      result.push(map(value));
    }
  }
  return result;
}

export function countVertices(nestedArray) {
  var count = 0;
  var index = -1;
  while (++index < nestedArray.length) {
    var value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      count += countVertices(value);
    } else {
      count++;
    }
  }
  return count;
}

// Flattens nested array of vertices, padding third coordinate as needed
export function flattenVertices(nestedArray) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$result = _ref2.result,
      result = _ref2$result === undefined ? [] : _ref2$result,
      _ref2$dimensions = _ref2.dimensions,
      dimensions = _ref2$dimensions === undefined ? 3 : _ref2$dimensions;

  var index = -1;
  var vertexLength = 0;
  while (++index < nestedArray.length) {
    var value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      flattenVertices(value, { result: result, dimensions: dimensions });
    } else {
      if (vertexLength < dimensions) {
        // eslint-disable-line
        result.push(value);
        vertexLength++;
      }
    }
  }
  // Add a third coordinate if needed
  if (vertexLength > 0 && vertexLength < dimensions) {
    result.push(0);
  }
  return result;
}

// Uses copyWithin to significantly speed up typed array value filling
export function fillArray(_ref3) {
  var target = _ref3.target,
      source = _ref3.source,
      _ref3$start = _ref3.start,
      start = _ref3$start === undefined ? 0 : _ref3$start,
      _ref3$count = _ref3.count,
      count = _ref3$count === undefined ? 1 : _ref3$count;

  var total = count * source.length;
  var copied = 0;
  for (var i = 0; i < source.length; ++i) {
    target[start + copied++] = source[i];
  }

  while (copied < total) {
    // If we have copied less than half, copy everything we got
    // else copy remaining in one operation
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }

  return target;
}

// Flattens nested array of vertices, padding third coordinate as needed
/*
export function flattenTypedVertices(nestedArray, {
  result = [],
  Type = Float32Array,
  start = 0,
  dimensions = 3
} = {}) {
  let index = -1;
  let vertexLength = 0;
  while (++index < nestedArray.length) {
    const value = nestedArray[index];
    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      start = flattenTypedVertices(value, {result, start, dimensions});
    } else {
      if (vertexLength < dimensions) { // eslint-disable-line
        result[start++] = value;
        vertexLength++;
      }
    }
  }
  // Add a third coordinate if needed
  if (vertexLength > 0 && vertexLength < dimensions) {
    result[start++] = 0;
  }
  return start;
}
*/
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb3JlL2xpYi91dGlscy9mbGF0dGVuLmpzIl0sIm5hbWVzIjpbImZsYXR0ZW4iLCJhcnJheSIsImZpbHRlciIsIm1hcCIsIngiLCJyZXN1bHQiLCJBcnJheSIsImlzQXJyYXkiLCJmbGF0dGVuQXJyYXkiLCJpbmRleCIsImxlbmd0aCIsInZhbHVlIiwicHVzaCIsImNvdW50VmVydGljZXMiLCJuZXN0ZWRBcnJheSIsImNvdW50IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJmbGF0dGVuVmVydGljZXMiLCJkaW1lbnNpb25zIiwidmVydGV4TGVuZ3RoIiwiZmlsbEFycmF5IiwidGFyZ2V0Iiwic291cmNlIiwic3RhcnQiLCJ0b3RhbCIsImNvcGllZCIsImkiLCJjb3B5V2l0aGluIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FBWUEsT0FBTyxTQUFTQSxPQUFULENBQWlCQyxLQUFqQixFQUlDO0FBQUEsaUZBQUosRUFBSTtBQUFBLHlCQUhOQyxNQUdNO0FBQUEsTUFITkEsTUFHTSwrQkFIRztBQUFBLFdBQU0sSUFBTjtBQUFBLEdBR0g7QUFBQSxzQkFGTkMsR0FFTTtBQUFBLE1BRk5BLEdBRU0sNEJBRkE7QUFBQSxXQUFLQyxDQUFMO0FBQUEsR0FFQTtBQUFBLHlCQUROQyxNQUNNO0FBQUEsTUFETkEsTUFDTSwrQkFERyxFQUNIOztBQUNOO0FBQ0EsTUFBSSxDQUFDQyxNQUFNQyxPQUFOLENBQWNOLEtBQWQsQ0FBTCxFQUEyQjtBQUN6QixXQUFPQyxPQUFPRCxLQUFQLElBQWdCLENBQUNFLElBQUlGLEtBQUosQ0FBRCxDQUFoQixHQUErQixFQUF0QztBQUNEO0FBQ0Q7QUFDQSxTQUFPTyxhQUFhUCxLQUFiLEVBQW9CQyxNQUFwQixFQUE0QkMsR0FB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UUFBSUMsU0FBU0QsUUFBUUMsTUFBckIsRUFBNkI7QUFDM0JKLGFBQU9NLFVBQVAsQ0FBa0JKLFFBQVFFLE1BQTFCLEVBQWtDRixLQUFsQyxFQUF5Q0EsUUFBUUUsTUFBakQ7QUFDQUEsZ0JBQVUsQ0FBVjtBQUNELEtBSEQsTUFHTztBQUNMSixhQUFPTSxVQUFQLENBQWtCSixRQUFRRSxNQUExQixFQUFrQ0YsS0FBbEMsRUFBeUNBLFFBQVFDLEtBQVIsR0FBZ0JDLE1BQXpEO0FBQ0FBLGVBQVNELEtBQVQ7QUFDRDtBQUNGOztBQUVELFNBQU9ILE1BQVA7QUFDRDs7QUFFRDtBQUNBIiwiZmlsZSI6ImZsYXR0ZW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLyoqXG4gKiBGbGF0dGVucyBhIG5lc3RlZCBhcnJheSBpbnRvIGEgc2luZ2xlIGxldmVsIGFycmF5LFxuICogb3IgYSBzaW5nbGUgdmFsdWUgaW50byBhbiBhcnJheSB3aXRoIG9uZSB2YWx1ZVxuICogQGV4YW1wbGUgZmxhdHRlbihbWzEsIFsyXV0sIFszXSwgNF0pID0+IFsxLCAyLCAzLCA0XVxuICogQGV4YW1wbGUgZmxhdHRlbigxKSA9PiBbMV1cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZmlsdGVyPSAtIE9wdGlvbmFsIHByZWRpY2F0ZSBjYWxsZWQgb24gZWFjaCBgdmFsdWVgIHRvXG4gKiAgIGRldGVybWluZSBpZiBpdCBzaG91bGQgYmUgaW5jbHVkZWQgKHB1c2hlZCBvbnRvKSB0aGUgcmVzdWx0aW5nIGFycmF5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWFwPSAtIE9wdGlvbmFsIHRyYW5zZm9ybSBhcHBsaWVkIHRvIGVhY2ggYXJyYXkgZWxlbWVudHMuXG4gKiBAcGFyYW0ge0FycmF5fSByZXN1bHQ9W10gLSBPcHRpb25hbCBhcnJheSB0byBwdXNoIHZhbHVlIGludG9cbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5IChuZXcgYXJyYXkgb3IgYHJlc3VsdGAgaWYgcHJvdmlkZWQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCB7XG4gIGZpbHRlciA9ICgpID0+IHRydWUsXG4gIG1hcCA9IHggPT4geCxcbiAgcmVzdWx0ID0gW11cbn0gPSB7fSkge1xuICAvLyBXcmFwIHNpbmdsZSBvYmplY3QgaW4gYXJyYXlcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgIHJldHVybiBmaWx0ZXIoYXJyYXkpID8gW21hcChhcnJheSldIDogW107XG4gIH1cbiAgLy8gRGVlcCBmbGF0dGVuIGFuZCBmaWx0ZXIgdGhlIGFycmF5XG4gIHJldHVybiBmbGF0dGVuQXJyYXkoYXJyYXksIGZpbHRlciwgbWFwLCByZXN1bHQpO1xufVxuXG4vLyBEZWVwIGZsYXR0ZW5zIGFuIGFycmF5LiBIZWxwZXIgdG8gYGZsYXR0ZW5gLCBzZWUgaXRzIHBhcmFtZXRlcnNcbmZ1bmN0aW9uIGZsYXR0ZW5BcnJheShhcnJheSwgZmlsdGVyLCBtYXAsIHJlc3VsdCkge1xuICBsZXQgaW5kZXggPSAtMTtcbiAgd2hpbGUgKCsraW5kZXggPCBhcnJheS5sZW5ndGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZsYXR0ZW5BcnJheSh2YWx1ZSwgZmlsdGVyLCBtYXAsIHJlc3VsdCk7XG4gICAgfSBlbHNlIGlmIChmaWx0ZXIodmFsdWUpKSB7XG4gICAgICByZXN1bHQucHVzaChtYXAodmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50VmVydGljZXMobmVzdGVkQXJyYXkpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIHdoaWxlICgrK2luZGV4IDwgbmVzdGVkQXJyYXkubGVuZ3RoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBuZXN0ZWRBcnJheVtpbmRleF07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgIGNvdW50ICs9IGNvdW50VmVydGljZXModmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbi8vIEZsYXR0ZW5zIG5lc3RlZCBhcnJheSBvZiB2ZXJ0aWNlcywgcGFkZGluZyB0aGlyZCBjb29yZGluYXRlIGFzIG5lZWRlZFxuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5WZXJ0aWNlcyhuZXN0ZWRBcnJheSwge3Jlc3VsdCA9IFtdLCBkaW1lbnNpb25zID0gM30gPSB7fSkge1xuICBsZXQgaW5kZXggPSAtMTtcbiAgbGV0IHZlcnRleExlbmd0aCA9IDA7XG4gIHdoaWxlICgrK2luZGV4IDwgbmVzdGVkQXJyYXkubGVuZ3RoKSB7XG4gICAgY29uc3QgdmFsdWUgPSBuZXN0ZWRBcnJheVtpbmRleF07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICAgIGZsYXR0ZW5WZXJ0aWNlcyh2YWx1ZSwge3Jlc3VsdCwgZGltZW5zaW9uc30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmVydGV4TGVuZ3RoIDwgZGltZW5zaW9ucykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgdmVydGV4TGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIEFkZCBhIHRoaXJkIGNvb3JkaW5hdGUgaWYgbmVlZGVkXG4gIGlmICh2ZXJ0ZXhMZW5ndGggPiAwICYmIHZlcnRleExlbmd0aCA8IGRpbWVuc2lvbnMpIHtcbiAgICByZXN1bHQucHVzaCgwKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBVc2VzIGNvcHlXaXRoaW4gdG8gc2lnbmlmaWNhbnRseSBzcGVlZCB1cCB0eXBlZCBhcnJheSB2YWx1ZSBmaWxsaW5nXG5leHBvcnQgZnVuY3Rpb24gZmlsbEFycmF5KHt0YXJnZXQsIHNvdXJjZSwgc3RhcnQgPSAwLCBjb3VudCA9IDF9KSB7XG4gIGNvbnN0IHRvdGFsID0gY291bnQgKiBzb3VyY2UubGVuZ3RoO1xuICBsZXQgY29waWVkID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICB0YXJnZXRbc3RhcnQgKyBjb3BpZWQrK10gPSBzb3VyY2VbaV07XG4gIH1cblxuICB3aGlsZSAoY29waWVkIDwgdG90YWwpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGNvcGllZCBsZXNzIHRoYW4gaGFsZiwgY29weSBldmVyeXRoaW5nIHdlIGdvdFxuICAgIC8vIGVsc2UgY29weSByZW1haW5pbmcgaW4gb25lIG9wZXJhdGlvblxuICAgIGlmIChjb3BpZWQgPCB0b3RhbCAtIGNvcGllZCkge1xuICAgICAgdGFyZ2V0LmNvcHlXaXRoaW4oc3RhcnQgKyBjb3BpZWQsIHN0YXJ0LCBzdGFydCArIGNvcGllZCk7XG4gICAgICBjb3BpZWQgKj0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0LmNvcHlXaXRoaW4oc3RhcnQgKyBjb3BpZWQsIHN0YXJ0LCBzdGFydCArIHRvdGFsIC0gY29waWVkKTtcbiAgICAgIGNvcGllZCA9IHRvdGFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIEZsYXR0ZW5zIG5lc3RlZCBhcnJheSBvZiB2ZXJ0aWNlcywgcGFkZGluZyB0aGlyZCBjb29yZGluYXRlIGFzIG5lZWRlZFxuLypcbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuVHlwZWRWZXJ0aWNlcyhuZXN0ZWRBcnJheSwge1xuICByZXN1bHQgPSBbXSxcbiAgVHlwZSA9IEZsb2F0MzJBcnJheSxcbiAgc3RhcnQgPSAwLFxuICBkaW1lbnNpb25zID0gM1xufSA9IHt9KSB7XG4gIGxldCBpbmRleCA9IC0xO1xuICBsZXQgdmVydGV4TGVuZ3RoID0gMDtcbiAgd2hpbGUgKCsraW5kZXggPCBuZXN0ZWRBcnJheS5sZW5ndGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG5lc3RlZEFycmF5W2luZGV4XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgICAgc3RhcnQgPSBmbGF0dGVuVHlwZWRWZXJ0aWNlcyh2YWx1ZSwge3Jlc3VsdCwgc3RhcnQsIGRpbWVuc2lvbnN9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZlcnRleExlbmd0aCA8IGRpbWVuc2lvbnMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICByZXN1bHRbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgICAgdmVydGV4TGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIEFkZCBhIHRoaXJkIGNvb3JkaW5hdGUgaWYgbmVlZGVkXG4gIGlmICh2ZXJ0ZXhMZW5ndGggPiAwICYmIHZlcnRleExlbmd0aCA8IGRpbWVuc2lvbnMpIHtcbiAgICByZXN1bHRbc3RhcnQrK10gPSAwO1xuICB9XG4gIHJldHVybiBzdGFydDtcbn1cbiovXG4iXX0=