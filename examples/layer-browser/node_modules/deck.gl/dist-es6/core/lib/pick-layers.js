// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import { log } from './utils';
import { drawPickingBuffer, getPixelRatio } from './draw-layers';

var EMPTY_PIXEL = new Uint8Array(4);

/* eslint-disable max-depth, max-statements */
// Pick the closest object at the given (x,y) coordinate
export function pickObject(gl, _ref) {
  var layers = _ref.layers,
      viewports = _ref.viewports,
      onViewportActive = _ref.onViewportActive,
      pickingFBO = _ref.pickingFBO,
      x = _ref.x,
      y = _ref.y,
      radius = _ref.radius,
      mode = _ref.mode,
      lastPickedInfo = _ref.lastPickedInfo,
      useDevicePixelRatio = _ref.useDevicePixelRatio;

  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = getPixelRatio({ useDevicePixelRatio: useDevicePixelRatio });
  var deviceX = Math.round(x * pixelRatio);
  var deviceY = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRadius = Math.round(radius * pixelRatio);

  var pickInfo = getClosestFromPickingBuffer(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    pickingFBO: pickingFBO,
    deviceX: deviceX,
    deviceY: deviceY,
    deviceRadius: deviceRadius
  });

  var pickedColor = pickInfo.pickedColor,
      pickedLayer = pickInfo.pickedLayer,
      pickedObjectIndex = pickInfo.pickedObjectIndex;


  var affectedLayers = pickedLayer ? [pickedLayer] : [];

  if (mode === 'hover') {
    // only invoke onHover events if picked object has changed
    var lastPickedObjectIndex = lastPickedInfo.index;
    var lastPickedLayerId = lastPickedInfo.layerId;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;

    // proceed only if picked object changed
    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        // We cannot store a ref to lastPickedLayer in the context because
        // the state of an outdated layer is no longer valid
        // and the props may have changed
        var lastPickedLayer = layers.find(function (layer) {
          return layer.props.id === lastPickedLayerId;
        });
        if (lastPickedLayer) {
          // Let leave event fire before enter event
          affectedLayers.unshift(lastPickedLayer);
        }
      }

      // Update layer manager context
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
    }
  }

  var viewport = getViewportFromCoordinates({ viewports: viewports }); // TODO - add coords

  var baseInfo = createInfo([x, y], viewport);
  baseInfo.devicePixel = [deviceX, deviceY];
  baseInfo.pixelRatio = pixelRatio;

  // Use a Map to store all picking infos.
  // The following two forEach loops are the result of
  // https://github.com/uber/deck.gl/issues/443
  // Please be very careful when changing this pattern
  var infos = new Map();
  var unhandledPickInfos = [];

  affectedLayers.forEach(function (layer) {
    var info = Object.assign({}, baseInfo);

    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }

    info = getLayerPickingInfo({ layer: layer, info: info, mode: mode });

    // This guarantees that there will be only one copy of info for
    // one composite layer
    if (info) {
      infos.set(info.layer.id, info);
    }

    var pickingSelectedColor = pickedColor;
    var pickingSelectedColorValid = Boolean(layer.props.autoHighlight && pickedLayer === layer && pickingSelectedColor !== EMPTY_PIXEL);
    // TODO - handle multi model layers?
    if (layer.state.model) {
      layer.state.model.updateModuleSettings({
        pickingSelectedColor: pickingSelectedColor,
        pickingSelectedColorValid: pickingSelectedColorValid
      });
    }
  });

  infos.forEach(function (info) {
    var handled = false;
    // Per-layer event handlers (e.g. onClick, onHover) are provided by the
    // user and out of deck.gl's control. It's very much possible that
    // the user calls React lifecycle methods in these function, such as
    // ReactComponent.setState(). React lifecycle methods sometimes induce
    // a re-render and re-generation of props of deck.gl and its layers,
    // which invalidates all layers currently passed to this very function.

    // Therefore, per-layer event handlers must be invoked at the end
    // of this function. NO operation that relies on the states of current
    // layers should be called after this code.
    switch (mode) {
      case 'click':
        handled = info.layer.props.onClick(info);break;
      case 'hover':
        handled = info.layer.props.onHover(info);break;
      case 'query':
        break;
      default:
        throw new Error('unknown pick type');
    }

    if (!handled) {
      unhandledPickInfos.push(info);
    }
  });

  return unhandledPickInfos;
}

// Pick all objects within the given bounding box
export function pickVisibleObjects(gl, _ref2) {
  var layers = _ref2.layers,
      viewports = _ref2.viewports,
      onViewportActive = _ref2.onViewportActive,
      pickingFBO = _ref2.pickingFBO,
      x = _ref2.x,
      y = _ref2.y,
      width = _ref2.width,
      height = _ref2.height,
      mode = _ref2.mode,
      useDevicePixelRatio = _ref2.useDevicePixelRatio;


  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = getPixelRatio({ useDevicePixelRatio: useDevicePixelRatio });

  var deviceLeft = Math.round(x * pixelRatio);
  var deviceBottom = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRight = Math.round((x + width) * pixelRatio);
  var deviceTop = Math.round(gl.canvas.height - (y + height) * pixelRatio);

  // Only return unique infos, identified by info.object
  var uniqueInfos = new Map();

  var pickInfos = getUniquesFromPickingBuffer(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    pickingFBO: pickingFBO,
    deviceRect: {
      x: deviceLeft,
      y: deviceTop,
      width: deviceRight - deviceLeft,
      height: deviceBottom - deviceTop
    }
  });

  pickInfos.forEach(function (pickInfo) {
    var viewport = getViewportFromCoordinates({ viewports: viewports }); // TODO - add coords
    var info = createInfo([pickInfo.x / pixelRatio, pickInfo.y / pixelRatio], viewport);
    info.devicePixel = [pickInfo.x, pickInfo.y];
    info.pixelRatio = pixelRatio;
    info.color = pickInfo.pickedColor;
    info.index = pickInfo.pickedObjectIndex;
    info.picked = true;

    info = getLayerPickingInfo({ layer: pickInfo.pickedLayer, info: info, mode: mode });
    if (!uniqueInfos.has(info.object)) {
      uniqueInfos.set(info.object, info);
    }
  });

  return Array.from(uniqueInfos.values());
}

// HELPER METHODS

// Indentifies which viewport, if any corresponds to x and y
// Returns first viewport if no match
// TODO - need to determine which viewport we are in
// TODO - document concept of "primary viewport" that matches all coords?
// TODO - static method on Viewport class?
function getViewportFromCoordinates(_ref3) {
  var viewports = _ref3.viewports;

  var viewport = viewports[0];
  return viewport;
}

function getPickedColors(gl, _ref4) {
  var layers = _ref4.layers,
      viewports = _ref4.viewports,
      onViewportActive = _ref4.onViewportActive,
      pickingFBO = _ref4.pickingFBO,
      deviceRect = _ref4.deviceRect;

  drawPickingBuffer(gl, { layers: layers, viewports: viewports, onViewportActive: onViewportActive, pickingFBO: pickingFBO, deviceRect: deviceRect });
  // TODO - restore when luma patch lands
  // const dataUrl = pickingFBO.readDataUrl();
  // window.open(dataUrl, 'picking buffer');

  var pickedColors = samplePickingBuffer(gl, { pickingFBO: pickingFBO, deviceRect: deviceRect });
  return pickedColors;
}

// Read from an already rendered picking buffer
// Returns an Uint8ClampedArray of picked pixels
export function samplePickingBuffer(gl, _ref5) {
  var pickingFBO = _ref5.pickingFBO,
      _ref5$deviceRect = _ref5.deviceRect,
      x = _ref5$deviceRect.x,
      y = _ref5$deviceRect.y,
      width = _ref5$deviceRect.width,
      height = _ref5$deviceRect.height;

  var pickedColors = new Uint8Array(width * height * 4);
  pickingFBO.readPixels({ x: x, y: y, width: width, height: height, pixelArray: pickedColors });
  return pickedColors;
}

/**
 * Pick at a specified pixel with a tolerance radius
 * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`
 */
function getClosestFromPickingBuffer(gl, _ref6) {
  var layers = _ref6.layers,
      viewports = _ref6.viewports,
      onViewportActive = _ref6.onViewportActive,
      pickingFBO = _ref6.pickingFBO,
      deviceX = _ref6.deviceX,
      deviceY = _ref6.deviceY,
      deviceRadius = _ref6.deviceRadius;

  var closestResultToCenter = {
    pickedColor: EMPTY_PIXEL,
    pickedLayer: null,
    pickedObjectIndex: -1
  };

  // x, y out of bounds or no layers to pick.
  var valid = layers.length > 0 && deviceX >= 0 && deviceY >= 0 && deviceX < pickingFBO.width && deviceY < pickingFBO.height;

  if (!valid) {
    return closestResultToCenter;
  }

  // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]
  var x = Math.max(0, deviceX - deviceRadius);
  var y = Math.max(0, deviceY - deviceRadius);
  var width = Math.min(pickingFBO.width, deviceX + deviceRadius) - x + 1;
  var height = Math.min(pickingFBO.height, deviceY + deviceRadius) - y + 1;

  var pickedColors = getPickedColors(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    pickingFBO: pickingFBO,
    deviceRect: { x: x, y: y, width: width, height: height }
  });

  // Traverse all pixels in picking results and find the one closest to the supplied
  // [deviceX, deviceY]
  var minSquareDistanceToCenter = deviceRadius * deviceRadius;
  var i = 0;

  for (var row = 0; row < height; row++) {
    for (var col = 0; col < width; col++) {
      // Decode picked layer from color
      var pickedLayerIndex = pickedColors[i + 3] - 1;

      if (pickedLayerIndex >= 0) {
        var dx = col + x - deviceX;
        var dy = row + y - deviceY;
        var d2 = dx * dx + dy * dy;

        if (d2 <= minSquareDistanceToCenter) {
          minSquareDistanceToCenter = d2;

          // Decode picked object index from color
          var pickedColor = pickedColors.slice(i, i + 4);
          var pickedLayer = layers[pickedLayerIndex];
          if (pickedLayer) {
            var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);
            closestResultToCenter = { pickedColor: pickedColor, pickedLayer: pickedLayer, pickedObjectIndex: pickedObjectIndex };
          } else {
            log.error(0, 'Picked non-existent layer. Is picking buffer corrupt?');
          }
        }
      }
      i += 4;
    }
  }

  return closestResultToCenter;
}
/* eslint-enable max-depth, max-statements */

/**
 * Query within a specified rectangle
 * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`
 */
function getUniquesFromPickingBuffer(gl, _ref7) {
  var layers = _ref7.layers,
      viewports = _ref7.viewports,
      onViewportActive = _ref7.onViewportActive,
      pickingFBO = _ref7.pickingFBO,
      _ref7$deviceRect = _ref7.deviceRect,
      x = _ref7$deviceRect.x,
      y = _ref7$deviceRect.y,
      width = _ref7$deviceRect.width,
      height = _ref7$deviceRect.height;

  var pickedColors = getPickedColors(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    pickingFBO: pickingFBO,
    deviceRect: { x: x, y: y, width: width, height: height }
  });
  var uniqueColors = new Map();

  // Traverse all pixels in picking results and get unique colors
  for (var i = 0; i < pickedColors.length; i += 4) {
    // Decode picked layer from color
    var pickedLayerIndex = pickedColors[i + 3] - 1;

    if (pickedLayerIndex >= 0) {
      var pickedColor = pickedColors.slice(i, i + 4);
      var colorKey = pickedColor.join(',');
      if (!uniqueColors.has(colorKey)) {
        var pickedLayer = layers[pickedLayerIndex];
        if (pickedLayer) {
          // eslint-disable-line
          uniqueColors.set(colorKey, {
            pickedColor: pickedColor,
            pickedLayer: pickedLayer,
            pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)
          });
        } else {
          log.error(0, 'Picked non-existent layer. Is picking buffer corrupt?');
        }
      }
    }
  }

  return Array.from(uniqueColors.values());
}

function createInfo(pixel, viewport) {
  // Assign a number of potentially useful props to the "info" object
  return {
    color: EMPTY_PIXEL,
    layer: null,
    index: -1,
    picked: false,
    x: pixel[0],
    y: pixel[1],
    pixel: pixel,
    lngLat: viewport.unproject(pixel)
  };
}

// Walk up the layer composite chain to populate the info object
function getLayerPickingInfo(_ref8) {
  var layer = _ref8.layer,
      info = _ref8.info,
      mode = _ref8.mode;

  while (layer && info) {
    // For a composite layer, sourceLayer will point to the sublayer
    // where the event originates from.
    // It provides additional context for the composite layer's
    // getPickingInfo() method to populate the info object
    var sourceLayer = info.layer || layer;
    info.layer = layer;
    // layer.pickLayer() function requires a non-null ```layer.state```
    // object to funtion properly. So the layer refereced here
    // must be the "current" layer, not an "out-dated" / "invalidated" layer
    info = layer.pickLayer({ info: info, mode: mode, sourceLayer: sourceLayer });
    layer = layer.parentLayer;
  }
  return info;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9waWNrLWxheWVycy5qcyJdLCJuYW1lcyI6WyJsb2ciLCJkcmF3UGlja2luZ0J1ZmZlciIsImdldFBpeGVsUmF0aW8iLCJFTVBUWV9QSVhFTCIsIlVpbnQ4QXJyYXkiLCJwaWNrT2JqZWN0IiwiZ2wiLCJsYXllcnMiLCJ2aWV3cG9ydHMiLCJvblZpZXdwb3J0QWN0aXZlIiwicGlja2luZ0ZCTyIsIngiLCJ5IiwicmFkaXVzIiwibW9kZSIsImxhc3RQaWNrZWRJbmZvIiwidXNlRGV2aWNlUGl4ZWxSYXRpbyIsInBpeGVsUmF0aW8iLCJkZXZpY2VYIiwiTWF0aCIsInJvdW5kIiwiZGV2aWNlWSIsImNhbnZhcyIsImhlaWdodCIsImRldmljZVJhZGl1cyIsInBpY2tJbmZvIiwiZ2V0Q2xvc2VzdEZyb21QaWNraW5nQnVmZmVyIiwicGlja2VkQ29sb3IiLCJwaWNrZWRMYXllciIsInBpY2tlZE9iamVjdEluZGV4IiwiYWZmZWN0ZWRMYXllcnMiLCJsYXN0UGlja2VkT2JqZWN0SW5kZXgiLCJpbmRleCIsImxhc3RQaWNrZWRMYXllcklkIiwibGF5ZXJJZCIsInBpY2tlZExheWVySWQiLCJwcm9wcyIsImlkIiwibGFzdFBpY2tlZExheWVyIiwiZmluZCIsImxheWVyIiwidW5zaGlmdCIsInZpZXdwb3J0IiwiZ2V0Vmlld3BvcnRGcm9tQ29vcmRpbmF0ZXMiLCJiYXNlSW5mbyIsImNyZWF0ZUluZm8iLCJkZXZpY2VQaXhlbCIsImluZm9zIiwiTWFwIiwidW5oYW5kbGVkUGlja0luZm9zIiwiZm9yRWFjaCIsImluZm8iLCJPYmplY3QiLCJhc3NpZ24iLCJjb2xvciIsInBpY2tlZCIsImdldExheWVyUGlja2luZ0luZm8iLCJzZXQiLCJwaWNraW5nU2VsZWN0ZWRDb2xvciIsInBpY2tpbmdTZWxlY3RlZENvbG9yVmFsaWQiLCJCb29sZWFuIiwiYXV0b0hpZ2hsaWdodCIsInN0YXRlIiwibW9kZWwiLCJ1cGRhdGVNb2R1bGVTZXR0aW5ncyIsImhhbmRsZWQiLCJvbkNsaWNrIiwib25Ib3ZlciIsIkVycm9yIiwicHVzaCIsInBpY2tWaXNpYmxlT2JqZWN0cyIsIndpZHRoIiwiZGV2aWNlTGVmdCIsImRldmljZUJvdHRvbSIsImRldmljZVJpZ2h0IiwiZGV2aWNlVG9wIiwidW5pcXVlSW5mb3MiLCJwaWNrSW5mb3MiLCJnZXRVbmlxdWVzRnJvbVBpY2tpbmdCdWZmZXIiLCJkZXZpY2VSZWN0IiwiaGFzIiwib2JqZWN0IiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiZ2V0UGlja2VkQ29sb3JzIiwicGlja2VkQ29sb3JzIiwic2FtcGxlUGlja2luZ0J1ZmZlciIsInJlYWRQaXhlbHMiLCJwaXhlbEFycmF5IiwiY2xvc2VzdFJlc3VsdFRvQ2VudGVyIiwidmFsaWQiLCJsZW5ndGgiLCJtYXgiLCJtaW4iLCJtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyIiwiaSIsInJvdyIsImNvbCIsInBpY2tlZExheWVySW5kZXgiLCJkeCIsImR5IiwiZDIiLCJzbGljZSIsImRlY29kZVBpY2tpbmdDb2xvciIsImVycm9yIiwidW5pcXVlQ29sb3JzIiwiY29sb3JLZXkiLCJqb2luIiwicGl4ZWwiLCJsbmdMYXQiLCJ1bnByb2plY3QiLCJzb3VyY2VMYXllciIsInBpY2tMYXllciIsInBhcmVudExheWVyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFRQSxHQUFSLFFBQWtCLFNBQWxCO0FBQ0EsU0FBUUMsaUJBQVIsRUFBMkJDLGFBQTNCLFFBQStDLGVBQS9DOztBQUVBLElBQU1DLGNBQWMsSUFBSUMsVUFBSixDQUFlLENBQWYsQ0FBcEI7O0FBRUE7QUFDQTtBQUNBLE9BQU8sU0FBU0MsVUFBVCxDQUFvQkMsRUFBcEIsUUFXSjtBQUFBLE1BVkRDLE1BVUMsUUFWREEsTUFVQztBQUFBLE1B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dXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNSAtIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge2xvZ30gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge2RyYXdQaWNraW5nQnVmZmVyLCBnZXRQaXhlbFJhdGlvfSBmcm9tICcuL2RyYXctbGF5ZXJzJztcblxuY29uc3QgRU1QVFlfUElYRUwgPSBuZXcgVWludDhBcnJheSg0KTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWRlcHRoLCBtYXgtc3RhdGVtZW50cyAqL1xuLy8gUGljayB0aGUgY2xvc2VzdCBvYmplY3QgYXQgdGhlIGdpdmVuICh4LHkpIGNvb3JkaW5hdGVcbmV4cG9ydCBmdW5jdGlvbiBwaWNrT2JqZWN0KGdsLCB7XG4gIGxheWVycyxcbiAgdmlld3BvcnRzLFxuICBvblZpZXdwb3J0QWN0aXZlLFxuICBwaWNraW5nRkJPLFxuICB4LFxuICB5LFxuICByYWRpdXMsXG4gIG1vZGUsXG4gIGxhc3RQaWNrZWRJbmZvLFxuICB1c2VEZXZpY2VQaXhlbFJhdGlvXG59KSB7XG4gIC8vIENvbnZlcnQgZnJvbSBjYW52YXMgdG9wLWxlZnQgdG8gV2ViR0wgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXNcbiAgLy8gQW5kIGNvbXBlbnNhdGUgZm9yIHBpeGVsUmF0aW9cbiAgY29uc3QgcGl4ZWxSYXRpbyA9IGdldFBpeGVsUmF0aW8oe3VzZURldmljZVBpeGVsUmF0aW99KTtcbiAgY29uc3QgZGV2aWNlWCA9IE1hdGgucm91bmQoeCAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VZID0gTWF0aC5yb3VuZChnbC5jYW52YXMuaGVpZ2h0IC0geSAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VSYWRpdXMgPSBNYXRoLnJvdW5kKHJhZGl1cyAqIHBpeGVsUmF0aW8pO1xuXG4gIGNvbnN0IHBpY2tJbmZvID0gZ2V0Q2xvc2VzdEZyb21QaWNraW5nQnVmZmVyKGdsLCB7XG4gICAgbGF5ZXJzLFxuICAgIHZpZXdwb3J0cyxcbiAgICBvblZpZXdwb3J0QWN0aXZlLFxuICAgIHBpY2tpbmdGQk8sXG4gICAgZGV2aWNlWCxcbiAgICBkZXZpY2VZLFxuICAgIGRldmljZVJhZGl1c1xuICB9KTtcblxuICBjb25zdCB7XG4gICAgcGlja2VkQ29sb3IsXG4gICAgcGlja2VkTGF5ZXIsXG4gICAgcGlja2VkT2JqZWN0SW5kZXhcbiAgfSA9IHBpY2tJbmZvO1xuXG4gIGNvbnN0IGFmZmVjdGVkTGF5ZXJzID0gcGlja2VkTGF5ZXIgPyBbcGlja2VkTGF5ZXJdIDogW107XG5cbiAgaWYgKG1vZGUgPT09ICdob3ZlcicpIHtcbiAgICAvLyBvbmx5IGludm9rZSBvbkhvdmVyIGV2ZW50cyBpZiBwaWNrZWQgb2JqZWN0IGhhcyBjaGFuZ2VkXG4gICAgY29uc3QgbGFzdFBpY2tlZE9iamVjdEluZGV4ID0gbGFzdFBpY2tlZEluZm8uaW5kZXg7XG4gICAgY29uc3QgbGFzdFBpY2tlZExheWVySWQgPSBsYXN0UGlja2VkSW5mby5sYXllcklkO1xuICAgIGNvbnN0IHBpY2tlZExheWVySWQgPSBwaWNrZWRMYXllciAmJiBwaWNrZWRMYXllci5wcm9wcy5pZDtcblxuICAgIC8vIHByb2NlZWQgb25seSBpZiBwaWNrZWQgb2JqZWN0IGNoYW5nZWRcbiAgICBpZiAocGlja2VkTGF5ZXJJZCAhPT0gbGFzdFBpY2tlZExheWVySWQgfHwgcGlja2VkT2JqZWN0SW5kZXggIT09IGxhc3RQaWNrZWRPYmplY3RJbmRleCkge1xuICAgICAgaWYgKHBpY2tlZExheWVySWQgIT09IGxhc3RQaWNrZWRMYXllcklkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCBzdG9yZSBhIHJlZiB0byBsYXN0UGlja2VkTGF5ZXIgaW4gdGhlIGNvbnRleHQgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgc3RhdGUgb2YgYW4gb3V0ZGF0ZWQgbGF5ZXIgaXMgbm8gbG9uZ2VyIHZhbGlkXG4gICAgICAgIC8vIGFuZCB0aGUgcHJvcHMgbWF5IGhhdmUgY2hhbmdlZFxuICAgICAgICBjb25zdCBsYXN0UGlja2VkTGF5ZXIgPSBsYXllcnMuZmluZChsYXllciA9PiBsYXllci5wcm9wcy5pZCA9PT0gbGFzdFBpY2tlZExheWVySWQpO1xuICAgICAgICBpZiAobGFzdFBpY2tlZExheWVyKSB7XG4gICAgICAgICAgLy8gTGV0IGxlYXZlIGV2ZW50IGZpcmUgYmVmb3JlIGVudGVyIGV2ZW50XG4gICAgICAgICAgYWZmZWN0ZWRMYXllcnMudW5zaGlmdChsYXN0UGlja2VkTGF5ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBsYXllciBtYW5hZ2VyIGNvbnRleHRcbiAgICAgIGxhc3RQaWNrZWRJbmZvLmxheWVySWQgPSBwaWNrZWRMYXllcklkO1xuICAgICAgbGFzdFBpY2tlZEluZm8uaW5kZXggPSBwaWNrZWRPYmplY3RJbmRleDtcbiAgICB9XG4gIH1cblxuICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0RnJvbUNvb3JkaW5hdGVzKHt2aWV3cG9ydHN9KTsgLy8gVE9ETyAtIGFkZCBjb29yZHNcblxuICBjb25zdCBiYXNlSW5mbyA9IGNyZWF0ZUluZm8oW3gsIHldLCB2aWV3cG9ydCk7XG4gIGJhc2VJbmZvLmRldmljZVBpeGVsID0gW2RldmljZVgsIGRldmljZVldO1xuICBiYXNlSW5mby5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcblxuICAvLyBVc2UgYSBNYXAgdG8gc3RvcmUgYWxsIHBpY2tpbmcgaW5mb3MuXG4gIC8vIFRoZSBmb2xsb3dpbmcgdHdvIGZvckVhY2ggbG9vcHMgYXJlIHRoZSByZXN1bHQgb2ZcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ViZXIvZGVjay5nbC9pc3N1ZXMvNDQzXG4gIC8vIFBsZWFzZSBiZSB2ZXJ5IGNhcmVmdWwgd2hlbiBjaGFuZ2luZyB0aGlzIHBhdHRlcm5cbiAgY29uc3QgaW5mb3MgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHVuaGFuZGxlZFBpY2tJbmZvcyA9IFtdO1xuXG4gIGFmZmVjdGVkTGF5ZXJzLmZvckVhY2gobGF5ZXIgPT4ge1xuICAgIGxldCBpbmZvID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZUluZm8pO1xuXG4gICAgaWYgKGxheWVyID09PSBwaWNrZWRMYXllcikge1xuICAgICAgaW5mby5jb2xvciA9IHBpY2tlZENvbG9yO1xuICAgICAgaW5mby5pbmRleCA9IHBpY2tlZE9iamVjdEluZGV4O1xuICAgICAgaW5mby5waWNrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGluZm8gPSBnZXRMYXllclBpY2tpbmdJbmZvKHtsYXllciwgaW5mbywgbW9kZX0pO1xuXG4gICAgLy8gVGhpcyBndWFyYW50ZWVzIHRoYXQgdGhlcmUgd2lsbCBiZSBvbmx5IG9uZSBjb3B5IG9mIGluZm8gZm9yXG4gICAgLy8gb25lIGNvbXBvc2l0ZSBsYXllclxuICAgIGlmIChpbmZvKSB7XG4gICAgICBpbmZvcy5zZXQoaW5mby5sYXllci5pZCwgaW5mbyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGlja2luZ1NlbGVjdGVkQ29sb3IgPSBwaWNrZWRDb2xvcjtcbiAgICBjb25zdCBwaWNraW5nU2VsZWN0ZWRDb2xvclZhbGlkID0gQm9vbGVhbihcbiAgICAgIGxheWVyLnByb3BzLmF1dG9IaWdobGlnaHQgJiZcbiAgICAgIHBpY2tlZExheWVyID09PSBsYXllciAmJlxuICAgICAgcGlja2luZ1NlbGVjdGVkQ29sb3IgIT09IEVNUFRZX1BJWEVMXG4gICAgKTtcbiAgICAvLyBUT0RPIC0gaGFuZGxlIG11bHRpIG1vZGVsIGxheWVycz9cbiAgICBpZiAobGF5ZXIuc3RhdGUubW9kZWwpIHtcbiAgICAgIGxheWVyLnN0YXRlLm1vZGVsLnVwZGF0ZU1vZHVsZVNldHRpbmdzKHtcbiAgICAgICAgcGlja2luZ1NlbGVjdGVkQ29sb3IsXG4gICAgICAgIHBpY2tpbmdTZWxlY3RlZENvbG9yVmFsaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgaW5mb3MuZm9yRWFjaChpbmZvID0+IHtcbiAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuICAgIC8vIFBlci1sYXllciBldmVudCBoYW5kbGVycyAoZS5nLiBvbkNsaWNrLCBvbkhvdmVyKSBhcmUgcHJvdmlkZWQgYnkgdGhlXG4gICAgLy8gdXNlciBhbmQgb3V0IG9mIGRlY2suZ2wncyBjb250cm9sLiBJdCdzIHZlcnkgbXVjaCBwb3NzaWJsZSB0aGF0XG4gICAgLy8gdGhlIHVzZXIgY2FsbHMgUmVhY3QgbGlmZWN5Y2xlIG1ldGhvZHMgaW4gdGhlc2UgZnVuY3Rpb24sIHN1Y2ggYXNcbiAgICAvLyBSZWFjdENvbXBvbmVudC5zZXRTdGF0ZSgpLiBSZWFjdCBsaWZlY3ljbGUgbWV0aG9kcyBzb21ldGltZXMgaW5kdWNlXG4gICAgLy8gYSByZS1yZW5kZXIgYW5kIHJlLWdlbmVyYXRpb24gb2YgcHJvcHMgb2YgZGVjay5nbCBhbmQgaXRzIGxheWVycyxcbiAgICAvLyB3aGljaCBpbnZhbGlkYXRlcyBhbGwgbGF5ZXJzIGN1cnJlbnRseSBwYXNzZWQgdG8gdGhpcyB2ZXJ5IGZ1bmN0aW9uLlxuXG4gICAgLy8gVGhlcmVmb3JlLCBwZXItbGF5ZXIgZXZlbnQgaGFuZGxlcnMgbXVzdCBiZSBpbnZva2VkIGF0IHRoZSBlbmRcbiAgICAvLyBvZiB0aGlzIGZ1bmN0aW9uLiBOTyBvcGVyYXRpb24gdGhhdCByZWxpZXMgb24gdGhlIHN0YXRlcyBvZiBjdXJyZW50XG4gICAgLy8gbGF5ZXJzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcyBjb2RlLlxuICAgIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgJ2NsaWNrJzogaGFuZGxlZCA9IGluZm8ubGF5ZXIucHJvcHMub25DbGljayhpbmZvKTsgYnJlYWs7XG4gICAgY2FzZSAnaG92ZXInOiBoYW5kbGVkID0gaW5mby5sYXllci5wcm9wcy5vbkhvdmVyKGluZm8pOyBicmVhaztcbiAgICBjYXNlICdxdWVyeSc6IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBwaWNrIHR5cGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIWhhbmRsZWQpIHtcbiAgICAgIHVuaGFuZGxlZFBpY2tJbmZvcy5wdXNoKGluZm8pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHVuaGFuZGxlZFBpY2tJbmZvcztcbn1cblxuLy8gUGljayBhbGwgb2JqZWN0cyB3aXRoaW4gdGhlIGdpdmVuIGJvdW5kaW5nIGJveFxuZXhwb3J0IGZ1bmN0aW9uIHBpY2tWaXNpYmxlT2JqZWN0cyhnbCwge1xuICBsYXllcnMsXG4gIHZpZXdwb3J0cyxcbiAgb25WaWV3cG9ydEFjdGl2ZSxcbiAgcGlja2luZ0ZCTyxcbiAgeCxcbiAgeSxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgbW9kZSxcbiAgdXNlRGV2aWNlUGl4ZWxSYXRpb1xufSkge1xuXG4gIC8vIENvbnZlcnQgZnJvbSBjYW52YXMgdG9wLWxlZnQgdG8gV2ViR0wgYm90dG9tLWxlZnQgY29vcmRpbmF0ZXNcbiAgLy8gQW5kIGNvbXBlbnNhdGUgZm9yIHBpeGVsUmF0aW9cbiAgY29uc3QgcGl4ZWxSYXRpbyA9IGdldFBpeGVsUmF0aW8oe3VzZURldmljZVBpeGVsUmF0aW99KTtcblxuICBjb25zdCBkZXZpY2VMZWZ0ID0gTWF0aC5yb3VuZCh4ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZUJvdHRvbSA9IE1hdGgucm91bmQoZ2wuY2FudmFzLmhlaWdodCAtIHkgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlUmlnaHQgPSBNYXRoLnJvdW5kKCh4ICsgd2lkdGgpICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVRvcCA9IE1hdGgucm91bmQoZ2wuY2FudmFzLmhlaWdodCAtICh5ICsgaGVpZ2h0KSAqIHBpeGVsUmF0aW8pO1xuXG4gIC8vIE9ubHkgcmV0dXJuIHVuaXF1ZSBpbmZvcywgaWRlbnRpZmllZCBieSBpbmZvLm9iamVjdFxuICBjb25zdCB1bmlxdWVJbmZvcyA9IG5ldyBNYXAoKTtcblxuICBjb25zdCBwaWNrSW5mb3MgPSBnZXRVbmlxdWVzRnJvbVBpY2tpbmdCdWZmZXIoZ2wsIHtcbiAgICBsYXllcnMsXG4gICAgdmlld3BvcnRzLFxuICAgIG9uVmlld3BvcnRBY3RpdmUsXG4gICAgcGlja2luZ0ZCTyxcbiAgICBkZXZpY2VSZWN0OiB7XG4gICAgICB4OiBkZXZpY2VMZWZ0LFxuICAgICAgeTogZGV2aWNlVG9wLFxuICAgICAgd2lkdGg6IGRldmljZVJpZ2h0IC0gZGV2aWNlTGVmdCxcbiAgICAgIGhlaWdodDogZGV2aWNlQm90dG9tIC0gZGV2aWNlVG9wXG4gICAgfVxuICB9KTtcblxuICBwaWNrSW5mb3MuZm9yRWFjaChwaWNrSW5mbyA9PiB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3cG9ydEZyb21Db29yZGluYXRlcyh7dmlld3BvcnRzfSk7IC8vIFRPRE8gLSBhZGQgY29vcmRzXG4gICAgbGV0IGluZm8gPSBjcmVhdGVJbmZvKFtwaWNrSW5mby54IC8gcGl4ZWxSYXRpbywgcGlja0luZm8ueSAvIHBpeGVsUmF0aW9dLCB2aWV3cG9ydCk7XG4gICAgaW5mby5kZXZpY2VQaXhlbCA9IFtwaWNrSW5mby54LCBwaWNrSW5mby55XTtcbiAgICBpbmZvLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIGluZm8uY29sb3IgPSBwaWNrSW5mby5waWNrZWRDb2xvcjtcbiAgICBpbmZvLmluZGV4ID0gcGlja0luZm8ucGlja2VkT2JqZWN0SW5kZXg7XG4gICAgaW5mby5waWNrZWQgPSB0cnVlO1xuXG4gICAgaW5mbyA9IGdldExheWVyUGlja2luZ0luZm8oe2xheWVyOiBwaWNrSW5mby5waWNrZWRMYXllciwgaW5mbywgbW9kZX0pO1xuICAgIGlmICghdW5pcXVlSW5mb3MuaGFzKGluZm8ub2JqZWN0KSkge1xuICAgICAgdW5pcXVlSW5mb3Muc2V0KGluZm8ub2JqZWN0LCBpbmZvKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBBcnJheS5mcm9tKHVuaXF1ZUluZm9zLnZhbHVlcygpKTtcbn1cblxuLy8gSEVMUEVSIE1FVEhPRFNcblxuLy8gSW5kZW50aWZpZXMgd2hpY2ggdmlld3BvcnQsIGlmIGFueSBjb3JyZXNwb25kcyB0byB4IGFuZCB5XG4vLyBSZXR1cm5zIGZpcnN0IHZpZXdwb3J0IGlmIG5vIG1hdGNoXG4vLyBUT0RPIC0gbmVlZCB0byBkZXRlcm1pbmUgd2hpY2ggdmlld3BvcnQgd2UgYXJlIGluXG4vLyBUT0RPIC0gZG9jdW1lbnQgY29uY2VwdCBvZiBcInByaW1hcnkgdmlld3BvcnRcIiB0aGF0IG1hdGNoZXMgYWxsIGNvb3Jkcz9cbi8vIFRPRE8gLSBzdGF0aWMgbWV0aG9kIG9uIFZpZXdwb3J0IGNsYXNzP1xuZnVuY3Rpb24gZ2V0Vmlld3BvcnRGcm9tQ29vcmRpbmF0ZXMoe3ZpZXdwb3J0c30pIHtcbiAgY29uc3Qgdmlld3BvcnQgPSB2aWV3cG9ydHNbMF07XG4gIHJldHVybiB2aWV3cG9ydDtcbn1cblxuZnVuY3Rpb24gZ2V0UGlja2VkQ29sb3JzKGdsLCB7bGF5ZXJzLCB2aWV3cG9ydHMsIG9uVmlld3BvcnRBY3RpdmUsIHBpY2tpbmdGQk8sIGRldmljZVJlY3R9KSB7XG4gIGRyYXdQaWNraW5nQnVmZmVyKGdsLCB7bGF5ZXJzLCB2aWV3cG9ydHMsIG9uVmlld3BvcnRBY3RpdmUsIHBpY2tpbmdGQk8sIGRldmljZVJlY3R9KTtcbiAgLy8gVE9ETyAtIHJlc3RvcmUgd2hlbiBsdW1hIHBhdGNoIGxhbmRzXG4gIC8vIGNvbnN0IGRhdGFVcmwgPSBwaWNraW5nRkJPLnJlYWREYXRhVXJsKCk7XG4gIC8vIHdpbmRvdy5vcGVuKGRhdGFVcmwsICdwaWNraW5nIGJ1ZmZlcicpO1xuXG4gIGNvbnN0IHBpY2tlZENvbG9ycyA9IHNhbXBsZVBpY2tpbmdCdWZmZXIoZ2wsIHtwaWNraW5nRkJPLCBkZXZpY2VSZWN0fSk7XG4gIHJldHVybiBwaWNrZWRDb2xvcnM7XG59XG5cbi8vIFJlYWQgZnJvbSBhbiBhbHJlYWR5IHJlbmRlcmVkIHBpY2tpbmcgYnVmZmVyXG4vLyBSZXR1cm5zIGFuIFVpbnQ4Q2xhbXBlZEFycmF5IG9mIHBpY2tlZCBwaXhlbHNcbmV4cG9ydCBmdW5jdGlvbiBzYW1wbGVQaWNraW5nQnVmZmVyKGdsLCB7XG4gIHBpY2tpbmdGQk8sXG4gIGRldmljZVJlY3Q6IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxufSkge1xuICBjb25zdCBwaWNrZWRDb2xvcnMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICBwaWNraW5nRkJPLnJlYWRQaXhlbHMoe3gsIHksIHdpZHRoLCBoZWlnaHQsIHBpeGVsQXJyYXk6IHBpY2tlZENvbG9yc30pO1xuICByZXR1cm4gcGlja2VkQ29sb3JzO1xufVxuXG4vKipcbiAqIFBpY2sgYXQgYSBzcGVjaWZpZWQgcGl4ZWwgd2l0aCBhIHRvbGVyYW5jZSByYWRpdXNcbiAqIFJldHVybnMgdGhlIGNsb3Nlc3Qgb2JqZWN0IHRvIHRoZSBwaXhlbCBpbiBzaGFwZSBge3BpY2tlZENvbG9yLCBwaWNrZWRMYXllciwgcGlja2VkT2JqZWN0SW5kZXh9YFxuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0RnJvbVBpY2tpbmdCdWZmZXIoZ2wsIHtcbiAgbGF5ZXJzLFxuICB2aWV3cG9ydHMsXG4gIG9uVmlld3BvcnRBY3RpdmUsXG4gIHBpY2tpbmdGQk8sXG4gIGRldmljZVgsXG4gIGRldmljZVksXG4gIGRldmljZVJhZGl1c1xufSkge1xuICBsZXQgY2xvc2VzdFJlc3VsdFRvQ2VudGVyID0ge1xuICAgIHBpY2tlZENvbG9yOiBFTVBUWV9QSVhFTCxcbiAgICBwaWNrZWRMYXllcjogbnVsbCxcbiAgICBwaWNrZWRPYmplY3RJbmRleDogLTFcbiAgfTtcblxuICAvLyB4LCB5IG91dCBvZiBib3VuZHMgb3Igbm8gbGF5ZXJzIHRvIHBpY2suXG4gIGNvbnN0IHZhbGlkID1cbiAgICBsYXllcnMubGVuZ3RoID4gMCAmJlxuICAgIGRldmljZVggPj0gMCAmJlxuICAgIGRldmljZVkgPj0gMCAmJlxuICAgIGRldmljZVggPCBwaWNraW5nRkJPLndpZHRoICYmXG4gICAgZGV2aWNlWSA8IHBpY2tpbmdGQk8uaGVpZ2h0O1xuXG4gIGlmICghdmFsaWQpIHtcbiAgICByZXR1cm4gY2xvc2VzdFJlc3VsdFRvQ2VudGVyO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgYm94IG9mIHNpemUgYHJhZGl1cyAqIDIgKyAxYCBjZW50ZXJlZCBhdCBbZGV2aWNlWCwgZGV2aWNlWV1cbiAgY29uc3QgeCA9IE1hdGgubWF4KDAsIGRldmljZVggLSBkZXZpY2VSYWRpdXMpO1xuICBjb25zdCB5ID0gTWF0aC5tYXgoMCwgZGV2aWNlWSAtIGRldmljZVJhZGl1cyk7XG4gIGNvbnN0IHdpZHRoID0gTWF0aC5taW4ocGlja2luZ0ZCTy53aWR0aCwgZGV2aWNlWCArIGRldmljZVJhZGl1cykgLSB4ICsgMTtcbiAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4ocGlja2luZ0ZCTy5oZWlnaHQsIGRldmljZVkgKyBkZXZpY2VSYWRpdXMpIC0geSArIDE7XG5cbiAgY29uc3QgcGlja2VkQ29sb3JzID0gZ2V0UGlja2VkQ29sb3JzKGdsLCB7XG4gICAgbGF5ZXJzLFxuICAgIHZpZXdwb3J0cyxcbiAgICBvblZpZXdwb3J0QWN0aXZlLFxuICAgIHBpY2tpbmdGQk8sXG4gICAgZGV2aWNlUmVjdDoge3gsIHksIHdpZHRoLCBoZWlnaHR9XG4gIH0pO1xuXG4gIC8vIFRyYXZlcnNlIGFsbCBwaXhlbHMgaW4gcGlja2luZyByZXN1bHRzIGFuZCBmaW5kIHRoZSBvbmUgY2xvc2VzdCB0byB0aGUgc3VwcGxpZWRcbiAgLy8gW2RldmljZVgsIGRldmljZVldXG4gIGxldCBtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyID0gZGV2aWNlUmFkaXVzICogZGV2aWNlUmFkaXVzO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgaGVpZ2h0OyByb3crKykge1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHdpZHRoOyBjb2wrKykge1xuICAgICAgLy8gRGVjb2RlIHBpY2tlZCBsYXllciBmcm9tIGNvbG9yXG4gICAgICBjb25zdCBwaWNrZWRMYXllckluZGV4ID0gcGlja2VkQ29sb3JzW2kgKyAzXSAtIDE7XG5cbiAgICAgIGlmIChwaWNrZWRMYXllckluZGV4ID49IDApIHtcbiAgICAgICAgY29uc3QgZHggPSBjb2wgKyB4IC0gZGV2aWNlWDtcbiAgICAgICAgY29uc3QgZHkgPSByb3cgKyB5IC0gZGV2aWNlWTtcbiAgICAgICAgY29uc3QgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcblxuICAgICAgICBpZiAoZDIgPD0gbWluU3F1YXJlRGlzdGFuY2VUb0NlbnRlcikge1xuICAgICAgICAgIG1pblNxdWFyZURpc3RhbmNlVG9DZW50ZXIgPSBkMjtcblxuICAgICAgICAgIC8vIERlY29kZSBwaWNrZWQgb2JqZWN0IGluZGV4IGZyb20gY29sb3JcbiAgICAgICAgICBjb25zdCBwaWNrZWRDb2xvciA9IHBpY2tlZENvbG9ycy5zbGljZShpLCBpICsgNCk7XG4gICAgICAgICAgY29uc3QgcGlja2VkTGF5ZXIgPSBsYXllcnNbcGlja2VkTGF5ZXJJbmRleF07XG4gICAgICAgICAgaWYgKHBpY2tlZExheWVyKSB7XG4gICAgICAgICAgICBjb25zdCBwaWNrZWRPYmplY3RJbmRleCA9IHBpY2tlZExheWVyLmRlY29kZVBpY2tpbmdDb2xvcihwaWNrZWRDb2xvcik7XG4gICAgICAgICAgICBjbG9zZXN0UmVzdWx0VG9DZW50ZXIgPSB7cGlja2VkQ29sb3IsIHBpY2tlZExheWVyLCBwaWNrZWRPYmplY3RJbmRleH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcigwLCAnUGlja2VkIG5vbi1leGlzdGVudCBsYXllci4gSXMgcGlja2luZyBidWZmZXIgY29ycnVwdD8nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkgKz0gNDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdFJlc3VsdFRvQ2VudGVyO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtZGVwdGgsIG1heC1zdGF0ZW1lbnRzICovXG5cbi8qKlxuICogUXVlcnkgd2l0aGluIGEgc3BlY2lmaWVkIHJlY3RhbmdsZVxuICogUmV0dXJucyBhcnJheSBvZiB1bmlxdWUgb2JqZWN0cyBpbiBzaGFwZSBge3gsIHksIHBpY2tlZENvbG9yLCBwaWNrZWRMYXllciwgcGlja2VkT2JqZWN0SW5kZXh9YFxuICovXG5mdW5jdGlvbiBnZXRVbmlxdWVzRnJvbVBpY2tpbmdCdWZmZXIoZ2wsIHtcbiAgbGF5ZXJzLFxuICB2aWV3cG9ydHMsXG4gIG9uVmlld3BvcnRBY3RpdmUsXG4gIHBpY2tpbmdGQk8sXG4gIGRldmljZVJlY3Q6IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxufSkge1xuICBjb25zdCBwaWNrZWRDb2xvcnMgPSBnZXRQaWNrZWRDb2xvcnMoZ2wsIHtcbiAgICBsYXllcnMsXG4gICAgdmlld3BvcnRzLFxuICAgIG9uVmlld3BvcnRBY3RpdmUsXG4gICAgcGlja2luZ0ZCTyxcbiAgICBkZXZpY2VSZWN0OiB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAgfSk7XG4gIGNvbnN0IHVuaXF1ZUNvbG9ycyA9IG5ldyBNYXAoKTtcblxuICAvLyBUcmF2ZXJzZSBhbGwgcGl4ZWxzIGluIHBpY2tpbmcgcmVzdWx0cyBhbmQgZ2V0IHVuaXF1ZSBjb2xvcnNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWNrZWRDb2xvcnMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAvLyBEZWNvZGUgcGlja2VkIGxheWVyIGZyb20gY29sb3JcbiAgICBjb25zdCBwaWNrZWRMYXllckluZGV4ID0gcGlja2VkQ29sb3JzW2kgKyAzXSAtIDE7XG5cbiAgICBpZiAocGlja2VkTGF5ZXJJbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBwaWNrZWRDb2xvciA9IHBpY2tlZENvbG9ycy5zbGljZShpLCBpICsgNCk7XG4gICAgICBjb25zdCBjb2xvcktleSA9IHBpY2tlZENvbG9yLmpvaW4oJywnKTtcbiAgICAgIGlmICghdW5pcXVlQ29sb3JzLmhhcyhjb2xvcktleSkpIHtcbiAgICAgICAgY29uc3QgcGlja2VkTGF5ZXIgPSBsYXllcnNbcGlja2VkTGF5ZXJJbmRleF07XG4gICAgICAgIGlmIChwaWNrZWRMYXllcikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgdW5pcXVlQ29sb3JzLnNldChjb2xvcktleSwge1xuICAgICAgICAgICAgcGlja2VkQ29sb3IsXG4gICAgICAgICAgICBwaWNrZWRMYXllcixcbiAgICAgICAgICAgIHBpY2tlZE9iamVjdEluZGV4OiBwaWNrZWRMYXllci5kZWNvZGVQaWNraW5nQ29sb3IocGlja2VkQ29sb3IpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nLmVycm9yKDAsICdQaWNrZWQgbm9uLWV4aXN0ZW50IGxheWVyLiBJcyBwaWNraW5nIGJ1ZmZlciBjb3JydXB0PycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEFycmF5LmZyb20odW5pcXVlQ29sb3JzLnZhbHVlcygpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5mbyhwaXhlbCwgdmlld3BvcnQpIHtcbiAgLy8gQXNzaWduIGEgbnVtYmVyIG9mIHBvdGVudGlhbGx5IHVzZWZ1bCBwcm9wcyB0byB0aGUgXCJpbmZvXCIgb2JqZWN0XG4gIHJldHVybiB7XG4gICAgY29sb3I6IEVNUFRZX1BJWEVMLFxuICAgIGxheWVyOiBudWxsLFxuICAgIGluZGV4OiAtMSxcbiAgICBwaWNrZWQ6IGZhbHNlLFxuICAgIHg6IHBpeGVsWzBdLFxuICAgIHk6IHBpeGVsWzFdLFxuICAgIHBpeGVsLFxuICAgIGxuZ0xhdDogdmlld3BvcnQudW5wcm9qZWN0KHBpeGVsKVxuICB9O1xufVxuXG4vLyBXYWxrIHVwIHRoZSBsYXllciBjb21wb3NpdGUgY2hhaW4gdG8gcG9wdWxhdGUgdGhlIGluZm8gb2JqZWN0XG5mdW5jdGlvbiBnZXRMYXllclBpY2tpbmdJbmZvKHtsYXllciwgaW5mbywgbW9kZX0pIHtcbiAgd2hpbGUgKGxheWVyICYmIGluZm8pIHtcbiAgICAvLyBGb3IgYSBjb21wb3NpdGUgbGF5ZXIsIHNvdXJjZUxheWVyIHdpbGwgcG9pbnQgdG8gdGhlIHN1YmxheWVyXG4gICAgLy8gd2hlcmUgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbS5cbiAgICAvLyBJdCBwcm92aWRlcyBhZGRpdGlvbmFsIGNvbnRleHQgZm9yIHRoZSBjb21wb3NpdGUgbGF5ZXInc1xuICAgIC8vIGdldFBpY2tpbmdJbmZvKCkgbWV0aG9kIHRvIHBvcHVsYXRlIHRoZSBpbmZvIG9iamVjdFxuICAgIGNvbnN0IHNvdXJjZUxheWVyID0gaW5mby5sYXllciB8fCBsYXllcjtcbiAgICBpbmZvLmxheWVyID0gbGF5ZXI7XG4gICAgLy8gbGF5ZXIucGlja0xheWVyKCkgZnVuY3Rpb24gcmVxdWlyZXMgYSBub24tbnVsbCBgYGBsYXllci5zdGF0ZWBgYFxuICAgIC8vIG9iamVjdCB0byBmdW50aW9uIHByb3Blcmx5LiBTbyB0aGUgbGF5ZXIgcmVmZXJlY2VkIGhlcmVcbiAgICAvLyBtdXN0IGJlIHRoZSBcImN1cnJlbnRcIiBsYXllciwgbm90IGFuIFwib3V0LWRhdGVkXCIgLyBcImludmFsaWRhdGVkXCIgbGF5ZXJcbiAgICBpbmZvID0gbGF5ZXIucGlja0xheWVyKHtpbmZvLCBtb2RlLCBzb3VyY2VMYXllcn0pO1xuICAgIGxheWVyID0gbGF5ZXIucGFyZW50TGF5ZXI7XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG4iXX0=