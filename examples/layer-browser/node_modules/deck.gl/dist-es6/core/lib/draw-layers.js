// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */
import { GL, withParameters, setParameters } from 'luma.gl';
import { log } from './utils';

var renderCount = 0;

// TODO - Exported for pick-layers.js - Move to util?
export var getPixelRatio = function getPixelRatio(_ref) {
  var useDevicePixelRatio = _ref.useDevicePixelRatio;
  return useDevicePixelRatio && typeof window !== 'undefined' ? window.devicePixelRatio : 1;
};

// Convert viewport top-left CSS coordinates to bottom up WebGL coordinates
var getGLViewport = function getGLViewport(gl, _ref2) {
  var viewport = _ref2.viewport,
      pixelRatio = _ref2.pixelRatio;

  var width = gl.canvas.clientWidth;
  var height = gl.canvas.clientHeight;
  // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates
  var dimensions = viewport.getDimensions({ width: width, height: height });
  return [dimensions.x * pixelRatio, (height - dimensions.y - dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
};

// Helper functions

function clearCanvas(gl, _ref3) {
  var useDevicePixelRatio = _ref3.useDevicePixelRatio;

  // const pixelRatio = getPixelRatio({useDevicePixelRatio});
  var width = gl.drawingBufferWidth;
  var height = gl.drawingBufferHeight;
  // clear depth and color buffers, restoring transparency
  withParameters(gl, { viewport: [0, 0, width, height] }, function () {
    gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
  });
}

// Draw a list of layers in a list of viewports
export function drawLayers(gl, _ref4) {
  var layers = _ref4.layers,
      viewports = _ref4.viewports,
      onViewportActive = _ref4.onViewportActive,
      useDevicePixelRatio = _ref4.useDevicePixelRatio,
      _ref4$drawPickingColo = _ref4.drawPickingColors,
      drawPickingColors = _ref4$drawPickingColo === undefined ? false : _ref4$drawPickingColo,
      _ref4$deviceRect = _ref4.deviceRect,
      deviceRect = _ref4$deviceRect === undefined ? null : _ref4$deviceRect,
      _ref4$parameters = _ref4.parameters,
      parameters = _ref4$parameters === undefined ? {} : _ref4$parameters,
      _ref4$pass = _ref4.pass,
      pass = _ref4$pass === undefined ? 'draw' : _ref4$pass;

  clearCanvas(gl, { useDevicePixelRatio: useDevicePixelRatio });

  // effectManager.preDraw();

  viewports.forEach(function (viewportOrDescriptor, i) {
    var viewport = getViewportFromDescriptor(viewportOrDescriptor);

    // Update context to point to this viewport
    onViewportActive(viewport);

    // render this viewport
    drawLayersInViewport(gl, {
      layers: layers,
      viewport: viewport,
      useDevicePixelRatio: useDevicePixelRatio,
      drawPickingColors: drawPickingColors,
      deviceRect: deviceRect,
      parameters: parameters,
      pass: pass
    });
  });

  // effectManager.draw();
}

// Draws list of layers and viewports into the picking buffer
// Note: does not sample the buffer, that has to be done by the caller
export function drawPickingBuffer(gl, _ref5) {
  var layers = _ref5.layers,
      viewports = _ref5.viewports,
      onViewportActive = _ref5.onViewportActive,
      useDevicePixelRatio = _ref5.useDevicePixelRatio,
      pickingFBO = _ref5.pickingFBO,
      _ref5$deviceRect = _ref5.deviceRect,
      x = _ref5$deviceRect.x,
      y = _ref5$deviceRect.y,
      width = _ref5$deviceRect.width,
      height = _ref5$deviceRect.height;

  // Make sure we clear scissor test and fbo bindings in case of exceptions
  // We are only interested in one pixel, no need to render anything else
  // Note that the callback here is called synchronously.
  // Set blend mode for picking
  // always overwrite existing pixel with [r,g,b,layerIndex]
  return withParameters(gl, {
    framebuffer: pickingFBO,
    scissorTest: true,
    scissor: [x, y, width, height],
    clearColor: [0, 0, 0, 0]
  }, function () {

    drawLayers(gl, {
      layers: layers,
      viewports: viewports,
      onViewportActive: onViewportActive,
      useDevicePixelRatio: useDevicePixelRatio,
      drawPickingColors: true,
      pass: 'picking',
      parameters: {
        blend: true,
        blendFunc: [gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO],
        blendEquation: gl.FUNC_ADD,
        blendColor: [0, 0, 0, 0]
      }
    });
  });
}

// Draws a list of layers in one viewport
// TODO - when picking we could completely skip rendering viewports that dont
// intersect with the picking rect
function drawLayersInViewport(gl, _ref6) {
  var layers = _ref6.layers,
      viewport = _ref6.viewport,
      useDevicePixelRatio = _ref6.useDevicePixelRatio,
      _ref6$drawPickingColo = _ref6.drawPickingColors,
      drawPickingColors = _ref6$drawPickingColo === undefined ? false : _ref6$drawPickingColo,
      _ref6$deviceRect = _ref6.deviceRect,
      deviceRect = _ref6$deviceRect === undefined ? null : _ref6$deviceRect,
      _ref6$parameters = _ref6.parameters,
      parameters = _ref6$parameters === undefined ? {} : _ref6$parameters,
      _ref6$pass = _ref6.pass,
      pass = _ref6$pass === undefined ? 'draw' : _ref6$pass;

  var pixelRatio = getPixelRatio({ useDevicePixelRatio: useDevicePixelRatio });
  var glViewport = getGLViewport(gl, { viewport: viewport, pixelRatio: pixelRatio });

  // render layers in normal colors
  var visibleCount = 0;
  var compositeCount = 0;
  var pickableCount = 0;

  // const {x, y, width, height} = deviceRect || [];

  // TODO: Update all layers to use 'picking_uActive' (picking shader module)
  // and then remove 'renderPickingBuffer' and 'pickingEnabled'.
  var pickingUniforms = {
    picking_uActive: drawPickingColors ? 1 : 0,
    renderPickingBuffer: drawPickingColors ? 1 : 0,
    pickingEnabled: drawPickingColors ? 1 : 0
  };

  setParameters(gl, parameters || {});

  // render layers in normal colors
  layers.forEach(function (layer, layerIndex) {
    if (layer.isComposite) {
      compositeCount++;
    }

    if (layer.props.pickable) {
      pickableCount++;
    }

    if (layer.props.visible && (layer.props.pickable || !drawPickingColors)) {

      visibleCount++;

      if (!drawPickingColors) {
        updateLayerHighlightColor(layer);
        // TODO - Disable during picking
      }

      if (layer.state.model) {
        // Update project module parameters
        layer.state.model.updateModuleSettings(Object.assign({}, layer.props, {
          viewport: layer.context.viewport
        }));
      }

      var uniforms = Object.assign(pickingUniforms, layer.context.uniforms, { layerIndex: layerIndex });

      // Blend parameters must not be overriden
      var layerParameters = Object.assign({ viewport: glViewport }, layer.props.parameters || {});

      if (drawPickingColors) {
        Object.assign(layerParameters, {
          blendColor: [0, 0, 0, (layerIndex + 1) / 255]
        });
      }

      withParameters(gl, parameters, function () {
        layer.drawLayer({
          uniforms: uniforms,
          parameters: layerParameters
        });
      });
    }
  });

  var totalCount = layers.length;
  var primitiveCount = totalCount - compositeCount;
  var hiddenCount = primitiveCount - visibleCount;

  var message = '#' + renderCount++ + ': Rendering ' + pass + ' : ' + visibleCount + ' of ' + totalCount + ' layers (' + hiddenCount + ' hidden, ' + compositeCount + ' composite ' + pickableCount + ' unpickable) DPR={pixelRatio} pick={$drawPickingColors}';

  log.log(2, message);
}

// Get a viewport from a viewport descriptor (which can be a plain viewport)
function getViewportFromDescriptor(viewportOrDescriptor) {
  return viewportOrDescriptor.viewport ? viewportOrDescriptor.viewport : viewportOrDescriptor;
}

/**
 * Returns the picking color of currenlty selected object of the given 'layer'.
 * @return {Array} - the picking color or null if layers selected object is invalid.
 */
function updateLayerHighlightColor(layer) {
  // TODO - inefficient to update settings every render?
  // TODO: Add warning if 'highlightedObjectIndex' is > numberOfInstances of the model.

  // Update picking module settings if highlightedObjectIndex is set.
  // This will overwrite any settings from auto highlighting.
  var pickingSelectedColorValid = layer.props.highlightedObjectIndex >= 0;
  if (layer.state.model && pickingSelectedColorValid) {
    var pickingSelectedColor = layer.encodePickingColor(layer.props.highlightedObjectIndex);

    // TODO - handle multimodel layers?
    layer.state.model.updateModuleSettings({
      pickingSelectedColor: pickingSelectedColor,
      pickingSelectedColorValid: pickingSelectedColorValid
    });
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9kcmF3LWxheWVycy5qcyJdLCJuYW1lcyI6WyJHTCIsIndpdGhQYXJhbWV0ZXJzIiwic2V0UGFyYW1ldGVycyIsImxvZyIsInJlbmRlckNvdW50IiwiZ2V0UGl4ZWxSYXRpbyIsInVzZURldmljZVBpeGVsUmF0aW8iLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwiZ2V0R0xWaWV3cG9ydCIsImdsIiwidmlld3BvcnQiLCJwaXhlbFJhdGlvIiwid2lkdGgiLCJjYW52YXMiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsImRpbWVuc2lvbnMiLCJnZXREaW1lbnNpb25zIiwieCIsInkiLCJjbGVhckNhbnZhcyIsImRyYXdpbmdCdWZmZXJXaWR0aCIsImRyYXdpbmdCdWZmZXJIZWlnaHQiLCJjbGVhciIsIkNPTE9SX0JVRkZFUl9CSVQiLCJERVBUSF9CVUZGRVJfQklUIiwiZHJhd0xheWVycyIsImxheWVycyIsInZpZXdwb3J0cyIsIm9uVmlld3BvcnRBY3RpdmUiLCJkcmF3UGlja2luZ0NvbG9ycyIsImRldmljZVJlY3QiLCJwYXJhbWV0ZXJzIiwicGFzcyIsImZvckVhY2giLCJ2aWV3cG9ydE9yRGVzY3JpcHRvciIsImkiLCJnZXRWaWV3cG9ydEZyb21EZXNjcmlwdG9yIiwiZHJhd0xheWVyc0luVmlld3BvcnQiLCJkcmF3UGlja2luZ0J1ZmZlciIsInBpY2tpbmdGQk8iLCJmcmFtZWJ1ZmZlciIsInNjaXNzb3JUZXN0Iiwic2Npc3NvciIsImNsZWFyQ29sb3IiLCJibGVuZCIsImJsZW5kRnVuYyIsIk9ORSIsIlpFUk8iLCJDT05TVEFOVF9BTFBIQSIsImJsZW5kRXF1YXRpb24iLCJGVU5DX0FERCIsImJsZW5kQ29sb3IiLCJnbFZpZXdwb3J0IiwidmlzaWJsZUNvdW50IiwiY29tcG9zaXRlQ291bnQiLCJwaWNrYWJsZUNvdW50IiwicGlja2luZ1VuaWZvcm1zIiwicGlja2luZ191QWN0aXZlIiwicmVuZGVyUGlja2luZ0J1ZmZlciIsInBpY2tpbmdFbmFibGVkIiwibGF5ZXIiLCJsYXllckluZGV4IiwiaXNDb21wb3NpdGUiLCJwcm9wcyIsInBpY2thYmxlIiwidmlzaWJsZSIsInVwZGF0ZUxheWVySGlnaGxpZ2h0Q29sb3IiLCJzdGF0ZSIsIm1vZGVsIiwidXBkYXRlTW9kdWxlU2V0dGluZ3MiLCJPYmplY3QiLCJhc3NpZ24iLCJjb250ZXh0IiwidW5pZm9ybXMiLCJsYXllclBhcmFtZXRlcnMiLCJkcmF3TGF5ZXIiLCJ0b3RhbENvdW50IiwibGVuZ3RoIiwicHJpbWl0aXZlQ291bnQiLCJoaWRkZW5Db3VudCIsIm1lc3NhZ2UiLCJwaWNraW5nU2VsZWN0ZWRDb2xvclZhbGlkIiwiaGlnaGxpZ2h0ZWRPYmplY3RJbmRleCIsInBpY2tpbmdTZWxlY3RlZENvbG9yIiwiZW5jb2RlUGlja2luZ0NvbG9yIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVFBLEVBQVIsRUFBWUMsY0FBWixFQUE0QkMsYUFBNUIsUUFBZ0QsU0FBaEQ7QUFDQSxTQUFRQyxHQUFSLFFBQWtCLFNBQWxCOztBQUVBLElBQUlDLGNBQWMsQ0FBbEI7O0FBRUE7QUFDQSxPQUFPLElBQU1DLGdCQUFnQixTQUFoQkEsYUFBZ0I7QUFBQSxNQUFFQyxtQkFBRixRQUFFQSxtQkFBRjtBQUFBLFNBQzNCQSx1QkFBdUIsT0FBT0MsTUFBUCxLQUFrQixXQUF6QyxHQUF1REEsT0FBT0MsZ0JBQTlELEdBQWlGLENBRHREO0FBQUEsQ0FBdEI7O0FBR1A7QUFDQSxJQUFNQyxnQkFBZ0IsU0FBaEJBLGFBQWdCLENBQUNDLEVBQUQsU0FBZ0M7QUFBQSxNQUExQkMsUUFBMEIsU0FBMUJBLFFBQTBCO0FBQUEsTUFBaEJDLFVBQWdCLFNBQWhCQSxVQUFnQjs7QUFDcEQsTUFB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LEVBQW9EO0FBQ2xELFFBQU1FLHVCQUF1QnZCLE1BQU13QixrQkFBTixDQUF5QnhCLE1BQU1HLEtBQU4sQ0FBWW1CLHNCQUFyQyxDQUE3Qjs7QUFFQTtBQUNBdEIsVUFBTU8sS0FBTixDQUFZQyxLQUFaLENBQWtCQyxvQkFBbEIsQ0FBdUM7QUFDckNjLGdEQURxQztBQUVyQ0Y7QUFGcUMsS0FBdkM7QUFJRDtBQUNGIiwiZmlsZSI6ImRyYXctbGF5ZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCB7R0wsIHdpdGhQYXJhbWV0ZXJzLCBzZXRQYXJhbWV0ZXJzfSBmcm9tICdsdW1hLmdsJztcbmltcG9ydCB7bG9nfSBmcm9tICcuL3V0aWxzJztcblxubGV0IHJlbmRlckNvdW50ID0gMDtcblxuLy8gVE9ETyAtIEV4cG9ydGVkIGZvciBwaWNrLWxheWVycy5qcyAtIE1vdmUgdG8gdXRpbD9cbmV4cG9ydCBjb25zdCBnZXRQaXhlbFJhdGlvID0gKHt1c2VEZXZpY2VQaXhlbFJhdGlvfSkgPT5cbiAgdXNlRGV2aWNlUGl4ZWxSYXRpbyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDogMTtcblxuLy8gQ29udmVydCB2aWV3cG9ydCB0b3AtbGVmdCBDU1MgY29vcmRpbmF0ZXMgdG8gYm90dG9tIHVwIFdlYkdMIGNvb3JkaW5hdGVzXG5jb25zdCBnZXRHTFZpZXdwb3J0ID0gKGdsLCB7dmlld3BvcnQsIHBpeGVsUmF0aW99KSA9PiB7XG4gIGNvbnN0IHdpZHRoID0gZ2wuY2FudmFzLmNsaWVudFdpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBnbC5jYW52YXMuY2xpZW50SGVpZ2h0O1xuICAvLyBDb252ZXJ0IHZpZXdwb3J0IHRvcC1sZWZ0IENTUyBjb29yZGluYXRlcyB0byBib3R0b20gdXAgV2ViR0wgY29vcmRpbmF0ZXNcbiAgY29uc3QgZGltZW5zaW9ucyA9IHZpZXdwb3J0LmdldERpbWVuc2lvbnMoe3dpZHRoLCBoZWlnaHR9KTtcbiAgcmV0dXJuIFtcbiAgICBkaW1lbnNpb25zLnggKiBwaXhlbFJhdGlvLFxuICAgIChoZWlnaHQgLSBkaW1lbnNpb25zLnkgLSBkaW1lbnNpb25zLmhlaWdodCkgKiBwaXhlbFJhdGlvLFxuICAgIGRpbWVuc2lvbnMud2lkdGggKiBwaXhlbFJhdGlvLFxuICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICogcGl4ZWxSYXRpb1xuICBdO1xufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uc1xuXG5mdW5jdGlvbiBjbGVhckNhbnZhcyhnbCwge3VzZURldmljZVBpeGVsUmF0aW99KSB7XG4gIC8vIGNvbnN0IHBpeGVsUmF0aW8gPSBnZXRQaXhlbFJhdGlvKHt1c2VEZXZpY2VQaXhlbFJhdGlvfSk7XG4gIGNvbnN0IHdpZHRoID0gZ2wuZHJhd2luZ0J1ZmZlcldpZHRoO1xuICBjb25zdCBoZWlnaHQgPSBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xuICAvLyBjbGVhciBkZXB0aCBhbmQgY29sb3IgYnVmZmVycywgcmVzdG9yaW5nIHRyYW5zcGFyZW5jeVxuICB3aXRoUGFyYW1ldGVycyhnbCwge3ZpZXdwb3J0OiBbMCwgMCwgd2lkdGgsIGhlaWdodF19LCAoKSA9PiB7XG4gICAgZ2wuY2xlYXIoR0wuQ09MT1JfQlVGRkVSX0JJVCB8IEdMLkRFUFRIX0JVRkZFUl9CSVQpO1xuICB9KTtcbn1cblxuLy8gRHJhdyBhIGxpc3Qgb2YgbGF5ZXJzIGluIGEgbGlzdCBvZiB2aWV3cG9ydHNcbmV4cG9ydCBmdW5jdGlvbiBkcmF3TGF5ZXJzKGdsLCB7XG4gIGxheWVycyxcbiAgdmlld3BvcnRzLFxuICBvblZpZXdwb3J0QWN0aXZlLFxuICB1c2VEZXZpY2VQaXhlbFJhdGlvLFxuICBkcmF3UGlja2luZ0NvbG9ycyA9IGZhbHNlLFxuICBkZXZpY2VSZWN0ID0gbnVsbCxcbiAgcGFyYW1ldGVycyA9IHt9LFxuICBwYXNzID0gJ2RyYXcnXG59KSB7XG4gIGNsZWFyQ2FudmFzKGdsLCB7dXNlRGV2aWNlUGl4ZWxSYXRpb30pO1xuXG4gIC8vIGVmZmVjdE1hbmFnZXIucHJlRHJhdygpO1xuXG4gIHZpZXdwb3J0cy5mb3JFYWNoKCh2aWV3cG9ydE9yRGVzY3JpcHRvciwgaSkgPT4ge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRGcm9tRGVzY3JpcHRvcih2aWV3cG9ydE9yRGVzY3JpcHRvcik7XG5cbiAgICAvLyBVcGRhdGUgY29udGV4dCB0byBwb2ludCB0byB0aGlzIHZpZXdwb3J0XG4gICAgb25WaWV3cG9ydEFjdGl2ZSh2aWV3cG9ydCk7XG5cbiAgICAvLyByZW5kZXIgdGhpcyB2aWV3cG9ydFxuICAgIGRyYXdMYXllcnNJblZpZXdwb3J0KGdsLCB7XG4gICAgICBsYXllcnMsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHVzZURldmljZVBpeGVsUmF0aW8sXG4gICAgICBkcmF3UGlja2luZ0NvbG9ycyxcbiAgICAgIGRldmljZVJlY3QsXG4gICAgICBwYXJhbWV0ZXJzLFxuICAgICAgcGFzc1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBlZmZlY3RNYW5hZ2VyLmRyYXcoKTtcbn1cblxuLy8gRHJhd3MgbGlzdCBvZiBsYXllcnMgYW5kIHZpZXdwb3J0cyBpbnRvIHRoZSBwaWNraW5nIGJ1ZmZlclxuLy8gTm90ZTogZG9lcyBub3Qgc2FtcGxlIHRoZSBidWZmZXIsIHRoYXQgaGFzIHRvIGJlIGRvbmUgYnkgdGhlIGNhbGxlclxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdQaWNraW5nQnVmZmVyKGdsLCB7XG4gIGxheWVycyxcbiAgdmlld3BvcnRzLFxuICBvblZpZXdwb3J0QWN0aXZlLFxuICB1c2VEZXZpY2VQaXhlbFJhdGlvLFxuICBwaWNraW5nRkJPLFxuICBkZXZpY2VSZWN0OiB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbn0pIHtcbiAgLy8gTWFrZSBzdXJlIHdlIGNsZWFyIHNjaXNzb3IgdGVzdCBhbmQgZmJvIGJpbmRpbmdzIGluIGNhc2Ugb2YgZXhjZXB0aW9uc1xuICAvLyBXZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIG9uZSBwaXhlbCwgbm8gbmVlZCB0byByZW5kZXIgYW55dGhpbmcgZWxzZVxuICAvLyBOb3RlIHRoYXQgdGhlIGNhbGxiYWNrIGhlcmUgaXMgY2FsbGVkIHN5bmNocm9ub3VzbHkuXG4gIC8vIFNldCBibGVuZCBtb2RlIGZvciBwaWNraW5nXG4gIC8vIGFsd2F5cyBvdmVyd3JpdGUgZXhpc3RpbmcgcGl4ZWwgd2l0aCBbcixnLGIsbGF5ZXJJbmRleF1cbiAgcmV0dXJuIHdpdGhQYXJhbWV0ZXJzKGdsLCB7XG4gICAgZnJhbWVidWZmZXI6IHBpY2tpbmdGQk8sXG4gICAgc2Npc3NvclRlc3Q6IHRydWUsXG4gICAgc2Npc3NvcjogW3gsIHksIHdpZHRoLCBoZWlnaHRdLFxuICAgIGNsZWFyQ29sb3I6IFswLCAwLCAwLCAwXVxuICB9LCAoKSA9PiB7XG5cbiAgICBkcmF3TGF5ZXJzKGdsLCB7XG4gICAgICBsYXllcnMsXG4gICAgICB2aWV3cG9ydHMsXG4gICAgICBvblZpZXdwb3J0QWN0aXZlLFxuICAgICAgdXNlRGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgIGRyYXdQaWNraW5nQ29sb3JzOiB0cnVlLFxuICAgICAgcGFzczogJ3BpY2tpbmcnLFxuICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICBibGVuZDogdHJ1ZSxcbiAgICAgICAgYmxlbmRGdW5jOiBbZ2wuT05FLCBnbC5aRVJPLCBnbC5DT05TVEFOVF9BTFBIQSwgZ2wuWkVST10sXG4gICAgICAgIGJsZW5kRXF1YXRpb246IGdsLkZVTkNfQURELFxuICAgICAgICBibGVuZENvbG9yOiBbMCwgMCwgMCwgMF1cbiAgICAgIH1cbiAgICB9KTtcblxuICB9KTtcbn1cblxuLy8gRHJhd3MgYSBsaXN0IG9mIGxheWVycyBpbiBvbmUgdmlld3BvcnRcbi8vIFRPRE8gLSB3aGVuIHBpY2tpbmcgd2UgY291bGQgY29tcGxldGVseSBza2lwIHJlbmRlcmluZyB2aWV3cG9ydHMgdGhhdCBkb250XG4vLyBpbnRlcnNlY3Qgd2l0aCB0aGUgcGlja2luZyByZWN0XG5mdW5jdGlvbiBkcmF3TGF5ZXJzSW5WaWV3cG9ydChnbCwge1xuICBsYXllcnMsXG4gIHZpZXdwb3J0LFxuICB1c2VEZXZpY2VQaXhlbFJhdGlvLFxuICBkcmF3UGlja2luZ0NvbG9ycyA9IGZhbHNlLFxuICBkZXZpY2VSZWN0ID0gbnVsbCxcbiAgcGFyYW1ldGVycyA9IHt9LFxuICBwYXNzID0gJ2RyYXcnXG59KSB7XG4gIGNvbnN0IHBpeGVsUmF0aW8gPSBnZXRQaXhlbFJhdGlvKHt1c2VEZXZpY2VQaXhlbFJhdGlvfSk7XG4gIGNvbnN0IGdsVmlld3BvcnQgPSBnZXRHTFZpZXdwb3J0KGdsLCB7dmlld3BvcnQsIHBpeGVsUmF0aW99KTtcblxuICAvLyByZW5kZXIgbGF5ZXJzIGluIG5vcm1hbCBjb2xvcnNcbiAgbGV0IHZpc2libGVDb3VudCA9IDA7XG4gIGxldCBjb21wb3NpdGVDb3VudCA9IDA7XG4gIGxldCBwaWNrYWJsZUNvdW50ID0gMDtcblxuICAvLyBjb25zdCB7eCwgeSwgd2lkdGgsIGhlaWdodH0gPSBkZXZpY2VSZWN0IHx8IFtdO1xuXG4gIC8vIFRPRE86IFVwZGF0ZSBhbGwgbGF5ZXJzIHRvIHVzZSAncGlja2luZ191QWN0aXZlJyAocGlja2luZyBzaGFkZXIgbW9kdWxlKVxuICAvLyBhbmQgdGhlbiByZW1vdmUgJ3JlbmRlclBpY2tpbmdCdWZmZXInIGFuZCAncGlja2luZ0VuYWJsZWQnLlxuICBjb25zdCBwaWNraW5nVW5pZm9ybXMgPSB7XG4gICAgcGlja2luZ191QWN0aXZlOiBkcmF3UGlja2luZ0NvbG9ycyA/IDEgOiAwLFxuICAgIHJlbmRlclBpY2tpbmdCdWZmZXI6IGRyYXdQaWNraW5nQ29sb3JzID8gMSA6IDAsXG4gICAgcGlja2luZ0VuYWJsZWQ6IGRyYXdQaWNraW5nQ29sb3JzID8gMSA6IDBcbiAgfTtcblxuICBzZXRQYXJhbWV0ZXJzKGdsLCBwYXJhbWV0ZXJzIHx8IHt9KTtcblxuICAvLyByZW5kZXIgbGF5ZXJzIGluIG5vcm1hbCBjb2xvcnNcbiAgbGF5ZXJzLmZvckVhY2goKGxheWVyLCBsYXllckluZGV4KSA9PiB7XG4gICAgaWYgKGxheWVyLmlzQ29tcG9zaXRlKSB7XG4gICAgICBjb21wb3NpdGVDb3VudCsrO1xuICAgIH1cblxuICAgIGlmIChsYXllci5wcm9wcy5waWNrYWJsZSkge1xuICAgICAgcGlja2FibGVDb3VudCsrO1xuICAgIH1cblxuICAgIGlmIChsYXllci5wcm9wcy52aXNpYmxlICYmIChsYXllci5wcm9wcy5waWNrYWJsZSB8fCAhZHJhd1BpY2tpbmdDb2xvcnMpKSB7XG5cbiAgICAgIHZpc2libGVDb3VudCsrO1xuXG4gICAgICBpZiAoIWRyYXdQaWNraW5nQ29sb3JzKSB7XG4gICAgICAgIHVwZGF0ZUxheWVySGlnaGxpZ2h0Q29sb3IobGF5ZXIpO1xuICAgICAgICAvLyBUT0RPIC0gRGlzYWJsZSBkdXJpbmcgcGlja2luZ1xuICAgICAgfVxuXG4gICAgICBpZiAobGF5ZXIuc3RhdGUubW9kZWwpIHtcbiAgICAgICAgLy8gVXBkYXRlIHByb2plY3QgbW9kdWxlIHBhcmFtZXRlcnNcbiAgICAgICAgbGF5ZXIuc3RhdGUubW9kZWwudXBkYXRlTW9kdWxlU2V0dGluZ3MoXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgbGF5ZXIucHJvcHMsIHtcbiAgICAgICAgICAgIHZpZXdwb3J0OiBsYXllci5jb250ZXh0LnZpZXdwb3J0XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdW5pZm9ybXMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICBwaWNraW5nVW5pZm9ybXMsXG4gICAgICAgIGxheWVyLmNvbnRleHQudW5pZm9ybXMsXG4gICAgICAgIHtsYXllckluZGV4fVxuICAgICAgKTtcblxuICAgICAgLy8gQmxlbmQgcGFyYW1ldGVycyBtdXN0IG5vdCBiZSBvdmVycmlkZW5cbiAgICAgIGNvbnN0IGxheWVyUGFyYW1ldGVycyA9IE9iamVjdC5hc3NpZ24oe3ZpZXdwb3J0OiBnbFZpZXdwb3J0fSwgbGF5ZXIucHJvcHMucGFyYW1ldGVycyB8fCB7fSk7XG5cbiAgICAgIGlmIChkcmF3UGlja2luZ0NvbG9ycykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGxheWVyUGFyYW1ldGVycywge1xuICAgICAgICAgIGJsZW5kQ29sb3I6IFswLCAwLCAwLCAobGF5ZXJJbmRleCArIDEpIC8gMjU1XVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgd2l0aFBhcmFtZXRlcnMoZ2wsIHBhcmFtZXRlcnMsICgpID0+IHtcbiAgICAgICAgbGF5ZXIuZHJhd0xheWVyKHtcbiAgICAgICAgICB1bmlmb3JtcyxcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBsYXllclBhcmFtZXRlcnNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IHRvdGFsQ291bnQgPSBsYXllcnMubGVuZ3RoO1xuICBjb25zdCBwcmltaXRpdmVDb3VudCA9IHRvdGFsQ291bnQgLSBjb21wb3NpdGVDb3VudDtcbiAgY29uc3QgaGlkZGVuQ291bnQgPSBwcmltaXRpdmVDb3VudCAtIHZpc2libGVDb3VudDtcblxuICBjb25zdCBtZXNzYWdlID0gYFxcXG4jJHtyZW5kZXJDb3VudCsrfTogUmVuZGVyaW5nICR7cGFzc30gOiAke3Zpc2libGVDb3VudH0gb2YgJHt0b3RhbENvdW50fSBsYXllcnMgXFxcbigke2hpZGRlbkNvdW50fSBoaWRkZW4sICR7Y29tcG9zaXRlQ291bnR9IGNvbXBvc2l0ZSAke3BpY2thYmxlQ291bnR9IHVucGlja2FibGUpIFxcXG5EUFI9e3BpeGVsUmF0aW99IHBpY2s9eyRkcmF3UGlja2luZ0NvbG9yc31gO1xuXG4gIGxvZy5sb2coMiwgbWVzc2FnZSk7XG59XG5cbi8vIEdldCBhIHZpZXdwb3J0IGZyb20gYSB2aWV3cG9ydCBkZXNjcmlwdG9yICh3aGljaCBjYW4gYmUgYSBwbGFpbiB2aWV3cG9ydClcbmZ1bmN0aW9uIGdldFZpZXdwb3J0RnJvbURlc2NyaXB0b3Iodmlld3BvcnRPckRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIHZpZXdwb3J0T3JEZXNjcmlwdG9yLnZpZXdwb3J0ID8gdmlld3BvcnRPckRlc2NyaXB0b3Iudmlld3BvcnQgOiB2aWV3cG9ydE9yRGVzY3JpcHRvcjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwaWNraW5nIGNvbG9yIG9mIGN1cnJlbmx0eSBzZWxlY3RlZCBvYmplY3Qgb2YgdGhlIGdpdmVuICdsYXllcicuXG4gKiBAcmV0dXJuIHtBcnJheX0gLSB0aGUgcGlja2luZyBjb2xvciBvciBudWxsIGlmIGxheWVycyBzZWxlY3RlZCBvYmplY3QgaXMgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlTGF5ZXJIaWdobGlnaHRDb2xvcihsYXllcikge1xuICAvLyBUT0RPIC0gaW5lZmZpY2llbnQgdG8gdXBkYXRlIHNldHRpbmdzIGV2ZXJ5IHJlbmRlcj9cbiAgLy8gVE9ETzogQWRkIHdhcm5pbmcgaWYgJ2hpZ2hsaWdodGVkT2JqZWN0SW5kZXgnIGlzID4gbnVtYmVyT2ZJbnN0YW5jZXMgb2YgdGhlIG1vZGVsLlxuXG4gIC8vIFVwZGF0ZSBwaWNraW5nIG1vZHVsZSBzZXR0aW5ncyBpZiBoaWdobGlnaHRlZE9iamVjdEluZGV4IGlzIHNldC5cbiAgLy8gVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgc2V0dGluZ3MgZnJvbSBhdXRvIGhpZ2hsaWdodGluZy5cbiAgY29uc3QgcGlja2luZ1NlbGVjdGVkQ29sb3JWYWxpZCA9IGxheWVyLnByb3BzLmhpZ2hsaWdodGVkT2JqZWN0SW5kZXggPj0gMDtcbiAgaWYgKGxheWVyLnN0YXRlLm1vZGVsICYmIHBpY2tpbmdTZWxlY3RlZENvbG9yVmFsaWQpIHtcbiAgICBjb25zdCBwaWNraW5nU2VsZWN0ZWRDb2xvciA9IGxheWVyLmVuY29kZVBpY2tpbmdDb2xvcihsYXllci5wcm9wcy5oaWdobGlnaHRlZE9iamVjdEluZGV4KTtcblxuICAgIC8vIFRPRE8gLSBoYW5kbGUgbXVsdGltb2RlbCBsYXllcnM/XG4gICAgbGF5ZXIuc3RhdGUubW9kZWwudXBkYXRlTW9kdWxlU2V0dGluZ3Moe1xuICAgICAgcGlja2luZ1NlbGVjdGVkQ29sb3IsXG4gICAgICBwaWNraW5nU2VsZWN0ZWRDb2xvclZhbGlkXG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==