import log from '../../utils/log';

var DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 64, 128, 64]);

var DEFAULT_MODULE_OPTIONS = {
  pickingSelectedColor: null, //  Set to a picking color to visually highlight that item
  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR, // Color of visual highlight of "selected" item
  pickingThreshold: 1.0,
  pickingActive: false, // Set to true when rendering to off-screen "picking" buffer
  pickingSelectedColorValid: false
};

/* eslint-disable camelcase */
function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;

  var uniforms = {};
  if (opts.pickingSelectedColorValid !== undefined) {
    uniforms.picking_uSelectedPickingColorValid = opts.pickingSelectedColorValid ? 1 : 0;
  }
  if (opts.pickingValid !== undefined) {
    uniforms.picking_uSelectedPickingColorValid = opts.pickingValid ? 1 : 0;
    log.deprecated('pickingValid', 'pickingSelectedColorValid');
  }
  if (opts.pickingSelectedColor !== undefined) {
    if (opts.pickingSelectedColor) {
      var selectedColor = [opts.pickingSelectedColor[0], opts.pickingSelectedColor[1], opts.pickingSelectedColor[2]];
      // console.log('selected picking color', selectedColor);
      uniforms.picking_uSelectedPickingColor = selectedColor;
    }
  }
  if (opts.pickingHighlightColor !== undefined) {
    uniforms.picking_uHighlightColor = opts.pickingHighlightColor;
  }
  // TODO - major hack - decide on normalization and remove
  if (opts.pickingThreshold !== undefined) {
    uniforms.picking_uThreshold = opts.pickingThreshold;
  }
  if (opts.pickingActive !== undefined) {
    uniforms.picking_uActive = opts.pickingActive ? 1 : 0;
  }
  return uniforms;
}

var vs = 'uniform vec3 picking_uSelectedPickingColor;\nuniform float picking_uThreshold;\nuniform bool picking_uSelectedPickingColorValid;\n\nvarying vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedPickingColorValid &&\n    abs(vertexColor.r - picking_uSelectedPickingColor.r) < picking_uThreshold &&\n    abs(vertexColor.g - picking_uSelectedPickingColor.g) < picking_uThreshold &&\n    abs(vertexColor.b - picking_uSelectedPickingColor.b) < picking_uThreshold;\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n  picking_vRGBcolor_Aselected.a =\n    float(isVertexPicked(pickingColor));\n\n  // Stores the picking color so that the fragment shader can render it during picking\n  picking_vRGBcolor_Aselected.rgb = pickingColor * COLOR_SCALE;\n}\n';

var fs = 'uniform bool picking_uActive; // true during rendering to offscreen picking buffer\nuniform vec3 picking_uSelectedPickingColor;\nuniform vec4 picking_uHighlightColor;\n\nvarying vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  bool selected = bool(picking_vRGBcolor_Aselected.a);\n  return selected ? (picking_uHighlightColor * COLOR_SCALE) : color;\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  vec3 pickingColor = picking_vRGBcolor_Aselected.rgb;\n  return picking_uActive ? vec4(pickingColor, 1.0) : color;\n}\n';

export default {
  name: 'picking',
  vs: vs,
  fs: fs,
  getUniforms: getUniforms
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb3JlL3NoYWRlcmxpYi9waWNraW5nL3BpY2tpbmcuanMiXSwibmFtZXMiOlsibG9nIiwiREVGQVVMVF9ISUdITElHSFRfQ09MT1IiLCJVaW50OEFycmF5IiwiREVGQVVMVF9NT0RVTEVfT1BUSU9OUyIsInBpY2tpbmdTZWxlY3RlZENvbG9yIiwicGlja2luZ0hpZ2hsaWdodENvbG9yIiwicGlja2luZ1RocmVzaG9sZCIsInBpY2tpbmdBY3RpdmUiLCJwaWNraW5nU2VsZWN0ZWRDb2xvclZhbGlkIiwiZ2V0VW5pZm9ybXMiLCJvcHRzIiwidW5pZm9ybXMiLCJ1bmRlZmluZWQiLCJwaWNraW5nX3VTZWxlY3RlZFBpY2tpbmdDb2xvclZhbGlkIiwicGlja2luZ1ZhbGlkIiwiZGVwcmVjYXRlZCIsInNlbGVjdGVkQ29sb3IiLCJwaWNraW5nX3VTZWxlY3RlZFBpY2tpbmdDb2xvciIsInBpY2tpbmdfdUhpZ2hsaWdodENvbG9yIiwicGlja2luZ191VGhyZXNob2xkIiwicGlja2luZ191QWN0aXZlIiwidnMiLCJmcyIsIm5hbWUiXSwibWFwcGluZ3MiOiJBQUFBLE9BQU9BLEdBQVAsTUFBZ0IsaUJBQWhCOztBQUVBLElBQU1DLDBCQUEwQixJQUFJQyxVQUFKLENBQWUsQ0FBQyxDQUFELEVBQUksRUFBSixFQUFRLEdBQVIsRUFBYSxFQUFiLENBQWYsQ0FBaEM7O0FBRUEsSUFBTUMseUJBQXlCO0FBQzdCQyx3QkFBc0IsSUFETyxFQUNEO0FBQzVCQyx5QkFBdUJKLHVCQUZNLEVBRW1CO0FBQ2hESyxvQkFBa0IsR0FIVztBQUk3QkMsaUJBQWUsS0FKYyxFQUlQO0FBQ3RCQyw2QkFBMkI7QUFMRSxDQUEvQjs7QUFRQTtBQUNBLFNBQVNDLFdBQVQsR0FBb0Q7QUFBQSxNQUEvQkMsSUFBK0IsdUVBQXhCUCxzQkFBd0I7O0FBQ2xELE1BQU1RLFdBQVcsRUFBakI7QUFDQSxNQUFJRCxLQUFLRix5QkFBTCxLQUFtQ0ksU0FBdkMsRUFBa0Q7QUFDaERELGFBQVNFLGtDQUFULEdBQThDSCxLQUFLRix5QkFBTCxHQUFpQyxDQUFqQyxHQUFxQyxDQUFuRjtBQUNEO0FBQ0QsTUFBSUUsS0FBS0ksWUFBTCxLQUFzQkYsU0FBMUIsRUFBcUM7QUFDbkNELGFBQVNFLGtDQUFULEdBQThDSCxLQUFLSSxZQUFMLEdBQW9CLENBQXBCLEdBQXdCLENBQXRFO0FBQ0FkLFFBQUllLFVBQUosQ0FBZSxjQUFmLEVBQStCLDJCQUEvQjtBQUNEO0FBQ0QsTUFBSUwsS0FBS04sb0JBQUwsS0FBOEJRLFNBQWxDLEVBQTZDO0FBQzNDLFFBQUlGLEtBQUtOLG9CQUFULEVBQStCO0FBQzdCLFVBQU1ZLGdCQUFnQixDQUNwQk4sS0FBS04sb0JBQUwsQ0FBMEIsQ0FBMUIsQ0FEb0IsRUFFcEJNLEtBQUtOLG9CQUFMLENBQTBCLENBQTFCLENBRm9CLEVBR3BCTSxLQUFLTixvQkFBTCxDQUEwQixDQUExQixDQUhvQixDQUF0QjtBQUtBO0FBQ0FPLGVBQVNNLDZCQUFULEdBQXlDRCxhQUF6QztBQUNEO0FBQ0Y7QUFDRCxNQUFJTixLQUFLTCxxQkFBTCxLQUErQk8sU0FBbkMsRUFBOEM7QUFDNUNELGFBQVNPLHVCQUFULEdBQW1DUixLQUFLTCxxQkFBeEM7QUFDRDtBQUNEO0FBQ0EsTUFBSUssS0FBS0osZ0JBQUwsS0FBMEJNLFNBQTlCLEVBQXlDO0FBQ3ZDRCxhQUFTUSxrQkFBVCxHQUE4QlQsS0FBS0osZ0JBQW5DO0FBQ0Q7QUFDRCxNQUFJSSxLQUFLSCxhQUFMLEtBQXVCSyxTQUEzQixFQUFzQztBQUNwQ0QsYUFBU1MsZUFBVCxHQUEyQlYsS0FBS0gsYUFBTCxHQUFxQixDQUFyQixHQUF5QixDQUFwRDtBQUNEO0FBQ0QsU0FBT0ksUUFBUDtBQUNEOztBQUVELElBQU1VLHc3QkFBTjs7QUEyQkEsSUFBTUMsZ3ZCQUFOOztBQTBCQSxlQUFlO0FBQ2JDLFFBQU0sU0FETztBQUViRixRQUZhO0FBR2JDLFFBSGE7QUFJYmI7QUFKYSxDQUFmIiwiZmlsZSI6InBpY2tpbmcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbG9nIGZyb20gJy4uLy4uL3V0aWxzL2xvZyc7XG5cbmNvbnN0IERFRkFVTFRfSElHSExJR0hUX0NPTE9SID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDY0LCAxMjgsIDY0XSk7XG5cbmNvbnN0IERFRkFVTFRfTU9EVUxFX09QVElPTlMgPSB7XG4gIHBpY2tpbmdTZWxlY3RlZENvbG9yOiBudWxsLCAvLyAgU2V0IHRvIGEgcGlja2luZyBjb2xvciB0byB2aXN1YWxseSBoaWdobGlnaHQgdGhhdCBpdGVtXG4gIHBpY2tpbmdIaWdobGlnaHRDb2xvcjogREVGQVVMVF9ISUdITElHSFRfQ09MT1IsIC8vIENvbG9yIG9mIHZpc3VhbCBoaWdobGlnaHQgb2YgXCJzZWxlY3RlZFwiIGl0ZW1cbiAgcGlja2luZ1RocmVzaG9sZDogMS4wLFxuICBwaWNraW5nQWN0aXZlOiBmYWxzZSwgLy8gU2V0IHRvIHRydWUgd2hlbiByZW5kZXJpbmcgdG8gb2ZmLXNjcmVlbiBcInBpY2tpbmdcIiBidWZmZXJcbiAgcGlja2luZ1NlbGVjdGVkQ29sb3JWYWxpZDogZmFsc2Vcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuZnVuY3Rpb24gZ2V0VW5pZm9ybXMob3B0cyA9IERFRkFVTFRfTU9EVUxFX09QVElPTlMpIHtcbiAgY29uc3QgdW5pZm9ybXMgPSB7fTtcbiAgaWYgKG9wdHMucGlja2luZ1NlbGVjdGVkQ29sb3JWYWxpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdW5pZm9ybXMucGlja2luZ191U2VsZWN0ZWRQaWNraW5nQ29sb3JWYWxpZCA9IG9wdHMucGlja2luZ1NlbGVjdGVkQ29sb3JWYWxpZCA/IDEgOiAwO1xuICB9XG4gIGlmIChvcHRzLnBpY2tpbmdWYWxpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdW5pZm9ybXMucGlja2luZ191U2VsZWN0ZWRQaWNraW5nQ29sb3JWYWxpZCA9IG9wdHMucGlja2luZ1ZhbGlkID8gMSA6IDA7XG4gICAgbG9nLmRlcHJlY2F0ZWQoJ3BpY2tpbmdWYWxpZCcsICdwaWNraW5nU2VsZWN0ZWRDb2xvclZhbGlkJyk7XG4gIH1cbiAgaWYgKG9wdHMucGlja2luZ1NlbGVjdGVkQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRzLnBpY2tpbmdTZWxlY3RlZENvbG9yKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZENvbG9yID0gW1xuICAgICAgICBvcHRzLnBpY2tpbmdTZWxlY3RlZENvbG9yWzBdLFxuICAgICAgICBvcHRzLnBpY2tpbmdTZWxlY3RlZENvbG9yWzFdLFxuICAgICAgICBvcHRzLnBpY2tpbmdTZWxlY3RlZENvbG9yWzJdXG4gICAgICBdO1xuICAgICAgLy8gY29uc29sZS5sb2coJ3NlbGVjdGVkIHBpY2tpbmcgY29sb3InLCBzZWxlY3RlZENvbG9yKTtcbiAgICAgIHVuaWZvcm1zLnBpY2tpbmdfdVNlbGVjdGVkUGlja2luZ0NvbG9yID0gc2VsZWN0ZWRDb2xvcjtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdHMucGlja2luZ0hpZ2hsaWdodENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICB1bmlmb3Jtcy5waWNraW5nX3VIaWdobGlnaHRDb2xvciA9IG9wdHMucGlja2luZ0hpZ2hsaWdodENvbG9yO1xuICB9XG4gIC8vIFRPRE8gLSBtYWpvciBoYWNrIC0gZGVjaWRlIG9uIG5vcm1hbGl6YXRpb24gYW5kIHJlbW92ZVxuICBpZiAob3B0cy5waWNraW5nVGhyZXNob2xkICE9PSB1bmRlZmluZWQpIHtcbiAgICB1bmlmb3Jtcy5waWNraW5nX3VUaHJlc2hvbGQgPSBvcHRzLnBpY2tpbmdUaHJlc2hvbGQ7XG4gIH1cbiAgaWYgKG9wdHMucGlja2luZ0FjdGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdW5pZm9ybXMucGlja2luZ191QWN0aXZlID0gb3B0cy5waWNraW5nQWN0aXZlID8gMSA6IDA7XG4gIH1cbiAgcmV0dXJuIHVuaWZvcm1zO1xufVxuXG5jb25zdCB2cyA9IGBcXFxudW5pZm9ybSB2ZWMzIHBpY2tpbmdfdVNlbGVjdGVkUGlja2luZ0NvbG9yO1xudW5pZm9ybSBmbG9hdCBwaWNraW5nX3VUaHJlc2hvbGQ7XG51bmlmb3JtIGJvb2wgcGlja2luZ191U2VsZWN0ZWRQaWNraW5nQ29sb3JWYWxpZDtcblxudmFyeWluZyB2ZWM0IHBpY2tpbmdfdlJHQmNvbG9yX0FzZWxlY3RlZDtcblxuY29uc3QgZmxvYXQgQ09MT1JfU0NBTEUgPSAxLiAvIDI1NS47XG5cbmJvb2wgaXNWZXJ0ZXhQaWNrZWQodmVjMyB2ZXJ0ZXhDb2xvcikge1xuICByZXR1cm5cbiAgICBwaWNraW5nX3VTZWxlY3RlZFBpY2tpbmdDb2xvclZhbGlkICYmXG4gICAgYWJzKHZlcnRleENvbG9yLnIgLSBwaWNraW5nX3VTZWxlY3RlZFBpY2tpbmdDb2xvci5yKSA8IHBpY2tpbmdfdVRocmVzaG9sZCAmJlxuICAgIGFicyh2ZXJ0ZXhDb2xvci5nIC0gcGlja2luZ191U2VsZWN0ZWRQaWNraW5nQ29sb3IuZykgPCBwaWNraW5nX3VUaHJlc2hvbGQgJiZcbiAgICBhYnModmVydGV4Q29sb3IuYiAtIHBpY2tpbmdfdVNlbGVjdGVkUGlja2luZ0NvbG9yLmIpIDwgcGlja2luZ191VGhyZXNob2xkO1xufVxuXG52b2lkIHBpY2tpbmdfc2V0UGlja2luZ0NvbG9yKHZlYzMgcGlja2luZ0NvbG9yKSB7XG4gIC8vIERvIHRoZSBjb21wYXJpc29uIHdpdGggc2VsZWN0ZWQgaXRlbSBjb2xvciBpbiB2ZXJ0ZXggc2hhZGVyIGFzIGl0IHNob3VsZCBtZWFuIGZld2VyIGNvbXBhcmVzXG4gIHBpY2tpbmdfdlJHQmNvbG9yX0FzZWxlY3RlZC5hID1cbiAgICBmbG9hdChpc1ZlcnRleFBpY2tlZChwaWNraW5nQ29sb3IpKTtcblxuICAvLyBTdG9yZXMgdGhlIHBpY2tpbmcgY29sb3Igc28gdGhhdCB0aGUgZnJhZ21lbnQgc2hhZGVyIGNhbiByZW5kZXIgaXQgZHVyaW5nIHBpY2tpbmdcbiAgcGlja2luZ192UkdCY29sb3JfQXNlbGVjdGVkLnJnYiA9IHBpY2tpbmdDb2xvciAqIENPTE9SX1NDQUxFO1xufVxuYDtcblxuY29uc3QgZnMgPSBgXFxcbnVuaWZvcm0gYm9vbCBwaWNraW5nX3VBY3RpdmU7IC8vIHRydWUgZHVyaW5nIHJlbmRlcmluZyB0byBvZmZzY3JlZW4gcGlja2luZyBidWZmZXJcbnVuaWZvcm0gdmVjMyBwaWNraW5nX3VTZWxlY3RlZFBpY2tpbmdDb2xvcjtcbnVuaWZvcm0gdmVjNCBwaWNraW5nX3VIaWdobGlnaHRDb2xvcjtcblxudmFyeWluZyB2ZWM0IHBpY2tpbmdfdlJHQmNvbG9yX0FzZWxlY3RlZDtcblxuY29uc3QgZmxvYXQgQ09MT1JfU0NBTEUgPSAxLiAvIDI1NS47XG5cbi8qXG4gKiBSZXR1cm5zIGhpZ2hsaWdodCBjb2xvciBpZiB0aGlzIGl0ZW0gaXMgc2VsZWN0ZWQuXG4gKi9cbnZlYzQgcGlja2luZ19maWx0ZXJIaWdobGlnaHRDb2xvcih2ZWM0IGNvbG9yKSB7XG4gIGJvb2wgc2VsZWN0ZWQgPSBib29sKHBpY2tpbmdfdlJHQmNvbG9yX0FzZWxlY3RlZC5hKTtcbiAgcmV0dXJuIHNlbGVjdGVkID8gKHBpY2tpbmdfdUhpZ2hsaWdodENvbG9yICogQ09MT1JfU0NBTEUpIDogY29sb3I7XG59XG5cbi8qXG4gKiBSZXR1cm5zIHBpY2tpbmcgY29sb3IgaWYgcGlja2luZyBlbmFibGVkIGVsc2UgdW5tb2RpZmllZCBhcmd1bWVudC5cbiAqL1xudmVjNCBwaWNraW5nX2ZpbHRlclBpY2tpbmdDb2xvcih2ZWM0IGNvbG9yKSB7XG4gIHZlYzMgcGlja2luZ0NvbG9yID0gcGlja2luZ192UkdCY29sb3JfQXNlbGVjdGVkLnJnYjtcbiAgcmV0dXJuIHBpY2tpbmdfdUFjdGl2ZSA/IHZlYzQocGlja2luZ0NvbG9yLCAxLjApIDogY29sb3I7XG59XG5gO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwaWNraW5nJyxcbiAgdnMsXG4gIGZzLFxuICBnZXRVbmlmb3Jtc1xufTtcbiJdfQ==