var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global window */
import mat4_multiply from 'gl-mat4/multiply';
import vec4_transformMat4 from 'gl-vec4/transformMat4';

import log from '../../utils/log';
import assert from 'assert';
import { COORDINATE_SYSTEM } from '../../lib/constants';

import { projectFlat } from 'viewport-mercator-project';

// To quickly set a vector to zero
var ZERO_VECTOR = [0, 0, 0, 0];
// 4x4 matrix that drops 4th component of vector
var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
var IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

// TODO - import these utils from fp64 package
function fp64ify(a) {
  var hiPart = Math.fround(a);
  var loPart = a - hiPart;
  return [hiPart, loPart];
}

// calculate WebGL 64 bit matrix (transposed "Float64Array")
function fp64ifyMatrix4(matrix) {
  // Transpose the projection matrix to column major for GLSL.
  var matrixFP64 = new Float32Array(32);
  for (var i = 0; i < 4; ++i) {
    for (var j = 0; j < 4; ++j) {
      var index = i * 4 + j;

      var _fp64ify = fp64ify(matrix[j * 4 + i]);

      var _fp64ify2 = _slicedToArray(_fp64ify, 2);

      matrixFP64[index * 2] = _fp64ify2[0];
      matrixFP64[index * 2 + 1] = _fp64ify2[1];
    }
  }
  return matrixFP64;
}

// Calculate transformed projectionCenter (using 64 bit precision JS)
// This is the key to offset mode precision
// (avoids doing this addition in 32 bit precision in GLSL)
function calculateProjectionCenter(_ref) {
  var coordinateOrigin = _ref.coordinateOrigin,
      coordinateZoom = _ref.coordinateZoom,
      viewProjectionMatrix = _ref.viewProjectionMatrix;

  var positionPixels = projectFlat(coordinateOrigin, Math.pow(2, coordinateZoom));
  // projectionCenter = new Matrix4(viewProjectionMatrix)
  //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);
  return vec4_transformMat4([], [positionPixels[0], positionPixels[1], 0.0, 1.0], viewProjectionMatrix);
}

// The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,
// has lower performance but provides error checking.
// Uncomment when debugging
function calculateMatrixAndOffset(_ref2) {
  var viewport = _ref2.viewport,
      modelMatrix = _ref2.modelMatrix,
      coordinateSystem = _ref2.coordinateSystem,
      coordinateOrigin = _ref2.coordinateOrigin,
      coordinateZoom = _ref2.coordinateZoom;
  var viewMatrixUncentered = viewport.viewMatrixUncentered;
  var viewMatrix = viewport.viewMatrix;
  var projectionMatrix = viewport.projectionMatrix;
  var viewProjectionMatrix = viewport.viewProjectionMatrix;


  var projectionCenter = void 0;

  switch (coordinateSystem) {

    case COORDINATE_SYSTEM.IDENTITY:
    case COORDINATE_SYSTEM.LNGLAT:
      projectionCenter = ZERO_VECTOR;
      break;

    // TODO: make lighitng work for meter offset mode
    case COORDINATE_SYSTEM.METER_OFFSETS:
      projectionCenter = calculateProjectionCenter({
        coordinateOrigin: coordinateOrigin, coordinateZoom: coordinateZoom, viewProjectionMatrix: viewProjectionMatrix
      });

      // Always apply uncentered projection matrix if available (shader adds center)
      viewMatrix = viewMatrixUncentered || viewMatrix;

      // Zero out 4th coordinate ("after" model matrix) - avoids further translations
      // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)
      //   .multiplyRight(VECTOR_TO_POINT_MATRIX);
      viewProjectionMatrix = mat4_multiply([], projectionMatrix, viewMatrix);
      viewProjectionMatrix = mat4_multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
      break;

    default:
      throw new Error('Unknown projection mode');
  }

  return {
    viewMatrix: viewMatrix,
    viewProjectionMatrix: viewProjectionMatrix,
    projectionCenter: projectionCenter,
    cameraPos: viewport.cameraPosition
  };
}

/**
 * Returns uniforms for shaders based on current projection
 * includes: projection matrix suitable for shaders
 *
 * TODO - Ensure this works with any viewport, not just WebMercatorViewports
 *
 * @param {WebMercatorViewport} viewport -
 * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
 */
export function getUniformsFromViewport() {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      viewport = _ref3.viewport,
      _ref3$modelMatrix = _ref3.modelMatrix,
      modelMatrix = _ref3$modelMatrix === undefined ? null : _ref3$modelMatrix,
      _ref3$coordinateSyste = _ref3.coordinateSystem,
      coordinateSystem = _ref3$coordinateSyste === undefined ? COORDINATE_SYSTEM.LNGLAT : _ref3$coordinateSyste,
      _ref3$coordinateOrigi = _ref3.coordinateOrigin,
      coordinateOrigin = _ref3$coordinateOrigi === undefined ? [0, 0] : _ref3$coordinateOrigi,
      projectionMode = _ref3.projectionMode,
      positionOrigin = _ref3.positionOrigin;

  assert(viewport);

  if (projectionMode !== undefined) {
    coordinateSystem = projectionMode;
    log.deprecated('projectionMode', 'coordinateSystem');
  }
  if (positionOrigin !== undefined) {
    coordinateOrigin = positionOrigin;
    log.deprecated('positionOrigin', 'coordinateOrigin');
  }

  var coordinateZoom = viewport.zoom;
  assert(coordinateZoom >= 0);

  var _calculateMatrixAndOf = calculateMatrixAndOffset({
    coordinateSystem: coordinateSystem, coordinateOrigin: coordinateOrigin, coordinateZoom: coordinateZoom, modelMatrix: modelMatrix, viewport: viewport
  }),
      projectionCenter = _calculateMatrixAndOf.projectionCenter,
      viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix,
      cameraPos = _calculateMatrixAndOf.cameraPos;

  assert(viewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix');

  // Calculate projection pixels per unit
  var distanceScales = viewport.getDistanceScales();

  // TODO - does this depend on useDevicePixelRatio?
  var devicePixelRatio = window && window.devicePixelRatio || 1;
  var viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];

  var glModelMatrix = new Float32Array(modelMatrix || IDENTITY_MATRIX);
  var glViewProjectionMatrix = new Float32Array(viewProjectionMatrix);

  var glViewProjectionMatrixFP64 = fp64ifyMatrix4(viewProjectionMatrix);
  var scaleFP64 = fp64ify(viewport.scale);

  return {
    // Projection mode values
    project_uCoordinateSystem: coordinateSystem,
    project_uCenter: projectionCenter,

    // Screen size
    project_uViewportSize: viewportSize,
    project_uDevicePixelRatio: devicePixelRatio,

    // Distance at which screen pixels are projected
    project_uFocalDistance: viewport.focalDistance || 1,
    project_uPixelsPerUnit: distanceScales.pixelsPerMeter,
    project_uScale: viewport.scale, // This is the mercator scale (2 ** zoom)

    project_uModelMatrix: glModelMatrix,
    project_uViewProjectionMatrix: glViewProjectionMatrix,

    // 64 bit support
    project_uViewProjectionMatrixFP64: fp64ifyMatrix4(viewProjectionMatrix),

    // This is for lighting calculations
    project_uCameraPosition: new Float32Array(cameraPos),

    project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,
    project64_uScale: scaleFP64,

    //
    // DEPRECATED UNIFORMS - For backwards compatibility with old custom layers
    //
    projectionMode: coordinateSystem,
    projectionCenter: projectionCenter,

    projectionOrigin: coordinateOrigin,
    modelMatrix: glModelMatrix,
    viewMatrix: viewport.viewMatrix,
    projectionMatrix: glViewProjectionMatrix,
    projectionPixelsPerUnit: distanceScales.pixelsPerMeter,
    projectionScale: viewport.scale, // This is the mercator scale (2 ** zoom)
    viewportSize: viewportSize,
    devicePixelRatio: devicePixelRatio,
    cameraPos: new Float32Array(cameraPos),

    projectionFP64: glViewProjectionMatrixFP64,
    projectionScaleFP64: scaleFP64
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb3JlL3NoYWRlcmxpYi9wcm9qZWN0L3ZpZXdwb3J0LXVuaWZvcm1zLmpzIl0sIm5hbWVzIjpbIm1hdDRfbXVsdGlwbHkiLCJ2ZWM0X3RyYW5zZm9ybU1hdDQiLCJsb2ciLCJhc3NlcnQiLCJDT09SRElOQVRFX1NZU1RFTSIsInByb2plY3RGbGF0IiwiWkVST19WRUNUT1IiLCJWRUNUT1JfVE9fUE9JTlRfTUFUUklYIiwiSURFTlRJVFlfTUFUUklYIiwiZnA2NGlmeSIsImEiLCJoaVBhcnQiLCJNYXRoIiwiZnJvdW5kIiwibG9QYXJ0IiwiZnA2NGlmeU1hdHJpeDQiLCJtYXRyaXgiLCJtYXRyaXhGUDY0IiwiRmxvYXQzMkFycmF5IiwiaSIsImoiLCJpbmRleCIsImNhbGN1bGF0ZVByb2plY3Rpb25DZW50ZXIiLCJjb29yZGluYXRlT3JpZ2luIiwiY29vcmRpbmF0ZVpvb20iLCJ2aWV3UHJvamVjdGlvbk1hdHJpeCIsInBvc2l0aW9uUGl4ZWxzIiwicG93IiwiY2FsY3VsYXRlTWF0cml4QW5kT2Zmc2V0Iiwidmlld3BvcnQiLCJtb2RlbE1hdHJpeCIsImNvb3JkaW5hdGVTeXN0ZW0iLCJ2aWV3TWF0cml4VW5jZW50ZXJlZCIsInZpZXdNYXRyaXgiLCJwcm9qZWN0aW9uTWF0cml4IiwicHJvamVjdGlvbkNlbnRlciIsIklERU5USVRZIiwiTE5HTEFUIiwiTUVURVJfT0ZGU0VUUyIsIkVycm9yIiwiY2FtZXJhUG9zIiwiY2FtZXJhUG9zaXRpb24iLCJnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydCIsInByb2plY3Rpb25Nb2RlIiwicG9zaXRpb25PcmlnaW4iLCJ1bmRlZmluZWQiLCJkZXByZWNhdGVkIiwiem9vbSIsImRpc3RhbmNlU2NhbGVzIiwiZ2V0RGlzdGFuY2VTY2FsZXMiLCJkZXZpY2VQaXhlbFJhdGlvIiwid2luZG93Iiwidmlld3BvcnRTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJnbE1vZGVsTWF0cml4IiwiZ2xWaWV3UHJvamVjdGlvbk1hdHJpeCIsImdsVmlld1Byb2plY3Rpb25NYXRyaXhGUDY0Iiwic2NhbGVGUDY0Iiwic2NhbGUiLCJwcm9qZWN0X3VDb29yZGluYXRlU3lzdGVtIiwicHJvamVjdF91Q2VudGVyIiwicHJvamVjdF91Vmlld3BvcnRTaXplIiwicHJvamVjdF91RGV2aWNlUGl4ZWxSYXRpbyIsInByb2plY3RfdUZvY2FsRGlzdGFuY2UiLCJmb2NhbERpc3RhbmNlIiwicHJvamVjdF91UGl4ZWxzUGVyVW5pdCIsInBpeGVsc1Blck1ldGVyIiwicHJvamVjdF91U2NhbGUiLCJwcm9qZWN0X3VNb2RlbE1hdHJpeCIsInByb2plY3RfdVZpZXdQcm9qZWN0aW9uTWF0cml4IiwicHJvamVjdF91Vmlld1Byb2plY3Rpb25NYXRyaXhGUDY0IiwicHJvamVjdF91Q2FtZXJhUG9zaXRpb24iLCJwcm9qZWN0NjRfdVZpZXdQcm9qZWN0aW9uTWF0cml4IiwicHJvamVjdDY0X3VTY2FsZSIsInByb2plY3Rpb25PcmlnaW4iLCJwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdCIsInByb2plY3Rpb25TY2FsZSIsInByb2plY3Rpb25GUDY0IiwicHJvamVjdGlvblNjYWxlRlA2NCJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU9BLGFBQVAsTUFBMEIsa0JBQTFCO0FBQ0EsT0FBT0Msa0JBQVAsTUFBK0IsdUJBQS9COztBQUVBLE9BQU9DLEdBQVAsTUFBZ0IsaUJBQWhCO0FBQ0EsT0FBT0MsTUFBUCxNQUFtQixRQUFuQjtBQUNBLFNBQVFDLGlCQUFSLFFBQWdDLHFCQUFoQzs7QUFFQSxTQUFRQyxXQUFSLFFBQTBCLDJCQUExQjs7QUFFQTtBQUNBLElBQU1DLGNBQWMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBQXBCO0FBQ0E7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QXdCbEIsZUFBZW1CLGNBWGxDO0FBWUxDLG9CQUFnQnZDLFNBQVM4QixLQVpwQixFQVkyQjs7QUFFaENVLDBCQUFzQmQsYUFkakI7QUFlTGUsbUNBQStCZCxzQkFmMUI7O0FBaUJMO0FBQ0FlLHVDQUFtQ3hELGVBQWVVLG9CQUFmLENBbEI5Qjs7QUFvQkw7QUFDQStDLDZCQUF5QixJQUFJdEQsWUFBSixDQUFpQnNCLFNBQWpCLENBckJwQjs7QUF1QkxpQyxxQ0FBaUNoQiwwQkF2QjVCO0FBd0JMaUIsc0JBQWtCaEIsU0F4QmI7O0FBMEJMO0FBQ0E7QUFDQTtBQUNBZixvQkFBZ0JaLGdCQTdCWDtBQThCTEksc0NBOUJLOztBQWdDTHdDLHNCQUFrQnBELGdCQWhDYjtBQWlDTE8saUJBQWF5QixhQWpDUjtBQWtDTHRCLGdCQUFZSixTQUFTSSxVQWxDaEI7QUFtQ0xDLHNCQUFrQnNCLHNCQW5DYjtBQW9DTG9CLDZCQUF5QjVCLGVBQWVtQixjQXBDbkM7QUFxQ0xVLHFCQUFpQmhELFNBQVM4QixLQXJDckIsRUFxQzRCO0FBQ2pDUCw4QkF0Q0s7QUF1Q0xGLHNDQXZDSztBQXdDTFYsZUFBVyxJQUFJdEIsWUFBSixDQUFpQnNCLFNBQWpCLENBeENOOztBQTBDTHNDLG9CQUFnQnJCLDBCQTFDWDtBQTJDTHNCLHlCQUFxQnJCO0FBM0NoQixHQUFQO0FBNkNEIiwiZmlsZSI6InZpZXdwb3J0LXVuaWZvcm1zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCBtYXQ0X211bHRpcGx5IGZyb20gJ2dsLW1hdDQvbXVsdGlwbHknO1xuaW1wb3J0IHZlYzRfdHJhbnNmb3JtTWF0NCBmcm9tICdnbC12ZWM0L3RyYW5zZm9ybU1hdDQnO1xuXG5pbXBvcnQgbG9nIGZyb20gJy4uLy4uL3V0aWxzL2xvZyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge0NPT1JESU5BVEVfU1lTVEVNfSBmcm9tICcuLi8uLi9saWIvY29uc3RhbnRzJztcblxuaW1wb3J0IHtwcm9qZWN0RmxhdH0gZnJvbSAndmlld3BvcnQtbWVyY2F0b3ItcHJvamVjdCc7XG5cbi8vIFRvIHF1aWNrbHkgc2V0IGEgdmVjdG9yIHRvIHplcm9cbmNvbnN0IFpFUk9fVkVDVE9SID0gWzAsIDAsIDAsIDBdO1xuLy8gNHg0IG1hdHJpeCB0aGF0IGRyb3BzIDR0aCBjb21wb25lbnQgb2YgdmVjdG9yXG5jb25zdCBWRUNUT1JfVE9fUE9JTlRfTUFUUklYID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDBdO1xuY29uc3QgSURFTlRJVFlfTUFUUklYID0gWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdO1xuXG4vLyBUT0RPIC0gaW1wb3J0IHRoZXNlIHV0aWxzIGZyb20gZnA2NCBwYWNrYWdlXG5mdW5jdGlvbiBmcDY0aWZ5KGEpIHtcbiAgY29uc3QgaGlQYXJ0ID0gTWF0aC5mcm91bmQoYSk7XG4gIGNvbnN0IGxvUGFydCA9IGEgLSBoaVBhcnQ7XG4gIHJldHVybiBbaGlQYXJ0LCBsb1BhcnRdO1xufVxuXG4vLyBjYWxjdWxhdGUgV2ViR0wgNjQgYml0IG1hdHJpeCAodHJhbnNwb3NlZCBcIkZsb2F0NjRBcnJheVwiKVxuZnVuY3Rpb24gZnA2NGlmeU1hdHJpeDQobWF0cml4KSB7XG4gIC8vIFRyYW5zcG9zZSB0aGUgcHJvamVjdGlvbiBtYXRyaXggdG8gY29sdW1uIG1ham9yIGZvciBHTFNMLlxuICBjb25zdCBtYXRyaXhGUDY0ID0gbmV3IEZsb2F0MzJBcnJheSgzMik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyArK2opIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAqIDQgKyBqO1xuICAgICAgW21hdHJpeEZQNjRbaW5kZXggKiAyXSwgbWF0cml4RlA2NFtpbmRleCAqIDIgKyAxXV0gPSBmcDY0aWZ5KG1hdHJpeFtqICogNCArIGldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdHJpeEZQNjQ7XG59XG5cbi8vIENhbGN1bGF0ZSB0cmFuc2Zvcm1lZCBwcm9qZWN0aW9uQ2VudGVyICh1c2luZyA2NCBiaXQgcHJlY2lzaW9uIEpTKVxuLy8gVGhpcyBpcyB0aGUga2V5IHRvIG9mZnNldCBtb2RlIHByZWNpc2lvblxuLy8gKGF2b2lkcyBkb2luZyB0aGlzIGFkZGl0aW9uIGluIDMyIGJpdCBwcmVjaXNpb24gaW4gR0xTTClcbmZ1bmN0aW9uIGNhbGN1bGF0ZVByb2plY3Rpb25DZW50ZXIoe2Nvb3JkaW5hdGVPcmlnaW4sIGNvb3JkaW5hdGVab29tLCB2aWV3UHJvamVjdGlvbk1hdHJpeH0pIHtcbiAgY29uc3QgcG9zaXRpb25QaXhlbHMgPSBwcm9qZWN0RmxhdChjb29yZGluYXRlT3JpZ2luLCBNYXRoLnBvdygyLCBjb29yZGluYXRlWm9vbSkpO1xuICAvLyBwcm9qZWN0aW9uQ2VudGVyID0gbmV3IE1hdHJpeDQodmlld1Byb2plY3Rpb25NYXRyaXgpXG4gIC8vICAgLnRyYW5zZm9ybVZlY3RvcihbcG9zaXRpb25QaXhlbHNbMF0sIHBvc2l0aW9uUGl4ZWxzWzFdLCAwLjAsIDEuMF0pO1xuICByZXR1cm4gdmVjNF90cmFuc2Zvcm1NYXQ0KFtdLFxuICAgIFtwb3NpdGlvblBpeGVsc1swXSwgcG9zaXRpb25QaXhlbHNbMV0sIDAuMCwgMS4wXSxcbiAgICB2aWV3UHJvamVjdGlvbk1hdHJpeCk7XG59XG5cbi8vIFRoZSBjb2RlIHRoYXQgdXRpbGl6ZXMgTWF0cml4NCBkb2VzIHRoZSBzYW1lIGNhbGN1bGF0aW9uIGFzIHRoZWlyIG1hdDQgY291bnRlcnBhcnRzLFxuLy8gaGFzIGxvd2VyIHBlcmZvcm1hbmNlIGJ1dCBwcm92aWRlcyBlcnJvciBjaGVja2luZy5cbi8vIFVuY29tbWVudCB3aGVuIGRlYnVnZ2luZ1xuZnVuY3Rpb24gY2FsY3VsYXRlTWF0cml4QW5kT2Zmc2V0KHtcbiAgLy8gVU5DSEFOR0VEXG4gIHZpZXdwb3J0LFxuICBtb2RlbE1hdHJpeCxcbiAgLy8gTkVXIFBBUkFNU1xuICBjb29yZGluYXRlU3lzdGVtLFxuICBjb29yZGluYXRlT3JpZ2luLFxuICBjb29yZGluYXRlWm9vbVxufSkge1xuICBjb25zdCB7dmlld01hdHJpeFVuY2VudGVyZWR9ID0gdmlld3BvcnQ7XG4gIGxldCB7dmlld01hdHJpeH0gPSB2aWV3cG9ydDtcbiAgY29uc3Qge3Byb2plY3Rpb25NYXRyaXh9ID0gdmlld3BvcnQ7XG4gIGxldCB7dmlld1Byb2plY3Rpb25NYXRyaXh9ID0gdmlld3BvcnQ7XG5cbiAgbGV0IHByb2plY3Rpb25DZW50ZXI7XG5cbiAgc3dpdGNoIChjb29yZGluYXRlU3lzdGVtKSB7XG5cbiAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5JREVOVElUWTpcbiAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQ6XG4gICAgcHJvamVjdGlvbkNlbnRlciA9IFpFUk9fVkVDVE9SO1xuICAgIGJyZWFrO1xuXG4gIC8vIFRPRE86IG1ha2UgbGlnaGl0bmcgd29yayBmb3IgbWV0ZXIgb2Zmc2V0IG1vZGVcbiAgY2FzZSBDT09SRElOQVRFX1NZU1RFTS5NRVRFUl9PRkZTRVRTOlxuICAgIHByb2plY3Rpb25DZW50ZXIgPSBjYWxjdWxhdGVQcm9qZWN0aW9uQ2VudGVyKHtcbiAgICAgIGNvb3JkaW5hdGVPcmlnaW4sIGNvb3JkaW5hdGVab29tLCB2aWV3UHJvamVjdGlvbk1hdHJpeFxuICAgIH0pO1xuXG4gICAgLy8gQWx3YXlzIGFwcGx5IHVuY2VudGVyZWQgcHJvamVjdGlvbiBtYXRyaXggaWYgYXZhaWxhYmxlIChzaGFkZXIgYWRkcyBjZW50ZXIpXG4gICAgdmlld01hdHJpeCA9IHZpZXdNYXRyaXhVbmNlbnRlcmVkIHx8IHZpZXdNYXRyaXg7XG5cbiAgICAvLyBaZXJvIG91dCA0dGggY29vcmRpbmF0ZSAoXCJhZnRlclwiIG1vZGVsIG1hdHJpeCkgLSBhdm9pZHMgZnVydGhlciB0cmFuc2xhdGlvbnNcbiAgICAvLyB2aWV3TWF0cml4ID0gbmV3IE1hdHJpeDQodmlld01hdHJpeFVuY2VudGVyZWQgfHwgdmlld01hdHJpeClcbiAgICAvLyAgIC5tdWx0aXBseVJpZ2h0KFZFQ1RPUl9UT19QT0lOVF9NQVRSSVgpO1xuICAgIHZpZXdQcm9qZWN0aW9uTWF0cml4ID0gbWF0NF9tdWx0aXBseShbXSwgcHJvamVjdGlvbk1hdHJpeCwgdmlld01hdHJpeCk7XG4gICAgdmlld1Byb2plY3Rpb25NYXRyaXggPSBtYXQ0X211bHRpcGx5KFtdLCB2aWV3UHJvamVjdGlvbk1hdHJpeCwgVkVDVE9SX1RPX1BPSU5UX01BVFJJWCk7XG4gICAgYnJlYWs7XG5cbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJvamVjdGlvbiBtb2RlJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZpZXdNYXRyaXgsXG4gICAgdmlld1Byb2plY3Rpb25NYXRyaXgsXG4gICAgcHJvamVjdGlvbkNlbnRlcixcbiAgICBjYW1lcmFQb3M6IHZpZXdwb3J0LmNhbWVyYVBvc2l0aW9uXG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB1bmlmb3JtcyBmb3Igc2hhZGVycyBiYXNlZCBvbiBjdXJyZW50IHByb2plY3Rpb25cbiAqIGluY2x1ZGVzOiBwcm9qZWN0aW9uIG1hdHJpeCBzdWl0YWJsZSBmb3Igc2hhZGVyc1xuICpcbiAqIFRPRE8gLSBFbnN1cmUgdGhpcyB3b3JrcyB3aXRoIGFueSB2aWV3cG9ydCwgbm90IGp1c3QgV2ViTWVyY2F0b3JWaWV3cG9ydHNcbiAqXG4gKiBAcGFyYW0ge1dlYk1lcmNhdG9yVmlld3BvcnR9IHZpZXdwb3J0IC1cbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gLSA0eDQgcHJvamVjdGlvbiBtYXRyaXggdGhhdCBjYW4gYmUgdXNlZCBpbiBzaGFkZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmlmb3Jtc0Zyb21WaWV3cG9ydCh7XG4gIHZpZXdwb3J0LFxuICBtb2RlbE1hdHJpeCA9IG51bGwsXG4gIGNvb3JkaW5hdGVTeXN0ZW0gPSBDT09SRElOQVRFX1NZU1RFTS5MTkdMQVQsXG4gIGNvb3JkaW5hdGVPcmlnaW4gPSBbMCwgMF0sXG4gIC8vIERlcHJlY2F0ZWRcbiAgcHJvamVjdGlvbk1vZGUsXG4gIHBvc2l0aW9uT3JpZ2luXG59ID0ge30pIHtcbiAgYXNzZXJ0KHZpZXdwb3J0KTtcblxuICBpZiAocHJvamVjdGlvbk1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvb3JkaW5hdGVTeXN0ZW0gPSBwcm9qZWN0aW9uTW9kZTtcbiAgICBsb2cuZGVwcmVjYXRlZCgncHJvamVjdGlvbk1vZGUnLCAnY29vcmRpbmF0ZVN5c3RlbScpO1xuICB9XG4gIGlmIChwb3NpdGlvbk9yaWdpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29vcmRpbmF0ZU9yaWdpbiA9IHBvc2l0aW9uT3JpZ2luO1xuICAgIGxvZy5kZXByZWNhdGVkKCdwb3NpdGlvbk9yaWdpbicsICdjb29yZGluYXRlT3JpZ2luJyk7XG4gIH1cblxuICBjb25zdCBjb29yZGluYXRlWm9vbSA9IHZpZXdwb3J0Lnpvb207XG4gIGFzc2VydChjb29yZGluYXRlWm9vbSA+PSAwKTtcblxuICBjb25zdCB7cHJvamVjdGlvbkNlbnRlciwgdmlld1Byb2plY3Rpb25NYXRyaXgsIGNhbWVyYVBvc30gPVxuICAgIGNhbGN1bGF0ZU1hdHJpeEFuZE9mZnNldCh7XG4gICAgICBjb29yZGluYXRlU3lzdGVtLCBjb29yZGluYXRlT3JpZ2luLCBjb29yZGluYXRlWm9vbSwgbW9kZWxNYXRyaXgsIHZpZXdwb3J0XG4gICAgfSk7XG5cbiAgYXNzZXJ0KHZpZXdQcm9qZWN0aW9uTWF0cml4LCAnVmlld3BvcnQgbWlzc2luZyBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4Jyk7XG5cbiAgLy8gQ2FsY3VsYXRlIHByb2plY3Rpb24gcGl4ZWxzIHBlciB1bml0XG4gIGNvbnN0IGRpc3RhbmNlU2NhbGVzID0gdmlld3BvcnQuZ2V0RGlzdGFuY2VTY2FsZXMoKTtcblxuICAvLyBUT0RPIC0gZG9lcyB0aGlzIGRlcGVuZCBvbiB1c2VEZXZpY2VQaXhlbFJhdGlvP1xuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gKHdpbmRvdyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgfHwgMTtcbiAgY29uc3Qgdmlld3BvcnRTaXplID0gW3ZpZXdwb3J0LndpZHRoICogZGV2aWNlUGl4ZWxSYXRpbywgdmlld3BvcnQuaGVpZ2h0ICogZGV2aWNlUGl4ZWxSYXRpb107XG5cbiAgY29uc3QgZ2xNb2RlbE1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkobW9kZWxNYXRyaXggfHwgSURFTlRJVFlfTUFUUklYKTtcbiAgY29uc3QgZ2xWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkodmlld1Byb2plY3Rpb25NYXRyaXgpO1xuXG4gIGNvbnN0IGdsVmlld1Byb2plY3Rpb25NYXRyaXhGUDY0ID0gZnA2NGlmeU1hdHJpeDQodmlld1Byb2plY3Rpb25NYXRyaXgpO1xuICBjb25zdCBzY2FsZUZQNjQgPSBmcDY0aWZ5KHZpZXdwb3J0LnNjYWxlKTtcblxuICByZXR1cm4ge1xuICAgIC8vIFByb2plY3Rpb24gbW9kZSB2YWx1ZXNcbiAgICBwcm9qZWN0X3VDb29yZGluYXRlU3lzdGVtOiBjb29yZGluYXRlU3lzdGVtLFxuICAgIHByb2plY3RfdUNlbnRlcjogcHJvamVjdGlvbkNlbnRlcixcblxuICAgIC8vIFNjcmVlbiBzaXplXG4gICAgcHJvamVjdF91Vmlld3BvcnRTaXplOiB2aWV3cG9ydFNpemUsXG4gICAgcHJvamVjdF91RGV2aWNlUGl4ZWxSYXRpbzogZGV2aWNlUGl4ZWxSYXRpbyxcblxuICAgIC8vIERpc3RhbmNlIGF0IHdoaWNoIHNjcmVlbiBwaXhlbHMgYXJlIHByb2plY3RlZFxuICAgIHByb2plY3RfdUZvY2FsRGlzdGFuY2U6IHZpZXdwb3J0LmZvY2FsRGlzdGFuY2UgfHwgMSxcbiAgICBwcm9qZWN0X3VQaXhlbHNQZXJVbml0OiBkaXN0YW5jZVNjYWxlcy5waXhlbHNQZXJNZXRlcixcbiAgICBwcm9qZWN0X3VTY2FsZTogdmlld3BvcnQuc2NhbGUsIC8vIFRoaXMgaXMgdGhlIG1lcmNhdG9yIHNjYWxlICgyICoqIHpvb20pXG5cbiAgICBwcm9qZWN0X3VNb2RlbE1hdHJpeDogZ2xNb2RlbE1hdHJpeCxcbiAgICBwcm9qZWN0X3VWaWV3UHJvamVjdGlvbk1hdHJpeDogZ2xWaWV3UHJvamVjdGlvbk1hdHJpeCxcblxuICAgIC8vIDY0IGJpdCBzdXBwb3J0XG4gICAgcHJvamVjdF91Vmlld1Byb2plY3Rpb25NYXRyaXhGUDY0OiBmcDY0aWZ5TWF0cml4NCh2aWV3UHJvamVjdGlvbk1hdHJpeCksXG5cbiAgICAvLyBUaGlzIGlzIGZvciBsaWdodGluZyBjYWxjdWxhdGlvbnNcbiAgICBwcm9qZWN0X3VDYW1lcmFQb3NpdGlvbjogbmV3IEZsb2F0MzJBcnJheShjYW1lcmFQb3MpLFxuXG4gICAgcHJvamVjdDY0X3VWaWV3UHJvamVjdGlvbk1hdHJpeDogZ2xWaWV3UHJvamVjdGlvbk1hdHJpeEZQNjQsXG4gICAgcHJvamVjdDY0X3VTY2FsZTogc2NhbGVGUDY0LFxuXG4gICAgLy9cbiAgICAvLyBERVBSRUNBVEVEIFVOSUZPUk1TIC0gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGN1c3RvbSBsYXllcnNcbiAgICAvL1xuICAgIHByb2plY3Rpb25Nb2RlOiBjb29yZGluYXRlU3lzdGVtLFxuICAgIHByb2plY3Rpb25DZW50ZXIsXG5cbiAgICBwcm9qZWN0aW9uT3JpZ2luOiBjb29yZGluYXRlT3JpZ2luLFxuICAgIG1vZGVsTWF0cml4OiBnbE1vZGVsTWF0cml4LFxuICAgIHZpZXdNYXRyaXg6IHZpZXdwb3J0LnZpZXdNYXRyaXgsXG4gICAgcHJvamVjdGlvbk1hdHJpeDogZ2xWaWV3UHJvamVjdGlvbk1hdHJpeCxcbiAgICBwcm9qZWN0aW9uUGl4ZWxzUGVyVW5pdDogZGlzdGFuY2VTY2FsZXMucGl4ZWxzUGVyTWV0ZXIsXG4gICAgcHJvamVjdGlvblNjYWxlOiB2aWV3cG9ydC5zY2FsZSwgLy8gVGhpcyBpcyB0aGUgbWVyY2F0b3Igc2NhbGUgKDIgKiogem9vbSlcbiAgICB2aWV3cG9ydFNpemUsXG4gICAgZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICBjYW1lcmFQb3M6IG5ldyBGbG9hdDMyQXJyYXkoY2FtZXJhUG9zKSxcblxuICAgIHByb2plY3Rpb25GUDY0OiBnbFZpZXdQcm9qZWN0aW9uTWF0cml4RlA2NCxcbiAgICBwcm9qZWN0aW9uU2NhbGVGUDY0OiBzY2FsZUZQNjRcbiAgfTtcbn1cbiJdfQ==