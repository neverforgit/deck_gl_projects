var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { Vector3, experimental } from 'math.gl';
var SphericalCoordinates = experimental.SphericalCoordinates;

import assert from 'assert';

var MOVEMENT_SPEED = 1; // 1 meter per keyboard click
// const ROTATION_STEP_RADIANS = 0.03;
var ROTATION_STEP_DEGREES = 2;

var defaultState = {
  position: [0, 0, 0],
  lookAt: [0, 0, 0],
  up: [0, 0, 1],

  rotationX: 0,
  rotationY: 0,

  fov: 50,
  near: 1,
  far: 100
};

/* Helpers */

// Constrain number between bounds
function clamp(x, min, max) {
  return x < min ? min : x > max ? max : x;
}

function ensureFinite(value, fallbackValue) {
  return Number.isFinite(value) ? value : fallbackValue;
}

var FirstPersonState = function () {
  function FirstPersonState(_ref) {
    var width = _ref.width,
        height = _ref.height,
        position = _ref.position,
        direction = _ref.direction,
        bearing = _ref.bearing,
        pitch = _ref.pitch,
        longitude = _ref.longitude,
        latitude = _ref.latitude,
        zoom = _ref.zoom,
        _ref$syncBearing = _ref.syncBearing,
        syncBearing = _ref$syncBearing === undefined ? true : _ref$syncBearing,
        bounds = _ref.bounds,
        startPanEventPosition = _ref.startPanEventPosition,
        startPanPosition = _ref.startPanPosition,
        startRotateCenter = _ref.startRotateCenter,
        startRotateViewport = _ref.startRotateViewport,
        startZoomPos = _ref.startZoomPos,
        startZoom = _ref.startZoom;

    _classCallCheck(this, FirstPersonState);

    assert(Number.isFinite(width), '`width` must be supplied');
    assert(Number.isFinite(height), '`height` must be supplied');
    // assert(Number.isFinite(distance), '`distance` must be supplied');

    bearing = ensureFinite(bearing, defaultState.bearing);

    this._viewportProps = this._applyConstraints({
      width: width,
      height: height,
      position: new Vector3(ensureFinite(position && position[0], defaultState.position[0]), ensureFinite(position && position[1], defaultState.position[1]), ensureFinite(position && position[2], defaultState.position[2])),
      direction: this._getDirectionFromBearing(bearing),
      bearing: bearing,
      pitch: ensureFinite(pitch, defaultState.pitch),
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      bounds: bounds
    });

    this._interactiveState = {
      startPanEventPosition: startPanEventPosition,
      startPanPosition: startPanPosition,
      startRotateCenter: startRotateCenter,
      startRotateViewport: startRotateViewport,
      startZoomPos: startZoomPos,
      startZoom: startZoom
    };
  }

  /* Public API */

  _createClass(FirstPersonState, [{
    key: 'getViewportProps',
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: 'getInteractiveState',
    value: function getInteractiveState() {
      return this._interactiveState;
    }
  }, {
    key: 'getLookAt',
    value: function getLookAt() {
      return [];
    }

    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'panStart',
    value: function panStart(_ref2) {
      var pos = _ref2.pos;
      var _viewportProps = this._viewportProps,
          translationX = _viewportProps.translationX,
          translationY = _viewportProps.translationY;


      return this._getUpdatedState({
        startPanPosition: [translationX, translationY],
        startPanEventPosition: pos
      });
    }

    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */

  }, {
    key: 'pan',
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;

      var startPanEventPosition = this._interactiveState.startPanEventPosition || startPos;
      assert(startPanEventPosition, '`startPanEventPosition` props is required');

      var _ref4 = this._interactiveState.startPanPosition || [],
          _ref5 = _slicedToArray(_ref4, 2),
          translationX = _ref5[0],
          translationY = _ref5[1];

      translationX = ensureFinite(translationX, this._viewportProps.translationX);
      translationY = ensureFinite(translationY, this._viewportProps.translationY);

      var deltaX = pos[0] - startPanEventPosition[0];
      var deltaY = pos[1] - startPanEventPosition[1];

      return this._getUpdatedState({
        translationX: translationX + deltaX,
        translationY: translationY - deltaY
      });
    }

    /**
     * End panning
     * Must call if `panStart()` was called
     */

  }, {
    key: 'panEnd',
    value: function panEnd() {
      return this._getUpdatedState({
        startPanPosition: null,
        startPanPos: null
      });
    }

    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'rotateStart',
    value: function rotateStart(_ref6) {
      var pos = _ref6.pos;

      return this._getUpdatedState({
        startRotateCenter: this._viewportProps.position,
        startRotateViewport: this._viewportProps
      });
    }

    /**
     * Rotate
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */

  }, {
    key: 'rotate',
    value: function rotate(_ref7) {
      var deltaScaleX = _ref7.deltaScaleX,
          deltaScaleY = _ref7.deltaScaleY;
      var direction = this._viewportProps.direction;


      return this._getUpdatedState({
        direction: new Vector3(direction).rotateZ({ radians: deltaScaleX / 50 })
      });
    }

    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */

  }, {
    key: 'rotateEnd',
    value: function rotateEnd() {
      return this._getUpdatedState({
        startRotateCenter: null,
        startRotateViewport: null
      });
    }

    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'zoomStart',
    value: function zoomStart(_ref8) {
      var pos = _ref8.pos;

      return this._getUpdatedState({
        startZoomPos: pos,
        startZoom: this._viewportProps.zoom
      });
    }

    /**
     * Zoom
     * @param {[Number, Number]} pos - position on screen where the current center is
     * @param {[Number, Number]} startPos - the center position at
     *   the start of the operation. Must be supplied of `zoomStart()` was not called
     * @param {Number} scale - a number between [0, 1] specifying the accumulated
     *   relative scale.
     */

  }, {
    key: 'zoom',
    value: function zoom(_ref9) {
      var pos = _ref9.pos,
          startPos = _ref9.startPos,
          scale = _ref9.scale;
      var _viewportProps2 = this._viewportProps,
          zoom = _viewportProps2.zoom,
          minZoom = _viewportProps2.minZoom,
          maxZoom = _viewportProps2.maxZoom,
          width = _viewportProps2.width,
          height = _viewportProps2.height,
          translationX = _viewportProps2.translationX,
          translationY = _viewportProps2.translationY;


      var startZoomPos = this._interactiveState.startZoomPos || startPos || pos;

      var newZoom = clamp(zoom * scale, minZoom, maxZoom);
      var deltaX = pos[0] - startZoomPos[0];
      var deltaY = pos[1] - startZoomPos[1];

      // Zoom around the center position
      var cx = startZoomPos[0] - width / 2;
      var cy = height / 2 - startZoomPos[1];
      /* eslint-disable no-unused-vars */
      var newTranslationX = cx - (cx - translationX) * newZoom / zoom + deltaX;
      var newTranslationY = cy - (cy - translationY) * newZoom / zoom - deltaY;
      /* eslint-enable no-unused-vars */

      // return this._getUpdatedState({
      //   position
      //   translationX: newTranslationX,
      //   translationY: newTranslationY
      // });

      // TODO HACK
      return newZoom / zoom < 1 ? this.moveBackward() : this.moveForward();
    }

    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */

  }, {
    key: 'zoomEnd',
    value: function zoomEnd() {
      return this._getUpdatedState({
        startZoomPos: null,
        startZoom: null
      });
    }
  }, {
    key: '_getDirectionFromBearing',
    value: function _getDirectionFromBearing(bearing) {
      var spherical = new SphericalCoordinates({
        bearing: bearing,
        pitch: 90
      });
      var direction = spherical.toVector3().normalize();
      return direction;
    }
  }, {
    key: 'moveLeft',
    value: function moveLeft() {
      // const {position, direction} = this._viewportProps;
      // const newDirection = new Vector3(direction).rotateZ({radians: ROTATION_STEP_RADIANS});
      // return this._getUpdatedState({
      //   direction: newDirection,
      //   lookAt: new Vector3(position).add(newDirection.normalize()),
      //   bearing: this._viewportProps.bearing - ROTATION_STEP_DEGREES
      // });

      var _viewportProps3 = this._viewportProps,
          position = _viewportProps3.position,
          bearing = _viewportProps3.bearing;

      var newBearing = bearing - ROTATION_STEP_DEGREES;
      var newDirection = this._getDirectionFromBearing(newBearing);
      return this._getUpdatedState({
        direction: newDirection,
        lookAt: new Vector3(position).add(newDirection),
        bearing: newBearing
      });
    }
  }, {
    key: 'moveRight',
    value: function moveRight() {
      // const {position, direction} = this._viewportProps;
      // const newDirection = new Vector3(direction).rotateZ({radians: -ROTATION_STEP_RADIANS});
      // return this._getUpdatedState({
      //   direction: newDirection,
      //   lookAt: new Vector3(position).add(newDirection.normalize()),
      //   bearing: this._viewportProps.bearing + ROTATION_STEP_DEGREES
      // });

      var _viewportProps4 = this._viewportProps,
          position = _viewportProps4.position,
          bearing = _viewportProps4.bearing;

      var newBearing = bearing + ROTATION_STEP_DEGREES;
      var newDirection = this._getDirectionFromBearing(newBearing);
      return this._getUpdatedState({
        direction: newDirection,
        lookAt: new Vector3(position).add(newDirection),
        bearing: newBearing
      });
    }
  }, {
    key: 'moveForward',
    value: function moveForward() {
      var _viewportProps5 = this._viewportProps,
          position = _viewportProps5.position,
          direction = _viewportProps5.direction;

      var delta = new Vector3(direction).normalize().scale(MOVEMENT_SPEED);
      return this._getUpdatedState({
        // pitch: this._viewportProps.pitch + 3
        position: new Vector3(position).add(delta),
        lookAt: new Vector3(position).add(direction)
      });
    }
  }, {
    key: 'moveBackward',
    value: function moveBackward() {
      var _viewportProps6 = this._viewportProps,
          position = _viewportProps6.position,
          direction = _viewportProps6.direction;

      var delta = new Vector3(direction).normalize().scale(-MOVEMENT_SPEED);
      return this._getUpdatedState({
        // pitch: this._viewportProps.pitch - 3
        position: new Vector3(position).add(delta),
        lookAt: new Vector3(position).add(direction)
      });
    }
  }, {
    key: 'moveUp',
    value: function moveUp() {
      var _viewportProps7 = this._viewportProps,
          position = _viewportProps7.position,
          direction = _viewportProps7.direction;

      var delta = [0, 0, 1];
      return this._getUpdatedState({
        // pitch: this._viewportProps.pitch + 3
        position: new Vector3(position).add(delta),
        lookAt: new Vector3(position).add(direction)
      });
    }
  }, {
    key: 'moveDown',
    value: function moveDown() {
      var _viewportProps8 = this._viewportProps,
          position = _viewportProps8.position,
          direction = _viewportProps8.direction;

      var delta = position[2] >= 1 ? [0, 0, -1] : [0, 0, 0];
      return this._getUpdatedState({
        // pitch: this._viewportProps.pitch + 3
        position: new Vector3(position).add(delta),
        lookAt: new Vector3(position).add(direction)
      });
    }
  }, {
    key: 'zoomIn',
    value: function zoomIn() {
      return this._getUpdatedState({
        zoom: this._viewportProps.zoom + 0.2
      });
    }
  }, {
    key: 'zoomOut',
    value: function zoomOut() {
      return this._getUpdatedState({
        zoom: this._viewportProps.zoom - 0.2
      });
    }

    /* Private methods */

  }, {
    key: '_getUpdatedState',
    value: function _getUpdatedState(newProps) {
      // Update _viewportProps
      return new FirstPersonState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }

    // Apply any constraints (mathematical or defined by _viewportProps) to map state

  }, {
    key: '_applyConstraints',
    value: function _applyConstraints(props) {
      // TODO/ib - Ensure position is within bounds
      return props;
    }
  }]);

  return FirstPersonState;
}();

export default FirstPersonState;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2NvbnRyb2xsZXJzL2ZpcnN0LXBlcnNvbi1zdGF0ZS5qcyJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiZXhwZXJpbWVudGFsIiwiU3BoZXJpY2FsQ29vcmRpbmF0ZXMiLCJhc3NlcnQiLCJNT1ZFTUVOVF9TUEVFRCIsIlJPVEFUSU9OX1NURVBfREVHUkVFUyIsImRlZmF1bHRTdGF0ZSIsInBvc2l0aW9uIiwibG9va0F0IiwidXAiLCJyb3RhdGlvblgiLCJyb3RhdGlvblkiLCJmb3YiLCJuZWFyIiwiZmFyIiwiY2xhbXAiLCJ4IiwibWluIiwibWF4IiwiZW5zdXJlRmluaXRlIiwidmFsdWUiLCJmYWxsYmFja1ZhbHVlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJGaXJzdFBlcnNvblN0YXRlIiwid2lkdGgiLCJoZWlnaHQiLCJkaXJlY3Rpb24iLCJiZWFyaW5nIiwicGl0Y2giLCJsb25naXR1ZGUiLCJsYXRpdHVkZSIsInpvb20iLCJzeW5jQmVhcmluZyIsImJvdW5kcyIsInN0YXJ0UGFuRXZlbnRQb3NpdGlvbiIsInN0YXJ0UGFuUG9zaXRpb24iLCJzdGFydFJvdGF0ZUNlbnRlciIsInN0YXJ0Um90YXRlVmlld3BvcnQiLCJzdGFydFpvb21Qb3MiLCJzdGFydFpvb20iLCJfdmlld3BvcnRQcm9wcyIsIl9hcHBseUNvbnN0cmFpbnRzIiwiX2dldERpcmVjdGlvbkZyb21CZWFyaW5nIiwiX2ludGVyYWN0aXZlU3RhdGUiLCJwb3MiLCJ0cmFuc2xhdGlvblgiLCJ0cmFuc2xhdGlvblkiLCJfZ2V0VXBkYXRlZFN0YXRlIiwic3RhcnRQb3MiLCJkZWx0YVgiLCJkZWx0YVkiLCJzdGFydFBhblBvcyIsImRlbHRhU2NhbGVYIiwiZGVsdGFTY2FsZVkiLCJyb3RhdGVaIiwicmFkaWFucyIsInNjYWxlIiwibWluWm9vbSIsIm1heFpvb20iLCJuZXdab29tIiwiY3giLCJjeSIsIm5ld1RyYW5zbGF0aW9uWCIsIm5ld1RyYW5zbGF0aW9uWSIsIm1vdmVCYWNrd2FyZCIsIm1vdmVGb3J3YXJkIiwic3BoZXJpY2FsIiwidG9WZWN0b3IzIiwibm9ybWFsaXplIiwibmV3QmVhcmluZyIsIm5ld0RpcmVjdGlvbiIsImFkZCIsImRlbHRhIiwibmV3UHJvcHMiLCJPYmplY3QiLCJhc3NpZ24iLCJwcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsU0FBUUEsT0FBUixFQUFpQkMsWUFBakIsUUFBb0MsU0FBcEM7SUFDT0Msb0IsR0FBd0JELFksQ0FBeEJDLG9COztBQUNQLE9BQU9DLE1BQVAsTUFBbUIsUUFBbkI7O0FBRUEsSUFBTUMsaUJBQWlCLENBQXZCLEMsQ0FBMkI7QUFDM0I7QUFDQSxJQUFNQyx3QkFBd0IsQ0FBOUI7O0FBRUEsSUFBTUMsZUFBZTtBQUNuQkMsWUFBVSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQURTO0FBRW5CQyxVQUFRLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBRlc7QUFHbkJDLE1BQUksQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FIZTs7QUFLbkJDLGFBQVcsQ0FMUTtBQU1uQkMsYUFBVyxDQU5ROztBQVFuQkMsT0FBSyxFQVJjO0FBU25CQyxRQUFNLENBVGE7QUFVbkJDLE9BQUs7QUFWYyxDQUFyQjs7QUFhQTs7QUFFQTtBQUNBLFNBQVNDLEtBQVQsQ0FBZUMsQ0FBZixFQUFrQkMsR0FBbEIsRUFBdUJDLEdBQXZCLEVBQTRCO0FBQzFCLFNBQU9GLElBQUlDLEdBQUosR0FBVUEsR0FBVixHQUFpQkQsSUFBSUUsR0FBSixHQUFVQSxHQUFWLEdBQWdCRixDQUF4QztBQUNEOztBQUVELFNBQVNHLFlBQVQsQ0FBc0JDLEtBQXRCLEVBQTZCQyxhQUE3QixFQUE0QztBQUMxQyxTQUFPQyxPQUFPQyxRQUFQLENBQWdCSCxLQUFoQixJQUF5QkEsS0FBekIsR0FBaUNDLGFBQXhDO0FBQ0Q7O0lBRW9CRyxnQjtBQUVuQixrQ0FtQ0c7QUFBQSxRQWpDREMsS0FpQ0MsUUFqQ0RBLEtBaUNDO0FBQUEs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Q0F6QyxrQkFBVSxJQUFJUCxPQUFKLENBQVlPLFFBQVosRUFBc0JpRSxHQUF0QixDQUEwQkMsS0FBMUIsQ0FGaUI7QUFHM0JqRSxnQkFBUSxJQUFJUixPQUFKLENBQVlPLFFBQVosRUFBc0JpRSxHQUF0QixDQUEwQjdDLFNBQTFCO0FBSG1CLE9BQXRCLENBQVA7QUFLRDs7OzZCQUVRO0FBQ1AsYUFBTyxLQUFLcUIsZ0JBQUwsQ0FBc0I7QUFDM0JoQixjQUFNLEtBQUtTLGNBQUwsQ0FBb0JULElBQXBCLEdBQTJCO0FBRE4sT0FBdEIsQ0FBUDtBQUdEOzs7OEJBRVM7QUFDUixhQUFPLEtBQUtnQixnQkFBTCxDQUFzQjtBQUMzQmhCLGNBQU0sS0FBS1MsY0FBTCxDQUFvQlQsSUFBcEIsR0FBMkI7QUFETixPQUF0QixDQUFQO0FBR0Q7O0FBRUQ7Ozs7cUNBRWlCMEMsUSxFQUFVO0FBQ3pCO0FBQ0EsYUFBTyxJQUFJbEQsZ0JBQUosQ0FDTG1ELE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLEtBQUtuQyxjQUF2QixFQUF1QyxLQUFLRyxpQkFBNUMsRUFBK0Q4QixRQUEvRCxDQURLLENBQVA7QUFHRDs7QUFFRDs7OztzQ0FDa0JHLEssRUFBTztBQUN2QjtBQUNBLGFBQU9BLEtBQVA7QUFDRDs7Ozs7O2VBN1VrQnJELGdCIiwiZmlsZSI6ImZpcnN0LXBlcnNvbi1zdGF0ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7VmVjdG9yMywgZXhwZXJpbWVudGFsfSBmcm9tICdtYXRoLmdsJztcbmNvbnN0IHtTcGhlcmljYWxDb29yZGluYXRlc30gPSBleHBlcmltZW50YWw7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IE1PVkVNRU5UX1NQRUVEID0gMTsgIC8vIDEgbWV0ZXIgcGVyIGtleWJvYXJkIGNsaWNrXG4vLyBjb25zdCBST1RBVElPTl9TVEVQX1JBRElBTlMgPSAwLjAzO1xuY29uc3QgUk9UQVRJT05fU1RFUF9ERUdSRUVTID0gMjtcblxuY29uc3QgZGVmYXVsdFN0YXRlID0ge1xuICBwb3NpdGlvbjogWzAsIDAsIDBdLFxuICBsb29rQXQ6IFswLCAwLCAwXSxcbiAgdXA6IFswLCAwLCAxXSxcblxuICByb3RhdGlvblg6IDAsXG4gIHJvdGF0aW9uWTogMCxcblxuICBmb3Y6IDUwLFxuICBuZWFyOiAxLFxuICBmYXI6IDEwMFxufTtcblxuLyogSGVscGVycyAqL1xuXG4vLyBDb25zdHJhaW4gbnVtYmVyIGJldHdlZW4gYm91bmRzXG5mdW5jdGlvbiBjbGFtcCh4LCBtaW4sIG1heCkge1xuICByZXR1cm4geCA8IG1pbiA/IG1pbiA6ICh4ID4gbWF4ID8gbWF4IDogeCk7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUZpbml0ZSh2YWx1ZSwgZmFsbGJhY2tWYWx1ZSkge1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogZmFsbGJhY2tWYWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlyc3RQZXJzb25TdGF0ZSB7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIC8qIFZpZXdwb3J0IGFyZ3VtZW50cyAqL1xuICAgIHdpZHRoLCAvLyBXaWR0aCBvZiB2aWV3cG9ydFxuICAgIGhlaWdodCwgLy8gSGVpZ2h0IG9mIHZpZXdwb3J0XG5cbiAgICAvLyBQb3NpdGlvbiBhbmQgb3JpZW50YXRpb25cbiAgICBwb3NpdGlvbiwgLy8gdHlwaWNhbGx5IGluIG1ldGVycyBmcm9tIGFuY2hvciBwb2ludFxuICAgIGRpcmVjdGlvbixcblxuICAgIGJlYXJpbmcsIC8vIFJvdGF0aW9uIGFyb3VuZCB5IGF4aXNcbiAgICBwaXRjaCwgLy8gUm90YXRpb24gYXJvdW5kIHggYXhpc1xuXG4gICAgLy8gR2Vvc3BhdGlhbCBhbmNob3JcbiAgICBsb25naXR1ZGUsXG4gICAgbGF0aXR1ZGUsXG4gICAgem9vbSxcblxuICAgIHN5bmNCZWFyaW5nID0gdHJ1ZSwgLy8gV2hldGhlciB0byBsb2NrIGJlYXJpbmcgdG8gZGlyZWN0aW9uXG5cbiAgICAvLyBDb25zdHJhaW50cyAtIHNpbXBsZSBtb3ZlbWVudCBsaW1pdFxuICAgIC8vIEJvdW5kaW5nIGJveCBvZiB0aGUgd29ybGQsIGluIHRoZSBzaGFwZSBvZiB7bWluWCwgbWF4WCwgbWluWSwgbWF4WSwgbWluWiwgbWF4Wn1cbiAgICBib3VuZHMsXG5cbiAgICAvKiogSW50ZXJhY3Rpb24gc3RhdGVzLCByZXF1aXJlZCB0byBjYWxjdWxhdGUgY2hhbmdlIGR1cmluZyB0cmFuc2Zvcm0gKi9cbiAgICAvLyBNb2RlbCBzdGF0ZSB3aGVuIHRoZSBwYW4gb3BlcmF0aW9uIGZpcnN0IHN0YXJ0ZWRcbiAgICBzdGFydFBhbkV2ZW50UG9zaXRpb24sXG4gICAgc3RhcnRQYW5Qb3NpdGlvbixcblxuICAgIC8vIE1vZGVsIHN0YXRlIHdoZW4gdGhlIHJvdGF0ZSBvcGVyYXRpb24gZmlyc3Qgc3RhcnRlZFxuICAgIHN0YXJ0Um90YXRlQ2VudGVyLFxuICAgIHN0YXJ0Um90YXRlVmlld3BvcnQsXG5cbiAgICAvLyBNb2RlbCBzdGF0ZSB3aGVuIHRoZSB6b29tIG9wZXJhdGlvbiBmaXJzdCBzdGFydGVkXG4gICAgc3RhcnRab29tUG9zLFxuICAgIHN0YXJ0Wm9vbVxuICB9KSB7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZSh3aWR0aCksICdgd2lkdGhgIG11c3QgYmUgc3VwcGxpZWQnKTtcbiAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKGhlaWdodCksICdgaGVpZ2h0YCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgLy8gYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShkaXN0YW5jZSksICdgZGlzdGFuY2VgIG11c3QgYmUgc3VwcGxpZWQnKTtcblxuICAgIGJlYXJpbmcgPSBlbnN1cmVGaW5pdGUoYmVhcmluZywgZGVmYXVsdFN0YXRlLmJlYXJpbmcpO1xuXG4gICAgdGhpcy5fdmlld3BvcnRQcm9wcyA9IHRoaXMuX2FwcGx5Q29uc3RyYWludHMoe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBwb3NpdGlvbjogbmV3IFZlY3RvcjMoXG4gICAgICAgIGVuc3VyZUZpbml0ZShwb3NpdGlvbiAmJiBwb3NpdGlvblswXSwgZGVmYXVsdFN0YXRlLnBvc2l0aW9uWzBdKSxcbiAgICAgICAgZW5zdXJlRmluaXRlKHBvc2l0aW9uICYmIHBvc2l0aW9uWzFdLCBkZWZhdWx0U3RhdGUucG9zaXRpb25bMV0pLFxuICAgICAgICBlbnN1cmVGaW5pdGUocG9zaXRpb24gJiYgcG9zaXRpb25bMl0sIGRlZmF1bHRTdGF0ZS5wb3NpdGlvblsyXSlcbiAgICAgICksXG4gICAgICBkaXJlY3Rpb246IHRoaXMuX2dldERpcmVjdGlvbkZyb21CZWFyaW5nKGJlYXJpbmcpLFxuICAgICAgYmVhcmluZyxcbiAgICAgIHBpdGNoOiBlbnN1cmVGaW5pdGUocGl0Y2gsIGRlZmF1bHRTdGF0ZS5waXRjaCksXG4gICAgICBsb25naXR1ZGUsXG4gICAgICBsYXRpdHVkZSxcbiAgICAgIHpvb20sXG4gICAgICBib3VuZHNcbiAgICB9KTtcblxuICAgIHRoaXMuX2ludGVyYWN0aXZlU3RhdGUgPSB7XG4gICAgICBzdGFydFBhbkV2ZW50UG9zaXRpb24sXG4gICAgICBzdGFydFBhblBvc2l0aW9uLFxuICAgICAgc3RhcnRSb3RhdGVDZW50ZXIsXG4gICAgICBzdGFydFJvdGF0ZVZpZXdwb3J0LFxuICAgICAgc3RhcnRab29tUG9zLFxuICAgICAgc3RhcnRab29tXG4gICAgfTtcbiAgfVxuXG4gIC8qIFB1YmxpYyBBUEkgKi9cblxuICBnZXRWaWV3cG9ydFByb3BzKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFByb3BzO1xuICB9XG5cbiAgZ2V0SW50ZXJhY3RpdmVTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJhY3RpdmVTdGF0ZTtcbiAgfVxuXG4gIGdldExvb2tBdCgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgcGFubmluZ1xuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgcG9pbnRlciBncmFic1xuICAgKi9cbiAgcGFuU3RhcnQoe3Bvc30pIHtcbiAgICBjb25zdCB7dHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvbll9ID0gdGhpcy5fdmlld3BvcnRQcm9wcztcblxuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgc3RhcnRQYW5Qb3NpdGlvbjogW3RyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZXSxcbiAgICAgIHN0YXJ0UGFuRXZlbnRQb3NpdGlvbjogcG9zXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFuXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBwb2ludGVyIGlzXG4gICAqL1xuICBwYW4oe3Bvcywgc3RhcnRQb3N9KSB7XG4gICAgY29uc3Qgc3RhcnRQYW5FdmVudFBvc2l0aW9uID0gdGhpcy5faW50ZXJhY3RpdmVTdGF0ZS5zdGFydFBhbkV2ZW50UG9zaXRpb24gfHwgc3RhcnRQb3M7XG4gICAgYXNzZXJ0KHN0YXJ0UGFuRXZlbnRQb3NpdGlvbiwgJ2BzdGFydFBhbkV2ZW50UG9zaXRpb25gIHByb3BzIGlzIHJlcXVpcmVkJyk7XG5cbiAgICBsZXQgW3RyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZXSA9IHRoaXMuX2ludGVyYWN0aXZlU3RhdGUuc3RhcnRQYW5Qb3NpdGlvbiB8fCBbXTtcbiAgICB0cmFuc2xhdGlvblggPSBlbnN1cmVGaW5pdGUodHJhbnNsYXRpb25YLCB0aGlzLl92aWV3cG9ydFByb3BzLnRyYW5zbGF0aW9uWCk7XG4gICAgdHJhbnNsYXRpb25ZID0gZW5zdXJlRmluaXRlKHRyYW5zbGF0aW9uWSwgdGhpcy5fdmlld3BvcnRQcm9wcy50cmFuc2xhdGlvblkpO1xuXG4gICAgY29uc3QgZGVsdGFYID0gcG9zWzBdIC0gc3RhcnRQYW5FdmVudFBvc2l0aW9uWzBdO1xuICAgIGNvbnN0IGRlbHRhWSA9IHBvc1sxXSAtIHN0YXJ0UGFuRXZlbnRQb3NpdGlvblsxXTtcblxuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgdHJhbnNsYXRpb25YOiB0cmFuc2xhdGlvblggKyBkZWx0YVgsXG4gICAgICB0cmFuc2xhdGlvblk6IHRyYW5zbGF0aW9uWSAtIGRlbHRhWVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCBwYW5uaW5nXG4gICAqIE11c3QgY2FsbCBpZiBgcGFuU3RhcnQoKWAgd2FzIGNhbGxlZFxuICAgKi9cbiAgcGFuRW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgc3RhcnRQYW5Qb3NpdGlvbjogbnVsbCxcbiAgICAgIHN0YXJ0UGFuUG9zOiBudWxsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgcm90YXRpbmdcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIHBvaW50ZXIgZ3JhYnNcbiAgICovXG4gIHJvdGF0ZVN0YXJ0KHtwb3N9KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBzdGFydFJvdGF0ZUNlbnRlcjogdGhpcy5fdmlld3BvcnRQcm9wcy5wb3NpdGlvbixcbiAgICAgIHN0YXJ0Um90YXRlVmlld3BvcnQ6IHRoaXMuX3ZpZXdwb3J0UHJvcHNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb3RhdGVcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIHBvaW50ZXIgaXNcbiAgICovXG4gIHJvdGF0ZSh7ZGVsdGFTY2FsZVgsIGRlbHRhU2NhbGVZfSkge1xuICAgIGNvbnN0IHtkaXJlY3Rpb259ID0gdGhpcy5fdmlld3BvcnRQcm9wcztcblxuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgZGlyZWN0aW9uOiBuZXcgVmVjdG9yMyhkaXJlY3Rpb24pLnJvdGF0ZVooe3JhZGlhbnM6IGRlbHRhU2NhbGVYIC8gNTB9KVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCByb3RhdGluZ1xuICAgKiBNdXN0IGNhbGwgaWYgYHJvdGF0ZVN0YXJ0KClgIHdhcyBjYWxsZWRcbiAgICovXG4gIHJvdGF0ZUVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHN0YXJ0Um90YXRlQ2VudGVyOiBudWxsLFxuICAgICAgc3RhcnRSb3RhdGVWaWV3cG9ydDogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHpvb21pbmdcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIHBvaW50ZXIgZ3JhYnNcbiAgICovXG4gIHpvb21TdGFydCh7cG9zfSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgc3RhcnRab29tUG9zOiBwb3MsXG4gICAgICBzdGFydFpvb206IHRoaXMuX3ZpZXdwb3J0UHJvcHMuem9vbVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFpvb21cbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIGN1cnJlbnQgY2VudGVyIGlzXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gc3RhcnRQb3MgLSB0aGUgY2VudGVyIHBvc2l0aW9uIGF0XG4gICAqICAgdGhlIHN0YXJ0IG9mIHRoZSBvcGVyYXRpb24uIE11c3QgYmUgc3VwcGxpZWQgb2YgYHpvb21TdGFydCgpYCB3YXMgbm90IGNhbGxlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBhIG51bWJlciBiZXR3ZWVuIFswLCAxXSBzcGVjaWZ5aW5nIHRoZSBhY2N1bXVsYXRlZFxuICAgKiAgIHJlbGF0aXZlIHNjYWxlLlxuICAgKi9cbiAgem9vbSh7cG9zLCBzdGFydFBvcywgc2NhbGV9KSB7XG4gICAgY29uc3Qge3pvb20sIG1pblpvb20sIG1heFpvb20sIHdpZHRoLCBoZWlnaHQsIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZfSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG5cbiAgICBjb25zdCBzdGFydFpvb21Qb3MgPSB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlLnN0YXJ0Wm9vbVBvcyB8fCBzdGFydFBvcyB8fCBwb3M7XG5cbiAgICBjb25zdCBuZXdab29tID0gY2xhbXAoem9vbSAqIHNjYWxlLCBtaW5ab29tLCBtYXhab29tKTtcbiAgICBjb25zdCBkZWx0YVggPSBwb3NbMF0gLSBzdGFydFpvb21Qb3NbMF07XG4gICAgY29uc3QgZGVsdGFZID0gcG9zWzFdIC0gc3RhcnRab29tUG9zWzFdO1xuXG4gICAgLy8gWm9vbSBhcm91bmQgdGhlIGNlbnRlciBwb3NpdGlvblxuICAgIGNvbnN0IGN4ID0gc3RhcnRab29tUG9zWzBdIC0gd2lkdGggLyAyO1xuICAgIGNvbnN0IGN5ID0gaGVpZ2h0IC8gMiAtIHN0YXJ0Wm9vbVBvc1sxXTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgIGNvbnN0IG5ld1RyYW5zbGF0aW9uWCA9IGN4IC0gKGN4IC0gdHJhbnNsYXRpb25YKSAqIG5ld1pvb20gLyB6b29tICsgZGVsdGFYO1xuICAgIGNvbnN0IG5ld1RyYW5zbGF0aW9uWSA9IGN5IC0gKGN5IC0gdHJhbnNsYXRpb25ZKSAqIG5ld1pvb20gLyB6b29tIC0gZGVsdGFZO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuICAgIC8vIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgIC8vICAgcG9zaXRpb25cbiAgICAvLyAgIHRyYW5zbGF0aW9uWDogbmV3VHJhbnNsYXRpb25YLFxuICAgIC8vICAgdHJhbnNsYXRpb25ZOiBuZXdUcmFuc2xhdGlvbllcbiAgICAvLyB9KTtcblxuICAgIC8vIFRPRE8gSEFDS1xuICAgIHJldHVybiBuZXdab29tIC8gem9vbSA8IDEgPyB0aGlzLm1vdmVCYWNrd2FyZCgpIDogdGhpcy5tb3ZlRm9yd2FyZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCB6b29taW5nXG4gICAqIE11c3QgY2FsbCBpZiBgem9vbVN0YXJ0KClgIHdhcyBjYWxsZWRcbiAgICovXG4gIHpvb21FbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBzdGFydFpvb21Qb3M6IG51bGwsXG4gICAgICBzdGFydFpvb206IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIF9nZXREaXJlY3Rpb25Gcm9tQmVhcmluZyhiZWFyaW5nKSB7XG4gICAgY29uc3Qgc3BoZXJpY2FsID0gbmV3IFNwaGVyaWNhbENvb3JkaW5hdGVzKHtcbiAgICAgIGJlYXJpbmcsXG4gICAgICBwaXRjaDogOTBcbiAgICB9KTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBzcGhlcmljYWwudG9WZWN0b3IzKCkubm9ybWFsaXplKCk7XG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxuXG4gIG1vdmVMZWZ0KCkge1xuICAgIC8vIGNvbnN0IHtwb3NpdGlvbiwgZGlyZWN0aW9ufSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG4gICAgLy8gY29uc3QgbmV3RGlyZWN0aW9uID0gbmV3IFZlY3RvcjMoZGlyZWN0aW9uKS5yb3RhdGVaKHtyYWRpYW5zOiBST1RBVElPTl9TVEVQX1JBRElBTlN9KTtcbiAgICAvLyByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAvLyAgIGRpcmVjdGlvbjogbmV3RGlyZWN0aW9uLFxuICAgIC8vICAgbG9va0F0OiBuZXcgVmVjdG9yMyhwb3NpdGlvbikuYWRkKG5ld0RpcmVjdGlvbi5ub3JtYWxpemUoKSksXG4gICAgLy8gICBiZWFyaW5nOiB0aGlzLl92aWV3cG9ydFByb3BzLmJlYXJpbmcgLSBST1RBVElPTl9TVEVQX0RFR1JFRVNcbiAgICAvLyB9KTtcblxuICAgIGNvbnN0IHtwb3NpdGlvbiwgYmVhcmluZ30gPSB0aGlzLl92aWV3cG9ydFByb3BzO1xuICAgIGNvbnN0IG5ld0JlYXJpbmcgPSBiZWFyaW5nIC0gUk9UQVRJT05fU1RFUF9ERUdSRUVTO1xuICAgIGNvbnN0IG5ld0RpcmVjdGlvbiA9IHRoaXMuX2dldERpcmVjdGlvbkZyb21CZWFyaW5nKG5ld0JlYXJpbmcpO1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgZGlyZWN0aW9uOiBuZXdEaXJlY3Rpb24sXG4gICAgICBsb29rQXQ6IG5ldyBWZWN0b3IzKHBvc2l0aW9uKS5hZGQobmV3RGlyZWN0aW9uKSxcbiAgICAgIGJlYXJpbmc6IG5ld0JlYXJpbmdcbiAgICB9KTtcbiAgfVxuXG4gIG1vdmVSaWdodCgpIHtcbiAgICAvLyBjb25zdCB7cG9zaXRpb24sIGRpcmVjdGlvbn0gPSB0aGlzLl92aWV3cG9ydFByb3BzO1xuICAgIC8vIGNvbnN0IG5ld0RpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKGRpcmVjdGlvbikucm90YXRlWih7cmFkaWFuczogLVJPVEFUSU9OX1NURVBfUkFESUFOU30pO1xuICAgIC8vIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgIC8vICAgZGlyZWN0aW9uOiBuZXdEaXJlY3Rpb24sXG4gICAgLy8gICBsb29rQXQ6IG5ldyBWZWN0b3IzKHBvc2l0aW9uKS5hZGQobmV3RGlyZWN0aW9uLm5vcm1hbGl6ZSgpKSxcbiAgICAvLyAgIGJlYXJpbmc6IHRoaXMuX3ZpZXdwb3J0UHJvcHMuYmVhcmluZyArIFJPVEFUSU9OX1NURVBfREVHUkVFU1xuICAgIC8vIH0pO1xuXG4gICAgY29uc3Qge3Bvc2l0aW9uLCBiZWFyaW5nfSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG4gICAgY29uc3QgbmV3QmVhcmluZyA9IGJlYXJpbmcgKyBST1RBVElPTl9TVEVQX0RFR1JFRVM7XG4gICAgY29uc3QgbmV3RGlyZWN0aW9uID0gdGhpcy5fZ2V0RGlyZWN0aW9uRnJvbUJlYXJpbmcobmV3QmVhcmluZyk7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBkaXJlY3Rpb246IG5ld0RpcmVjdGlvbixcbiAgICAgIGxvb2tBdDogbmV3IFZlY3RvcjMocG9zaXRpb24pLmFkZChuZXdEaXJlY3Rpb24pLFxuICAgICAgYmVhcmluZzogbmV3QmVhcmluZ1xuICAgIH0pO1xuICB9XG5cbiAgbW92ZUZvcndhcmQoKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCBkaXJlY3Rpb259ID0gdGhpcy5fdmlld3BvcnRQcm9wcztcbiAgICBjb25zdCBkZWx0YSA9IG5ldyBWZWN0b3IzKGRpcmVjdGlvbikubm9ybWFsaXplKCkuc2NhbGUoTU9WRU1FTlRfU1BFRUQpO1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgLy8gcGl0Y2g6IHRoaXMuX3ZpZXdwb3J0UHJvcHMucGl0Y2ggKyAzXG4gICAgICBwb3NpdGlvbjogbmV3IFZlY3RvcjMocG9zaXRpb24pLmFkZChkZWx0YSksXG4gICAgICBsb29rQXQ6IG5ldyBWZWN0b3IzKHBvc2l0aW9uKS5hZGQoZGlyZWN0aW9uKVxuICAgIH0pO1xuICB9XG5cbiAgbW92ZUJhY2t3YXJkKCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgZGlyZWN0aW9ufSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG4gICAgY29uc3QgZGVsdGEgPSBuZXcgVmVjdG9yMyhkaXJlY3Rpb24pLm5vcm1hbGl6ZSgpLnNjYWxlKC1NT1ZFTUVOVF9TUEVFRCk7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICAvLyBwaXRjaDogdGhpcy5fdmlld3BvcnRQcm9wcy5waXRjaCAtIDNcbiAgICAgIHBvc2l0aW9uOiBuZXcgVmVjdG9yMyhwb3NpdGlvbikuYWRkKGRlbHRhKSxcbiAgICAgIGxvb2tBdDogbmV3IFZlY3RvcjMocG9zaXRpb24pLmFkZChkaXJlY3Rpb24pXG4gICAgfSk7XG4gIH1cblxuICBtb3ZlVXAoKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCBkaXJlY3Rpb259ID0gdGhpcy5fdmlld3BvcnRQcm9wcztcbiAgICBjb25zdCBkZWx0YSA9IFswLCAwLCAxXTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIC8vIHBpdGNoOiB0aGlzLl92aWV3cG9ydFByb3BzLnBpdGNoICsgM1xuICAgICAgcG9zaXRpb246IG5ldyBWZWN0b3IzKHBvc2l0aW9uKS5hZGQoZGVsdGEpLFxuICAgICAgbG9va0F0OiBuZXcgVmVjdG9yMyhwb3NpdGlvbikuYWRkKGRpcmVjdGlvbilcbiAgICB9KTtcbiAgfVxuXG4gIG1vdmVEb3duKCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgZGlyZWN0aW9ufSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG4gICAgY29uc3QgZGVsdGEgPSBwb3NpdGlvblsyXSA+PSAxID8gWzAsIDAsIC0xXSA6IFswLCAwLCAwXTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIC8vIHBpdGNoOiB0aGlzLl92aWV3cG9ydFByb3BzLnBpdGNoICsgM1xuICAgICAgcG9zaXRpb246IG5ldyBWZWN0b3IzKHBvc2l0aW9uKS5hZGQoZGVsdGEpLFxuICAgICAgbG9va0F0OiBuZXcgVmVjdG9yMyhwb3NpdGlvbikuYWRkKGRpcmVjdGlvbilcbiAgICB9KTtcbiAgfVxuXG4gIHpvb21JbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHpvb206IHRoaXMuX3ZpZXdwb3J0UHJvcHMuem9vbSArIDAuMlxuICAgIH0pO1xuICB9XG5cbiAgem9vbU91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHpvb206IHRoaXMuX3ZpZXdwb3J0UHJvcHMuem9vbSAtIDAuMlxuICAgIH0pO1xuICB9XG5cbiAgLyogUHJpdmF0ZSBtZXRob2RzICovXG5cbiAgX2dldFVwZGF0ZWRTdGF0ZShuZXdQcm9wcykge1xuICAgIC8vIFVwZGF0ZSBfdmlld3BvcnRQcm9wc1xuICAgIHJldHVybiBuZXcgRmlyc3RQZXJzb25TdGF0ZShcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3ZpZXdwb3J0UHJvcHMsIHRoaXMuX2ludGVyYWN0aXZlU3RhdGUsIG5ld1Byb3BzKVxuICAgICk7XG4gIH1cblxuICAvLyBBcHBseSBhbnkgY29uc3RyYWludHMgKG1hdGhlbWF0aWNhbCBvciBkZWZpbmVkIGJ5IF92aWV3cG9ydFByb3BzKSB0byBtYXAgc3RhdGVcbiAgX2FwcGx5Q29uc3RyYWludHMocHJvcHMpIHtcbiAgICAvLyBUT0RPL2liIC0gRW5zdXJlIHBvc2l0aW9uIGlzIHdpdGhpbiBib3VuZHNcbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cbn1cbiJdfQ==