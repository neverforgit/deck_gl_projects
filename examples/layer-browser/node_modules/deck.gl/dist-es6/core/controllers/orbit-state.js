var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import OrbitViewport from '../viewports/orbit-viewport';
import vec3_add from 'gl-vec3/add';
import vec3_scale from 'gl-vec3/scale';
import vec3_lerp from 'gl-vec3/lerp';
import assert from 'assert';

var defaultState = {
  lookAt: [0, 0, 0],
  rotationX: 0,
  rotationY: 0,
  fov: 50,
  near: 1,
  far: 100,
  translationX: 0,
  translationY: 0,
  zoom: 1
};

var defaultConstraints = {
  minZoom: 0,
  maxZoom: Infinity
};

/* Helpers */

// Whether number is between bounds
function inRange(x, min, max) {
  return x >= min && x <= max;
}
// Constrain number between bounds
function clamp(x, min, max) {
  return x < min ? min : x > max ? max : x;
}
// Get ratio of x on domain
function interpolate(x, domain0, domain1) {
  if (domain0 === domain1) {
    return x === domain0 ? 0 : Infinity;
  }
  return (x - domain0) / (domain1 - domain0);
}

function ensureFinite(value, fallbackValue) {
  return Number.isFinite(value) ? value : fallbackValue;
}

var OrbitState = function () {
  function OrbitState(_ref) {
    var width = _ref.width,
        height = _ref.height,
        distance = _ref.distance,
        rotationX = _ref.rotationX,
        rotationY = _ref.rotationY,
        bounds = _ref.bounds,
        lookAt = _ref.lookAt,
        fov = _ref.fov,
        near = _ref.near,
        far = _ref.far,
        translationX = _ref.translationX,
        translationY = _ref.translationY,
        zoom = _ref.zoom,
        minZoom = _ref.minZoom,
        maxZoom = _ref.maxZoom,
        startPanPos = _ref.startPanPos,
        startPanTranslation = _ref.startPanTranslation,
        startRotateCenter = _ref.startRotateCenter,
        startRotateViewport = _ref.startRotateViewport,
        startZoomPos = _ref.startZoomPos,
        startZoom = _ref.startZoom;

    _classCallCheck(this, OrbitState);

    assert(Number.isFinite(width), '`width` must be supplied');
    assert(Number.isFinite(height), '`height` must be supplied');
    assert(Number.isFinite(distance), '`distance` must be supplied');

    this._viewportProps = this._applyConstraints({
      width: width,
      height: height,
      distance: distance,
      rotationX: ensureFinite(rotationX, defaultState.rotationX),
      rotationY: ensureFinite(rotationY, defaultState.rotationY),

      bounds: bounds,
      lookAt: lookAt || defaultState.lookAt,

      fov: ensureFinite(fov, defaultState.fov),
      near: ensureFinite(near, defaultState.near),
      far: ensureFinite(far, defaultState.far),
      translationX: ensureFinite(translationX, defaultState.translationX),
      translationY: ensureFinite(translationY, defaultState.translationY),
      zoom: ensureFinite(zoom, defaultState.zoom),

      minZoom: ensureFinite(minZoom, defaultConstraints.minZoom),
      maxZoom: ensureFinite(maxZoom, defaultConstraints.maxZoom)
    });

    this._interactiveState = {
      startPanPos: startPanPos,
      startPanTranslation: startPanTranslation,
      startRotateCenter: startRotateCenter,
      startRotateViewport: startRotateViewport,
      startZoomPos: startZoomPos,
      startZoom: startZoom
    };
  }

  /* Public API */

  _createClass(OrbitState, [{
    key: 'getViewportProps',
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: 'getInteractiveState',
    value: function getInteractiveState() {
      return this._interactiveState;
    }

    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'panStart',
    value: function panStart(_ref2) {
      var pos = _ref2.pos;
      var _viewportProps = this._viewportProps,
          translationX = _viewportProps.translationX,
          translationY = _viewportProps.translationY;


      return this._getUpdatedOrbitState({
        startPanTranslation: [translationX, translationY],
        startPanPos: pos
      });
    }

    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */

  }, {
    key: 'pan',
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;

      var startPanPos = this._interactiveState.startPanPos || startPos;
      assert(startPanPos, '`startPanPos` props is required');

      var _ref4 = this._interactiveState.startPanTranslation || [],
          _ref5 = _slicedToArray(_ref4, 2),
          translationX = _ref5[0],
          translationY = _ref5[1];

      translationX = ensureFinite(translationX, this._viewportProps.translationX);
      translationY = ensureFinite(translationY, this._viewportProps.translationY);

      var deltaX = pos[0] - startPanPos[0];
      var deltaY = pos[1] - startPanPos[1];

      return this._getUpdatedOrbitState({
        translationX: translationX + deltaX,
        translationY: translationY - deltaY
      });
    }

    /**
     * End panning
     * Must call if `panStart()` was called
     */

  }, {
    key: 'panEnd',
    value: function panEnd() {
      return this._getUpdatedOrbitState({
        startPanTranslation: null,
        startPanPos: null
      });
    }

    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'rotateStart',
    value: function rotateStart(_ref6) {
      var pos = _ref6.pos;

      // Rotation center should be the worldspace position at the center of the
      // the screen. If not found, use the last one.
      var startRotateCenter = this._getLocationAtCenter() || this._interactiveState.startRotateCenter;

      return this._getUpdatedOrbitState({
        startRotateCenter: startRotateCenter,
        startRotateViewport: this._viewportProps
      });
    }

    /**
     * Rotate
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */

  }, {
    key: 'rotate',
    value: function rotate(_ref7) {
      var deltaScaleX = _ref7.deltaScaleX,
          deltaScaleY = _ref7.deltaScaleY;
      var _interactiveState = this._interactiveState,
          startRotateCenter = _interactiveState.startRotateCenter,
          startRotateViewport = _interactiveState.startRotateViewport;

      var _ref8 = startRotateViewport || {},
          rotationX = _ref8.rotationX,
          rotationY = _ref8.rotationY,
          translationX = _ref8.translationX,
          translationY = _ref8.translationY;

      rotationX = ensureFinite(rotationX, this._viewportProps.rotationX);
      rotationY = ensureFinite(rotationY, this._viewportProps.rotationY);
      translationX = ensureFinite(translationX, this._viewportProps.translationX);
      translationY = ensureFinite(translationY, this._viewportProps.translationY);

      var newRotationX = clamp(rotationX - deltaScaleY * 180, -89.999, 89.999);
      var newRotationY = (rotationY - deltaScaleX * 180) % 360;

      var newTranslationX = translationX;
      var newTranslationY = translationY;

      if (startRotateCenter) {
        // Keep rotation center at the center of the screen
        var oldViewport = new OrbitViewport(startRotateViewport);
        var oldCenterPos = oldViewport.project(startRotateCenter);

        var newViewport = new OrbitViewport(Object.assign({}, startRotateViewport, {
          rotationX: newRotationX,
          rotationY: newRotationY
        }));
        var newCenterPos = newViewport.project(startRotateCenter);

        newTranslationX += oldCenterPos[0] - newCenterPos[0];
        newTranslationY -= oldCenterPos[1] - newCenterPos[1];
      }

      return this._getUpdatedOrbitState({
        rotationX: newRotationX,
        rotationY: newRotationY,
        translationX: newTranslationX,
        translationY: newTranslationY
      });
    }

    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */

  }, {
    key: 'rotateEnd',
    value: function rotateEnd() {
      return this._getUpdatedOrbitState({
        startRotateCenter: null,
        startRotateViewport: null
      });
    }

    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'zoomStart',
    value: function zoomStart(_ref9) {
      var pos = _ref9.pos;

      return this._getUpdatedOrbitState({
        startZoomPos: pos,
        startZoom: this._viewportProps.zoom
      });
    }

    /**
     * Zoom
     * @param {[Number, Number]} pos - position on screen where the current center is
     * @param {[Number, Number]} startPos - the center position at
     *   the start of the operation. Must be supplied of `zoomStart()` was not called
     * @param {Number} scale - a number between [0, 1] specifying the accumulated
     *   relative scale.
     */

  }, {
    key: 'zoom',
    value: function zoom(_ref10) {
      var pos = _ref10.pos,
          startPos = _ref10.startPos,
          scale = _ref10.scale;
      var _viewportProps2 = this._viewportProps,
          zoom = _viewportProps2.zoom,
          minZoom = _viewportProps2.minZoom,
          maxZoom = _viewportProps2.maxZoom,
          width = _viewportProps2.width,
          height = _viewportProps2.height,
          translationX = _viewportProps2.translationX,
          translationY = _viewportProps2.translationY;


      var startZoomPos = this._interactiveState.startZoomPos || startPos || pos;

      var newZoom = clamp(zoom * scale, minZoom, maxZoom);
      var deltaX = pos[0] - startZoomPos[0];
      var deltaY = pos[1] - startZoomPos[1];

      // Zoom around the center position
      var cx = startZoomPos[0] - width / 2;
      var cy = height / 2 - startZoomPos[1];
      var newTranslationX = cx - (cx - translationX) * newZoom / zoom + deltaX;
      var newTranslationY = cy - (cy - translationY) * newZoom / zoom - deltaY;

      return this._getUpdatedOrbitState({
        zoom: newZoom,
        translationX: newTranslationX,
        translationY: newTranslationY
      });
    }

    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */

  }, {
    key: 'zoomEnd',
    value: function zoomEnd() {
      return this._getUpdatedOrbitState({
        startZoomPos: null,
        startZoom: null
      });
    }

    /* Private methods */

  }, {
    key: '_getUpdatedOrbitState',
    value: function _getUpdatedOrbitState(newProps) {
      // Update _viewportProps
      return new OrbitState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }

    // Apply any constraints (mathematical or defined by _viewportProps) to map state

  }, {
    key: '_applyConstraints',
    value: function _applyConstraints(props) {
      // Ensure zoom is within specified range
      var maxZoom = props.maxZoom,
          minZoom = props.minZoom,
          zoom = props.zoom;

      props.zoom = zoom > maxZoom ? maxZoom : zoom;
      props.zoom = zoom < minZoom ? minZoom : zoom;

      return props;
    }

    /* Cast a ray into the screen center and take the average of all
     * intersections with the bounding box:
     *
     *                         (x=w/2)
     *                          .
     *                          .
     *   (bounding box)         .
     *           _-------------_.
     *          | "-_           :-_
     *         |     "-_        .  "-_
     *        |         "-------+-----:
     *       |.........|........C....|............. (y=h/2)
     *      |         |         .   |
     *     |         |          .  |
     *    |         |           . |
     *   |         |            .|
     *  |         |             |                      Y
     *   "-_     |             |.             Z       |
     *      "-_ |             | .              "-_   |
     *         "-------------"                    "-|_____ X
     */

  }, {
    key: '_getLocationAtCenter',
    value: function _getLocationAtCenter() {
      var _viewportProps3 = this._viewportProps,
          width = _viewportProps3.width,
          height = _viewportProps3.height,
          bounds = _viewportProps3.bounds;


      if (!bounds) {
        return null;
      }

      var viewport = new OrbitViewport(this._viewportProps);

      var C0 = viewport.unproject([width / 2, height / 2, 0]);
      var C1 = viewport.unproject([width / 2, height / 2, 1]);
      var sum = [0, 0, 0];
      var count = 0;

      [
      // depth at intersection with X = minX
      interpolate(bounds.minX, C0[0], C1[0]),
      // depth at intersection with X = maxX
      interpolate(bounds.maxX, C0[0], C1[0]),
      // depth at intersection with Y = minY
      interpolate(bounds.minY, C0[1], C1[1]),
      // depth at intersection with Y = maxY
      interpolate(bounds.maxY, C0[1], C1[1]),
      // depth at intersection with Z = minZ
      interpolate(bounds.minZ, C0[2], C1[2]),
      // depth at intersection with Z = maxZ
      interpolate(bounds.maxZ, C0[2], C1[2])].forEach(function (d) {
        // worldspace position of the intersection
        var C = vec3_lerp([], C0, C1, d);
        // check if position is on the bounding box
        if (inRange(C[0], bounds.minX, bounds.maxX) && inRange(C[1], bounds.minY, bounds.maxY) && inRange(C[2], bounds.minZ, bounds.maxZ)) {
          count++;
          vec3_add(sum, sum, C);
        }
      });

      return count > 0 ? vec3_scale([], sum, 1 / count) : null;
    }
  }]);

  return OrbitState;
}();

export default OrbitState;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2NvbnRyb2xsZXJzL29yYml0LXN0YXRlLmpzIl0sIm5hbWVzIjpbIk9yYml0Vmlld3BvcnQiLCJ2ZWMzX2FkZCIsInZlYzNfc2NhbGUiLCJ2ZWMzX2xlcnAiLCJhc3NlcnQiLCJkZWZhdWx0U3RhdGUiLCJsb29rQXQiLCJyb3RhdGlvblgiLCJyb3RhdGlvblkiLCJmb3YiLCJuZWFyIiwiZmFyIiwidHJhbnNsYXRpb25YIiwidHJhbnNsYXRpb25ZIiwiem9vbSIsImRlZmF1bHRDb25zdHJhaW50cyIsIm1pblpvb20iLCJtYXhab29tIiwiSW5maW5pdHkiLCJpblJhbmdlIiwieCIsIm1pbiIsIm1heCIsImNsYW1wIiwiaW50ZXJwb2xhdGUiLCJkb21haW4wIiwiZG9tYWluMSIsImVuc3VyZUZpbml0ZSIsInZhbHVlIiwiZmFsbGJhY2tWYWx1ZSIsIk51bWJlciIsImlzRmluaXRlIiwiT3JiaXRTdGF0ZSIsIndpZHRoIiwiaGVpZ2h0IiwiZGlzdGFuY2UiLCJib3VuZHMiLCJzdGFydFBhblBvcyIsInN0YXJ0UGFuVHJhbnNsYXRpb24iLCJzdGFydFJvdGF0ZUNlbnRlciIsInN0YXJ0Um90YXRlVmlld3BvcnQiLCJzdGFydFpvb21Qb3MiLCJzdGFydFpvb20iLCJfdmlld3BvcnRQcm9wcyIsIl9hcHBseUNvbnN0cmFpbnRzIiwiX2ludGVyYWN0aXZlU3RhdGUiLCJwb3MiLCJfZ2V0VXBkYXRlZE9yYml0U3RhdGUiLCJzdGFydFBvcyIsImRlbHRhWCIsImRlbHRhWSIsIl9nZXRMb2NhdGlvbkF0Q2VudGVyIiwiZGVsdGFTY2FsZVgiLCJkZWx0YVNjYWxlWSIsIm5ld1JvdGF0aW9uWCIsIm5ld1JvdGF0aW9uWSIsIm5ld1RyYW5zbGF0aW9uWCIsIm5ld1RyYW5zbGF0aW9uWSIsIm9sZFZpZXdwb3J0Iiwib2xkQ2VudGVyUG9zIiwicHJvamVjdCIsIm5ld1ZpZXdwb3J0IiwiT2JqZWN0IiwiYXNzaWduIiwibmV3Q2VudGVyUG9zIiwic2NhbGUiLCJuZXdab29tIiwiY3giLCJjeSIsIm5ld1Byb3BzIiwicHJvcHMiLCJ2aWV3cG9ydCIsIkMwIiwidW5wcm9qZWN0IiwiQzEiLCJzdW0iLCJjb3VudCIsIm1pblgiLCJtYXhYIiwibWluWSIsIm1heFkiLCJtaW5aIiwibWF4WiIsImZvckVhY2giLCJDIiwiZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsT0FBT0EsYUFBUCxNQUEwQiw2QkFBMUI7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLGFBQXJCO0FBQ0EsT0FBT0MsVUFBUCxNQUF1QixlQUF2QjtBQUNBLE9BQU9DLFNBQVAsTUFBc0IsY0FBdEI7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLFFBQW5COztBQUVBLElBQU1DLGVBQWU7QUFDbkJDLFVBQVEsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FEVztBQUVuQkMsYUFBVyxDQUZRO0FBR25CQyxhQUFXLENBSFE7QUFJbkJDLE9BQUssRUFKYztBQUtuQkMsUUFBTSxDQUxhO0FBTW5CQyxPQUFLLEdBTmM7QUFPbkJDLGdCQUFjLENBUEs7QUFRbkJDLGdCQUFjLENBUks7QUFTbkJDLFFBQU07QUFUYSxDQUFyQjs7QUFZQSxJQUFNQyxxQkFBcUI7QUFDekJDLFdBQVMsQ0FEZ0I7QUFFekJDLFdBQVNDO0FBRmdCLENBQTNCOztBQUtBOztBQUVBO0FBQ0EsU0FBU0MsT0FBVCxDQUFpQkMsQ0FBakIsRUFBb0JDLEdBQXBCLEVBQXlCQyxHQUF6QixFQUE4QjtBQUM1QixTQUFPRixLQUFLQyxHQUFMLElBQVlELEtBQUtFLEdBQXhCO0FBQ0Q7QUFDRDtBQUNBLFNBQVNDLEtBQVQsQ0FBZUgsQ0FBZixFQUFrQkMsR0FBbEIsRUFBdUJDLEdBQXZCLEVBQTRCO0FBQzFCLFNBQU9GLElBQUlDLEdBQUosR0FBVUEsR0FBVixHQUFpQkQsSUFBSUUsR0FBSixHQUFVQSxHQUFWLEdBQWdCRixDQUF4QztBQUNEO0FBQ0Q7QUFDQSxTQUFTSSxXQUFULENBQXFCSixDQUFyQixFQUF3QkssT0FBeEIsRUFBaUND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SWpGLFVBQVUsRUFBVixFQUFjcUUsRUFBZCxFQUFrQkUsRUFBbEIsRUFBc0JXLENBQXRCLENBQVY7QUFDQTtBQUNBLFlBQUlsRSxRQUFRaUUsRUFBRSxDQUFGLENBQVIsRUFBY2hELE9BQU95QyxJQUFyQixFQUEyQnpDLE9BQU8wQyxJQUFsQyxLQUNBM0QsUUFBUWlFLEVBQUUsQ0FBRixDQUFSLEVBQWNoRCxPQUFPMkMsSUFBckIsRUFBMkIzQyxPQUFPNEMsSUFBbEMsQ0FEQSxJQUVBN0QsUUFBUWlFLEVBQUUsQ0FBRixDQUFSLEVBQWNoRCxPQUFPNkMsSUFBckIsRUFBMkI3QyxPQUFPOEMsSUFBbEMsQ0FGSixFQUU2QztBQUMzQ047QUFDQTNFLG1CQUFTMEUsR0FBVCxFQUFjQSxHQUFkLEVBQW1CUyxDQUFuQjtBQUNEO0FBQ0YsT0F2QkQ7O0FBeUJBLGFBQU9SLFFBQVEsQ0FBUixHQUFZMUUsV0FBVyxFQUFYLEVBQWV5RSxHQUFmLEVBQW9CLElBQUlDLEtBQXhCLENBQVosR0FBNkMsSUFBcEQ7QUFDRDs7Ozs7O2VBMVVrQjVDLFUiLCJmaWxlIjoib3JiaXQtc3RhdGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgT3JiaXRWaWV3cG9ydCBmcm9tICcuLi92aWV3cG9ydHMvb3JiaXQtdmlld3BvcnQnO1xuaW1wb3J0IHZlYzNfYWRkIGZyb20gJ2dsLXZlYzMvYWRkJztcbmltcG9ydCB2ZWMzX3NjYWxlIGZyb20gJ2dsLXZlYzMvc2NhbGUnO1xuaW1wb3J0IHZlYzNfbGVycCBmcm9tICdnbC12ZWMzL2xlcnAnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gIGxvb2tBdDogWzAsIDAsIDBdLFxuICByb3RhdGlvblg6IDAsXG4gIHJvdGF0aW9uWTogMCxcbiAgZm92OiA1MCxcbiAgbmVhcjogMSxcbiAgZmFyOiAxMDAsXG4gIHRyYW5zbGF0aW9uWDogMCxcbiAgdHJhbnNsYXRpb25ZOiAwLFxuICB6b29tOiAxXG59O1xuXG5jb25zdCBkZWZhdWx0Q29uc3RyYWludHMgPSB7XG4gIG1pblpvb206IDAsXG4gIG1heFpvb206IEluZmluaXR5XG59O1xuXG4vKiBIZWxwZXJzICovXG5cbi8vIFdoZXRoZXIgbnVtYmVyIGlzIGJldHdlZW4gYm91bmRzXG5mdW5jdGlvbiBpblJhbmdlKHgsIG1pbiwgbWF4KSB7XG4gIHJldHVybiB4ID49IG1pbiAmJiB4IDw9IG1heDtcbn1cbi8vIENvbnN0cmFpbiBudW1iZXIgYmV0d2VlbiBib3VuZHNcbmZ1bmN0aW9uIGNsYW1wKHgsIG1pbiwgbWF4KSB7XG4gIHJldHVybiB4IDwgbWluID8gbWluIDogKHggPiBtYXggPyBtYXggOiB4KTtcbn1cbi8vIEdldCByYXRpbyBvZiB4IG9uIGRvbWFpblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoeCwgZG9tYWluMCwgZG9tYWluMSkge1xuICBpZiAoZG9tYWluMCA9PT0gZG9tYWluMSkge1xuICAgIHJldHVybiB4ID09PSBkb21haW4wID8gMCA6IEluZmluaXR5O1xuICB9XG4gIHJldHVybiAoeCAtIGRvbWFpbjApIC8gKGRvbWFpbjEgLSBkb21haW4wKTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlRmluaXRlKHZhbHVlLCBmYWxsYmFja1ZhbHVlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBmYWxsYmFja1ZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcmJpdFN0YXRlIHtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgLyogVmlld3BvcnQgYXJndW1lbnRzICovXG4gICAgd2lkdGgsIC8vIFdpZHRoIG9mIHZpZXdwb3J0XG4gICAgaGVpZ2h0LCAvLyBIZWlnaHQgb2Ygdmlld3BvcnRcbiAgICBkaXN0YW5jZSwgLy8gRnJvbSBleWUgdG8gdGFyZ2V0XG4gICAgcm90YXRpb25YLCAvLyBSb3RhdGlvbiBhcm91bmQgeCBheGlzXG4gICAgcm90YXRpb25ZLCAvLyBSb3RhdGlvbiBhcm91bmQgeSBheGlzXG5cbiAgICAvLyBCb3VuZGluZyBib3ggb2YgdGhlIG1vZGVsLCBpbiB0aGUgc2hhcGUgb2Yge21pblgsIG1heFgsIG1pblksIG1heFksIG1pblosIG1heFp9XG4gICAgYm91bmRzLFxuXG4gICAgLyogVmlldyBtYXRyaXggYXJndW1lbnRzICovXG4gICAgbG9va0F0LCAvLyBXaGljaCBwb2ludCBpcyBjYW1lcmEgbG9va2luZyBhdCwgZGVmYXVsdCBvcmlnaW5cblxuICAgIC8qIFByb2plY3Rpb24gbWF0cml4IGFyZ3VtZW50cyAqL1xuICAgIGZvdiwgLy8gRmllbGQgb2YgdmlldyBjb3ZlcmVkIGJ5IGNhbWVyYVxuICAgIG5lYXIsIC8vIERpc3RhbmNlIG9mIG5lYXIgY2xpcHBpbmcgcGxhbmVcbiAgICBmYXIsIC8vIERpc3RhbmNlIG9mIGZhciBjbGlwcGluZyBwbGFuZVxuXG4gICAgLyogQWZ0ZXIgcHJvamVjdGlvbiAqL1xuICAgIHRyYW5zbGF0aW9uWCwgLy8gaW4gcGl4ZWxzXG4gICAgdHJhbnNsYXRpb25ZLCAvLyBpbiBwaXhlbHNcbiAgICB6b29tLFxuXG4gICAgLyogVmlld3BvcnQgY29uc3RyYWludHMgKi9cbiAgICBtaW5ab29tLFxuICAgIG1heFpvb20sXG5cbiAgICAvKiogSW50ZXJhY3Rpb24gc3RhdGVzLCByZXF1aXJlZCB0byBjYWxjdWxhdGUgY2hhbmdlIGR1cmluZyB0cmFuc2Zvcm0gKi9cbiAgICAvLyBNb2RlbCBzdGF0ZSB3aGVuIHRoZSBwYW4gb3BlcmF0aW9uIGZpcnN0IHN0YXJ0ZWRcbiAgICBzdGFydFBhblBvcyxcbiAgICBzdGFydFBhblRyYW5zbGF0aW9uLFxuICAgIC8vIE1vZGVsIHN0YXRlIHdoZW4gdGhlIHJvdGF0ZSBvcGVyYXRpb24gZmlyc3Qgc3RhcnRlZFxuICAgIHN0YXJ0Um90YXRlQ2VudGVyLFxuICAgIHN0YXJ0Um90YXRlVmlld3BvcnQsXG4gICAgLy8gTW9kZWwgc3RhdGUgd2hlbiB0aGUgem9vbSBvcGVyYXRpb24gZmlyc3Qgc3RhcnRlZFxuICAgIHN0YXJ0Wm9vbVBvcyxcbiAgICBzdGFydFpvb21cbiAgfSkge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUod2lkdGgpLCAnYHdpZHRoYCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShoZWlnaHQpLCAnYGhlaWdodGAgbXVzdCBiZSBzdXBwbGllZCcpO1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoZGlzdGFuY2UpLCAnYGRpc3RhbmNlYCBtdXN0IGJlIHN1cHBsaWVkJyk7XG5cbiAgICB0aGlzLl92aWV3cG9ydFByb3BzID0gdGhpcy5fYXBwbHlDb25zdHJhaW50cyh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgcm90YXRpb25YOiBlbnN1cmVGaW5pdGUocm90YXRpb25YLCBkZWZhdWx0U3RhdGUucm90YXRpb25YKSxcbiAgICAgIHJvdGF0aW9uWTogZW5zdXJlRmluaXRlKHJvdGF0aW9uWSwgZGVmYXVsdFN0YXRlLnJvdGF0aW9uWSksXG5cbiAgICAgIGJvdW5kcyxcbiAgICAgIGxvb2tBdDogbG9va0F0IHx8IGRlZmF1bHRTdGF0ZS5sb29rQXQsXG5cbiAgICAgIGZvdjogZW5zdXJlRmluaXRlKGZvdiwgZGVmYXVsdFN0YXRlLmZvdiksXG4gICAgICBuZWFyOiBlbnN1cmVGaW5pdGUobmVhciwgZGVmYXVsdFN0YXRlLm5lYXIpLFxuICAgICAgZmFyOiBlbnN1cmVGaW5pdGUoZmFyLCBkZWZhdWx0U3RhdGUuZmFyKSxcbiAgICAgIHRyYW5zbGF0aW9uWDogZW5zdXJlRmluaXRlKHRyYW5zbGF0aW9uWCwgZGVmYXVsdFN0YXRlLnRyYW5zbGF0aW9uWCksXG4gICAgICB0cmFuc2xhdGlvblk6IGVuc3VyZUZpbml0ZSh0cmFuc2xhdGlvblksIGRlZmF1bHRTdGF0ZS50cmFuc2xhdGlvblkpLFxuICAgICAgem9vbTogZW5zdXJlRmluaXRlKHpvb20sIGRlZmF1bHRTdGF0ZS56b29tKSxcblxuICAgICAgbWluWm9vbTogZW5zdXJlRmluaXRlKG1pblpvb20sIGRlZmF1bHRDb25zdHJhaW50cy5taW5ab29tKSxcbiAgICAgIG1heFpvb206IGVuc3VyZUZpbml0ZShtYXhab29tLCBkZWZhdWx0Q29uc3RyYWludHMubWF4Wm9vbSlcbiAgICB9KTtcblxuICAgIHRoaXMuX2ludGVyYWN0aXZlU3RhdGUgPSB7XG4gICAgICBzdGFydFBhblBvcyxcbiAgICAgIHN0YXJ0UGFuVHJhbnNsYXRpb24sXG4gICAgICBzdGFydFJvdGF0ZUNlbnRlcixcbiAgICAgIHN0YXJ0Um90YXRlVmlld3BvcnQsXG4gICAgICBzdGFydFpvb21Qb3MsXG4gICAgICBzdGFydFpvb21cbiAgICB9O1xuICB9XG5cbiAgLyogUHVibGljIEFQSSAqL1xuXG4gIGdldFZpZXdwb3J0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG4gIH1cblxuICBnZXRJbnRlcmFjdGl2ZVN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHBhbm5pbmdcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIHBvaW50ZXIgZ3JhYnNcbiAgICovXG4gIHBhblN0YXJ0KHtwb3N9KSB7XG4gICAgY29uc3Qge3RyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZfSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE9yYml0U3RhdGUoe1xuICAgICAgc3RhcnRQYW5UcmFuc2xhdGlvbjogW3RyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZXSxcbiAgICAgIHN0YXJ0UGFuUG9zOiBwb3NcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYW5cbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIHBvaW50ZXIgaXNcbiAgICovXG4gIHBhbih7cG9zLCBzdGFydFBvc30pIHtcbiAgICBjb25zdCBzdGFydFBhblBvcyA9IHRoaXMuX2ludGVyYWN0aXZlU3RhdGUuc3RhcnRQYW5Qb3MgfHwgc3RhcnRQb3M7XG4gICAgYXNzZXJ0KHN0YXJ0UGFuUG9zLCAnYHN0YXJ0UGFuUG9zYCBwcm9wcyBpcyByZXF1aXJlZCcpO1xuXG4gICAgbGV0IFt0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWV0gPSB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlLnN0YXJ0UGFuVHJhbnNsYXRpb24gfHwgW107XG4gICAgdHJhbnNsYXRpb25YID0gZW5zdXJlRmluaXRlKHRyYW5zbGF0aW9uWCwgdGhpcy5fdmlld3BvcnRQcm9wcy50cmFuc2xhdGlvblgpO1xuICAgIHRyYW5zbGF0aW9uWSA9IGVuc3VyZUZpbml0ZSh0cmFuc2xhdGlvblksIHRoaXMuX3ZpZXdwb3J0UHJvcHMudHJhbnNsYXRpb25ZKTtcblxuICAgIGNvbnN0IGRlbHRhWCA9IHBvc1swXSAtIHN0YXJ0UGFuUG9zWzBdO1xuICAgIGNvbnN0IGRlbHRhWSA9IHBvc1sxXSAtIHN0YXJ0UGFuUG9zWzFdO1xuXG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRPcmJpdFN0YXRlKHtcbiAgICAgIHRyYW5zbGF0aW9uWDogdHJhbnNsYXRpb25YICsgZGVsdGFYLFxuICAgICAgdHJhbnNsYXRpb25ZOiB0cmFuc2xhdGlvblkgLSBkZWx0YVlcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmQgcGFubmluZ1xuICAgKiBNdXN0IGNhbGwgaWYgYHBhblN0YXJ0KClgIHdhcyBjYWxsZWRcbiAgICovXG4gIHBhbkVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE9yYml0U3RhdGUoe1xuICAgICAgc3RhcnRQYW5UcmFuc2xhdGlvbjogbnVsbCxcbiAgICAgIHN0YXJ0UGFuUG9zOiBudWxsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgcm90YXRpbmdcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIHBvaW50ZXIgZ3JhYnNcbiAgICovXG4gIHJvdGF0ZVN0YXJ0KHtwb3N9KSB7XG4gICAgLy8gUm90YXRpb24gY2VudGVyIHNob3VsZCBiZSB0aGUgd29ybGRzcGFjZSBwb3NpdGlvbiBhdCB0aGUgY2VudGVyIG9mIHRoZVxuICAgIC8vIHRoZSBzY3JlZW4uIElmIG5vdCBmb3VuZCwgdXNlIHRoZSBsYXN0IG9uZS5cbiAgICBjb25zdCBzdGFydFJvdGF0ZUNlbnRlciA9IHRoaXMuX2dldExvY2F0aW9uQXRDZW50ZXIoKSB8fFxuICAgICAgdGhpcy5faW50ZXJhY3RpdmVTdGF0ZS5zdGFydFJvdGF0ZUNlbnRlcjtcblxuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkT3JiaXRTdGF0ZSh7XG4gICAgICBzdGFydFJvdGF0ZUNlbnRlcixcbiAgICAgIHN0YXJ0Um90YXRlVmlld3BvcnQ6IHRoaXMuX3ZpZXdwb3J0UHJvcHNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb3RhdGVcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIHBvaW50ZXIgaXNcbiAgICovXG4gIHJvdGF0ZSh7ZGVsdGFTY2FsZVgsIGRlbHRhU2NhbGVZfSkge1xuICAgIGNvbnN0IHtzdGFydFJvdGF0ZUNlbnRlciwgc3RhcnRSb3RhdGVWaWV3cG9ydH0gPSB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlO1xuXG4gICAgbGV0IHtyb3RhdGlvblgsIHJvdGF0aW9uWSwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvbll9ID0gc3RhcnRSb3RhdGVWaWV3cG9ydCB8fCB7fTtcbiAgICByb3RhdGlvblggPSBlbnN1cmVGaW5pdGUocm90YXRpb25YLCB0aGlzLl92aWV3cG9ydFByb3BzLnJvdGF0aW9uWCk7XG4gICAgcm90YXRpb25ZID0gZW5zdXJlRmluaXRlKHJvdGF0aW9uWSwgdGhpcy5fdmlld3BvcnRQcm9wcy5yb3RhdGlvblkpO1xuICAgIHRyYW5zbGF0aW9uWCA9IGVuc3VyZUZpbml0ZSh0cmFuc2xhdGlvblgsIHRoaXMuX3ZpZXdwb3J0UHJvcHMudHJhbnNsYXRpb25YKTtcbiAgICB0cmFuc2xhdGlvblkgPSBlbnN1cmVGaW5pdGUodHJhbnNsYXRpb25ZLCB0aGlzLl92aWV3cG9ydFByb3BzLnRyYW5zbGF0aW9uWSk7XG5cbiAgICBjb25zdCBuZXdSb3RhdGlvblggPSBjbGFtcChyb3RhdGlvblggLSBkZWx0YVNjYWxlWSAqIDE4MCwgLTg5Ljk5OSwgODkuOTk5KTtcbiAgICBjb25zdCBuZXdSb3RhdGlvblkgPSAocm90YXRpb25ZIC0gZGVsdGFTY2FsZVggKiAxODApICUgMzYwO1xuXG4gICAgbGV0IG5ld1RyYW5zbGF0aW9uWCA9IHRyYW5zbGF0aW9uWDtcbiAgICBsZXQgbmV3VHJhbnNsYXRpb25ZID0gdHJhbnNsYXRpb25ZO1xuXG4gICAgaWYgKHN0YXJ0Um90YXRlQ2VudGVyKSB7XG4gICAgICAvLyBLZWVwIHJvdGF0aW9uIGNlbnRlciBhdCB0aGUgY2VudGVyIG9mIHRoZSBzY3JlZW5cbiAgICAgIGNvbnN0IG9sZFZpZXdwb3J0ID0gbmV3IE9yYml0Vmlld3BvcnQoc3RhcnRSb3RhdGVWaWV3cG9ydCk7XG4gICAgICBjb25zdCBvbGRDZW50ZXJQb3MgPSBvbGRWaWV3cG9ydC5wcm9qZWN0KHN0YXJ0Um90YXRlQ2VudGVyKTtcblxuICAgICAgY29uc3QgbmV3Vmlld3BvcnQgPSBuZXcgT3JiaXRWaWV3cG9ydChPYmplY3QuYXNzaWduKHt9LCBzdGFydFJvdGF0ZVZpZXdwb3J0LCB7XG4gICAgICAgIHJvdGF0aW9uWDogbmV3Um90YXRpb25YLFxuICAgICAgICByb3RhdGlvblk6IG5ld1JvdGF0aW9uWVxuICAgICAgfSkpO1xuICAgICAgY29uc3QgbmV3Q2VudGVyUG9zID0gbmV3Vmlld3BvcnQucHJvamVjdChzdGFydFJvdGF0ZUNlbnRlcik7XG5cbiAgICAgIG5ld1RyYW5zbGF0aW9uWCArPSBvbGRDZW50ZXJQb3NbMF0gLSBuZXdDZW50ZXJQb3NbMF07XG4gICAgICBuZXdUcmFuc2xhdGlvblkgLT0gb2xkQ2VudGVyUG9zWzFdIC0gbmV3Q2VudGVyUG9zWzFdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkT3JiaXRTdGF0ZSh7XG4gICAgICByb3RhdGlvblg6IG5ld1JvdGF0aW9uWCxcbiAgICAgIHJvdGF0aW9uWTogbmV3Um90YXRpb25ZLFxuICAgICAgdHJhbnNsYXRpb25YOiBuZXdUcmFuc2xhdGlvblgsXG4gICAgICB0cmFuc2xhdGlvblk6IG5ld1RyYW5zbGF0aW9uWVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCByb3RhdGluZ1xuICAgKiBNdXN0IGNhbGwgaWYgYHJvdGF0ZVN0YXJ0KClgIHdhcyBjYWxsZWRcbiAgICovXG4gIHJvdGF0ZUVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE9yYml0U3RhdGUoe1xuICAgICAgc3RhcnRSb3RhdGVDZW50ZXI6IG51bGwsXG4gICAgICBzdGFydFJvdGF0ZVZpZXdwb3J0OiBudWxsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgem9vbWluZ1xuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgcG9pbnRlciBncmFic1xuICAgKi9cbiAgem9vbVN0YXJ0KHtwb3N9KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRPcmJpdFN0YXRlKHtcbiAgICAgIHN0YXJ0Wm9vbVBvczogcG9zLFxuICAgICAgc3RhcnRab29tOiB0aGlzLl92aWV3cG9ydFByb3BzLnpvb21cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBab29tXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBjdXJyZW50IGNlbnRlciBpc1xuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHN0YXJ0UG9zIC0gdGhlIGNlbnRlciBwb3NpdGlvbiBhdFxuICAgKiAgIHRoZSBzdGFydCBvZiB0aGUgb3BlcmF0aW9uLiBNdXN0IGJlIHN1cHBsaWVkIG9mIGB6b29tU3RhcnQoKWAgd2FzIG5vdCBjYWxsZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIC0gYSBudW1iZXIgYmV0d2VlbiBbMCwgMV0gc3BlY2lmeWluZyB0aGUgYWNjdW11bGF0ZWRcbiAgICogICByZWxhdGl2ZSBzY2FsZS5cbiAgICovXG4gIHpvb20oe3Bvcywgc3RhcnRQb3MsIHNjYWxlfSkge1xuICAgIGNvbnN0IHt6b29tLCBtaW5ab29tLCBtYXhab29tLCB3aWR0aCwgaGVpZ2h0LCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWX0gPSB0aGlzLl92aWV3cG9ydFByb3BzO1xuXG4gICAgY29uc3Qgc3RhcnRab29tUG9zID0gdGhpcy5faW50ZXJhY3RpdmVTdGF0ZS5zdGFydFpvb21Qb3MgfHwgc3RhcnRQb3MgfHwgcG9zO1xuXG4gICAgY29uc3QgbmV3Wm9vbSA9IGNsYW1wKHpvb20gKiBzY2FsZSwgbWluWm9vbSwgbWF4Wm9vbSk7XG4gICAgY29uc3QgZGVsdGFYID0gcG9zWzBdIC0gc3RhcnRab29tUG9zWzBdO1xuICAgIGNvbnN0IGRlbHRhWSA9IHBvc1sxXSAtIHN0YXJ0Wm9vbVBvc1sxXTtcblxuICAgIC8vIFpvb20gYXJvdW5kIHRoZSBjZW50ZXIgcG9zaXRpb25cbiAgICBjb25zdCBjeCA9IHN0YXJ0Wm9vbVBvc1swXSAtIHdpZHRoIC8gMjtcbiAgICBjb25zdCBjeSA9IGhlaWdodCAvIDIgLSBzdGFydFpvb21Qb3NbMV07XG4gICAgY29uc3QgbmV3VHJhbnNsYXRpb25YID0gY3ggLSAoY3ggLSB0cmFuc2xhdGlvblgpICogbmV3Wm9vbSAvIHpvb20gKyBkZWx0YVg7XG4gICAgY29uc3QgbmV3VHJhbnNsYXRpb25ZID0gY3kgLSAoY3kgLSB0cmFuc2xhdGlvblkpICogbmV3Wm9vbSAvIHpvb20gLSBkZWx0YVk7XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZE9yYml0U3RhdGUoe1xuICAgICAgem9vbTogbmV3Wm9vbSxcbiAgICAgIHRyYW5zbGF0aW9uWDogbmV3VHJhbnNsYXRpb25YLFxuICAgICAgdHJhbnNsYXRpb25ZOiBuZXdUcmFuc2xhdGlvbllcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmQgem9vbWluZ1xuICAgKiBNdXN0IGNhbGwgaWYgYHpvb21TdGFydCgpYCB3YXMgY2FsbGVkXG4gICAqL1xuICB6b29tRW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkT3JiaXRTdGF0ZSh7XG4gICAgICBzdGFydFpvb21Qb3M6IG51bGwsXG4gICAgICBzdGFydFpvb206IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIC8qIFByaXZhdGUgbWV0aG9kcyAqL1xuXG4gIF9nZXRVcGRhdGVkT3JiaXRTdGF0ZShuZXdQcm9wcykge1xuICAgIC8vIFVwZGF0ZSBfdmlld3BvcnRQcm9wc1xuICAgIHJldHVybiBuZXcgT3JiaXRTdGF0ZShPYmplY3QuYXNzaWduKHt9LCB0aGlzLl92aWV3cG9ydFByb3BzLCB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlLCBuZXdQcm9wcykpO1xuICB9XG5cbiAgLy8gQXBwbHkgYW55IGNvbnN0cmFpbnRzIChtYXRoZW1hdGljYWwgb3IgZGVmaW5lZCBieSBfdmlld3BvcnRQcm9wcykgdG8gbWFwIHN0YXRlXG4gIF9hcHBseUNvbnN0cmFpbnRzKHByb3BzKSB7XG4gICAgLy8gRW5zdXJlIHpvb20gaXMgd2l0aGluIHNwZWNpZmllZCByYW5nZVxuICAgIGNvbnN0IHttYXhab29tLCBtaW5ab29tLCB6b29tfSA9IHByb3BzO1xuICAgIHByb3BzLnpvb20gPSB6b29tID4gbWF4Wm9vbSA/IG1heFpvb20gOiB6b29tO1xuICAgIHByb3BzLnpvb20gPSB6b29tIDwgbWluWm9vbSA/IG1pblpvb20gOiB6b29tO1xuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgLyogQ2FzdCBhIHJheSBpbnRvIHRoZSBzY3JlZW4gY2VudGVyIGFuZCB0YWtlIHRoZSBhdmVyYWdlIG9mIGFsbFxuICAgKiBpbnRlcnNlY3Rpb25zIHdpdGggdGhlIGJvdW5kaW5nIGJveDpcbiAgICpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgKHg9dy8yKVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgKiAgIChib3VuZGluZyBib3gpICAgICAgICAgLlxuICAgKiAgICAgICAgICAgXy0tLS0tLS0tLS0tLS1fLlxuICAgKiAgICAgICAgICB8IFwiLV8gICAgICAgICAgIDotX1xuICAgKiAgICAgICAgIHwgICAgIFwiLV8gICAgICAgIC4gIFwiLV9cbiAgICogICAgICAgIHwgICAgICAgICBcIi0tLS0tLS0rLS0tLS06XG4gICAqICAgICAgIHwuLi4uLi4uLi58Li4uLi4uLi5DLi4uLnwuLi4uLi4uLi4uLi4uICh5PWgvMilcbiAgICogICAgICB8ICAgICAgICAgfCAgICAgICAgIC4gICB8XG4gICAqICAgICB8ICAgICAgICAgfCAgICAgICAgICAuICB8XG4gICAqICAgIHwgICAgICAgICB8ICAgICAgICAgICAuIHxcbiAgICogICB8ICAgICAgICAgfCAgICAgICAgICAgIC58XG4gICAqICB8ICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgIFlcbiAgICogICBcIi1fICAgICB8ICAgICAgICAgICAgIHwuICAgICAgICAgICAgIFogICAgICAgfFxuICAgKiAgICAgIFwiLV8gfCAgICAgICAgICAgICB8IC4gICAgICAgICAgICAgIFwiLV8gICB8XG4gICAqICAgICAgICAgXCItLS0tLS0tLS0tLS0tXCIgICAgICAgICAgICAgICAgICAgIFwiLXxfX19fXyBYXG4gICAqL1xuICBfZ2V0TG9jYXRpb25BdENlbnRlcigpIHtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodCwgYm91bmRzfSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG5cbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgdmlld3BvcnQgPSBuZXcgT3JiaXRWaWV3cG9ydCh0aGlzLl92aWV3cG9ydFByb3BzKTtcblxuICAgIGNvbnN0IEMwID0gdmlld3BvcnQudW5wcm9qZWN0KFt3aWR0aCAvIDIsIGhlaWdodCAvIDIsIDBdKTtcbiAgICBjb25zdCBDMSA9IHZpZXdwb3J0LnVucHJvamVjdChbd2lkdGggLyAyLCBoZWlnaHQgLyAyLCAxXSk7XG4gICAgY29uc3Qgc3VtID0gWzAsIDAsIDBdO1xuICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICBbXG4gICAgICAvLyBkZXB0aCBhdCBpbnRlcnNlY3Rpb24gd2l0aCBYID0gbWluWFxuICAgICAgaW50ZXJwb2xhdGUoYm91bmRzLm1pblgsIEMwWzBdLCBDMVswXSksXG4gICAgICAvLyBkZXB0aCBhdCBpbnRlcnNlY3Rpb24gd2l0aCBYID0gbWF4WFxuICAgICAgaW50ZXJwb2xhdGUoYm91bmRzLm1heFgsIEMwWzBdLCBDMVswXSksXG4gICAgICAvLyBkZXB0aCBhdCBpbnRlcnNlY3Rpb24gd2l0aCBZID0gbWluWVxuICAgICAgaW50ZXJwb2xhdGUoYm91bmRzLm1pblksIEMwWzFdLCBDMVsxXSksXG4gICAgICAvLyBkZXB0aCBhdCBpbnRlcnNlY3Rpb24gd2l0aCBZID0gbWF4WVxuICAgICAgaW50ZXJwb2xhdGUoYm91bmRzLm1heFksIEMwWzFdLCBDMVsxXSksXG4gICAgICAvLyBkZXB0aCBhdCBpbnRlcnNlY3Rpb24gd2l0aCBaID0gbWluWlxuICAgICAgaW50ZXJwb2xhdGUoYm91bmRzLm1pblosIEMwWzJdLCBDMVsyXSksXG4gICAgICAvLyBkZXB0aCBhdCBpbnRlcnNlY3Rpb24gd2l0aCBaID0gbWF4WlxuICAgICAgaW50ZXJwb2xhdGUoYm91bmRzLm1heFosIEMwWzJdLCBDMVsyXSlcbiAgICBdLmZvckVhY2goZCA9PiB7XG4gICAgICAvLyB3b3JsZHNwYWNlIHBvc2l0aW9uIG9mIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAgIGNvbnN0IEMgPSB2ZWMzX2xlcnAoW10sIEMwLCBDMSwgZCk7XG4gICAgICAvLyBjaGVjayBpZiBwb3NpdGlvbiBpcyBvbiB0aGUgYm91bmRpbmcgYm94XG4gICAgICBpZiAoaW5SYW5nZShDWzBdLCBib3VuZHMubWluWCwgYm91bmRzLm1heFgpICYmXG4gICAgICAgICAgaW5SYW5nZShDWzFdLCBib3VuZHMubWluWSwgYm91bmRzLm1heFkpICYmXG4gICAgICAgICAgaW5SYW5nZShDWzJdLCBib3VuZHMubWluWiwgYm91bmRzLm1heFopKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIHZlYzNfYWRkKHN1bSwgc3VtLCBDKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjb3VudCA+IDAgPyB2ZWMzX3NjYWxlKFtdLCBzdW0sIDEgLyBjb3VudCkgOiBudWxsO1xuICB9XG59XG4iXX0=