'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PolygonTesselatorExtruded = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var _polygon = require('./polygon');

var Polygon = _interopRequireWildcard(_polygon);

var _normalize = require('gl-vec3/normalize');

var _normalize2 = _interopRequireDefault(_normalize);

var _fp = require('../../core/lib/utils/fp64');

var _utils = require('../../core/lib/utils');

var _earcut = require('earcut');

var _earcut2 = _interopRequireDefault(_earcut);

var _lodash = require('lodash.flattendeep');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getPickingColor(index) {
  return [index + 1 & 255, index + 1 >> 8 & 255, index + 1 >> 8 >> 8 & 255];
}

function parseColor(color) {
  if (!Array.isArray(color)) {
    color = [(0, _utils.get)(color, 0), (0, _utils.get)(color, 1), (0, _utils.get)(color, 2), (0, _utils.get)(color, 3)];
  }
  color[3] = Number.isFinite(color[3]) ? color[3] : 255;
  return color;
}

var DEFAULT_COLOR = [0, 0, 0, 255]; // Black

var PolygonTesselatorExtruded = exports.PolygonTesselatorExtruded = function () {
  function PolygonTesselatorExtruded(_ref) {
    var polygons = _ref.polygons,
        _ref$getHeight = _ref.getHeight,
        getHeight = _ref$getHeight === undefined ? function (x) {
      return 1000;
    } : _ref$getHeight,
        _ref$getColor = _ref.getColor,
        getColor = _ref$getColor === undefined ? function (x) {
      return [0, 0, 0, 255];
    } : _ref$getColor,
        _ref$wireframe = _ref.wireframe,
        wireframe = _ref$wireframe === undefined ? false : _ref$wireframe,
        _ref$fp = _ref.fp64,
        fp64 = _ref$fp === undefined ? false : _ref$fp;

    _classCallCheck(this, PolygonTesselatorExtruded);

    this.fp64 = fp64;

    // Expensive operation, convert all polygons to arrays
    polygons = polygons.map(function (complexPolygon, polygonIndex) {
      var height = getHeight(polygonIndex) || 0;
      return Polygon.normalize(complexPolygon).map(function (polygon) {
        return polygon.map(function (coord) {
          return [(0, _utils.get)(coord, 0), (0, _utils.get)(coord, 1), height];
        });
      });
    });

    var groupedVertices = polygons;
    this.groupedVertices = polygons;
    this.wireframe = wireframe;

    this.attributes = {};

    var positionsJS = calculatePositionsJS({ groupedVertices: groupedVertices, wireframe: wireframe });
    Object.assign(this.attributes, {
      positions: calculatePositions(positionsJS, this.fp64),
      indices: calculateIndices({ groupedVertices: groupedVertices, wireframe: wireframe }),
      normals: calculateNormals({ groupedVertices: groupedVertices, wireframe: wireframe }),
      // colors: calculateColors({groupedVertices, wireframe, getColor}),
      pickingColors: calculatePickingColors({ groupedVertices: groupedVertices, wireframe: wireframe })
    });
  }

  _createClass(PolygonTesselatorExtruded, [{
    key: 'indices',
    value: function indices() {
      return this.attributes.indices;
    }
  }, {
    key: 'positions',
    value: function positions() {
      return this.attributes.positions;
    }
  }, {
    key: 'normals',
    value: function normals() {
      return this.attributes.normals;
    }
  }, {
    key: 'colors',
    value: function colors() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$getColor = _ref2.getColor,
          getColor = _ref2$getColor === undefined ? function (x) {
        return DEFAULT_COLOR;
      } : _ref2$getColor;

      var groupedVertices = this.groupedVertices,
          wireframe = this.wireframe;

      return calculateColors({ groupedVertices: groupedVertices, wireframe: wireframe, getColor: getColor });
    }
  }, {
    key: 'pickingColors',
    value: function pickingColors() {
      return this.attributes.pickingColors;
    }

    // updateTriggers: {
    //   positions: ['getHeight'],
    //   colors: ['getColors']
    //   pickingColors: 'none'
    // }

  }]);

  return PolygonTesselatorExtruded;
}();

function countVertices(vertices) {
  return vertices.reduce(function (vertexCount, polygon) {
    return vertexCount + (0, _utils.count)(polygon);
  }, 0);
}

function calculateIndices(_ref3) {
  var groupedVertices = _ref3.groupedVertices,
      _ref3$wireframe = _ref3.wireframe,
      wireframe = _ref3$wireframe === undefined ? false : _ref3$wireframe;

  // adjust index offset for multiple polygons
  var multiplier = wireframe ? 2 : 5;
  var offsets = groupedVertices.reduce(function (acc, vertices) {
    return acc.concat(acc[acc.length - 1] + countVertices(vertices) * multiplier);
  }, [0]);

  var indices = groupedVertices.map(function (vertices, polygonIndex) {
    return wireframe ?
    // 1. get sequentially ordered indices of each polygons wireframe
    // 2. offset them by the number of indices in previous polygons
    calculateContourIndices(vertices, offsets[polygonIndex]) :
    // 1. get triangulated indices for the internal areas
    // 2. offset them by the number of indices in previous polygons
    calculateSurfaceIndices(vertices, offsets[polygonIndex]);
  });

  return new Uint32Array((0, _lodash2.default)(indices));
}

// Calculate a flat position array in JS - can be mapped to 32 or 64 bit typed arrays
// Remarks:
// * each top vertex is on 3 surfaces
// * each bottom vertex is on 2 surfaces
function calculatePositionsJS(_ref4) {
  var groupedVertices = _ref4.groupedVertices,
      _ref4$wireframe = _ref4.wireframe,
      wireframe = _ref4$wireframe === undefined ? false : _ref4$wireframe;

  var positions = groupedVertices.map(function (vertices) {
    var topVertices = Array.prototype.concat.apply([], vertices);
    var baseVertices = topVertices.map(function (v) {
      return [(0, _utils.get)(v, 0), (0, _utils.get)(v, 1), 0];
    });
    return wireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];
  });

  return (0, _lodash2.default)(positions);
}

function calculatePositions(positionsJS, fp64) {
  var positionLow = void 0;
  if (fp64) {
    // We only need x, y component
    positionLow = new Float32Array(positionsJS.length / 3 * 2);
    for (var i = 0; i < positionsJS.length / 3; i++) {
      positionLow[i * 2 + 0] = (0, _fp.fp64ify)(positionsJS[i * 3 + 0])[1];
      positionLow[i * 2 + 1] = (0, _fp.fp64ify)(positionsJS[i * 3 + 1])[1];
    }
  }
  return { positions: new Float32Array(positionsJS), positions64xyLow: positionLow };
}

function calculateNormals(_ref5) {
  var groupedVertices = _ref5.groupedVertices,
      wireframe = _ref5.wireframe;

  var up = [0, 1, 0];

  var normals = groupedVertices.map(function (vertices, polygonIndex) {
    var topNormals = new Array(countVertices(vertices)).fill(up);
    var sideNormals = vertices.map(function (polygon) {
      return calculateSideNormals(polygon);
    });
    var sideNormalsForward = sideNormals.map(function (n) {
      return n[0];
    });
    var sideNormalsBackward = sideNormals.map(function (n) {
      return n[1];
    });

    return wireframe ? [topNormals, topNormals] : [topNormals, sideNormalsForward, sideNormalsBackward, sideNormalsForward, sideNormalsBackward];
  });

  return new Float32Array((0, _lodash2.default)(normals));
}

function calculateSideNormals(vertices) {
  var normals = [];

  var lastVertice = null;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var vertice = _step.value;

      if (lastVertice) {
        // vertex[i-1], vertex[i]
        var n = getNormal(lastVertice, vertice);
        normals.push(n);
      }
      lastVertice = vertice;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return [[normals.concat(normals[0])], [[normals[0]].concat(normals)]];
}

function calculateColors(_ref6) {
  var groupedVertices = _ref6.groupedVertices,
      getColor = _ref6.getColor,
      _ref6$wireframe = _ref6.wireframe,
      wireframe = _ref6$wireframe === undefined ? false : _ref6$wireframe;

  var colors = groupedVertices.map(function (complexPolygon, polygonIndex) {
    var color = getColor(polygonIndex);
    color = parseColor(color);

    var numVertices = countVertices(complexPolygon);
    var topColors = new Array(numVertices).fill(color);
    var baseColors = new Array(numVertices).fill(color);
    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];
  });
  return new Uint8ClampedArray((0, _lodash2.default)(colors));
}

function calculatePickingColors(_ref7) {
  var groupedVertices = _ref7.groupedVertices,
      _ref7$wireframe = _ref7.wireframe,
      wireframe = _ref7$wireframe === undefined ? false : _ref7$wireframe;

  var colors = groupedVertices.map(function (vertices, polygonIndex) {
    var numVertices = countVertices(vertices);
    var color = getPickingColor(polygonIndex);
    var topColors = new Array(numVertices).fill(color);
    var baseColors = new Array(numVertices).fill(color);
    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];
  });
  return new Uint8ClampedArray((0, _lodash2.default)(colors));
}

function calculateContourIndices(vertices, offset) {
  var stride = countVertices(vertices);

  return vertices.map(function (polygon) {
    var indices = [offset];
    var numVertices = polygon.length;

    // polygon top
    // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]
    for (var i = 1; i < numVertices - 1; i++) {
      indices.push(i + offset, i + offset);
    }
    indices.push(offset);

    // polygon sides
    for (var _i = 0; _i < numVertices - 1; _i++) {
      indices.push(_i + offset, _i + stride + offset);
    }

    offset += numVertices;
    return indices;
  });
}

function calculateSurfaceIndices(vertices, offset) {
  var stride = countVertices(vertices);
  var quad = [[0, 1], [0, 3], [1, 2], [1, 2], [0, 3], [1, 4]];

  function drawRectangle(i) {
    return quad.map(function (v) {
      return i + v[0] + stride * v[1] + offset;
    });
  }

  var holes = null;

  if (vertices.length > 1) {
    holes = vertices.reduce(function (acc, polygon) {
      return acc.concat(acc[acc.length - 1] + polygon.length);
    }, [0]).slice(1, vertices.length);
  }

  var topIndices = (0, _earcut2.default)((0, _lodash2.default)(vertices), holes, 3).map(function (index) {
    return index + offset;
  });

  var sideIndices = vertices.map(function (polygon) {
    var numVertices = polygon.length;
    // polygon top
    var indices = [];

    // polygon sides
    for (var i = 0; i < numVertices - 1; i++) {
      indices = indices.concat(drawRectangle(i));
    }

    offset += numVertices;
    return indices;
  });

  return [topIndices, sideIndices];
}

// helpers

// get normal vector of line segment
function getNormal(p1, p2) {
  var p1x = (0, _utils.get)(p1, 0);
  var p1y = (0, _utils.get)(p1, 1);
  var p2x = (0, _utils.get)(p2, 0);
  var p2y = (0, _utils.get)(p2, 1);

  if (p1x === p2x && p1y === p2y) {
    return [1, 0, 0];
  }

  var degrees2radians = Math.PI / 180;
  var lon1 = degrees2radians * p1x;
  var lon2 = degrees2radians * p2x;
  var lat1 = degrees2radians * p1y;
  var lat2 = degrees2radians * p2y;
  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  return (0, _normalize2.default)([], [b, 0, -a]);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlLWxheWVycy9zb2xpZC1wb2x5Z29uLWxheWVyL3BvbHlnb24tdGVzc2VsYXRvci1leHRydWRlZC5qcyJdLCJuYW1lcyI6WyJQb2x5Z29uIiwiZ2V0UGlja2luZ0NvbG9yIiwiaW5kZXgiLCJwYXJzZUNvbG9yIiwiY29sb3IiLCJBcnJheSIsImlzQXJyYXkiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIkRFRkFVTFRfQ09MT1IiLCJQb2x5Z29uVGVzc2VsYXRvckV4dHJ1ZGVkIiwicG9seWdvbnMiLCJnZXRIZWlnaHQiLCJnZXRDb2xvciIsIndpcmVmcmFtZSIsImZwNjQiLCJtYXAiLCJjb21wbGV4UG9seWdvbiIsInBvbHlnb25JbmRleCIsImhlaWdodCIsIm5vcm1hbGl6ZSIsInBvbHlnb24iLCJjb29yZCIsImdyb3VwZWRWZXJ0aWNlcyIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbnNKUyIsImNhbGN1bGF0ZVBvc2l0aW9uc0pTIiwiT2JqZWN0IiwiYXNzaWduIiwicG9zaXRpb25zIiwiY2FsY3VsYXRlUG9zaXRpb25zIiwiaW5kaWNlcyIsImNhbGN1bGF0ZUluZGljZXMiLCJub3JtYWxzIiwiY2FsY3VsYXRlTm9ybWFscyIsInBpY2tpbmdDb2xvcnMiLCJjYWxjdWxhdGVQaWNraW5nQ29sb3JzIiwiY2FsY3VsYXRlQ29sb3JzIiwiY291bnRWZXJ0aWNlcyIsInZlcnRpY2VzIiwicmVkdWNlIiwidmVydGV4Q291bnQiLCJtdWx0aXBsaWVyIiwib2Zmc2V0cyIsImFjYyIsImNvbmNhdCIsImxlbmd0aCIsImNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzIiwiY2FsY3VsYXRlU3VyZmFjZUluZGljZXMiLCJVaW50MzJBcnJheSIsInRvcFZlcnRpY2VzIiwicHJvdG90eXBlIiwiYXBwbHkiLCJiYXNlVmVydGljZXMiLCJ2IiwicG9zaXRpb25Mb3ciLCJGbG9hdDMyQXJyYXkiLCJpIiwicG9zaXRpb25zNjR4eUxvdyIsInVwIiwidG9wTm9ybWFscyIsImZpbGwiLCJzaWRlTm9ybWFscyIsImNhbGN1bGF0ZVNpZGVOb3JtYWxzIiwic2lkZU5vcm1hbHNGb3J3YXJkIiwibiIsInNpZGVOb3JtYWxzQmFja3dhcmQiLCJsYXN0VmVydGljZSIsInZlcnRpY2UiLCJnZXROb3JtYWwiLCJwdXNoIiwiY29sb3JzIiwibnVtVmVydGljZXMiLCJ0b3BDb2xvcnMiLCJiYXNlQ29sb3JzIiwiVWludDhDbGFtcGVkQXJyYXkiLCJvZmZzZXQiLCJzdHJpZGUiLCJxdWFkIiwiZHJhd1JlY3RhbmdsZSIsImhvbGVzIiwic2xpY2UiLCJ0b3BJbmRpY2VzIiwic2lkZUluZGljZXMiLCJwMSIsInAyIiwicDF4IiwicDF5IiwicDJ4IiwicDJ5IiwiZGVncmVlczJyYWRpYW5zIiwiTWF0aCIsIlBJIiwibG9uMSIsImxvbjIiLCJsYXQxIiwibGF0MiIsImEiLCJzaW4iLCJjb3MiLCJiIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O3FqQkFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7SUFBWUEsTzs7QUFDWjs7OztBQUNBOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7QUFFQSxTQUFTQyxlQUFULENBQXlCQyxLQUF6QixFQUFnQztBQUM5QixTQUFPLENBQ0pBLFFBQVEsQ0FBVCxHQUFjLEdBRFQsRUFFSEEsUUFBUSxDQUFULElBQWUsQ0FBaEIsR0FBcUIsR0FGaEIsRUFHRkEsUUFBUSxDQUFULElBQWUsQ0FBaEIsSUFBc0IsQ0FBdkIsR0FBNEIsR0FIdkIsQ0FBUDtBQUtEOztBQUVELFNBQVNDLFVBQVQsQ0FBb0JDLEtBQXBCLEVBQTJCO0FBQ3pCLE1BQUksQ0FBQ0MsTUFBTUMsT0FBTixDQUFjRixLQUFkLENBQUwsRUFBMkI7QUFDekJBLFlBQVEsQ0FBQyxnQkFBSUEsS0FBSixFQUFXLENBQVgsQ0FBRCxFQUFnQixnQkFBSUEsS0FBSixFQUFX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WjtBQUNBLE1BQU1HLE1BQU0sZ0JBQUlILEVBQUosRUFBUSxDQUFSLENBQVo7QUFDQSxNQUFNSSxNQUFNLGdCQUFJSCxFQUFKLEVBQVEsQ0FBUixDQUFaO0FBQ0EsTUFBTUksTUFBTSxnQkFBSUosRUFBSixFQUFRLENBQVIsQ0FBWjs7QUFFQSxNQUFJQyxRQUFRRSxHQUFSLElBQWVELFFBQVFFLEdBQTNCLEVBQWdDO0FBQzlCLFdBQU8sQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBUDtBQUNEOztBQUVELE1BQU1DLGtCQUFrQkMsS0FBS0MsRUFBTCxHQUFVLEdBQWxDO0FBQ0EsTUFBTUMsT0FBT0gsa0JBQWtCSixHQUEvQjtBQUNBLE1BQU1RLE9BQU9KLGtCQUFrQkYsR0FBL0I7QUFDQSxNQUFNTyxPQUFPTCxrQkFBa0JILEdBQS9CO0FBQ0EsTUFBTVMsT0FBT04sa0JBQWtCRCxHQUEvQjtBQUNBLE1BQU1RLElBQUlOLEtBQUtPLEdBQUwsQ0FBU0osT0FBT0QsSUFBaEIsSUFBd0JGLEtBQUtRLEdBQUwsQ0FBU0gsSUFBVCxDQUFsQztBQUNBLE1BQU1JLElBQUlULEtBQUtRLEdBQUwsQ0FBU0osSUFBVCxJQUFpQkosS0FBS08sR0FBTCxDQUFTRixJQUFULENBQWpCLEdBQ1JMLEtBQUtPLEdBQUwsQ0FBU0gsSUFBVCxJQUFpQkosS0FBS1EsR0FBTCxDQUFTSCxJQUFULENBQWpCLEdBQWtDTCxLQUFLUSxHQUFMLENBQVNMLE9BQU9ELElBQWhCLENBRHBDO0FBRUEsU0FBTyx5QkFBZSxFQUFmLEVBQW1CLENBQUNPLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBQ0gsQ0FBUixDQUFuQixDQUFQO0FBQ0QiLCJmaWxlIjoicG9seWdvbi10ZXNzZWxhdG9yLWV4dHJ1ZGVkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCAqIGFzIFBvbHlnb24gZnJvbSAnLi9wb2x5Z29uJztcbmltcG9ydCB2ZWMzX25vcm1hbGl6ZSBmcm9tICdnbC12ZWMzL25vcm1hbGl6ZSc7XG5pbXBvcnQge2ZwNjRpZnl9IGZyb20gJy4uLy4uL2NvcmUvbGliL3V0aWxzL2ZwNjQnO1xuaW1wb3J0IHtnZXQsIGNvdW50fSBmcm9tICcuLi8uLi9jb3JlL2xpYi91dGlscyc7XG5pbXBvcnQgZWFyY3V0IGZyb20gJ2VhcmN1dCc7XG5pbXBvcnQgZmxhdHRlbkRlZXAgZnJvbSAnbG9kYXNoLmZsYXR0ZW5kZWVwJztcblxuZnVuY3Rpb24gZ2V0UGlja2luZ0NvbG9yKGluZGV4KSB7XG4gIHJldHVybiBbXG4gICAgKGluZGV4ICsgMSkgJiAyNTUsXG4gICAgKChpbmRleCArIDEpID4+IDgpICYgMjU1LFxuICAgICgoKGluZGV4ICsgMSkgPj4gOCkgPj4gOCkgJiAyNTVcbiAgXTtcbn1cblxuZnVuY3Rpb24gcGFyc2VDb2xvcihjb2xvcikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgY29sb3IgPSBbZ2V0KGNvbG9yLCAwKSwgZ2V0KGNvbG9yLCAxKSwgZ2V0KGNvbG9yLCAyKSwgZ2V0KGNvbG9yLCAzKV07XG4gIH1cbiAgY29sb3JbM10gPSBOdW1iZXIuaXNGaW5pdGUoY29sb3JbM10pID8gY29sb3JbM10gOiAyNTU7XG4gIHJldHVybiBjb2xvcjtcbn1cblxuY29uc3QgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAwLCAyNTVdOyAvLyBCbGFja1xuXG5leHBvcnQgY2xhc3MgUG9seWdvblRlc3NlbGF0b3JFeHRydWRlZCB7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHBvbHlnb25zLFxuICAgIGdldEhlaWdodCA9IHggPT4gMTAwMCxcbiAgICBnZXRDb2xvciA9IHggPT4gWzAsIDAsIDAsIDI1NV0sXG4gICAgd2lyZWZyYW1lID0gZmFsc2UsXG4gICAgZnA2NCA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLmZwNjQgPSBmcDY0O1xuXG4gICAgLy8gRXhwZW5zaXZlIG9wZXJhdGlvbiwgY29udmVydCBhbGwgcG9seWdvbnMgdG8gYXJyYXlzXG4gICAgcG9seWdvbnMgPSBwb2x5Z29ucy5tYXAoKGNvbXBsZXhQb2x5Z29uLCBwb2x5Z29uSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGdldEhlaWdodChwb2x5Z29uSW5kZXgpIHx8IDA7XG4gICAgICByZXR1cm4gUG9seWdvbi5ub3JtYWxpemUoY29tcGxleFBvbHlnb24pLm1hcChcbiAgICAgICAgcG9seWdvbiA9PiBwb2x5Z29uLm1hcChjb29yZCA9PiBbZ2V0KGNvb3JkLCAwKSwgZ2V0KGNvb3JkLCAxKSwgaGVpZ2h0XSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBncm91cGVkVmVydGljZXMgPSBwb2x5Z29ucztcbiAgICB0aGlzLmdyb3VwZWRWZXJ0aWNlcyA9IHBvbHlnb25zO1xuICAgIHRoaXMud2lyZWZyYW1lID0gd2lyZWZyYW1lO1xuXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG5cbiAgICBjb25zdCBwb3NpdGlvbnNKUyA9IGNhbGN1bGF0ZVBvc2l0aW9uc0pTKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZX0pO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5hdHRyaWJ1dGVzLCB7XG4gICAgICBwb3NpdGlvbnM6IGNhbGN1bGF0ZVBvc2l0aW9ucyhwb3NpdGlvbnNKUywgdGhpcy5mcDY0KSxcbiAgICAgIGluZGljZXM6IGNhbGN1bGF0ZUluZGljZXMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lfSksXG4gICAgICBub3JtYWxzOiBjYWxjdWxhdGVOb3JtYWxzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZX0pLFxuICAgICAgLy8gY29sb3JzOiBjYWxjdWxhdGVDb2xvcnMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lLCBnZXRDb2xvcn0pLFxuICAgICAgcGlja2luZ0NvbG9yczogY2FsY3VsYXRlUGlja2luZ0NvbG9ycyh7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWV9KVxuICAgIH0pO1xuICB9XG5cbiAgaW5kaWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmluZGljZXM7XG4gIH1cblxuICBwb3NpdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbnM7XG4gIH1cblxuICBub3JtYWxzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMubm9ybWFscztcbiAgfVxuXG4gIGNvbG9ycyh7Z2V0Q29sb3IgPSB4ID0+IERFRkFVTFRfQ09MT1J9ID0ge30pIHtcbiAgICBjb25zdCB7Z3JvdXBlZFZlcnRpY2VzLCB3aXJlZnJhbWV9ID0gdGhpcztcbiAgICByZXR1cm4gY2FsY3VsYXRlQ29sb3JzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZSwgZ2V0Q29sb3J9KTtcbiAgfVxuXG4gIHBpY2tpbmdDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5waWNraW5nQ29sb3JzO1xuICB9XG5cbiAgLy8gdXBkYXRlVHJpZ2dlcnM6IHtcbiAgLy8gICBwb3NpdGlvbnM6IFsnZ2V0SGVpZ2h0J10sXG4gIC8vICAgY29sb3JzOiBbJ2dldENvbG9ycyddXG4gIC8vICAgcGlja2luZ0NvbG9yczogJ25vbmUnXG4gIC8vIH1cbn1cblxuZnVuY3Rpb24gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcykge1xuICByZXR1cm4gdmVydGljZXMucmVkdWNlKCh2ZXJ0ZXhDb3VudCwgcG9seWdvbikgPT4gdmVydGV4Q291bnQgKyBjb3VudChwb2x5Z29uKSwgMCk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUluZGljZXMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lID0gZmFsc2V9KSB7XG4gIC8vIGFkanVzdCBpbmRleCBvZmZzZXQgZm9yIG11bHRpcGxlIHBvbHlnb25zXG4gIGNvbnN0IG11bHRpcGxpZXIgPSB3aXJlZnJhbWUgPyAyIDogNTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGdyb3VwZWRWZXJ0aWNlcy5yZWR1Y2UoXG4gICAgKGFjYywgdmVydGljZXMpID0+XG4gICAgICBhY2MuY29uY2F0KGFjY1thY2MubGVuZ3RoIC0gMV0gKyBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKSAqIG11bHRpcGxpZXIpLFxuICAgIFswXVxuICApO1xuXG4gIGNvbnN0IGluZGljZXMgPSBncm91cGVkVmVydGljZXMubWFwKCh2ZXJ0aWNlcywgcG9seWdvbkluZGV4KSA9PlxuICAgIHdpcmVmcmFtZSA/XG4gICAgICAvLyAxLiBnZXQgc2VxdWVudGlhbGx5IG9yZGVyZWQgaW5kaWNlcyBvZiBlYWNoIHBvbHlnb25zIHdpcmVmcmFtZVxuICAgICAgLy8gMi4gb2Zmc2V0IHRoZW0gYnkgdGhlIG51bWJlciBvZiBpbmRpY2VzIGluIHByZXZpb3VzIHBvbHlnb25zXG4gICAgICBjYWxjdWxhdGVDb250b3VySW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0c1twb2x5Z29uSW5kZXhdKSA6XG4gICAgICAvLyAxLiBnZXQgdHJpYW5ndWxhdGVkIGluZGljZXMgZm9yIHRoZSBpbnRlcm5hbCBhcmVhc1xuICAgICAgLy8gMi4gb2Zmc2V0IHRoZW0gYnkgdGhlIG51bWJlciBvZiBpbmRpY2VzIGluIHByZXZpb3VzIHBvbHlnb25zXG4gICAgICBjYWxjdWxhdGVTdXJmYWNlSW5kaWNlcyh2ZXJ0aWNlcywgb2Zmc2V0c1twb2x5Z29uSW5kZXhdKVxuICApO1xuXG4gIHJldHVybiBuZXcgVWludDMyQXJyYXkoZmxhdHRlbkRlZXAoaW5kaWNlcykpO1xufVxuXG4vLyBDYWxjdWxhdGUgYSBmbGF0IHBvc2l0aW9uIGFycmF5IGluIEpTIC0gY2FuIGJlIG1hcHBlZCB0byAzMiBvciA2NCBiaXQgdHlwZWQgYXJyYXlzXG4vLyBSZW1hcmtzOlxuLy8gKiBlYWNoIHRvcCB2ZXJ0ZXggaXMgb24gMyBzdXJmYWNlc1xuLy8gKiBlYWNoIGJvdHRvbSB2ZXJ0ZXggaXMgb24gMiBzdXJmYWNlc1xuZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25zSlMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lID0gZmFsc2V9KSB7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IGdyb3VwZWRWZXJ0aWNlcy5tYXAoXG4gICAgdmVydGljZXMgPT4ge1xuICAgICAgY29uc3QgdG9wVmVydGljZXMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCB2ZXJ0aWNlcyk7XG4gICAgICBjb25zdCBiYXNlVmVydGljZXMgPSB0b3BWZXJ0aWNlcy5tYXAodiA9PiBbZ2V0KHYsIDApLCBnZXQodiwgMSksIDBdKTtcbiAgICAgIHJldHVybiB3aXJlZnJhbWUgPyBbdG9wVmVydGljZXMsIGJhc2VWZXJ0aWNlc10gOlxuICAgICAgICBbdG9wVmVydGljZXMsIHRvcFZlcnRpY2VzLCB0b3BWZXJ0aWNlcywgYmFzZVZlcnRpY2VzLCBiYXNlVmVydGljZXNdO1xuICAgIH1cbiAgKTtcblxuICByZXR1cm4gZmxhdHRlbkRlZXAocG9zaXRpb25zKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25zKHBvc2l0aW9uc0pTLCBmcDY0KSB7XG4gIGxldCBwb3NpdGlvbkxvdztcbiAgaWYgKGZwNjQpIHtcbiAgICAvLyBXZSBvbmx5IG5lZWQgeCwgeSBjb21wb25lbnRcbiAgICBwb3NpdGlvbkxvdyA9IG5ldyBGbG9hdDMyQXJyYXkocG9zaXRpb25zSlMubGVuZ3RoIC8gMyAqIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zSlMubGVuZ3RoIC8gMzsgaSsrKSB7XG4gICAgICBwb3NpdGlvbkxvd1tpICogMiArIDBdID0gZnA2NGlmeShwb3NpdGlvbnNKU1tpICogMyArIDBdKVsxXTtcbiAgICAgIHBvc2l0aW9uTG93W2kgKiAyICsgMV0gPSBmcDY0aWZ5KHBvc2l0aW9uc0pTW2kgKiAzICsgMV0pWzFdO1xuICAgIH1cblxuICB9XG4gIHJldHVybiB7cG9zaXRpb25zOiBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uc0pTKSwgcG9zaXRpb25zNjR4eUxvdzogcG9zaXRpb25Mb3d9O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVOb3JtYWxzKHtncm91cGVkVmVydGljZXMsIHdpcmVmcmFtZX0pIHtcbiAgY29uc3QgdXAgPSBbMCwgMSwgMF07XG5cbiAgY29uc3Qgbm9ybWFscyA9IGdyb3VwZWRWZXJ0aWNlcy5tYXAoKHZlcnRpY2VzLCBwb2x5Z29uSW5kZXgpID0+IHtcbiAgICBjb25zdCB0b3BOb3JtYWxzID0gbmV3IEFycmF5KGNvdW50VmVydGljZXModmVydGljZXMpKS5maWxsKHVwKTtcbiAgICBjb25zdCBzaWRlTm9ybWFscyA9IHZlcnRpY2VzLm1hcChwb2x5Z29uID0+IGNhbGN1bGF0ZVNpZGVOb3JtYWxzKHBvbHlnb24pKTtcbiAgICBjb25zdCBzaWRlTm9ybWFsc0ZvcndhcmQgPSBzaWRlTm9ybWFscy5tYXAobiA9PiBuWzBdKTtcbiAgICBjb25zdCBzaWRlTm9ybWFsc0JhY2t3YXJkID0gc2lkZU5vcm1hbHMubWFwKG4gPT4gblsxXSk7XG5cbiAgICByZXR1cm4gd2lyZWZyYW1lID9cbiAgICBbdG9wTm9ybWFscywgdG9wTm9ybWFsc10gOlxuICAgIFt0b3BOb3JtYWxzLCBzaWRlTm9ybWFsc0ZvcndhcmQsIHNpZGVOb3JtYWxzQmFja3dhcmQsIHNpZGVOb3JtYWxzRm9yd2FyZCwgc2lkZU5vcm1hbHNCYWNrd2FyZF07XG4gIH0pO1xuXG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGZsYXR0ZW5EZWVwKG5vcm1hbHMpKTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlU2lkZU5vcm1hbHModmVydGljZXMpIHtcbiAgY29uc3Qgbm9ybWFscyA9IFtdO1xuXG4gIGxldCBsYXN0VmVydGljZSA9IG51bGw7XG4gIGZvciAoY29uc3QgdmVydGljZSBvZiB2ZXJ0aWNlcykge1xuICAgIGlmIChsYXN0VmVydGljZSkge1xuICAgICAgLy8gdmVydGV4W2ktMV0sIHZlcnRleFtpXVxuICAgICAgY29uc3QgbiA9IGdldE5vcm1hbChsYXN0VmVydGljZSwgdmVydGljZSk7XG4gICAgICBub3JtYWxzLnB1c2gobik7XG4gICAgfVxuICAgIGxhc3RWZXJ0aWNlID0gdmVydGljZTtcbiAgfVxuXG4gIHJldHVybiBbW25vcm1hbHMuY29uY2F0KG5vcm1hbHNbMF0pXSwgW1tub3JtYWxzWzBdXS5jb25jYXQobm9ybWFscyldXTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQ29sb3JzKHtncm91cGVkVmVydGljZXMsIGdldENvbG9yLCB3aXJlZnJhbWUgPSBmYWxzZX0pIHtcbiAgY29uc3QgY29sb3JzID0gZ3JvdXBlZFZlcnRpY2VzLm1hcCgoY29tcGxleFBvbHlnb24sIHBvbHlnb25JbmRleCkgPT4ge1xuICAgIGxldCBjb2xvciA9IGdldENvbG9yKHBvbHlnb25JbmRleCk7XG4gICAgY29sb3IgPSBwYXJzZUNvbG9yKGNvbG9yKTtcblxuICAgIGNvbnN0IG51bVZlcnRpY2VzID0gY291bnRWZXJ0aWNlcyhjb21wbGV4UG9seWdvbik7XG4gICAgY29uc3QgdG9wQ29sb3JzID0gbmV3IEFycmF5KG51bVZlcnRpY2VzKS5maWxsKGNvbG9yKTtcbiAgICBjb25zdCBiYXNlQ29sb3JzID0gbmV3IEFycmF5KG51bVZlcnRpY2VzKS5maWxsKGNvbG9yKTtcbiAgICByZXR1cm4gd2lyZWZyYW1lID9cbiAgICAgIFt0b3BDb2xvcnMsIGJhc2VDb2xvcnNdIDpcbiAgICAgIFt0b3BDb2xvcnMsIHRvcENvbG9ycywgdG9wQ29sb3JzLCBiYXNlQ29sb3JzLCBiYXNlQ29sb3JzXTtcbiAgfSk7XG4gIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkoZmxhdHRlbkRlZXAoY29sb3JzKSk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBpY2tpbmdDb2xvcnMoe2dyb3VwZWRWZXJ0aWNlcywgd2lyZWZyYW1lID0gZmFsc2V9KSB7XG4gIGNvbnN0IGNvbG9ycyA9IGdyb3VwZWRWZXJ0aWNlcy5tYXAoKHZlcnRpY2VzLCBwb2x5Z29uSW5kZXgpID0+IHtcbiAgICBjb25zdCBudW1WZXJ0aWNlcyA9IGNvdW50VmVydGljZXModmVydGljZXMpO1xuICAgIGNvbnN0IGNvbG9yID0gZ2V0UGlja2luZ0NvbG9yKHBvbHlnb25JbmRleCk7XG4gICAgY29uc3QgdG9wQ29sb3JzID0gbmV3IEFycmF5KG51bVZlcnRpY2VzKS5maWxsKGNvbG9yKTtcbiAgICBjb25zdCBiYXNlQ29sb3JzID0gbmV3IEFycmF5KG51bVZlcnRpY2VzKS5maWxsKGNvbG9yKTtcbiAgICByZXR1cm4gd2lyZWZyYW1lID9cbiAgICAgIFt0b3BDb2xvcnMsIGJhc2VDb2xvcnNdIDpcbiAgICAgIFt0b3BDb2xvcnMsIHRvcENvbG9ycywgdG9wQ29sb3JzLCBiYXNlQ29sb3JzLCBiYXNlQ29sb3JzXTtcbiAgfSk7XG4gIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkoZmxhdHRlbkRlZXAoY29sb3JzKSk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRvdXJJbmRpY2VzKHZlcnRpY2VzLCBvZmZzZXQpIHtcbiAgY29uc3Qgc3RyaWRlID0gY291bnRWZXJ0aWNlcyh2ZXJ0aWNlcyk7XG5cbiAgcmV0dXJuIHZlcnRpY2VzLm1hcChwb2x5Z29uID0+IHtcbiAgICBjb25zdCBpbmRpY2VzID0gW29mZnNldF07XG4gICAgY29uc3QgbnVtVmVydGljZXMgPSBwb2x5Z29uLmxlbmd0aDtcblxuICAgIC8vIHBvbHlnb24gdG9wXG4gICAgLy8gdXNlIHZlcnRleCBwYWlycyBmb3IgR0wuTElORVMgPT4gWzAsIDEsIDEsIDIsIDIsIC4uLiwgbi0xLCBuLTEsIDBdXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1WZXJ0aWNlcyAtIDE7IGkrKykge1xuICAgICAgaW5kaWNlcy5wdXNoKGkgKyBvZmZzZXQsIGkgKyBvZmZzZXQpO1xuICAgIH1cbiAgICBpbmRpY2VzLnB1c2gob2Zmc2V0KTtcblxuICAgIC8vIHBvbHlnb24gc2lkZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZlcnRpY2VzIC0gMTsgaSsrKSB7XG4gICAgICBpbmRpY2VzLnB1c2goaSArIG9mZnNldCwgaSArIHN0cmlkZSArIG9mZnNldCk7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IG51bVZlcnRpY2VzO1xuICAgIHJldHVybiBpbmRpY2VzO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlU3VyZmFjZUluZGljZXModmVydGljZXMsIG9mZnNldCkge1xuICBjb25zdCBzdHJpZGUgPSBjb3VudFZlcnRpY2VzKHZlcnRpY2VzKTtcbiAgY29uc3QgcXVhZCA9IFtcbiAgICBbMCwgMV0sIFswLCAzXSwgWzEsIDJdLFxuICAgIFsxLCAyXSwgWzAsIDNdLCBbMSwgNF1cbiAgXTtcblxuICBmdW5jdGlvbiBkcmF3UmVjdGFuZ2xlKGkpIHtcbiAgICByZXR1cm4gcXVhZC5tYXAodiA9PiBpICsgdlswXSArIHN0cmlkZSAqIHZbMV0gKyBvZmZzZXQpO1xuICB9XG5cbiAgbGV0IGhvbGVzID0gbnVsbDtcblxuICBpZiAodmVydGljZXMubGVuZ3RoID4gMSkge1xuICAgIGhvbGVzID0gdmVydGljZXMucmVkdWNlKFxuICAgICAgKGFjYywgcG9seWdvbikgPT4gYWNjLmNvbmNhdChhY2NbYWNjLmxlbmd0aCAtIDFdICsgcG9seWdvbi5sZW5ndGgpLFxuICAgICAgWzBdXG4gICAgKS5zbGljZSgxLCB2ZXJ0aWNlcy5sZW5ndGgpO1xuICB9XG5cbiAgY29uc3QgdG9wSW5kaWNlcyA9IGVhcmN1dChmbGF0dGVuRGVlcCh2ZXJ0aWNlcyksIGhvbGVzLCAzKS5tYXAoaW5kZXggPT4gaW5kZXggKyBvZmZzZXQpO1xuXG4gIGNvbnN0IHNpZGVJbmRpY2VzID0gdmVydGljZXMubWFwKHBvbHlnb24gPT4ge1xuICAgIGNvbnN0IG51bVZlcnRpY2VzID0gcG9seWdvbi5sZW5ndGg7XG4gICAgLy8gcG9seWdvbiB0b3BcbiAgICBsZXQgaW5kaWNlcyA9IFtdO1xuXG4gICAgLy8gcG9seWdvbiBzaWRlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmVydGljZXMgLSAxOyBpKyspIHtcbiAgICAgIGluZGljZXMgPSBpbmRpY2VzLmNvbmNhdChkcmF3UmVjdGFuZ2xlKGkpKTtcbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gbnVtVmVydGljZXM7XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH0pO1xuXG4gIHJldHVybiBbdG9wSW5kaWNlcywgc2lkZUluZGljZXNdO1xufVxuXG4vLyBoZWxwZXJzXG5cbi8vIGdldCBub3JtYWwgdmVjdG9yIG9mIGxpbmUgc2VnbWVudFxuZnVuY3Rpb24gZ2V0Tm9ybWFsKHAxLCBwMikge1xuICBjb25zdCBwMXggPSBnZXQocDEsIDApO1xuICBjb25zdCBwMXkgPSBnZXQocDEsIDEpO1xuICBjb25zdCBwMnggPSBnZXQocDIsIDApO1xuICBjb25zdCBwMnkgPSBnZXQocDIsIDEpO1xuXG4gIGlmIChwMXggPT09IHAyeCAmJiBwMXkgPT09IHAyeSkge1xuICAgIHJldHVybiBbMSwgMCwgMF07XG4gIH1cblxuICBjb25zdCBkZWdyZWVzMnJhZGlhbnMgPSBNYXRoLlBJIC8gMTgwO1xuICBjb25zdCBsb24xID0gZGVncmVlczJyYWRpYW5zICogcDF4O1xuICBjb25zdCBsb24yID0gZGVncmVlczJyYWRpYW5zICogcDJ4O1xuICBjb25zdCBsYXQxID0gZGVncmVlczJyYWRpYW5zICogcDF5O1xuICBjb25zdCBsYXQyID0gZGVncmVlczJyYWRpYW5zICogcDJ5O1xuICBjb25zdCBhID0gTWF0aC5zaW4obG9uMiAtIGxvbjEpICogTWF0aC5jb3MobGF0Mik7XG4gIGNvbnN0IGIgPSBNYXRoLmNvcyhsYXQxKSAqIE1hdGguc2luKGxhdDIpIC1cbiAgICBNYXRoLnNpbihsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MobG9uMiAtIGxvbjEpO1xuICByZXR1cm4gdmVjM19ub3JtYWxpemUoW10sIFtiLCAwLCAtYV0pO1xufVxuIl19