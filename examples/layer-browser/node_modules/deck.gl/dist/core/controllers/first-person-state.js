'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _math = require('math.gl');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SphericalCoordinates = _math.experimental.SphericalCoordinates;


var MOVEMENT_SPEED = 1; // 1 meter per keyboard click
// const ROTATION_STEP_RADIANS = 0.03;
var ROTATION_STEP_DEGREES = 2;

var defaultState = {
  position: [0, 0, 0],
  lookAt: [0, 0, 0],
  up: [0, 0, 1],

  rotationX: 0,
  rotationY: 0,

  fov: 50,
  near: 1,
  far: 100
};

/* Helpers */

// Constrain number between bounds
function clamp(x, min, max) {
  return x < min ? min : x > max ? max : x;
}

function ensureFinite(value, fallbackValue) {
  return Number.isFinite(value) ? value : fallbackValue;
}

var FirstPersonState = function () {
  function FirstPersonState(_ref) {
    var width = _ref.width,
        height = _ref.height,
        position = _ref.position,
        direction = _ref.direction,
        bearing = _ref.bearing,
        pitch = _ref.pitch,
        longitude = _ref.longitude,
        latitude = _ref.latitude,
        zoom = _ref.zoom,
        _ref$syncBearing = _ref.syncBearing,
        syncBearing = _ref$syncBearing === undefined ? true : _ref$syncBearing,
        bounds = _ref.bounds,
        startPanEventPosition = _ref.startPanEventPosition,
        startPanPosition = _ref.startPanPosition,
        startRotateCenter = _ref.startRotateCenter,
        startRotateViewport = _ref.startRotateViewport,
        startZoomPos = _ref.startZoomPos,
        startZoom = _ref.startZoom;

    _classCallCheck(this, FirstPersonState);

    (0, _assert2.default)(Number.isFinite(width), '`width` must be supplied');
    (0, _assert2.default)(Number.isFinite(height), '`height` must be supplied');
    // assert(Number.isFinite(distance), '`distance` must be supplied');

    bearing = ensureFinite(bearing, defaultState.bearing);

    this._viewportProps = this._applyConstraints({
      width: width,
      height: height,
      position: new _math.Vector3(ensureFinite(position && position[0], defaultState.position[0]), ensureFinite(position && position[1], defaultState.position[1]), ensureFinite(position && position[2], defaultState.position[2])),
      direction: this._getDirectionFromBearing(bearing),
      bearing: bearing,
      pitch: ensureFinite(pitch, defaultState.pitch),
      longitude: longitude,
      latitude: latitude,
      zoom: zoom,
      bounds: bounds
    });

    this._interactiveState = {
      startPanEventPosition: startPanEventPosition,
      startPanPosition: startPanPosition,
      startRotateCenter: startRotateCenter,
      startRotateViewport: startRotateViewport,
      startZoomPos: startZoomPos,
      startZoom: startZoom
    };
  }

  /* Public API */

  _createClass(FirstPersonState, [{
    key: 'getViewportProps',
    value: function getViewportProps() {
      return this._viewportProps;
    }
  }, {
    key: 'getInteractiveState',
    value: function getInteractiveState() {
      return this._interactiveState;
    }
  }, {
    key: 'getLookAt',
    value: function getLookAt() {
      return [];
    }

    /**
     * Start panning
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'panStart',
    value: function panStart(_ref2) {
      var pos = _ref2.pos;
      var _viewportProps = this._viewportProps,
          translationX = _viewportProps.translationX,
          translationY = _viewportProps.translationY;


      return this._getUpdatedState({
        startPanPosition: [translationX, translationY],
        startPanEventPosition: pos
      });
    }

    /**
     * Pan
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */

  }, {
    key: 'pan',
    value: function pan(_ref3) {
      var pos = _ref3.pos,
          startPos = _ref3.startPos;

      var startPanEventPosition = this._interactiveState.startPanEventPosition || startPos;
      (0, _assert2.default)(startPanEventPosition, '`startPanEventPosition` props is required');

      var _ref4 = this._interactiveState.startPanPosition || [],
          _ref5 = _slicedToArray(_ref4, 2),
          translationX = _ref5[0],
          translationY = _ref5[1];

      translationX = ensureFinite(translationX, this._viewportProps.translationX);
      translationY = ensureFinite(translationY, this._viewportProps.translationY);

      var deltaX = pos[0] - startPanEventPosition[0];
      var deltaY = pos[1] - startPanEventPosition[1];

      return this._getUpdatedState({
        translationX: translationX + deltaX,
        translationY: translationY - deltaY
      });
    }

    /**
     * End panning
     * Must call if `panStart()` was called
     */

  }, {
    key: 'panEnd',
    value: function panEnd() {
      return this._getUpdatedState({
        startPanPosition: null,
        startPanPos: null
      });
    }

    /**
     * Start rotating
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'rotateStart',
    value: function rotateStart(_ref6) {
      var pos = _ref6.pos;

      return this._getUpdatedState({
        startRotateCenter: this._viewportProps.position,
        startRotateViewport: this._viewportProps
      });
    }

    /**
     * Rotate
     * @param {[Number, Number]} pos - position on screen where the pointer is
     */

  }, {
    key: 'rotate',
    value: function rotate(_ref7) {
      var deltaScaleX = _ref7.deltaScaleX,
          deltaScaleY = _ref7.deltaScaleY;
      var direction = this._viewportProps.direction;


      return this._getUpdatedState({
        direction: new _math.Vector3(direction).rotateZ({ radians: deltaScaleX / 50 })
      });
    }

    /**
     * End rotating
     * Must call if `rotateStart()` was called
     */

  }, {
    key: 'rotateEnd',
    value: function rotateEnd() {
      return this._getUpdatedState({
        startRotateCenter: null,
        startRotateViewport: null
      });
    }

    /**
     * Start zooming
     * @param {[Number, Number]} pos - position on screen where the pointer grabs
     */

  }, {
    key: 'zoomStart',
    value: function zoomStart(_ref8) {
      var pos = _ref8.pos;

      return this._getUpdatedState({
        startZoomPos: pos,
        startZoom: this._viewportProps.zoom
      });
    }

    /**
     * Zoom
     * @param {[Number, Number]} pos - position on screen where the current center is
     * @param {[Number, Number]} startPos - the center position at
     *   the start of the operation. Must be supplied of `zoomStart()` was not called
     * @param {Number} scale - a number between [0, 1] specifying the accumulated
     *   relative scale.
     */

  }, {
    key: 'zoom',
    value: function zoom(_ref9) {
      var pos = _ref9.pos,
          startPos = _ref9.startPos,
          scale = _ref9.scale;
      var _viewportProps2 = this._viewportProps,
          zoom = _viewportProps2.zoom,
          minZoom = _viewportProps2.minZoom,
          maxZoom = _viewportProps2.maxZoom,
          width = _viewportProps2.width,
          height = _viewportProps2.height,
          translationX = _viewportProps2.translationX,
          translationY = _viewportProps2.translationY;


      var startZoomPos = this._interactiveState.startZoomPos || startPos || pos;

      var newZoom = clamp(zoom * scale, minZoom, maxZoom);
      var deltaX = pos[0] - startZoomPos[0];
      var deltaY = pos[1] - startZoomPos[1];

      // Zoom around the center position
      var cx = startZoomPos[0] - width / 2;
      var cy = height / 2 - startZoomPos[1];
      /* eslint-disable no-unused-vars */
      var newTranslationX = cx - (cx - translationX) * newZoom / zoom + deltaX;
      var newTranslationY = cy - (cy - translationY) * newZoom / zoom - deltaY;
      /* eslint-enable no-unused-vars */

      // return this._getUpdatedState({
      //   position
      //   translationX: newTranslationX,
      //   translationY: newTranslationY
      // });

      // TODO HACK
      return newZoom / zoom < 1 ? this.moveBackward() : this.moveForward();
    }

    /**
     * End zooming
     * Must call if `zoomStart()` was called
     */

  }, {
    key: 'zoomEnd',
    value: function zoomEnd() {
      return this._getUpdatedState({
        startZoomPos: null,
        startZoom: null
      });
    }
  }, {
    key: '_getDirectionFromBearing',
    value: function _getDirectionFromBearing(bearing) {
      var spherical = new SphericalCoordinates({
        bearing: bearing,
        pitch: 90
      });
      var direction = spherical.toVector3().normalize();
      return direction;
    }
  }, {
    key: 'moveLeft',
    value: function moveLeft() {
      // const {position, direction} = this._viewportProps;
      // const newDirection = new Vector3(direction).rotateZ({radians: ROTATION_STEP_RADIANS});
      // return this._getUpdatedState({
      //   direction: newDirection,
      //   lookAt: new Vector3(position).add(newDirection.normalize()),
      //   bearing: this._viewportProps.bearing - ROTATION_STEP_DEGREES
      // });

      var _viewportProps3 = this._viewportProps,
          position = _viewportProps3.position,
          bearing = _viewportProps3.bearing;

      var newBearing = bearing - ROTATION_STEP_DEGREES;
      var newDirection = this._getDirectionFromBearing(newBearing);
      return this._getUpdatedState({
        direction: newDirection,
        lookAt: new _math.Vector3(position).add(newDirection),
        bearing: newBearing
      });
    }
  }, {
    key: 'moveRight',
    value: function moveRight() {
      // const {position, direction} = this._viewportProps;
      // const newDirection = new Vector3(direction).rotateZ({radians: -ROTATION_STEP_RADIANS});
      // return this._getUpdatedState({
      //   direction: newDirection,
      //   lookAt: new Vector3(position).add(newDirection.normalize()),
      //   bearing: this._viewportProps.bearing + ROTATION_STEP_DEGREES
      // });

      var _viewportProps4 = this._viewportProps,
          position = _viewportProps4.position,
          bearing = _viewportProps4.bearing;

      var newBearing = bearing + ROTATION_STEP_DEGREES;
      var newDirection = this._getDirectionFromBearing(newBearing);
      return this._getUpdatedState({
        direction: newDirection,
        lookAt: new _math.Vector3(position).add(newDirection),
        bearing: newBearing
      });
    }
  }, {
    key: 'moveForward',
    value: function moveForward() {
      var _viewportProps5 = this._viewportProps,
          position = _viewportProps5.position,
          direction = _viewportProps5.direction;

      var delta = new _math.Vector3(direction).normalize().scale(MOVEMENT_SPEED);
      return this._getUpdatedState({
        // pitch: this._viewportProps.pitch + 3
        position: new _math.Vector3(position).add(delta),
        lookAt: new _math.Vector3(position).add(direction)
      });
    }
  }, {
    key: 'moveBackward',
    value: function moveBackward() {
      var _viewportProps6 = this._viewportProps,
          position = _viewportProps6.position,
          direction = _viewportProps6.direction;

      var delta = new _math.Vector3(direction).normalize().scale(-MOVEMENT_SPEED);
      return this._getUpdatedState({
        // pitch: this._viewportProps.pitch - 3
        position: new _math.Vector3(position).add(delta),
        lookAt: new _math.Vector3(position).add(direction)
      });
    }
  }, {
    key: 'moveUp',
    value: function moveUp() {
      var _viewportProps7 = this._viewportProps,
          position = _viewportProps7.position,
          direction = _viewportProps7.direction;

      var delta = [0, 0, 1];
      return this._getUpdatedState({
        // pitch: this._viewportProps.pitch + 3
        position: new _math.Vector3(position).add(delta),
        lookAt: new _math.Vector3(position).add(direction)
      });
    }
  }, {
    key: 'moveDown',
    value: function moveDown() {
      var _viewportProps8 = this._viewportProps,
          position = _viewportProps8.position,
          direction = _viewportProps8.direction;

      var delta = position[2] >= 1 ? [0, 0, -1] : [0, 0, 0];
      return this._getUpdatedState({
        // pitch: this._viewportProps.pitch + 3
        position: new _math.Vector3(position).add(delta),
        lookAt: new _math.Vector3(position).add(direction)
      });
    }
  }, {
    key: 'zoomIn',
    value: function zoomIn() {
      return this._getUpdatedState({
        zoom: this._viewportProps.zoom + 0.2
      });
    }
  }, {
    key: 'zoomOut',
    value: function zoomOut() {
      return this._getUpdatedState({
        zoom: this._viewportProps.zoom - 0.2
      });
    }

    /* Private methods */

  }, {
    key: '_getUpdatedState',
    value: function _getUpdatedState(newProps) {
      // Update _viewportProps
      return new FirstPersonState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
    }

    // Apply any constraints (mathematical or defined by _viewportProps) to map state

  }, {
    key: '_applyConstraints',
    value: function _applyConstraints(props) {
      // TODO/ib - Ensure position is within bounds
      return props;
    }
  }]);

  return FirstPersonState;
}();

exports.default = FirstPersonState;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2NvbnRyb2xsZXJzL2ZpcnN0LXBlcnNvbi1zdGF0ZS5qcyJdLCJuYW1lcyI6WyJTcGhlcmljYWxDb29yZGluYXRlcyIsIk1PVkVNRU5UX1NQRUVEIiwiUk9UQVRJT05fU1RFUF9ERUdSRUVTIiwiZGVmYXVsdFN0YXRlIiwicG9zaXRpb24iLCJsb29rQXQiLCJ1cCIsInJvdGF0aW9uWCIsInJvdGF0aW9uWSIsImZvdiIsIm5lYXIiLCJmYXIiLCJjbGFtcCIsIngiLCJtaW4iLCJtYXgiLCJlbnN1cmVGaW5pdGUiLCJ2YWx1ZSIsImZhbGxiYWNrVmFsdWUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIkZpcnN0UGVyc29uU3RhdGUiLCJ3aWR0aCIsImhlaWdodCIsImRpcmVjdGlvbiIsImJlYXJpbmciLCJwaXRjaCIsImxvbmdpdHVkZSIsImxhdGl0dWRlIiwiem9vbSIsInN5bmNCZWFyaW5nIiwiYm91bmRzIiwic3RhcnRQYW5FdmVudFBvc2l0aW9uIiwic3RhcnRQYW5Qb3NpdGlvbiIsInN0YXJ0Um90YXRlQ2VudGVyIiwic3RhcnRSb3RhdGVWaWV3cG9ydCIsInN0YXJ0Wm9vbVBvcyIsInN0YXJ0Wm9vbSIsIl92aWV3cG9ydFByb3BzIiwiX2FwcGx5Q29uc3RyYWludHMiLCJfZ2V0RGlyZWN0aW9uRnJvbUJlYXJpbmciLCJfaW50ZXJhY3RpdmVTdGF0ZSIsInBvcyIsInRyYW5zbGF0aW9uWCIsInRyYW5zbGF0aW9uWSIsIl9nZXRVcGRhdGVkU3RhdGUiLCJzdGFydFBvcyIsImRlbHRhWCIsImRlbHRhWSIsInN0YXJ0UGFuUG9zIiwiZGVsdGFTY2FsZVgiLCJkZWx0YVNjYWxlWSIsInJvdGF0ZVoiLCJyYWRpYW5zIiwic2NhbGUiLCJtaW5ab29tIiwibWF4Wm9vbSIsIm5ld1pvb20iLCJjeCIsImN5IiwibmV3VHJhbnNsYXRpb25YIiwibmV3VHJhbnNsYXRpb25ZIiwibW92ZUJhY2t3YXJkIiwibW92ZUZvcndhcmQiLCJzcGhlcmljYWwiLCJ0b1ZlY3RvcjMiLCJub3JtYWxpemUiLCJuZXdCZWFyaW5nIiwibmV3RGlyZWN0aW9uIiwiYWRkIiwiZGVsdGEiLCJuZXdQcm9wcyIsIk9iamVjdCIsImFzc2lnbiIsInByb3BzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7O0FBRUE7Ozs7Ozs7O0lBRE9BLG9CLHNCQUFBQSxvQjs7O0FBR1AsSUFBTUMsaUJBQWlCLENBQXZCLEMsQ0FBMkI7QUFDM0I7QUFDQSxJQUFNQyx3QkFBd0IsQ0FBOUI7O0FBRUEsSUFBTUMsZUFBZTtBQUNuQkMsWUFBVSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxDQURTO0FBRW5CQyxVQUFRLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBRlc7QUFHbkJDLE1BQUksQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FIZTs7QUFLbkJDLGFBQVcsQ0FMUTtBQU1uQkMsYUFBVyxDQU5ROztBQVFuQkMsT0FBSyxFQVJjO0FBU25CQyxRQUFNLENBVGE7QUFVbkJDLE9BQUs7QUFWYyxDQUFyQjs7QUFhQTs7QUFFQTtBQUNBLFNBQVNDLEtBQVQsQ0FBZUMsQ0FBZixFQUFrQkMsR0FBbEIsRUFBdUJDLEdBQXZCLEVBQTRCO0FBQzFCLFNBQU9GLElBQUlDLEdBQUosR0FBVUEsR0FBVixHQUFpQkQsSUFBSUUsR0FBSixHQUFVQSxHQUFWLEdBQWdCRixDQUF4QztBQUNEOztBQUVELFNBQVNHLFlBQVQsQ0FBc0JDLEtBQXRCLEVBQTZCQyxhQUE3QixFQUE0QztBQUMxQyxTQUFPQyxPQUFPQyxRQUFQLENBQWdCSCxLQUFoQixJQUF5QkEsS0FBekIsR0FBaUNDLGFBQXhDO0FBQ0Q7O0lBRW9CRyxnQjtBQUVuQixrQ0FtQ0c7QUFBQSxRQWpDREMsS0FpQ0MsUUFqQ0RBLEtBaUNDO0FBQUEsUUFoQ0RDLE1BZ0NDLFFBaENEQSxNQWdDQztBQUFBLFFBN0JEbkIsUUE2QkMsUUE3QkRBLFFBNkJDO0FBQUEsUUE1QkRvQixTQTRCQyxRQTVCREEsU0E0QkM7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dEIsQ0FBUDtBQUdEOzs7OEJBRVM7QUFDUixhQUFPLEtBQUtnQixnQkFBTCxDQUFzQjtBQUMzQmhCLGNBQU0sS0FBS1MsY0FBTCxDQUFvQlQsSUFBcEIsR0FBMkI7QUFETixPQUF0QixDQUFQO0FBR0Q7O0FBRUQ7Ozs7cUNBRWlCMEMsUSxFQUFVO0FBQ3pCO0FBQ0EsYUFBTyxJQUFJbEQsZ0JBQUosQ0FDTG1ELE9BQU9DLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLEtBQUtuQyxjQUF2QixFQUF1QyxLQUFLRyxpQkFBNUMsRUFBK0Q4QixRQUEvRCxDQURLLENBQVA7QUFHRDs7QUFFRDs7OztzQ0FDa0JHLEssRUFBTztBQUN2QjtBQUNBLGFBQU9BLEtBQVA7QUFDRDs7Ozs7O2tCQTdVa0JyRCxnQiIsImZpbGUiOiJmaXJzdC1wZXJzb24tc3RhdGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1ZlY3RvcjMsIGV4cGVyaW1lbnRhbH0gZnJvbSAnbWF0aC5nbCc7XG5jb25zdCB7U3BoZXJpY2FsQ29vcmRpbmF0ZXN9ID0gZXhwZXJpbWVudGFsO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5jb25zdCBNT1ZFTUVOVF9TUEVFRCA9IDE7ICAvLyAxIG1ldGVyIHBlciBrZXlib2FyZCBjbGlja1xuLy8gY29uc3QgUk9UQVRJT05fU1RFUF9SQURJQU5TID0gMC4wMztcbmNvbnN0IFJPVEFUSU9OX1NURVBfREVHUkVFUyA9IDI7XG5cbmNvbnN0IGRlZmF1bHRTdGF0ZSA9IHtcbiAgcG9zaXRpb246IFswLCAwLCAwXSxcbiAgbG9va0F0OiBbMCwgMCwgMF0sXG4gIHVwOiBbMCwgMCwgMV0sXG5cbiAgcm90YXRpb25YOiAwLFxuICByb3RhdGlvblk6IDAsXG5cbiAgZm92OiA1MCxcbiAgbmVhcjogMSxcbiAgZmFyOiAxMDBcbn07XG5cbi8qIEhlbHBlcnMgKi9cblxuLy8gQ29uc3RyYWluIG51bWJlciBiZXR3ZWVuIGJvdW5kc1xuZnVuY3Rpb24gY2xhbXAoeCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHggPCBtaW4gPyBtaW4gOiAoeCA+IG1heCA/IG1heCA6IHgpO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVGaW5pdGUodmFsdWUsIGZhbGxiYWNrVmFsdWUpIHtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IGZhbGxiYWNrVmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpcnN0UGVyc29uU3RhdGUge1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICAvKiBWaWV3cG9ydCBhcmd1bWVudHMgKi9cbiAgICB3aWR0aCwgLy8gV2lkdGggb2Ygdmlld3BvcnRcbiAgICBoZWlnaHQsIC8vIEhlaWdodCBvZiB2aWV3cG9ydFxuXG4gICAgLy8gUG9zaXRpb24gYW5kIG9yaWVudGF0aW9uXG4gICAgcG9zaXRpb24sIC8vIHR5cGljYWxseSBpbiBtZXRlcnMgZnJvbSBhbmNob3IgcG9pbnRcbiAgICBkaXJlY3Rpb24sXG5cbiAgICBiZWFyaW5nLCAvLyBSb3RhdGlvbiBhcm91bmQgeSBheGlzXG4gICAgcGl0Y2gsIC8vIFJvdGF0aW9uIGFyb3VuZCB4IGF4aXNcblxuICAgIC8vIEdlb3NwYXRpYWwgYW5jaG9yXG4gICAgbG9uZ2l0dWRlLFxuICAgIGxhdGl0dWRlLFxuICAgIHpvb20sXG5cbiAgICBzeW5jQmVhcmluZyA9IHRydWUsIC8vIFdoZXRoZXIgdG8gbG9jayBiZWFyaW5nIHRvIGRpcmVjdGlvblxuXG4gICAgLy8gQ29uc3RyYWludHMgLSBzaW1wbGUgbW92ZW1lbnQgbGltaXRcbiAgICAvLyBCb3VuZGluZyBib3ggb2YgdGhlIHdvcmxkLCBpbiB0aGUgc2hhcGUgb2Yge21pblgsIG1heFgsIG1pblksIG1heFksIG1pblosIG1heFp9XG4gICAgYm91bmRzLFxuXG4gICAgLyoqIEludGVyYWN0aW9uIHN0YXRlcywgcmVxdWlyZWQgdG8gY2FsY3VsYXRlIGNoYW5nZSBkdXJpbmcgdHJhbnNmb3JtICovXG4gICAgLy8gTW9kZWwgc3RhdGUgd2hlbiB0aGUgcGFuIG9wZXJhdGlvbiBmaXJzdCBzdGFydGVkXG4gICAgc3RhcnRQYW5FdmVudFBvc2l0aW9uLFxuICAgIHN0YXJ0UGFuUG9zaXRpb24sXG5cbiAgICAvLyBNb2RlbCBzdGF0ZSB3aGVuIHRoZSByb3RhdGUgb3BlcmF0aW9uIGZpcnN0IHN0YXJ0ZWRcbiAgICBzdGFydFJvdGF0ZUNlbnRlcixcbiAgICBzdGFydFJvdGF0ZVZpZXdwb3J0LFxuXG4gICAgLy8gTW9kZWwgc3RhdGUgd2hlbiB0aGUgem9vbSBvcGVyYXRpb24gZmlyc3Qgc3RhcnRlZFxuICAgIHN0YXJ0Wm9vbVBvcyxcbiAgICBzdGFydFpvb21cbiAgfSkge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUod2lkdGgpLCAnYHdpZHRoYCBtdXN0IGJlIHN1cHBsaWVkJyk7XG4gICAgYXNzZXJ0KE51bWJlci5pc0Zpbml0ZShoZWlnaHQpLCAnYGhlaWdodGAgbXVzdCBiZSBzdXBwbGllZCcpO1xuICAgIC8vIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoZGlzdGFuY2UpLCAnYGRpc3RhbmNlYCBtdXN0IGJlIHN1cHBsaWVkJyk7XG5cbiAgICBiZWFyaW5nID0gZW5zdXJlRmluaXRlKGJlYXJpbmcsIGRlZmF1bHRTdGF0ZS5iZWFyaW5nKTtcblxuICAgIHRoaXMuX3ZpZXdwb3J0UHJvcHMgPSB0aGlzLl9hcHBseUNvbnN0cmFpbnRzKHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcG9zaXRpb246IG5ldyBWZWN0b3IzKFxuICAgICAgICBlbnN1cmVGaW5pdGUocG9zaXRpb24gJiYgcG9zaXRpb25bMF0sIGRlZmF1bHRTdGF0ZS5wb3NpdGlvblswXSksXG4gICAgICAgIGVuc3VyZUZpbml0ZShwb3NpdGlvbiAmJiBwb3NpdGlvblsxXSwgZGVmYXVsdFN0YXRlLnBvc2l0aW9uWzFdKSxcbiAgICAgICAgZW5zdXJlRmluaXRlKHBvc2l0aW9uICYmIHBvc2l0aW9uWzJdLCBkZWZhdWx0U3RhdGUucG9zaXRpb25bMl0pXG4gICAgICApLFxuICAgICAgZGlyZWN0aW9uOiB0aGlzLl9nZXREaXJlY3Rpb25Gcm9tQmVhcmluZyhiZWFyaW5nKSxcbiAgICAgIGJlYXJpbmcsXG4gICAgICBwaXRjaDogZW5zdXJlRmluaXRlKHBpdGNoLCBkZWZhdWx0U3RhdGUucGl0Y2gpLFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgbGF0aXR1ZGUsXG4gICAgICB6b29tLFxuICAgICAgYm91bmRzXG4gICAgfSk7XG5cbiAgICB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlID0ge1xuICAgICAgc3RhcnRQYW5FdmVudFBvc2l0aW9uLFxuICAgICAgc3RhcnRQYW5Qb3NpdGlvbixcbiAgICAgIHN0YXJ0Um90YXRlQ2VudGVyLFxuICAgICAgc3RhcnRSb3RhdGVWaWV3cG9ydCxcbiAgICAgIHN0YXJ0Wm9vbVBvcyxcbiAgICAgIHN0YXJ0Wm9vbVxuICAgIH07XG4gIH1cblxuICAvKiBQdWJsaWMgQVBJICovXG5cbiAgZ2V0Vmlld3BvcnRQcm9wcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRQcm9wcztcbiAgfVxuXG4gIGdldEludGVyYWN0aXZlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVyYWN0aXZlU3RhdGU7XG4gIH1cblxuICBnZXRMb29rQXQoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHBhbm5pbmdcbiAgICogQHBhcmFtIHtbTnVtYmVyLCBOdW1iZXJdfSBwb3MgLSBwb3NpdGlvbiBvbiBzY3JlZW4gd2hlcmUgdGhlIHBvaW50ZXIgZ3JhYnNcbiAgICovXG4gIHBhblN0YXJ0KHtwb3N9KSB7XG4gICAgY29uc3Qge3RyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZfSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHN0YXJ0UGFuUG9zaXRpb246IFt0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWV0sXG4gICAgICBzdGFydFBhbkV2ZW50UG9zaXRpb246IHBvc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhblxuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHBvcyAtIHBvc2l0aW9uIG9uIHNjcmVlbiB3aGVyZSB0aGUgcG9pbnRlciBpc1xuICAgKi9cbiAgcGFuKHtwb3MsIHN0YXJ0UG9zfSkge1xuICAgIGNvbnN0IHN0YXJ0UGFuRXZlbnRQb3NpdGlvbiA9IHRoaXMuX2ludGVyYWN0aXZlU3RhdGUuc3RhcnRQYW5FdmVudFBvc2l0aW9uIHx8IHN0YXJ0UG9zO1xuICAgIGFzc2VydChzdGFydFBhbkV2ZW50UG9zaXRpb24sICdgc3RhcnRQYW5FdmVudFBvc2l0aW9uYCBwcm9wcyBpcyByZXF1aXJlZCcpO1xuXG4gICAgbGV0IFt0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWV0gPSB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlLnN0YXJ0UGFuUG9zaXRpb24gfHwgW107XG4gICAgdHJhbnNsYXRpb25YID0gZW5zdXJlRmluaXRlKHRyYW5zbGF0aW9uWCwgdGhpcy5fdmlld3BvcnRQcm9wcy50cmFuc2xhdGlvblgpO1xuICAgIHRyYW5zbGF0aW9uWSA9IGVuc3VyZUZpbml0ZSh0cmFuc2xhdGlvblksIHRoaXMuX3ZpZXdwb3J0UHJvcHMudHJhbnNsYXRpb25ZKTtcblxuICAgIGNvbnN0IGRlbHRhWCA9IHBvc1swXSAtIHN0YXJ0UGFuRXZlbnRQb3NpdGlvblswXTtcbiAgICBjb25zdCBkZWx0YVkgPSBwb3NbMV0gLSBzdGFydFBhbkV2ZW50UG9zaXRpb25bMV07XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHRyYW5zbGF0aW9uWDogdHJhbnNsYXRpb25YICsgZGVsdGFYLFxuICAgICAgdHJhbnNsYXRpb25ZOiB0cmFuc2xhdGlvblkgLSBkZWx0YVlcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmQgcGFubmluZ1xuICAgKiBNdXN0IGNhbGwgaWYgYHBhblN0YXJ0KClgIHdhcyBjYWxsZWRcbiAgICovXG4gIHBhbkVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHN0YXJ0UGFuUG9zaXRpb246IG51bGwsXG4gICAgICBzdGFydFBhblBvczogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHJvdGF0aW5nXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBwb2ludGVyIGdyYWJzXG4gICAqL1xuICByb3RhdGVTdGFydCh7cG9zfSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgc3RhcnRSb3RhdGVDZW50ZXI6IHRoaXMuX3ZpZXdwb3J0UHJvcHMucG9zaXRpb24sXG4gICAgICBzdGFydFJvdGF0ZVZpZXdwb3J0OiB0aGlzLl92aWV3cG9ydFByb3BzXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUm90YXRlXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBwb2ludGVyIGlzXG4gICAqL1xuICByb3RhdGUoe2RlbHRhU2NhbGVYLCBkZWx0YVNjYWxlWX0pIHtcbiAgICBjb25zdCB7ZGlyZWN0aW9ufSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoZGlyZWN0aW9uKS5yb3RhdGVaKHtyYWRpYW5zOiBkZWx0YVNjYWxlWCAvIDUwfSlcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmQgcm90YXRpbmdcbiAgICogTXVzdCBjYWxsIGlmIGByb3RhdGVTdGFydCgpYCB3YXMgY2FsbGVkXG4gICAqL1xuICByb3RhdGVFbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICBzdGFydFJvdGF0ZUNlbnRlcjogbnVsbCxcbiAgICAgIHN0YXJ0Um90YXRlVmlld3BvcnQ6IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB6b29taW5nXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBwb2ludGVyIGdyYWJzXG4gICAqL1xuICB6b29tU3RhcnQoe3Bvc30pIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIHN0YXJ0Wm9vbVBvczogcG9zLFxuICAgICAgc3RhcnRab29tOiB0aGlzLl92aWV3cG9ydFByb3BzLnpvb21cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBab29tXG4gICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gcG9zIC0gcG9zaXRpb24gb24gc2NyZWVuIHdoZXJlIHRoZSBjdXJyZW50IGNlbnRlciBpc1xuICAgKiBAcGFyYW0ge1tOdW1iZXIsIE51bWJlcl19IHN0YXJ0UG9zIC0gdGhlIGNlbnRlciBwb3NpdGlvbiBhdFxuICAgKiAgIHRoZSBzdGFydCBvZiB0aGUgb3BlcmF0aW9uLiBNdXN0IGJlIHN1cHBsaWVkIG9mIGB6b29tU3RhcnQoKWAgd2FzIG5vdCBjYWxsZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIC0gYSBudW1iZXIgYmV0d2VlbiBbMCwgMV0gc3BlY2lmeWluZyB0aGUgYWNjdW11bGF0ZWRcbiAgICogICByZWxhdGl2ZSBzY2FsZS5cbiAgICovXG4gIHpvb20oe3Bvcywgc3RhcnRQb3MsIHNjYWxlfSkge1xuICAgIGNvbnN0IHt6b29tLCBtaW5ab29tLCBtYXhab29tLCB3aWR0aCwgaGVpZ2h0LCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWX0gPSB0aGlzLl92aWV3cG9ydFByb3BzO1xuXG4gICAgY29uc3Qgc3RhcnRab29tUG9zID0gdGhpcy5faW50ZXJhY3RpdmVTdGF0ZS5zdGFydFpvb21Qb3MgfHwgc3RhcnRQb3MgfHwgcG9zO1xuXG4gICAgY29uc3QgbmV3Wm9vbSA9IGNsYW1wKHpvb20gKiBzY2FsZSwgbWluWm9vbSwgbWF4Wm9vbSk7XG4gICAgY29uc3QgZGVsdGFYID0gcG9zWzBdIC0gc3RhcnRab29tUG9zWzBdO1xuICAgIGNvbnN0IGRlbHRhWSA9IHBvc1sxXSAtIHN0YXJ0Wm9vbVBvc1sxXTtcblxuICAgIC8vIFpvb20gYXJvdW5kIHRoZSBjZW50ZXIgcG9zaXRpb25cbiAgICBjb25zdCBjeCA9IHN0YXJ0Wm9vbVBvc1swXSAtIHdpZHRoIC8gMjtcbiAgICBjb25zdCBjeSA9IGhlaWdodCAvIDIgLSBzdGFydFpvb21Qb3NbMV07XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICBjb25zdCBuZXdUcmFuc2xhdGlvblggPSBjeCAtIChjeCAtIHRyYW5zbGF0aW9uWCkgKiBuZXdab29tIC8gem9vbSArIGRlbHRhWDtcbiAgICBjb25zdCBuZXdUcmFuc2xhdGlvblkgPSBjeSAtIChjeSAtIHRyYW5zbGF0aW9uWSkgKiBuZXdab29tIC8gem9vbSAtIGRlbHRhWTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgICAvLyByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAvLyAgIHBvc2l0aW9uXG4gICAgLy8gICB0cmFuc2xhdGlvblg6IG5ld1RyYW5zbGF0aW9uWCxcbiAgICAvLyAgIHRyYW5zbGF0aW9uWTogbmV3VHJhbnNsYXRpb25ZXG4gICAgLy8gfSk7XG5cbiAgICAvLyBUT0RPIEhBQ0tcbiAgICByZXR1cm4gbmV3Wm9vbSAvIHpvb20gPCAxID8gdGhpcy5tb3ZlQmFja3dhcmQoKSA6IHRoaXMubW92ZUZvcndhcmQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmQgem9vbWluZ1xuICAgKiBNdXN0IGNhbGwgaWYgYHpvb21TdGFydCgpYCB3YXMgY2FsbGVkXG4gICAqL1xuICB6b29tRW5kKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgc3RhcnRab29tUG9zOiBudWxsLFxuICAgICAgc3RhcnRab29tOiBudWxsXG4gICAgfSk7XG4gIH1cblxuICBfZ2V0RGlyZWN0aW9uRnJvbUJlYXJpbmcoYmVhcmluZykge1xuICAgIGNvbnN0IHNwaGVyaWNhbCA9IG5ldyBTcGhlcmljYWxDb29yZGluYXRlcyh7XG4gICAgICBiZWFyaW5nLFxuICAgICAgcGl0Y2g6IDkwXG4gICAgfSk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gc3BoZXJpY2FsLnRvVmVjdG9yMygpLm5vcm1hbGl6ZSgpO1xuICAgIHJldHVybiBkaXJlY3Rpb247XG4gIH1cblxuICBtb3ZlTGVmdCgpIHtcbiAgICAvLyBjb25zdCB7cG9zaXRpb24sIGRpcmVjdGlvbn0gPSB0aGlzLl92aWV3cG9ydFByb3BzO1xuICAgIC8vIGNvbnN0IG5ld0RpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKGRpcmVjdGlvbikucm90YXRlWih7cmFkaWFuczogUk9UQVRJT05fU1RFUF9SQURJQU5TfSk7XG4gICAgLy8gcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgLy8gICBkaXJlY3Rpb246IG5ld0RpcmVjdGlvbixcbiAgICAvLyAgIGxvb2tBdDogbmV3IFZlY3RvcjMocG9zaXRpb24pLmFkZChuZXdEaXJlY3Rpb24ubm9ybWFsaXplKCkpLFxuICAgIC8vICAgYmVhcmluZzogdGhpcy5fdmlld3BvcnRQcm9wcy5iZWFyaW5nIC0gUk9UQVRJT05fU1RFUF9ERUdSRUVTXG4gICAgLy8gfSk7XG5cbiAgICBjb25zdCB7cG9zaXRpb24sIGJlYXJpbmd9ID0gdGhpcy5fdmlld3BvcnRQcm9wcztcbiAgICBjb25zdCBuZXdCZWFyaW5nID0gYmVhcmluZyAtIFJPVEFUSU9OX1NURVBfREVHUkVFUztcbiAgICBjb25zdCBuZXdEaXJlY3Rpb24gPSB0aGlzLl9nZXREaXJlY3Rpb25Gcm9tQmVhcmluZyhuZXdCZWFyaW5nKTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIGRpcmVjdGlvbjogbmV3RGlyZWN0aW9uLFxuICAgICAgbG9va0F0OiBuZXcgVmVjdG9yMyhwb3NpdGlvbikuYWRkKG5ld0RpcmVjdGlvbiksXG4gICAgICBiZWFyaW5nOiBuZXdCZWFyaW5nXG4gICAgfSk7XG4gIH1cblxuICBtb3ZlUmlnaHQoKSB7XG4gICAgLy8gY29uc3Qge3Bvc2l0aW9uLCBkaXJlY3Rpb259ID0gdGhpcy5fdmlld3BvcnRQcm9wcztcbiAgICAvLyBjb25zdCBuZXdEaXJlY3Rpb24gPSBuZXcgVmVjdG9yMyhkaXJlY3Rpb24pLnJvdGF0ZVooe3JhZGlhbnM6IC1ST1RBVElPTl9TVEVQX1JBRElBTlN9KTtcbiAgICAvLyByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAvLyAgIGRpcmVjdGlvbjogbmV3RGlyZWN0aW9uLFxuICAgIC8vICAgbG9va0F0OiBuZXcgVmVjdG9yMyhwb3NpdGlvbikuYWRkKG5ld0RpcmVjdGlvbi5ub3JtYWxpemUoKSksXG4gICAgLy8gICBiZWFyaW5nOiB0aGlzLl92aWV3cG9ydFByb3BzLmJlYXJpbmcgKyBST1RBVElPTl9TVEVQX0RFR1JFRVNcbiAgICAvLyB9KTtcblxuICAgIGNvbnN0IHtwb3NpdGlvbiwgYmVhcmluZ30gPSB0aGlzLl92aWV3cG9ydFByb3BzO1xuICAgIGNvbnN0IG5ld0JlYXJpbmcgPSBiZWFyaW5nICsgUk9UQVRJT05fU1RFUF9ERUdSRUVTO1xuICAgIGNvbnN0IG5ld0RpcmVjdGlvbiA9IHRoaXMuX2dldERpcmVjdGlvbkZyb21CZWFyaW5nKG5ld0JlYXJpbmcpO1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgZGlyZWN0aW9uOiBuZXdEaXJlY3Rpb24sXG4gICAgICBsb29rQXQ6IG5ldyBWZWN0b3IzKHBvc2l0aW9uKS5hZGQobmV3RGlyZWN0aW9uKSxcbiAgICAgIGJlYXJpbmc6IG5ld0JlYXJpbmdcbiAgICB9KTtcbiAgfVxuXG4gIG1vdmVGb3J3YXJkKCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgZGlyZWN0aW9ufSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG4gICAgY29uc3QgZGVsdGEgPSBuZXcgVmVjdG9yMyhkaXJlY3Rpb24pLm5vcm1hbGl6ZSgpLnNjYWxlKE1PVkVNRU5UX1NQRUVEKTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VXBkYXRlZFN0YXRlKHtcbiAgICAgIC8vIHBpdGNoOiB0aGlzLl92aWV3cG9ydFByb3BzLnBpdGNoICsgM1xuICAgICAgcG9zaXRpb246IG5ldyBWZWN0b3IzKHBvc2l0aW9uKS5hZGQoZGVsdGEpLFxuICAgICAgbG9va0F0OiBuZXcgVmVjdG9yMyhwb3NpdGlvbikuYWRkKGRpcmVjdGlvbilcbiAgICB9KTtcbiAgfVxuXG4gIG1vdmVCYWNrd2FyZCgpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIGRpcmVjdGlvbn0gPSB0aGlzLl92aWV3cG9ydFByb3BzO1xuICAgIGNvbnN0IGRlbHRhID0gbmV3IFZlY3RvcjMoZGlyZWN0aW9uKS5ub3JtYWxpemUoKS5zY2FsZSgtTU9WRU1FTlRfU1BFRUQpO1xuICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVkU3RhdGUoe1xuICAgICAgLy8gcGl0Y2g6IHRoaXMuX3ZpZXdwb3J0UHJvcHMucGl0Y2ggLSAzXG4gICAgICBwb3NpdGlvbjogbmV3IFZlY3RvcjMocG9zaXRpb24pLmFkZChkZWx0YSksXG4gICAgICBsb29rQXQ6IG5ldyBWZWN0b3IzKHBvc2l0aW9uKS5hZGQoZGlyZWN0aW9uKVxuICAgIH0pO1xuICB9XG5cbiAgbW92ZVVwKCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgZGlyZWN0aW9ufSA9IHRoaXMuX3ZpZXdwb3J0UHJvcHM7XG4gICAgY29uc3QgZGVsdGEgPSBbMCwgMCwgMV07XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICAvLyBwaXRjaDogdGhpcy5fdmlld3BvcnRQcm9wcy5waXRjaCArIDNcbiAgICAgIHBvc2l0aW9uOiBuZXcgVmVjdG9yMyhwb3NpdGlvbikuYWRkKGRlbHRhKSxcbiAgICAgIGxvb2tBdDogbmV3IFZlY3RvcjMocG9zaXRpb24pLmFkZChkaXJlY3Rpb24pXG4gICAgfSk7XG4gIH1cblxuICBtb3ZlRG93bigpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIGRpcmVjdGlvbn0gPSB0aGlzLl92aWV3cG9ydFByb3BzO1xuICAgIGNvbnN0IGRlbHRhID0gcG9zaXRpb25bMl0gPj0gMSA/IFswLCAwLCAtMV0gOiBbMCwgMCwgMF07XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICAvLyBwaXRjaDogdGhpcy5fdmlld3BvcnRQcm9wcy5waXRjaCArIDNcbiAgICAgIHBvc2l0aW9uOiBuZXcgVmVjdG9yMyhwb3NpdGlvbikuYWRkKGRlbHRhKSxcbiAgICAgIGxvb2tBdDogbmV3IFZlY3RvcjMocG9zaXRpb24pLmFkZChkaXJlY3Rpb24pXG4gICAgfSk7XG4gIH1cblxuICB6b29tSW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICB6b29tOiB0aGlzLl92aWV3cG9ydFByb3BzLnpvb20gKyAwLjJcbiAgICB9KTtcbiAgfVxuXG4gIHpvb21PdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFVwZGF0ZWRTdGF0ZSh7XG4gICAgICB6b29tOiB0aGlzLl92aWV3cG9ydFByb3BzLnpvb20gLSAwLjJcbiAgICB9KTtcbiAgfVxuXG4gIC8qIFByaXZhdGUgbWV0aG9kcyAqL1xuXG4gIF9nZXRVcGRhdGVkU3RhdGUobmV3UHJvcHMpIHtcbiAgICAvLyBVcGRhdGUgX3ZpZXdwb3J0UHJvcHNcbiAgICByZXR1cm4gbmV3IEZpcnN0UGVyc29uU3RhdGUoXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl92aWV3cG9ydFByb3BzLCB0aGlzLl9pbnRlcmFjdGl2ZVN0YXRlLCBuZXdQcm9wcylcbiAgICApO1xuICB9XG5cbiAgLy8gQXBwbHkgYW55IGNvbnN0cmFpbnRzIChtYXRoZW1hdGljYWwgb3IgZGVmaW5lZCBieSBfdmlld3BvcnRQcm9wcykgdG8gbWFwIHN0YXRlXG4gIF9hcHBseUNvbnN0cmFpbnRzKHByb3BzKSB7XG4gICAgLy8gVE9ETy9pYiAtIEVuc3VyZSBwb3NpdGlvbiBpcyB3aXRoaW4gYm91bmRzXG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG59XG4iXX0=