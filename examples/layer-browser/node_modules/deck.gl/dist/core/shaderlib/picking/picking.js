'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _log = require('../../utils/log');

var _log2 = _interopRequireDefault(_log);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 64, 128, 64]);

var DEFAULT_MODULE_OPTIONS = {
  pickingSelectedColor: null, //  Set to a picking color to visually highlight that item
  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR, // Color of visual highlight of "selected" item
  pickingThreshold: 1.0,
  pickingActive: false, // Set to true when rendering to off-screen "picking" buffer
  pickingSelectedColorValid: false
};

/* eslint-disable camelcase */
function getUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;

  var uniforms = {};
  if (opts.pickingSelectedColorValid !== undefined) {
    uniforms.picking_uSelectedPickingColorValid = opts.pickingSelectedColorValid ? 1 : 0;
  }
  if (opts.pickingValid !== undefined) {
    uniforms.picking_uSelectedPickingColorValid = opts.pickingValid ? 1 : 0;
    _log2.default.deprecated('pickingValid', 'pickingSelectedColorValid');
  }
  if (opts.pickingSelectedColor !== undefined) {
    if (opts.pickingSelectedColor) {
      var selectedColor = [opts.pickingSelectedColor[0], opts.pickingSelectedColor[1], opts.pickingSelectedColor[2]];
      // console.log('selected picking color', selectedColor);
      uniforms.picking_uSelectedPickingColor = selectedColor;
    }
  }
  if (opts.pickingHighlightColor !== undefined) {
    uniforms.picking_uHighlightColor = opts.pickingHighlightColor;
  }
  // TODO - major hack - decide on normalization and remove
  if (opts.pickingThreshold !== undefined) {
    uniforms.picking_uThreshold = opts.pickingThreshold;
  }
  if (opts.pickingActive !== undefined) {
    uniforms.picking_uActive = opts.pickingActive ? 1 : 0;
  }
  return uniforms;
}

var vs = 'uniform vec3 picking_uSelectedPickingColor;\nuniform float picking_uThreshold;\nuniform bool picking_uSelectedPickingColorValid;\n\nvarying vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedPickingColorValid &&\n    abs(vertexColor.r - picking_uSelectedPickingColor.r) < picking_uThreshold &&\n    abs(vertexColor.g - picking_uSelectedPickingColor.g) < picking_uThreshold &&\n    abs(vertexColor.b - picking_uSelectedPickingColor.b) < picking_uThreshold;\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n  picking_vRGBcolor_Aselected.a =\n    float(isVertexPicked(pickingColor));\n\n  // Stores the picking color so that the fragment shader can render it during picking\n  picking_vRGBcolor_Aselected.rgb = pickingColor * COLOR_SCALE;\n}\n';

var fs = 'uniform bool picking_uActive; // true during rendering to offscreen picking buffer\nuniform vec3 picking_uSelectedPickingColor;\nuniform vec4 picking_uHighlightColor;\n\nvarying vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  bool selected = bool(picking_vRGBcolor_Aselected.a);\n  return selected ? (picking_uHighlightColor * COLOR_SCALE) : color;\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  vec3 pickingColor = picking_vRGBcolor_Aselected.rgb;\n  return picking_uActive ? vec4(pickingColor, 1.0) : color;\n}\n';

exports.default = {
  name: 'picking',
  vs: vs,
  fs: fs,
  getUniforms: getUniforms
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb3JlL3NoYWRlcmxpYi9waWNraW5nL3BpY2tpbmcuanMiXSwibmFtZXMiOlsiREVGQVVMVF9ISUdITElHSFRfQ09MT1IiLCJVaW50OEFycmF5IiwiREVGQVVMVF9NT0RVTEVfT1BUSU9OUyIsInBpY2tpbmdTZWxlY3RlZENvbG9yIiwicGlja2luZ0hpZ2hsaWdodENvbG9yIiwicGlja2luZ1RocmVzaG9sZCIsInBpY2tpbmdBY3RpdmUiLCJwaWNraW5nU2VsZWN0ZWRDb2xvclZhbGlkIiwiZ2V0VW5pZm9ybXMiLCJvcHRzIiwidW5pZm9ybXMiLCJ1bmRlZmluZWQiLCJwaWNraW5nX3VTZWxlY3RlZFBpY2tpbmdDb2xvclZhbGlkIiwicGlja2luZ1ZhbGlkIiwiZGVwcmVjYXRlZCIsInNlbGVjdGVkQ29sb3IiLCJwaWNraW5nX3VTZWxlY3RlZFBpY2tpbmdDb2xvciIsInBpY2tpbmdfdUhpZ2hsaWdodENvbG9yIiwicGlja2luZ191VGhyZXNob2xkIiwicGlja2luZ191QWN0aXZlIiwidnMiLCJmcyIsIm5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7QUFFQSxJQUFNQSwwQkFBMEIsSUFBSUMsVUFBSixDQUFlLENBQUMsQ0FBRCxFQUFJLEVBQUosRUFBUSxHQUFSLEVBQWEsRUFBYixDQUFmLENBQWhDOztBQUVBLElBQU1DLHlCQUF5QjtBQUM3QkMsd0JBQXNCLElBRE8sRUFDRDtBQUM1QkMseUJBQXVCSix1QkFGTSxFQUVtQjtBQUNoREssb0JBQWtCLEdBSFc7QUFJN0JDLGlCQUFlLEtBSmMsRUFJUDtBQUN0QkMsNkJBQTJCO0FBTEUsQ0FBL0I7O0FBUUE7QUFDQSxTQUFTQyxXQUFULEdBQW9EO0FBQUEsTUFBL0JDLElBQStCLHVFQUF4QlAsc0JBQXdCOztBQUNsRCxNQUFNUSxXQUFXLEVBQWpCO0FBQ0EsTUFBSUQsS0FBS0YseUJBQUwsS0FBbUNJLFNBQXZDLEVBQWtEO0FBQ2hERCxhQUFTRSxrQ0FBVCxHQUE4Q0gsS0FBS0YseUJBQUwsR0FBaUMsQ0FBakMsR0FBcUMsQ0FBbkY7QUFDRDtBQUNELE1BQUlFLEtBQUtJLFlBQUwsS0FBc0JGLFNBQTFCLEVBQXFDO0FBQ25DRCxhQUFTRSxrQ0FBVCxHQUE4Q0gsS0FBS0ksWUFBTCxHQUFvQixDQUFwQixHQUF3QixDQUF0RTtBQUNBLGtCQUFJQyxVQUFKLENBQWUsY0FBZixFQUErQiwyQkFBL0I7QUFDRDtBQUNELE1BQUlMLEtBQUtOLG9CQUFMLEtBQThCUSxTQUFsQyxFQUE2QztBQUMzQyxRQUFJRixLQUFLTixvQkFBVCxFQUErQjtBQUM3QixVQUFNWSxnQkFBZ0IsQ0FDcEJOLEtBQUtOLG9CQUFMLENBQTBCLENBQTFCLENBRG9CLEVBRXBCTSxLQUFLTixvQkFBTCxDQUEwQixDQUExQixDQUZvQixFQUdwQk0sS0FBS04sb0JBQUwsQ0FBMEIsQ0FBMUIsQ0FIb0IsQ0FBdEI7QUFLQTtBQUNBTyxlQUFTTSw2QkFBVCxHQUF5Q0QsYUFBekM7QUFDRDtBQUNGO0FBQ0QsTUFBSU4sS0FBS0wscUJBQUwsS0FBK0JPLFNBQW5DLEVBQThDO0FBQzVDRCxhQUFTTyx1QkFBVCxHQUFtQ1IsS0FBS0wscUJBQXhDO0FBQ0Q7QUFDRDtBQUNBLE1BQUlLLEtBQUtKLGdCQUFMLEtBQTBCTSxTQUE5QixFQUF5QztBQUN2Q0QsYUFBU1Esa0JBQVQsR0FBOEJULEtBQUtKLGdCQUFuQztBQUNEO0FBQ0QsTUFBSUksS0FBS0gsYUFBTCxLQUF1QkssU0FBM0IsRUFBc0M7QUFDcENELGFBQVNTLGVBQVQsR0FBMkJWLEtBQUtILGFBQUwsR0FBcUIsQ0FBckIsR0FBeUIsQ0FBcEQ7QUFDRDtBQUNELFNBQU9JLFFBQVA7QUFDRDs7QUFFRCxJQUFNVSx3N0JBQU47O0FBMkJBLElBQU1DLGd2QkFBTjs7a0JBMEJlO0FBQ2JDLFFBQU0sU0FETztBQUViRixRQUZhO0FBR2JDLFFBSGE7QUFJYmI7QUFKYSxDIiwiZmlsZSI6InBpY2tpbmcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbG9nIGZyb20gJy4uLy4uL3V0aWxzL2xvZyc7XG5cbmNvbnN0IERFRkFVTFRfSElHSExJR0hUX0NPTE9SID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDY0LCAxMjgsIDY0XSk7XG5cbmNvbnN0IERFRkFVTFRfTU9EVUxFX09QVElPTlMgPSB7XG4gIHBpY2tpbmdTZWxlY3RlZENvbG9yOiBudWxsLCAvLyAgU2V0IHRvIGEgcGlja2luZyBjb2xvciB0byB2aXN1YWxseSBoaWdobGlnaHQgdGhhdCBpdGVtXG4gIHBpY2tpbmdIaWdobGlnaHRDb2xvcjogREVGQVVMVF9ISUdITElHSFRfQ09MT1IsIC8vIENvbG9yIG9mIHZpc3VhbCBoaWdobGlnaHQgb2YgXCJzZWxlY3RlZFwiIGl0ZW1cbiAgcGlja2luZ1RocmVzaG9sZDogMS4wLFxuICBwaWNraW5nQWN0aXZlOiBmYWxzZSwgLy8gU2V0IHRvIHRydWUgd2hlbiByZW5kZXJpbmcgdG8gb2ZmLXNjcmVlbiBcInBpY2tpbmdcIiBidWZmZXJcbiAgcGlja2luZ1NlbGVjdGVkQ29sb3JWYWxpZDogZmFsc2Vcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuZnVuY3Rpb24gZ2V0VW5pZm9ybXMob3B0cyA9IERFRkFVTFRfTU9EVUxFX09QVElPTlMpIHtcbiAgY29uc3QgdW5pZm9ybXMgPSB7fTtcbiAgaWYgKG9wdHMucGlja2luZ1NlbGVjdGVkQ29sb3JWYWxpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdW5pZm9ybXMucGlja2luZ191U2VsZWN0ZWRQaWNraW5nQ29sb3JWYWxpZCA9IG9wdHMucGlja2luZ1NlbGVjdGVkQ29sb3JWYWxpZCA/IDEgOiAwO1xuICB9XG4gIGlmIChvcHRzLnBpY2tpbmdWYWxpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdW5pZm9ybXMucGlja2luZ191U2VsZWN0ZWRQaWNraW5nQ29sb3JWYWxpZCA9IG9wdHMucGlja2luZ1ZhbGlkID8gMSA6IDA7XG4gICAgbG9nLmRlcHJlY2F0ZWQoJ3BpY2tpbmdWYWxpZCcsICdwaWNraW5nU2VsZWN0ZWRDb2xvclZhbGlkJyk7XG4gIH1cbiAgaWYgKG9wdHMucGlja2luZ1NlbGVjdGVkQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRzLnBpY2tpbmdTZWxlY3RlZENvbG9yKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZENvbG9yID0gW1xuICAgICAgICBvcHRzLnBpY2tpbmdTZWxlY3RlZENvbG9yWzBdLFxuICAgICAgICBvcHRzLnBpY2tpbmdTZWxlY3RlZENvbG9yWzFdLFxuICAgICAgICBvcHRzLnBpY2tpbmdTZWxlY3RlZENvbG9yWzJdXG4gICAgICBdO1xuICAgICAgLy8gY29uc29sZS5sb2coJ3NlbGVjdGVkIHBpY2tpbmcgY29sb3InLCBzZWxlY3RlZENvbG9yKTtcbiAgICAgIHVuaWZvcm1zLnBpY2tpbmdfdVNlbGVjdGVkUGlja2luZ0NvbG9yID0gc2VsZWN0ZWRDb2xvcjtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdHMucGlja2luZ0hpZ2hsaWdodENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICB1bmlmb3Jtcy5waWNraW5nX3VIaWdobGlnaHRDb2xvciA9IG9wdHMucGlja2luZ0hpZ2hsaWdodENvbG9yO1xuICB9XG4gIC8vIFRPRE8gLSBtYWpvciBoYWNrIC0gZGVjaWRlIG9uIG5vcm1hbGl6YXRpb24gYW5kIHJlbW92ZVxuICBpZiAob3B0cy5waWNraW5nVGhyZXNob2xkICE9PSB1bmRlZmluZWQpIHtcbiAgICB1bmlmb3Jtcy5waWNraW5nX3VUaHJlc2hvbGQgPSBvcHRzLnBpY2tpbmdUaHJlc2hvbGQ7XG4gIH1cbiAgaWYgKG9wdHMucGlja2luZ0FjdGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdW5pZm9ybXMucGlja2luZ191QWN0aXZlID0gb3B0cy5waWNraW5nQWN0aXZlID8gMSA6IDA7XG4gIH1cbiAgcmV0dXJuIHVuaWZvcm1zO1xufVxuXG5jb25zdCB2cyA9IGBcXFxudW5pZm9ybSB2ZWMzIHBpY2tpbmdfdVNlbGVjdGVkUGlja2luZ0NvbG9yO1xudW5pZm9ybSBmbG9hdCBwaWNraW5nX3VUaHJlc2hvbGQ7XG51bmlmb3JtIGJvb2wgcGlja2luZ191U2VsZWN0ZWRQaWNraW5nQ29sb3JWYWxpZDtcblxudmFyeWluZyB2ZWM0IHBpY2tpbmdfdlJHQmNvbG9yX0FzZWxlY3RlZDtcblxuY29uc3QgZmxvYXQgQ09MT1JfU0NBTEUgPSAxLiAvIDI1NS47XG5cbmJvb2wgaXNWZXJ0ZXhQaWNrZWQodmVjMyB2ZXJ0ZXhDb2xvcikge1xuICByZXR1cm5cbiAgICBwaWNraW5nX3VTZWxlY3RlZFBpY2tpbmdDb2xvclZhbGlkICYmXG4gICAgYWJzKHZlcnRleENvbG9yLnIgLSBwaWNraW5nX3VTZWxlY3RlZFBpY2tpbmdDb2xvci5yKSA8IHBpY2tpbmdfdVRocmVzaG9sZCAmJlxuICAgIGFicyh2ZXJ0ZXhDb2xvci5nIC0gcGlja2luZ191U2VsZWN0ZWRQaWNraW5nQ29sb3IuZykgPCBwaWNraW5nX3VUaHJlc2hvbGQgJiZcbiAgICBhYnModmVydGV4Q29sb3IuYiAtIHBpY2tpbmdfdVNlbGVjdGVkUGlja2luZ0NvbG9yLmIpIDwgcGlja2luZ191VGhyZXNob2xkO1xufVxuXG52b2lkIHBpY2tpbmdfc2V0UGlja2luZ0NvbG9yKHZlYzMgcGlja2luZ0NvbG9yKSB7XG4gIC8vIERvIHRoZSBjb21wYXJpc29uIHdpdGggc2VsZWN0ZWQgaXRlbSBjb2xvciBpbiB2ZXJ0ZXggc2hhZGVyIGFzIGl0IHNob3VsZCBtZWFuIGZld2VyIGNvbXBhcmVzXG4gIHBpY2tpbmdfdlJHQmNvbG9yX0FzZWxlY3RlZC5hID1cbiAgICBmbG9hdChpc1ZlcnRleFBpY2tlZChwaWNraW5nQ29sb3IpKTtcblxuICAvLyBTdG9yZXMgdGhlIHBpY2tpbmcgY29sb3Igc28gdGhhdCB0aGUgZnJhZ21lbnQgc2hhZGVyIGNhbiByZW5kZXIgaXQgZHVyaW5nIHBpY2tpbmdcbiAgcGlja2luZ192UkdCY29sb3JfQXNlbGVjdGVkLnJnYiA9IHBpY2tpbmdDb2xvciAqIENPTE9SX1NDQUxFO1xufVxuYDtcblxuY29uc3QgZnMgPSBgXFxcbnVuaWZvcm0gYm9vbCBwaWNraW5nX3VBY3RpdmU7IC8vIHRydWUgZHVyaW5nIHJlbmRlcmluZyB0byBvZmZzY3JlZW4gcGlja2luZyBidWZmZXJcbnVuaWZvcm0gdmVjMyBwaWNraW5nX3VTZWxlY3RlZFBpY2tpbmdDb2xvcjtcbnVuaWZvcm0gdmVjNCBwaWNraW5nX3VIaWdobGlnaHRDb2xvcjtcblxudmFyeWluZyB2ZWM0IHBpY2tpbmdfdlJHQmNvbG9yX0FzZWxlY3RlZDtcblxuY29uc3QgZmxvYXQgQ09MT1JfU0NBTEUgPSAxLiAvIDI1NS47XG5cbi8qXG4gKiBSZXR1cm5zIGhpZ2hsaWdodCBjb2xvciBpZiB0aGlzIGl0ZW0gaXMgc2VsZWN0ZWQuXG4gKi9cbnZlYzQgcGlja2luZ19maWx0ZXJIaWdobGlnaHRDb2xvcih2ZWM0IGNvbG9yKSB7XG4gIGJvb2wgc2VsZWN0ZWQgPSBib29sKHBpY2tpbmdfdlJHQmNvbG9yX0FzZWxlY3RlZC5hKTtcbiAgcmV0dXJuIHNlbGVjdGVkID8gKHBpY2tpbmdfdUhpZ2hsaWdodENvbG9yICogQ09MT1JfU0NBTEUpIDogY29sb3I7XG59XG5cbi8qXG4gKiBSZXR1cm5zIHBpY2tpbmcgY29sb3IgaWYgcGlja2luZyBlbmFibGVkIGVsc2UgdW5tb2RpZmllZCBhcmd1bWVudC5cbiAqL1xudmVjNCBwaWNraW5nX2ZpbHRlclBpY2tpbmdDb2xvcih2ZWM0IGNvbG9yKSB7XG4gIHZlYzMgcGlja2luZ0NvbG9yID0gcGlja2luZ192UkdCY29sb3JfQXNlbGVjdGVkLnJnYjtcbiAgcmV0dXJuIHBpY2tpbmdfdUFjdGl2ZSA/IHZlYzQocGlja2luZ0NvbG9yLCAxLjApIDogY29sb3I7XG59XG5gO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwaWNraW5nJyxcbiAgdnMsXG4gIGZzLFxuICBnZXRVbmlmb3Jtc1xufTtcbiJdfQ==