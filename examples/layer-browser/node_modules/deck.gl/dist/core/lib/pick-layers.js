'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pickObject = pickObject;
exports.pickVisibleObjects = pickVisibleObjects;
exports.samplePickingBuffer = samplePickingBuffer;

var _utils = require('./utils');

var _drawLayers = require('./draw-layers');

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var EMPTY_PIXEL = new Uint8Array(4);

/* eslint-disable max-depth, max-statements */
// Pick the closest object at the given (x,y) coordinate
function pickObject(gl, _ref) {
  var layers = _ref.layers,
      viewports = _ref.viewports,
      onViewportActive = _ref.onViewportActive,
      pickingFBO = _ref.pickingFBO,
      x = _ref.x,
      y = _ref.y,
      radius = _ref.radius,
      mode = _ref.mode,
      lastPickedInfo = _ref.lastPickedInfo,
      useDevicePixelRatio = _ref.useDevicePixelRatio;

  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = (0, _drawLayers.getPixelRatio)({ useDevicePixelRatio: useDevicePixelRatio });
  var deviceX = Math.round(x * pixelRatio);
  var deviceY = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRadius = Math.round(radius * pixelRatio);

  var pickInfo = getClosestFromPickingBuffer(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    pickingFBO: pickingFBO,
    deviceX: deviceX,
    deviceY: deviceY,
    deviceRadius: deviceRadius
  });

  var pickedColor = pickInfo.pickedColor,
      pickedLayer = pickInfo.pickedLayer,
      pickedObjectIndex = pickInfo.pickedObjectIndex;


  var affectedLayers = pickedLayer ? [pickedLayer] : [];

  if (mode === 'hover') {
    // only invoke onHover events if picked object has changed
    var lastPickedObjectIndex = lastPickedInfo.index;
    var lastPickedLayerId = lastPickedInfo.layerId;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;

    // proceed only if picked object changed
    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        // We cannot store a ref to lastPickedLayer in the context because
        // the state of an outdated layer is no longer valid
        // and the props may have changed
        var lastPickedLayer = layers.find(function (layer) {
          return layer.props.id === lastPickedLayerId;
        });
        if (lastPickedLayer) {
          // Let leave event fire before enter event
          affectedLayers.unshift(lastPickedLayer);
        }
      }

      // Update layer manager context
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
    }
  }

  var viewport = getViewportFromCoordinates({ viewports: viewports }); // TODO - add coords

  var baseInfo = createInfo([x, y], viewport);
  baseInfo.devicePixel = [deviceX, deviceY];
  baseInfo.pixelRatio = pixelRatio;

  // Use a Map to store all picking infos.
  // The following two forEach loops are the result of
  // https://github.com/uber/deck.gl/issues/443
  // Please be very careful when changing this pattern
  var infos = new Map();
  var unhandledPickInfos = [];

  affectedLayers.forEach(function (layer) {
    var info = Object.assign({}, baseInfo);

    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }

    info = getLayerPickingInfo({ layer: layer, info: info, mode: mode });

    // This guarantees that there will be only one copy of info for
    // one composite layer
    if (info) {
      infos.set(info.layer.id, info);
    }

    var pickingSelectedColor = pickedColor;
    var pickingSelectedColorValid = Boolean(layer.props.autoHighlight && pickedLayer === layer && pickingSelectedColor !== EMPTY_PIXEL);
    // TODO - handle multi model layers?
    if (layer.state.model) {
      layer.state.model.updateModuleSettings({
        pickingSelectedColor: pickingSelectedColor,
        pickingSelectedColorValid: pickingSelectedColorValid
      });
    }
  });

  infos.forEach(function (info) {
    var handled = false;
    // Per-layer event handlers (e.g. onClick, onHover) are provided by the
    // user and out of deck.gl's control. It's very much possible that
    // the user calls React lifecycle methods in these function, such as
    // ReactComponent.setState(). React lifecycle methods sometimes induce
    // a re-render and re-generation of props of deck.gl and its layers,
    // which invalidates all layers currently passed to this very function.

    // Therefore, per-layer event handlers must be invoked at the end
    // of this function. NO operation that relies on the states of current
    // layers should be called after this code.
    switch (mode) {
      case 'click':
        handled = info.layer.props.onClick(info);break;
      case 'hover':
        handled = info.layer.props.onHover(info);break;
      case 'query':
        break;
      default:
        throw new Error('unknown pick type');
    }

    if (!handled) {
      unhandledPickInfos.push(info);
    }
  });

  return unhandledPickInfos;
}

// Pick all objects within the given bounding box
function pickVisibleObjects(gl, _ref2) {
  var layers = _ref2.layers,
      viewports = _ref2.viewports,
      onViewportActive = _ref2.onViewportActive,
      pickingFBO = _ref2.pickingFBO,
      x = _ref2.x,
      y = _ref2.y,
      width = _ref2.width,
      height = _ref2.height,
      mode = _ref2.mode,
      useDevicePixelRatio = _ref2.useDevicePixelRatio;


  // Convert from canvas top-left to WebGL bottom-left coordinates
  // And compensate for pixelRatio
  var pixelRatio = (0, _drawLayers.getPixelRatio)({ useDevicePixelRatio: useDevicePixelRatio });

  var deviceLeft = Math.round(x * pixelRatio);
  var deviceBottom = Math.round(gl.canvas.height - y * pixelRatio);
  var deviceRight = Math.round((x + width) * pixelRatio);
  var deviceTop = Math.round(gl.canvas.height - (y + height) * pixelRatio);

  // Only return unique infos, identified by info.object
  var uniqueInfos = new Map();

  var pickInfos = getUniquesFromPickingBuffer(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    pickingFBO: pickingFBO,
    deviceRect: {
      x: deviceLeft,
      y: deviceTop,
      width: deviceRight - deviceLeft,
      height: deviceBottom - deviceTop
    }
  });

  pickInfos.forEach(function (pickInfo) {
    var viewport = getViewportFromCoordinates({ viewports: viewports }); // TODO - add coords
    var info = createInfo([pickInfo.x / pixelRatio, pickInfo.y / pixelRatio], viewport);
    info.devicePixel = [pickInfo.x, pickInfo.y];
    info.pixelRatio = pixelRatio;
    info.color = pickInfo.pickedColor;
    info.index = pickInfo.pickedObjectIndex;
    info.picked = true;

    info = getLayerPickingInfo({ layer: pickInfo.pickedLayer, info: info, mode: mode });
    if (!uniqueInfos.has(info.object)) {
      uniqueInfos.set(info.object, info);
    }
  });

  return Array.from(uniqueInfos.values());
}

// HELPER METHODS

// Indentifies which viewport, if any corresponds to x and y
// Returns first viewport if no match
// TODO - need to determine which viewport we are in
// TODO - document concept of "primary viewport" that matches all coords?
// TODO - static method on Viewport class?
function getViewportFromCoordinates(_ref3) {
  var viewports = _ref3.viewports;

  var viewport = viewports[0];
  return viewport;
}

function getPickedColors(gl, _ref4) {
  var layers = _ref4.layers,
      viewports = _ref4.viewports,
      onViewportActive = _ref4.onViewportActive,
      pickingFBO = _ref4.pickingFBO,
      deviceRect = _ref4.deviceRect;

  (0, _drawLayers.drawPickingBuffer)(gl, { layers: layers, viewports: viewports, onViewportActive: onViewportActive, pickingFBO: pickingFBO, deviceRect: deviceRect });
  // TODO - restore when luma patch lands
  // const dataUrl = pickingFBO.readDataUrl();
  // window.open(dataUrl, 'picking buffer');

  var pickedColors = samplePickingBuffer(gl, { pickingFBO: pickingFBO, deviceRect: deviceRect });
  return pickedColors;
}

// Read from an already rendered picking buffer
// Returns an Uint8ClampedArray of picked pixels
function samplePickingBuffer(gl, _ref5) {
  var pickingFBO = _ref5.pickingFBO,
      _ref5$deviceRect = _ref5.deviceRect,
      x = _ref5$deviceRect.x,
      y = _ref5$deviceRect.y,
      width = _ref5$deviceRect.width,
      height = _ref5$deviceRect.height;

  var pickedColors = new Uint8Array(width * height * 4);
  pickingFBO.readPixels({ x: x, y: y, width: width, height: height, pixelArray: pickedColors });
  return pickedColors;
}

/**
 * Pick at a specified pixel with a tolerance radius
 * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`
 */
function getClosestFromPickingBuffer(gl, _ref6) {
  var layers = _ref6.layers,
      viewports = _ref6.viewports,
      onViewportActive = _ref6.onViewportActive,
      pickingFBO = _ref6.pickingFBO,
      deviceX = _ref6.deviceX,
      deviceY = _ref6.deviceY,
      deviceRadius = _ref6.deviceRadius;

  var closestResultToCenter = {
    pickedColor: EMPTY_PIXEL,
    pickedLayer: null,
    pickedObjectIndex: -1
  };

  // x, y out of bounds or no layers to pick.
  var valid = layers.length > 0 && deviceX >= 0 && deviceY >= 0 && deviceX < pickingFBO.width && deviceY < pickingFBO.height;

  if (!valid) {
    return closestResultToCenter;
  }

  // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]
  var x = Math.max(0, deviceX - deviceRadius);
  var y = Math.max(0, deviceY - deviceRadius);
  var width = Math.min(pickingFBO.width, deviceX + deviceRadius) - x + 1;
  var height = Math.min(pickingFBO.height, deviceY + deviceRadius) - y + 1;

  var pickedColors = getPickedColors(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    pickingFBO: pickingFBO,
    deviceRect: { x: x, y: y, width: width, height: height }
  });

  // Traverse all pixels in picking results and find the one closest to the supplied
  // [deviceX, deviceY]
  var minSquareDistanceToCenter = deviceRadius * deviceRadius;
  var i = 0;

  for (var row = 0; row < height; row++) {
    for (var col = 0; col < width; col++) {
      // Decode picked layer from color
      var pickedLayerIndex = pickedColors[i + 3] - 1;

      if (pickedLayerIndex >= 0) {
        var dx = col + x - deviceX;
        var dy = row + y - deviceY;
        var d2 = dx * dx + dy * dy;

        if (d2 <= minSquareDistanceToCenter) {
          minSquareDistanceToCenter = d2;

          // Decode picked object index from color
          var pickedColor = pickedColors.slice(i, i + 4);
          var pickedLayer = layers[pickedLayerIndex];
          if (pickedLayer) {
            var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);
            closestResultToCenter = { pickedColor: pickedColor, pickedLayer: pickedLayer, pickedObjectIndex: pickedObjectIndex };
          } else {
            _utils.log.error(0, 'Picked non-existent layer. Is picking buffer corrupt?');
          }
        }
      }
      i += 4;
    }
  }

  return closestResultToCenter;
}
/* eslint-enable max-depth, max-statements */

/**
 * Query within a specified rectangle
 * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`
 */
function getUniquesFromPickingBuffer(gl, _ref7) {
  var layers = _ref7.layers,
      viewports = _ref7.viewports,
      onViewportActive = _ref7.onViewportActive,
      pickingFBO = _ref7.pickingFBO,
      _ref7$deviceRect = _ref7.deviceRect,
      x = _ref7$deviceRect.x,
      y = _ref7$deviceRect.y,
      width = _ref7$deviceRect.width,
      height = _ref7$deviceRect.height;

  var pickedColors = getPickedColors(gl, {
    layers: layers,
    viewports: viewports,
    onViewportActive: onViewportActive,
    pickingFBO: pickingFBO,
    deviceRect: { x: x, y: y, width: width, height: height }
  });
  var uniqueColors = new Map();

  // Traverse all pixels in picking results and get unique colors
  for (var i = 0; i < pickedColors.length; i += 4) {
    // Decode picked layer from color
    var pickedLayerIndex = pickedColors[i + 3] - 1;

    if (pickedLayerIndex >= 0) {
      var pickedColor = pickedColors.slice(i, i + 4);
      var colorKey = pickedColor.join(',');
      if (!uniqueColors.has(colorKey)) {
        var pickedLayer = layers[pickedLayerIndex];
        if (pickedLayer) {
          // eslint-disable-line
          uniqueColors.set(colorKey, {
            pickedColor: pickedColor,
            pickedLayer: pickedLayer,
            pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)
          });
        } else {
          _utils.log.error(0, 'Picked non-existent layer. Is picking buffer corrupt?');
        }
      }
    }
  }

  return Array.from(uniqueColors.values());
}

function createInfo(pixel, viewport) {
  // Assign a number of potentially useful props to the "info" object
  return {
    color: EMPTY_PIXEL,
    layer: null,
    index: -1,
    picked: false,
    x: pixel[0],
    y: pixel[1],
    pixel: pixel,
    lngLat: viewport.unproject(pixel)
  };
}

// Walk up the layer composite chain to populate the info object
function getLayerPickingInfo(_ref8) {
  var layer = _ref8.layer,
      info = _ref8.info,
      mode = _ref8.mode;

  while (layer && info) {
    // For a composite layer, sourceLayer will point to the sublayer
    // where the event originates from.
    // It provides additional context for the composite layer's
    // getPickingInfo() method to populate the info object
    var sourceLayer = info.layer || layer;
    info.layer = layer;
    // layer.pickLayer() function requires a non-null ```layer.state```
    // object to funtion properly. So the layer refereced here
    // must be the "current" layer, not an "out-dated" / "invalidated" layer
    info = layer.pickLayer({ info: info, mode: mode, sourceLayer: sourceLayer });
    layer = layer.parentLayer;
  }
  return info;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9waWNrLWxheWVycy5qcyJdLCJuYW1lcyI6WyJwaWNrT2JqZWN0IiwicGlja1Zpc2libGVPYmplY3RzIiwic2FtcGxlUGlja2luZ0J1ZmZlciIsIkVNUFRZX1BJWEVMIiwiVWludDhBcnJheSIsImdsIiwibGF5ZXJzIiwidmlld3BvcnRzIiwib25WaWV3cG9ydEFjdGl2ZSIsInBpY2tpbmdGQk8iLCJ4IiwieSIsInJhZGl1cyIsIm1vZGUiLCJsYXN0UGlja2VkSW5mbyIsInVzZURldmljZVBpeGVsUmF0aW8iLCJwaXhlbFJhdGlvIiwiZGV2aWNlWCIsIk1hdGgiLCJyb3VuZCIsImRldmljZVkiLCJjYW52YXMiLCJoZWlnaHQiLCJkZXZpY2VSYWRpdXMiLCJwaWNrSW5mbyIsImdldENsb3Nlc3RGcm9tUGlja2luZ0J1ZmZlciIsInBpY2tlZENvbG9yIiwicGlja2VkTGF5ZXIiLCJwaWNrZWRPYmplY3RJbmRleCIsImFmZmVjdGVkTGF5ZXJzIiwibGFzdFBpY2tlZE9iamVjdEluZGV4IiwiaW5kZXgiLCJsYXN0UGlja2VkTGF5ZXJJZCIsImxheWVySWQiLCJwaWNrZWRMYXllcklkIiwicHJvcHMiLCJpZCIsImxhc3RQaWNrZWRMYXllciIsImZpbmQiLCJsYXllciIsInVuc2hpZnQiLCJ2aWV3cG9ydCIsImdldFZpZXdwb3J0RnJvbUNvb3JkaW5hdGVzIiwiYmFzZUluZm8iLCJjcmVhdGVJbmZvIiwiZGV2aWNlUGl4ZWwiLCJpbmZvcyIsIk1hcCIsInVuaGFuZGxlZFBpY2tJbmZvcyIsImZvckVhY2giLCJpbmZvIiwiT2JqZWN0IiwiYXNzaWduIiwiY29sb3IiLCJwaWNrZWQiLCJnZXRMYXllclBpY2tpbmdJbmZvIiwic2V0IiwicGlja2luZ1NlbGVjdGVkQ29sb3IiLCJwaWNraW5nU2VsZWN0ZWRDb2xvclZhbGlkIiwiQm9vbGVhbiIsImF1dG9IaWdobGlnaHQiLCJzdGF0ZSIsIm1vZGVsIiwidXBkYXRlTW9kdWxlU2V0dGluZ3MiLCJoYW5kbGVkIiwib25DbGljayIsIm9uSG92ZXIiLCJFcnJvciIsInB1c2giLCJ3aWR0aCIsImRldmljZUxlZnQiLCJkZXZpY2VCb3R0b20iLCJkZXZpY2VSaWdodCIsImRldmljZVRvcCIsInVuaXF1ZUluZm9zIiwicGlja0luZm9zIiwiZ2V0VW5pcXVlc0Zyb21QaWNraW5nQnVmZmVyIiwiZGV2aWNlUmVjdCIsImhhcyIsIm9iamVjdCIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImdldFBpY2tlZENvbG9ycyIsInBpY2tlZENvbG9ycyIsInJlYWRQaXhlbHMiLCJwaXhlbEFycmF5IiwiY2xvc2VzdFJlc3VsdFRvQ2VudGVyIiwidmFsaWQiLCJsZW5ndGgiLCJtYXgiLCJtaW4iLCJtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyIiwiaSIsInJvdyIsImNvbCIsInBpY2tlZExheWVySW5kZXgiLCJkeCIsImR5IiwiZDIiLCJzbGljZSIsImRlY29kZVBpY2tpbmdDb2xvciIsImVycm9yIiwidW5pcXVlQ29sb3JzIiwiY29sb3JLZXkiLCJqb2luIiwicGl4ZWwiLCJsbmdMYXQiLCJ1bnByb2plY3QiLCJzb3VyY2VMYXllciIsInBpY2tMYXllciIsInBhcmVudExheWVyIl0sIm1hcHBpbmdzIjoiOzs7OztRQTJCZ0JBLFUsR0FBQUEsVTtRQXVJQUMsa0IsR0FBQUEsa0I7UUFnRkFDLG1CLEdBQUFBLG1COztBQTlOaEI7O0FBQ0E7O0FBckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtBLElBQU1DLGNBQWMsSUFBSUMsVUFBSixDQUFlLENBQWYsQ0FBcEI7O0FBRUE7QUFDQTtBQUNPLFNBQVNKLFVBQVQsQ0FBb0JLLEVBQXBCLFFBV0o7QUFBQSxNQVZEQyxNQVVDLFFBVkRBLE1BVUM7QUFBQSxNQVREQyxTQVNDLFFBVERBLFNBU0M7QUFBQSxNQVJEQyxnQkFRQyxRQVJE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WTBFLGtCQUFaLENBQStCM0UsV0FBL0I7QUFITSxXQUEzQjtBQUtELFNBTkQsTUFNTztBQUNMLHFCQUFJNEUsS0FBSixDQUFVLENBQVYsRUFBYSx1REFBYjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFNBQU90QixNQUFNQyxJQUFOLENBQVdzQixhQUFhckIsTUFBYixFQUFYLENBQVA7QUFDRDs7QUFFRCxTQUFTdEMsVUFBVCxDQUFvQjhELEtBQXBCLEVBQTJCakUsUUFBM0IsRUFBcUM7QUFDbkM7QUFDQSxTQUFPO0FBQ0xZLFdBQU9sRCxXQURGO0FBRUxvQyxXQUFPLElBRkY7QUFHTFIsV0FBTyxDQUFDLENBSEg7QUFJTHVCLFlBQVEsS0FKSDtBQUtMNUMsT0FBR2dHLE1BQU0sQ0FBTixDQUxFO0FBTUwvRixPQUFHK0YsTUFBTSxDQUFOLENBTkU7QUFPTEEsZ0JBUEs7QUFRTEMsWUFBUWxFLFNBQVNtRSxTQUFULENBQW1CRixLQUFuQjtBQVJILEdBQVA7QUFVRDs7QUFFRDtBQUNBLFNBQVNuRCxtQkFBVCxRQUFrRDtBQUFBLE1BQXBCaEIsS0FBb0IsU0FBcEJBLEtBQW9CO0FBQUEsTUFBYlcsSUFBYSxTQUFiQSxJQUFhO0FBQUEsTUFBUHJDLElBQU8sU0FBUEEsSUFBTzs7QUFDaEQsU0FBTzBCLFNBQVNXLElBQWhCLEVBQXNCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTTJELGNBQWMzRCxLQUFLWCxLQUFMLElBQWNBLEtBQWxDO0FBQ0FXLFNBQUtYLEtBQUwsR0FBYUEsS0FBYjtBQUNBO0FBQ0E7QUFDQTtBQUNBVyxXQUFPWCxNQUFNdUUsU0FBTixDQUFnQixFQUFDNUQsVUFBRCxFQUFPckMsVUFBUCxFQUFhZ0csd0JBQWIsRUFBaEIsQ0FBUDtBQUNBdEUsWUFBUUEsTUFBTXdFLFdBQWQ7QUFDRDtBQUNELFNBQU83RCxJQUFQO0FBQ0QiLCJmaWxlIjoicGljay1sYXllcnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtsb2d9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHtkcmF3UGlja2luZ0J1ZmZlciwgZ2V0UGl4ZWxSYXRpb30gZnJvbSAnLi9kcmF3LWxheWVycyc7XG5cbmNvbnN0IEVNUFRZX1BJWEVMID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCwgbWF4LXN0YXRlbWVudHMgKi9cbi8vIFBpY2sgdGhlIGNsb3Nlc3Qgb2JqZWN0IGF0IHRoZSBnaXZlbiAoeCx5KSBjb29yZGluYXRlXG5leHBvcnQgZnVuY3Rpb24gcGlja09iamVjdChnbCwge1xuICBsYXllcnMsXG4gIHZpZXdwb3J0cyxcbiAgb25WaWV3cG9ydEFjdGl2ZSxcbiAgcGlja2luZ0ZCTyxcbiAgeCxcbiAgeSxcbiAgcmFkaXVzLFxuICBtb2RlLFxuICBsYXN0UGlja2VkSW5mbyxcbiAgdXNlRGV2aWNlUGl4ZWxSYXRpb1xufSkge1xuICAvLyBDb252ZXJ0IGZyb20gY2FudmFzIHRvcC1sZWZ0IHRvIFdlYkdMIGJvdHRvbS1sZWZ0IGNvb3JkaW5hdGVzXG4gIC8vIEFuZCBjb21wZW5zYXRlIGZvciBwaXhlbFJhdGlvXG4gIGNvbnN0IHBpeGVsUmF0aW8gPSBnZXRQaXhlbFJhdGlvKHt1c2VEZXZpY2VQaXhlbFJhdGlvfSk7XG4gIGNvbnN0IGRldmljZVggPSBNYXRoLnJvdW5kKHggKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlWSA9IE1hdGgucm91bmQoZ2wuY2FudmFzLmhlaWdodCAtIHkgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlUmFkaXVzID0gTWF0aC5yb3VuZChyYWRpdXMgKiBwaXhlbFJhdGlvKTtcblxuICBjb25zdCBwaWNrSW5mbyA9IGdldENsb3Nlc3RGcm9tUGlja2luZ0J1ZmZlcihnbCwge1xuICAgIGxheWVycyxcbiAgICB2aWV3cG9ydHMsXG4gICAgb25WaWV3cG9ydEFjdGl2ZSxcbiAgICBwaWNraW5nRkJPLFxuICAgIGRldmljZVgsXG4gICAgZGV2aWNlWSxcbiAgICBkZXZpY2VSYWRpdXNcbiAgfSk7XG5cbiAgY29uc3Qge1xuICAgIHBpY2tlZENvbG9yLFxuICAgIHBpY2tlZExheWVyLFxuICAgIHBpY2tlZE9iamVjdEluZGV4XG4gIH0gPSBwaWNrSW5mbztcblxuICBjb25zdCBhZmZlY3RlZExheWVycyA9IHBpY2tlZExheWVyID8gW3BpY2tlZExheWVyXSA6IFtdO1xuXG4gIGlmIChtb2RlID09PSAnaG92ZXInKSB7XG4gICAgLy8gb25seSBpbnZva2Ugb25Ib3ZlciBldmVudHMgaWYgcGlja2VkIG9iamVjdCBoYXMgY2hhbmdlZFxuICAgIGNvbnN0IGxhc3RQaWNrZWRPYmplY3RJbmRleCA9IGxhc3RQaWNrZWRJbmZvLmluZGV4O1xuICAgIGNvbnN0IGxhc3RQaWNrZWRMYXllcklkID0gbGFzdFBpY2tlZEluZm8ubGF5ZXJJZDtcbiAgICBjb25zdCBwaWNrZWRMYXllcklkID0gcGlja2VkTGF5ZXIgJiYgcGlja2VkTGF5ZXIucHJvcHMuaWQ7XG5cbiAgICAvLyBwcm9jZWVkIG9ubHkgaWYgcGlja2VkIG9iamVjdCBjaGFuZ2VkXG4gICAgaWYgKHBpY2tlZExheWVySWQgIT09IGxhc3RQaWNrZWRMYXllcklkIHx8IHBpY2tlZE9iamVjdEluZGV4ICE9PSBsYXN0UGlja2VkT2JqZWN0SW5kZXgpIHtcbiAgICAgIGlmIChwaWNrZWRMYXllcklkICE9PSBsYXN0UGlja2VkTGF5ZXJJZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3Qgc3RvcmUgYSByZWYgdG8gbGFzdFBpY2tlZExheWVyIGluIHRoZSBjb250ZXh0IGJlY2F1c2VcbiAgICAgICAgLy8gdGhlIHN0YXRlIG9mIGFuIG91dGRhdGVkIGxheWVyIGlzIG5vIGxvbmdlciB2YWxpZFxuICAgICAgICAvLyBhbmQgdGhlIHByb3BzIG1heSBoYXZlIGNoYW5nZWRcbiAgICAgICAgY29uc3QgbGFzdFBpY2tlZExheWVyID0gbGF5ZXJzLmZpbmQobGF5ZXIgPT4gbGF5ZXIucHJvcHMuaWQgPT09IGxhc3RQaWNrZWRMYXllcklkKTtcbiAgICAgICAgaWYgKGxhc3RQaWNrZWRMYXllcikge1xuICAgICAgICAgIC8vIExldCBsZWF2ZSBldmVudCBmaXJlIGJlZm9yZSBlbnRlciBldmVudFxuICAgICAgICAgIGFmZmVjdGVkTGF5ZXJzLnVuc2hpZnQobGFzdFBpY2tlZExheWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgbGF5ZXIgbWFuYWdlciBjb250ZXh0XG4gICAgICBsYXN0UGlja2VkSW5mby5sYXllcklkID0gcGlja2VkTGF5ZXJJZDtcbiAgICAgIGxhc3RQaWNrZWRJbmZvLmluZGV4ID0gcGlja2VkT2JqZWN0SW5kZXg7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3cG9ydEZyb21Db29yZGluYXRlcyh7dmlld3BvcnRzfSk7IC8vIFRPRE8gLSBhZGQgY29vcmRzXG5cbiAgY29uc3QgYmFzZUluZm8gPSBjcmVhdGVJbmZvKFt4LCB5XSwgdmlld3BvcnQpO1xuICBiYXNlSW5mby5kZXZpY2VQaXhlbCA9IFtkZXZpY2VYLCBkZXZpY2VZXTtcbiAgYmFzZUluZm8ucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG5cbiAgLy8gVXNlIGEgTWFwIHRvIHN0b3JlIGFsbCBwaWNraW5nIGluZm9zLlxuICAvLyBUaGUgZm9sbG93aW5nIHR3byBmb3JFYWNoIGxvb3BzIGFyZSB0aGUgcmVzdWx0IG9mXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91YmVyL2RlY2suZ2wvaXNzdWVzLzQ0M1xuICAvLyBQbGVhc2UgYmUgdmVyeSBjYXJlZnVsIHdoZW4gY2hhbmdpbmcgdGhpcyBwYXR0ZXJuXG4gIGNvbnN0IGluZm9zID0gbmV3IE1hcCgpO1xuICBjb25zdCB1bmhhbmRsZWRQaWNrSW5mb3MgPSBbXTtcblxuICBhZmZlY3RlZExheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICBsZXQgaW5mbyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VJbmZvKTtcblxuICAgIGlmIChsYXllciA9PT0gcGlja2VkTGF5ZXIpIHtcbiAgICAgIGluZm8uY29sb3IgPSBwaWNrZWRDb2xvcjtcbiAgICAgIGluZm8uaW5kZXggPSBwaWNrZWRPYmplY3RJbmRleDtcbiAgICAgIGluZm8ucGlja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpbmZvID0gZ2V0TGF5ZXJQaWNraW5nSW5mbyh7bGF5ZXIsIGluZm8sIG1vZGV9KTtcblxuICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHRoZXJlIHdpbGwgYmUgb25seSBvbmUgY29weSBvZiBpbmZvIGZvclxuICAgIC8vIG9uZSBjb21wb3NpdGUgbGF5ZXJcbiAgICBpZiAoaW5mbykge1xuICAgICAgaW5mb3Muc2V0KGluZm8ubGF5ZXIuaWQsIGluZm8pO1xuICAgIH1cblxuICAgIGNvbnN0IHBpY2tpbmdTZWxlY3RlZENvbG9yID0gcGlja2VkQ29sb3I7XG4gICAgY29uc3QgcGlja2luZ1NlbGVjdGVkQ29sb3JWYWxpZCA9IEJvb2xlYW4oXG4gICAgICBsYXllci5wcm9wcy5hdXRvSGlnaGxpZ2h0ICYmXG4gICAgICBwaWNrZWRMYXllciA9PT0gbGF5ZXIgJiZcbiAgICAgIHBpY2tpbmdTZWxlY3RlZENvbG9yICE9PSBFTVBUWV9QSVhFTFxuICAgICk7XG4gICAgLy8gVE9ETyAtIGhhbmRsZSBtdWx0aSBtb2RlbCBsYXllcnM/XG4gICAgaWYgKGxheWVyLnN0YXRlLm1vZGVsKSB7XG4gICAgICBsYXllci5zdGF0ZS5tb2RlbC51cGRhdGVNb2R1bGVTZXR0aW5ncyh7XG4gICAgICAgIHBpY2tpbmdTZWxlY3RlZENvbG9yLFxuICAgICAgICBwaWNraW5nU2VsZWN0ZWRDb2xvclZhbGlkXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIGluZm9zLmZvckVhY2goaW5mbyA9PiB7XG4gICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcbiAgICAvLyBQZXItbGF5ZXIgZXZlbnQgaGFuZGxlcnMgKGUuZy4gb25DbGljaywgb25Ib3ZlcikgYXJlIHByb3ZpZGVkIGJ5IHRoZVxuICAgIC8vIHVzZXIgYW5kIG91dCBvZiBkZWNrLmdsJ3MgY29udHJvbC4gSXQncyB2ZXJ5IG11Y2ggcG9zc2libGUgdGhhdFxuICAgIC8vIHRoZSB1c2VyIGNhbGxzIFJlYWN0IGxpZmVjeWNsZSBtZXRob2RzIGluIHRoZXNlIGZ1bmN0aW9uLCBzdWNoIGFzXG4gICAgLy8gUmVhY3RDb21wb25lbnQuc2V0U3RhdGUoKS4gUmVhY3QgbGlmZWN5Y2xlIG1ldGhvZHMgc29tZXRpbWVzIGluZHVjZVxuICAgIC8vIGEgcmUtcmVuZGVyIGFuZCByZS1nZW5lcmF0aW9uIG9mIHByb3BzIG9mIGRlY2suZ2wgYW5kIGl0cyBsYXllcnMsXG4gICAgLy8gd2hpY2ggaW52YWxpZGF0ZXMgYWxsIGxheWVycyBjdXJyZW50bHkgcGFzc2VkIHRvIHRoaXMgdmVyeSBmdW5jdGlvbi5cblxuICAgIC8vIFRoZXJlZm9yZSwgcGVyLWxheWVyIGV2ZW50IGhhbmRsZXJzIG11c3QgYmUgaW52b2tlZCBhdCB0aGUgZW5kXG4gICAgLy8gb2YgdGhpcyBmdW5jdGlvbi4gTk8gb3BlcmF0aW9uIHRoYXQgcmVsaWVzIG9uIHRoZSBzdGF0ZXMgb2YgY3VycmVudFxuICAgIC8vIGxheWVycyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoaXMgY29kZS5cbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlICdjbGljayc6IGhhbmRsZWQgPSBpbmZvLmxheWVyLnByb3BzLm9uQ2xpY2soaW5mbyk7IGJyZWFrO1xuICAgIGNhc2UgJ2hvdmVyJzogaGFuZGxlZCA9IGluZm8ubGF5ZXIucHJvcHMub25Ib3ZlcihpbmZvKTsgYnJlYWs7XG4gICAgY2FzZSAncXVlcnknOiBicmVhaztcbiAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gcGljayB0eXBlJyk7XG4gICAgfVxuXG4gICAgaWYgKCFoYW5kbGVkKSB7XG4gICAgICB1bmhhbmRsZWRQaWNrSW5mb3MucHVzaChpbmZvKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB1bmhhbmRsZWRQaWNrSW5mb3M7XG59XG5cbi8vIFBpY2sgYWxsIG9iamVjdHMgd2l0aGluIHRoZSBnaXZlbiBib3VuZGluZyBib3hcbmV4cG9ydCBmdW5jdGlvbiBwaWNrVmlzaWJsZU9iamVjdHMoZ2wsIHtcbiAgbGF5ZXJzLFxuICB2aWV3cG9ydHMsXG4gIG9uVmlld3BvcnRBY3RpdmUsXG4gIHBpY2tpbmdGQk8sXG4gIHgsXG4gIHksXG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIG1vZGUsXG4gIHVzZURldmljZVBpeGVsUmF0aW9cbn0pIHtcblxuICAvLyBDb252ZXJ0IGZyb20gY2FudmFzIHRvcC1sZWZ0IHRvIFdlYkdMIGJvdHRvbS1sZWZ0IGNvb3JkaW5hdGVzXG4gIC8vIEFuZCBjb21wZW5zYXRlIGZvciBwaXhlbFJhdGlvXG4gIGNvbnN0IHBpeGVsUmF0aW8gPSBnZXRQaXhlbFJhdGlvKHt1c2VEZXZpY2VQaXhlbFJhdGlvfSk7XG5cbiAgY29uc3QgZGV2aWNlTGVmdCA9IE1hdGgucm91bmQoeCAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VCb3R0b20gPSBNYXRoLnJvdW5kKGdsLmNhbnZhcy5oZWlnaHQgLSB5ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVJpZ2h0ID0gTWF0aC5yb3VuZCgoeCArIHdpZHRoKSAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VUb3AgPSBNYXRoLnJvdW5kKGdsLmNhbnZhcy5oZWlnaHQgLSAoeSArIGhlaWdodCkgKiBwaXhlbFJhdGlvKTtcblxuICAvLyBPbmx5IHJldHVybiB1bmlxdWUgaW5mb3MsIGlkZW50aWZpZWQgYnkgaW5mby5vYmplY3RcbiAgY29uc3QgdW5pcXVlSW5mb3MgPSBuZXcgTWFwKCk7XG5cbiAgY29uc3QgcGlja0luZm9zID0gZ2V0VW5pcXVlc0Zyb21QaWNraW5nQnVmZmVyKGdsLCB7XG4gICAgbGF5ZXJzLFxuICAgIHZpZXdwb3J0cyxcbiAgICBvblZpZXdwb3J0QWN0aXZlLFxuICAgIHBpY2tpbmdGQk8sXG4gICAgZGV2aWNlUmVjdDoge1xuICAgICAgeDogZGV2aWNlTGVmdCxcbiAgICAgIHk6IGRldmljZVRvcCxcbiAgICAgIHdpZHRoOiBkZXZpY2VSaWdodCAtIGRldmljZUxlZnQsXG4gICAgICBoZWlnaHQ6IGRldmljZUJvdHRvbSAtIGRldmljZVRvcFxuICAgIH1cbiAgfSk7XG5cbiAgcGlja0luZm9zLmZvckVhY2gocGlja0luZm8gPT4ge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRGcm9tQ29vcmRpbmF0ZXMoe3ZpZXdwb3J0c30pOyAvLyBUT0RPIC0gYWRkIGNvb3Jkc1xuICAgIGxldCBpbmZvID0gY3JlYXRlSW5mbyhbcGlja0luZm8ueCAvIHBpeGVsUmF0aW8sIHBpY2tJbmZvLnkgLyBwaXhlbFJhdGlvXSwgdmlld3BvcnQpO1xuICAgIGluZm8uZGV2aWNlUGl4ZWwgPSBbcGlja0luZm8ueCwgcGlja0luZm8ueV07XG4gICAgaW5mby5waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICBpbmZvLmNvbG9yID0gcGlja0luZm8ucGlja2VkQ29sb3I7XG4gICAgaW5mby5pbmRleCA9IHBpY2tJbmZvLnBpY2tlZE9iamVjdEluZGV4O1xuICAgIGluZm8ucGlja2VkID0gdHJ1ZTtcblxuICAgIGluZm8gPSBnZXRMYXllclBpY2tpbmdJbmZvKHtsYXllcjogcGlja0luZm8ucGlja2VkTGF5ZXIsIGluZm8sIG1vZGV9KTtcbiAgICBpZiAoIXVuaXF1ZUluZm9zLmhhcyhpbmZvLm9iamVjdCkpIHtcbiAgICAgIHVuaXF1ZUluZm9zLnNldChpbmZvLm9iamVjdCwgaW5mbyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gQXJyYXkuZnJvbSh1bmlxdWVJbmZvcy52YWx1ZXMoKSk7XG59XG5cbi8vIEhFTFBFUiBNRVRIT0RTXG5cbi8vIEluZGVudGlmaWVzIHdoaWNoIHZpZXdwb3J0LCBpZiBhbnkgY29ycmVzcG9uZHMgdG8geCBhbmQgeVxuLy8gUmV0dXJucyBmaXJzdCB2aWV3cG9ydCBpZiBubyBtYXRjaFxuLy8gVE9ETyAtIG5lZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIHZpZXdwb3J0IHdlIGFyZSBpblxuLy8gVE9ETyAtIGRvY3VtZW50IGNvbmNlcHQgb2YgXCJwcmltYXJ5IHZpZXdwb3J0XCIgdGhhdCBtYXRjaGVzIGFsbCBjb29yZHM/XG4vLyBUT0RPIC0gc3RhdGljIG1ldGhvZCBvbiBWaWV3cG9ydCBjbGFzcz9cbmZ1bmN0aW9uIGdldFZpZXdwb3J0RnJvbUNvb3JkaW5hdGVzKHt2aWV3cG9ydHN9KSB7XG4gIGNvbnN0IHZpZXdwb3J0ID0gdmlld3BvcnRzWzBdO1xuICByZXR1cm4gdmlld3BvcnQ7XG59XG5cbmZ1bmN0aW9uIGdldFBpY2tlZENvbG9ycyhnbCwge2xheWVycywgdmlld3BvcnRzLCBvblZpZXdwb3J0QWN0aXZlLCBwaWNraW5nRkJPLCBkZXZpY2VSZWN0fSkge1xuICBkcmF3UGlja2luZ0J1ZmZlcihnbCwge2xheWVycywgdmlld3BvcnRzLCBvblZpZXdwb3J0QWN0aXZlLCBwaWNraW5nRkJPLCBkZXZpY2VSZWN0fSk7XG4gIC8vIFRPRE8gLSByZXN0b3JlIHdoZW4gbHVtYSBwYXRjaCBsYW5kc1xuICAvLyBjb25zdCBkYXRhVXJsID0gcGlja2luZ0ZCTy5yZWFkRGF0YVVybCgpO1xuICAvLyB3aW5kb3cub3BlbihkYXRhVXJsLCAncGlja2luZyBidWZmZXInKTtcblxuICBjb25zdCBwaWNrZWRDb2xvcnMgPSBzYW1wbGVQaWNraW5nQnVmZmVyKGdsLCB7cGlja2luZ0ZCTywgZGV2aWNlUmVjdH0pO1xuICByZXR1cm4gcGlja2VkQ29sb3JzO1xufVxuXG4vLyBSZWFkIGZyb20gYW4gYWxyZWFkeSByZW5kZXJlZCBwaWNraW5nIGJ1ZmZlclxuLy8gUmV0dXJucyBhbiBVaW50OENsYW1wZWRBcnJheSBvZiBwaWNrZWQgcGl4ZWxzXG5leHBvcnQgZnVuY3Rpb24gc2FtcGxlUGlja2luZ0J1ZmZlcihnbCwge1xuICBwaWNraW5nRkJPLFxuICBkZXZpY2VSZWN0OiB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbn0pIHtcbiAgY29uc3QgcGlja2VkQ29sb3JzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgcGlja2luZ0ZCTy5yZWFkUGl4ZWxzKHt4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwaXhlbEFycmF5OiBwaWNrZWRDb2xvcnN9KTtcbiAgcmV0dXJuIHBpY2tlZENvbG9ycztcbn1cblxuLyoqXG4gKiBQaWNrIGF0IGEgc3BlY2lmaWVkIHBpeGVsIHdpdGggYSB0b2xlcmFuY2UgcmFkaXVzXG4gKiBSZXR1cm5zIHRoZSBjbG9zZXN0IG9iamVjdCB0byB0aGUgcGl4ZWwgaW4gc2hhcGUgYHtwaWNrZWRDb2xvciwgcGlja2VkTGF5ZXIsIHBpY2tlZE9iamVjdEluZGV4fWBcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEZyb21QaWNraW5nQnVmZmVyKGdsLCB7XG4gIGxheWVycyxcbiAgdmlld3BvcnRzLFxuICBvblZpZXdwb3J0QWN0aXZlLFxuICBwaWNraW5nRkJPLFxuICBkZXZpY2VYLFxuICBkZXZpY2VZLFxuICBkZXZpY2VSYWRpdXNcbn0pIHtcbiAgbGV0IGNsb3Nlc3RSZXN1bHRUb0NlbnRlciA9IHtcbiAgICBwaWNrZWRDb2xvcjogRU1QVFlfUElYRUwsXG4gICAgcGlja2VkTGF5ZXI6IG51bGwsXG4gICAgcGlja2VkT2JqZWN0SW5kZXg6IC0xXG4gIH07XG5cbiAgLy8geCwgeSBvdXQgb2YgYm91bmRzIG9yIG5vIGxheWVycyB0byBwaWNrLlxuICBjb25zdCB2YWxpZCA9XG4gICAgbGF5ZXJzLmxlbmd0aCA+IDAgJiZcbiAgICBkZXZpY2VYID49IDAgJiZcbiAgICBkZXZpY2VZID49IDAgJiZcbiAgICBkZXZpY2VYIDwgcGlja2luZ0ZCTy53aWR0aCAmJlxuICAgIGRldmljZVkgPCBwaWNraW5nRkJPLmhlaWdodDtcblxuICBpZiAoIXZhbGlkKSB7XG4gICAgcmV0dXJuIGNsb3Nlc3RSZXN1bHRUb0NlbnRlcjtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIGJveCBvZiBzaXplIGByYWRpdXMgKiAyICsgMWAgY2VudGVyZWQgYXQgW2RldmljZVgsIGRldmljZVldXG4gIGNvbnN0IHggPSBNYXRoLm1heCgwLCBkZXZpY2VYIC0gZGV2aWNlUmFkaXVzKTtcbiAgY29uc3QgeSA9IE1hdGgubWF4KDAsIGRldmljZVkgLSBkZXZpY2VSYWRpdXMpO1xuICBjb25zdCB3aWR0aCA9IE1hdGgubWluKHBpY2tpbmdGQk8ud2lkdGgsIGRldmljZVggKyBkZXZpY2VSYWRpdXMpIC0geCArIDE7XG4gIGNvbnN0IGhlaWdodCA9IE1hdGgubWluKHBpY2tpbmdGQk8uaGVpZ2h0LCBkZXZpY2VZICsgZGV2aWNlUmFkaXVzKSAtIHkgKyAxO1xuXG4gIGNvbnN0IHBpY2tlZENvbG9ycyA9IGdldFBpY2tlZENvbG9ycyhnbCwge1xuICAgIGxheWVycyxcbiAgICB2aWV3cG9ydHMsXG4gICAgb25WaWV3cG9ydEFjdGl2ZSxcbiAgICBwaWNraW5nRkJPLFxuICAgIGRldmljZVJlY3Q6IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICB9KTtcblxuICAvLyBUcmF2ZXJzZSBhbGwgcGl4ZWxzIGluIHBpY2tpbmcgcmVzdWx0cyBhbmQgZmluZCB0aGUgb25lIGNsb3Nlc3QgdG8gdGhlIHN1cHBsaWVkXG4gIC8vIFtkZXZpY2VYLCBkZXZpY2VZXVxuICBsZXQgbWluU3F1YXJlRGlzdGFuY2VUb0NlbnRlciA9IGRldmljZVJhZGl1cyAqIGRldmljZVJhZGl1cztcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IGhlaWdodDsgcm93KyspIHtcbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB3aWR0aDsgY29sKyspIHtcbiAgICAgIC8vIERlY29kZSBwaWNrZWQgbGF5ZXIgZnJvbSBjb2xvclxuICAgICAgY29uc3QgcGlja2VkTGF5ZXJJbmRleCA9IHBpY2tlZENvbG9yc1tpICsgM10gLSAxO1xuXG4gICAgICBpZiAocGlja2VkTGF5ZXJJbmRleCA+PSAwKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gY29sICsgeCAtIGRldmljZVg7XG4gICAgICAgIGNvbnN0IGR5ID0gcm93ICsgeSAtIGRldmljZVk7XG4gICAgICAgIGNvbnN0IGQyID0gZHggKiBkeCArIGR5ICogZHk7XG5cbiAgICAgICAgaWYgKGQyIDw9IG1pblNxdWFyZURpc3RhbmNlVG9DZW50ZXIpIHtcbiAgICAgICAgICBtaW5TcXVhcmVEaXN0YW5jZVRvQ2VudGVyID0gZDI7XG5cbiAgICAgICAgICAvLyBEZWNvZGUgcGlja2VkIG9iamVjdCBpbmRleCBmcm9tIGNvbG9yXG4gICAgICAgICAgY29uc3QgcGlja2VkQ29sb3IgPSBwaWNrZWRDb2xvcnMuc2xpY2UoaSwgaSArIDQpO1xuICAgICAgICAgIGNvbnN0IHBpY2tlZExheWVyID0gbGF5ZXJzW3BpY2tlZExheWVySW5kZXhdO1xuICAgICAgICAgIGlmIChwaWNrZWRMYXllcikge1xuICAgICAgICAgICAgY29uc3QgcGlja2VkT2JqZWN0SW5kZXggPSBwaWNrZWRMYXllci5kZWNvZGVQaWNraW5nQ29sb3IocGlja2VkQ29sb3IpO1xuICAgICAgICAgICAgY2xvc2VzdFJlc3VsdFRvQ2VudGVyID0ge3BpY2tlZENvbG9yLCBwaWNrZWRMYXllciwgcGlja2VkT2JqZWN0SW5kZXh9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoMCwgJ1BpY2tlZCBub24tZXhpc3RlbnQgbGF5ZXIuIElzIHBpY2tpbmcgYnVmZmVyIGNvcnJ1cHQ/Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpICs9IDQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3RSZXN1bHRUb0NlbnRlcjtcbn1cbi8qIGVzbGludC1lbmFibGUgbWF4LWRlcHRoLCBtYXgtc3RhdGVtZW50cyAqL1xuXG4vKipcbiAqIFF1ZXJ5IHdpdGhpbiBhIHNwZWNpZmllZCByZWN0YW5nbGVcbiAqIFJldHVybnMgYXJyYXkgb2YgdW5pcXVlIG9iamVjdHMgaW4gc2hhcGUgYHt4LCB5LCBwaWNrZWRDb2xvciwgcGlja2VkTGF5ZXIsIHBpY2tlZE9iamVjdEluZGV4fWBcbiAqL1xuZnVuY3Rpb24gZ2V0VW5pcXVlc0Zyb21QaWNraW5nQnVmZmVyKGdsLCB7XG4gIGxheWVycyxcbiAgdmlld3BvcnRzLFxuICBvblZpZXdwb3J0QWN0aXZlLFxuICBwaWNraW5nRkJPLFxuICBkZXZpY2VSZWN0OiB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbn0pIHtcbiAgY29uc3QgcGlja2VkQ29sb3JzID0gZ2V0UGlja2VkQ29sb3JzKGdsLCB7XG4gICAgbGF5ZXJzLFxuICAgIHZpZXdwb3J0cyxcbiAgICBvblZpZXdwb3J0QWN0aXZlLFxuICAgIHBpY2tpbmdGQk8sXG4gICAgZGV2aWNlUmVjdDoge3gsIHksIHdpZHRoLCBoZWlnaHR9XG4gIH0pO1xuICBjb25zdCB1bmlxdWVDb2xvcnMgPSBuZXcgTWFwKCk7XG5cbiAgLy8gVHJhdmVyc2UgYWxsIHBpeGVscyBpbiBwaWNraW5nIHJlc3VsdHMgYW5kIGdldCB1bmlxdWUgY29sb3JzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGlja2VkQ29sb3JzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgLy8gRGVjb2RlIHBpY2tlZCBsYXllciBmcm9tIGNvbG9yXG4gICAgY29uc3QgcGlja2VkTGF5ZXJJbmRleCA9IHBpY2tlZENvbG9yc1tpICsgM10gLSAxO1xuXG4gICAgaWYgKHBpY2tlZExheWVySW5kZXggPj0gMCkge1xuICAgICAgY29uc3QgcGlja2VkQ29sb3IgPSBwaWNrZWRDb2xvcnMuc2xpY2UoaSwgaSArIDQpO1xuICAgICAgY29uc3QgY29sb3JLZXkgPSBwaWNrZWRDb2xvci5qb2luKCcsJyk7XG4gICAgICBpZiAoIXVuaXF1ZUNvbG9ycy5oYXMoY29sb3JLZXkpKSB7XG4gICAgICAgIGNvbnN0IHBpY2tlZExheWVyID0gbGF5ZXJzW3BpY2tlZExheWVySW5kZXhdO1xuICAgICAgICBpZiAocGlja2VkTGF5ZXIpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgIHVuaXF1ZUNvbG9ycy5zZXQoY29sb3JLZXksIHtcbiAgICAgICAgICAgIHBpY2tlZENvbG9yLFxuICAgICAgICAgICAgcGlja2VkTGF5ZXIsXG4gICAgICAgICAgICBwaWNrZWRPYmplY3RJbmRleDogcGlja2VkTGF5ZXIuZGVjb2RlUGlja2luZ0NvbG9yKHBpY2tlZENvbG9yKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvZy5lcnJvcigwLCAnUGlja2VkIG5vbi1leGlzdGVudCBsYXllci4gSXMgcGlja2luZyBidWZmZXIgY29ycnVwdD8nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKHVuaXF1ZUNvbG9ycy52YWx1ZXMoKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluZm8ocGl4ZWwsIHZpZXdwb3J0KSB7XG4gIC8vIEFzc2lnbiBhIG51bWJlciBvZiBwb3RlbnRpYWxseSB1c2VmdWwgcHJvcHMgdG8gdGhlIFwiaW5mb1wiIG9iamVjdFxuICByZXR1cm4ge1xuICAgIGNvbG9yOiBFTVBUWV9QSVhFTCxcbiAgICBsYXllcjogbnVsbCxcbiAgICBpbmRleDogLTEsXG4gICAgcGlja2VkOiBmYWxzZSxcbiAgICB4OiBwaXhlbFswXSxcbiAgICB5OiBwaXhlbFsxXSxcbiAgICBwaXhlbCxcbiAgICBsbmdMYXQ6IHZpZXdwb3J0LnVucHJvamVjdChwaXhlbClcbiAgfTtcbn1cblxuLy8gV2FsayB1cCB0aGUgbGF5ZXIgY29tcG9zaXRlIGNoYWluIHRvIHBvcHVsYXRlIHRoZSBpbmZvIG9iamVjdFxuZnVuY3Rpb24gZ2V0TGF5ZXJQaWNraW5nSW5mbyh7bGF5ZXIsIGluZm8sIG1vZGV9KSB7XG4gIHdoaWxlIChsYXllciAmJiBpbmZvKSB7XG4gICAgLy8gRm9yIGEgY29tcG9zaXRlIGxheWVyLCBzb3VyY2VMYXllciB3aWxsIHBvaW50IHRvIHRoZSBzdWJsYXllclxuICAgIC8vIHdoZXJlIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20uXG4gICAgLy8gSXQgcHJvdmlkZXMgYWRkaXRpb25hbCBjb250ZXh0IGZvciB0aGUgY29tcG9zaXRlIGxheWVyJ3NcbiAgICAvLyBnZXRQaWNraW5nSW5mbygpIG1ldGhvZCB0byBwb3B1bGF0ZSB0aGUgaW5mbyBvYmplY3RcbiAgICBjb25zdCBzb3VyY2VMYXllciA9IGluZm8ubGF5ZXIgfHwgbGF5ZXI7XG4gICAgaW5mby5sYXllciA9IGxheWVyO1xuICAgIC8vIGxheWVyLnBpY2tMYXllcigpIGZ1bmN0aW9uIHJlcXVpcmVzIGEgbm9uLW51bGwgYGBgbGF5ZXIuc3RhdGVgYGBcbiAgICAvLyBvYmplY3QgdG8gZnVudGlvbiBwcm9wZXJseS4gU28gdGhlIGxheWVyIHJlZmVyZWNlZCBoZXJlXG4gICAgLy8gbXVzdCBiZSB0aGUgXCJjdXJyZW50XCIgbGF5ZXIsIG5vdCBhbiBcIm91dC1kYXRlZFwiIC8gXCJpbnZhbGlkYXRlZFwiIGxheWVyXG4gICAgaW5mbyA9IGxheWVyLnBpY2tMYXllcih7aW5mbywgbW9kZSwgc291cmNlTGF5ZXJ9KTtcbiAgICBsYXllciA9IGxheWVyLnBhcmVudExheWVyO1xuICB9XG4gIHJldHVybiBpbmZvO1xufVxuIl19