'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.compareProps = compareProps;
exports.getDefaultProps = getDefaultProps;
exports.mergeDefaultProps = mergeDefaultProps;

var _utils = require('./utils');

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * @param {Object} opt.oldProps - object with old key/value pairs
 * @param {Object} opt.newProps - object with new key/value pairs
 * @param {Object} opt.ignoreProps={} - object, keys that should not be compared
 * @returns {null|String} - null when values of all keys are strictly equal.
 *   if unequal, returns a string explaining what changed.
 */
/* eslint-disable max-statements, complexity */
function compareProps() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      oldProps = _ref.oldProps,
      newProps = _ref.newProps,
      _ref$ignoreProps = _ref.ignoreProps,
      ignoreProps = _ref$ignoreProps === undefined ? {} : _ref$ignoreProps,
      _ref$triggerName = _ref.triggerName,
      triggerName = _ref$triggerName === undefined ? 'props' : _ref$triggerName;

  (0, _assert2.default)(oldProps !== undefined && newProps !== undefined, 'compareProps args');

  // shallow equality => deep equality
  if (oldProps === newProps) {
    return null;
  }

  if ((typeof newProps === 'undefined' ? 'undefined' : _typeof(newProps)) !== 'object' || newProps === null) {
    return triggerName + ' changed shallowly';
  }

  if ((typeof oldProps === 'undefined' ? 'undefined' : _typeof(oldProps)) !== 'object' || oldProps === null) {
    return triggerName + ' changed shallowly';
  }

  // Test if new props different from old props
  for (var key in oldProps) {
    if (!(key in ignoreProps)) {
      if (!newProps.hasOwnProperty(key)) {
        return triggerName + ' ' + key + ' dropped: ' + oldProps[key] + ' -> (undefined)';
      }

      var equals = newProps[key] && oldProps[key] && newProps[key].equals;
      if (equals && !equals.call(newProps[key], oldProps[key])) {
        return triggerName + ' ' + key + ' changed deeply: ' + oldProps[key] + ' -> ' + newProps[key];
      }

      if (!equals && oldProps[key] !== newProps[key]) {
        return triggerName + ' ' + key + ' changed shallowly: ' + oldProps[key] + ' -> ' + newProps[key];
      }
    }
  }

  // Test if any new props have been added
  for (var _key in newProps) {
    if (!(_key in ignoreProps)) {
      if (!oldProps.hasOwnProperty(_key)) {
        return triggerName + ' ' + _key + ' added: (undefined) -> ' + newProps[_key];
      }
    }
  }

  return null;
}
/* eslint-enable max-statements, complexity */

// HELPERS

// Constructors have their super class constructors as prototypes
function getOwnProperty(object, prop) {
  return object.hasOwnProperty(prop) && object[prop];
}

/*
 * Return merged default props stored on layers constructor, create them if needed
 */
function getDefaultProps(layer) {
  var mergedDefaultProps = getOwnProperty(layer.constructor, 'mergedDefaultProps');
  if (mergedDefaultProps) {
    return mergedDefaultProps;
  }
  return mergeDefaultProps(layer);
}

/*
 * Walk a prototype chain and merge all default props from any 'defaultProps' objects
 */
function mergeDefaultProps(object) {
  var objectNameKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'layerName';

  var subClassConstructor = object.constructor;
  var objectName = getOwnProperty(subClassConstructor, objectNameKey);
  if (!objectName) {
    _utils.log.once(0, object.constructor.name + ' does not specify a ' + objectNameKey);
  }

  // Use the object's constructor name as default id prop.
  // Note that constructor names are substituted during minification and may not be "human readable"
  var mergedDefaultProps = {
    id: objectName || object.constructor.name
  };

  // Reverse shadowing
  // TODO - Rewrite to stop when mergedDefaultProps is available on parent?
  while (object) {
    var objectDefaultProps = getOwnProperty(object.constructor, 'defaultProps');
    Object.freeze(objectDefaultProps);
    if (objectDefaultProps) {
      mergedDefaultProps = Object.assign({}, objectDefaultProps, mergedDefaultProps);
    }
    object = Object.getPrototypeOf(object);
  }

  Object.freeze(mergedDefaultProps);

  // Store for quick lookup
  subClassConstructor.mergedDefaultProps = mergedDefaultProps;

  (0, _assert2.default)(mergeDefaultProps);
  return mergedDefaultProps;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL2xpYi9wcm9wcy5qcyJdLCJuYW1lcyI6WyJjb21wYXJlUHJvcHMiLCJnZXREZWZhdWx0UHJvcHMiLCJtZXJnZURlZmF1bHRQcm9wcyIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJpZ25vcmVQcm9wcyIsInRyaWdnZXJOYW1lIiwidW5kZWZpbmVkIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJlcXVhbHMiLCJjYWxsIiwiZ2V0T3duUHJvcGVydHkiLCJvYmplY3QiLCJwcm9wIiwibGF5ZXIiLCJtZXJnZWREZWZhdWx0UHJvcHMiLCJjb25zdHJ1Y3RvciIsIm9iamVjdE5hbWVLZXkiLCJzdWJDbGFzc0NvbnN0cnVjdG9yIiwib2JqZWN0TmFtZSIsIm9uY2UiLCJuYW1lIiwiaWQiLCJvYmplY3REZWZhdWx0UHJvcHMiLCJPYmplY3QiLCJmcmVlemUiLCJhc3NpZ24iLCJnZXRQcm90b3R5cGVPZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7UUFhZ0JBLFksR0FBQUEsWTtRQXlEQUMsZSxHQUFBQSxlO1FBV0FDLGlCLEdBQUFBLGlCOztBQWpGaEI7O0FBQ0E7Ozs7OztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNPLFNBQVNGLFlBQVQsR0FBMEY7QUFBQSxpRkFBSixFQUFJO0FBQUEsTUFBbkVHLFFBQW1FLFFBQW5FQSxRQUFtRTtBQUFBLE1BQXpEQyxRQUF5RCxRQUF6REEsUUFBeUQ7QUFBQSw4QkFBL0NDLFdBQStDO0FBQUEsTUFBL0NBLFdBQStDLG9DQUFqQyxFQUFpQztBQUFBLDhCQUE3QkMsV0FBNkI7QUFBQSxNQUE3QkEsV0FBNkIsb0NBQWYsT0FBZTs7QUFDL0Ysd0JBQU9ILGFBQWFJLFNBQWIsSUFBMEJILGFBQWFHLFNBQTlDLEVBQXlELG1CQUF6RDs7QUFFQTtBQUNBLE1BQUlKLGFBQWFDLFFBQWpCLEVBQTJCO0FBQ3pCLFdBQU8sSUFBUDtBQUNEOztBQUVELE1BQUksUUFBT0EsUUFBUCx5Q0FBT0EsUUFBUCxPQUFvQixRQUFwQixJ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LEVBQWtCSCxrQkFBbEIsRUFBc0NSLGtCQUF0QyxDQUFyQjtBQUNEO0FBQ0RILGFBQVNZLE9BQU9HLGNBQVAsQ0FBc0JmLE1BQXRCLENBQVQ7QUFDRDs7QUFFRFksU0FBT0MsTUFBUCxDQUFjVixrQkFBZDs7QUFFQTtBQUNBRyxzQkFBb0JILGtCQUFwQixHQUF5Q0Esa0JBQXpDOztBQUVBLHdCQUFPZCxpQkFBUDtBQUNBLFNBQU9jLGtCQUFQO0FBQ0QiLCJmaWxlIjoicHJvcHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2xvZ30gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0Lm9sZFByb3BzIC0gb2JqZWN0IHdpdGggb2xkIGtleS92YWx1ZSBwYWlyc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdC5uZXdQcm9wcyAtIG9iamVjdCB3aXRoIG5ldyBrZXkvdmFsdWUgcGFpcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHQuaWdub3JlUHJvcHM9e30gLSBvYmplY3QsIGtleXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbXBhcmVkXG4gKiBAcmV0dXJucyB7bnVsbHxTdHJpbmd9IC0gbnVsbCB3aGVuIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKiAgIGlmIHVuZXF1YWwsIHJldHVybnMgYSBzdHJpbmcgZXhwbGFpbmluZyB3aGF0IGNoYW5nZWQuXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzLCBjb21wbGV4aXR5ICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVByb3BzKHtvbGRQcm9wcywgbmV3UHJvcHMsIGlnbm9yZVByb3BzID0ge30sIHRyaWdnZXJOYW1lID0gJ3Byb3BzJ30gPSB7fSkge1xuICBhc3NlcnQob2xkUHJvcHMgIT09IHVuZGVmaW5lZCAmJiBuZXdQcm9wcyAhPT0gdW5kZWZpbmVkLCAnY29tcGFyZVByb3BzIGFyZ3MnKTtcblxuICAvLyBzaGFsbG93IGVxdWFsaXR5ID0+IGRlZXAgZXF1YWxpdHlcbiAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBuZXdQcm9wcyAhPT0gJ29iamVjdCcgfHwgbmV3UHJvcHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gYCR7dHJpZ2dlck5hbWV9IGNoYW5nZWQgc2hhbGxvd2x5YDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2xkUHJvcHMgIT09ICdvYmplY3QnIHx8IG9sZFByb3BzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGAke3RyaWdnZXJOYW1lfSBjaGFuZ2VkIHNoYWxsb3dseWA7XG4gIH1cblxuICAvLyBUZXN0IGlmIG5ldyBwcm9wcyBkaWZmZXJlbnQgZnJvbSBvbGQgcHJvcHNcbiAgZm9yIChjb25zdCBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gaWdub3JlUHJvcHMpKSB7XG4gICAgICBpZiAoIW5ld1Byb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGAke3RyaWdnZXJOYW1lfSAke2tleX0gZHJvcHBlZDogJHtvbGRQcm9wc1trZXldfSAtPiAodW5kZWZpbmVkKWA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVxdWFscyA9IG5ld1Byb3BzW2tleV0gJiYgb2xkUHJvcHNba2V5XSAmJiBuZXdQcm9wc1trZXldLmVxdWFscztcbiAgICAgIGlmIChlcXVhbHMgJiYgIWVxdWFscy5jYWxsKG5ld1Byb3BzW2tleV0sIG9sZFByb3BzW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBgJHt0cmlnZ2VyTmFtZX0gJHtrZXl9IGNoYW5nZWQgZGVlcGx5OiAke29sZFByb3BzW2tleV19IC0+ICR7bmV3UHJvcHNba2V5XX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVxdWFscyAmJiBvbGRQcm9wc1trZXldICE9PSBuZXdQcm9wc1trZXldKSB7XG4gICAgICAgIHJldHVybiBgJHt0cmlnZ2VyTmFtZX0gJHtrZXl9IGNoYW5nZWQgc2hhbGxvd2x5OiAke29sZFByb3BzW2tleV19IC0+ICR7bmV3UHJvcHNba2V5XX1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRlc3QgaWYgYW55IG5ldyBwcm9wcyBoYXZlIGJlZW4gYWRkZWRcbiAgZm9yIChjb25zdCBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gaWdub3JlUHJvcHMpKSB7XG4gICAgICBpZiAoIW9sZFByb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGAke3RyaWdnZXJOYW1lfSAke2tleX0gYWRkZWQ6ICh1bmRlZmluZWQpIC0+ICR7bmV3UHJvcHNba2V5XX1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cywgY29tcGxleGl0eSAqL1xuXG4vLyBIRUxQRVJTXG5cbi8vIENvbnN0cnVjdG9ycyBoYXZlIHRoZWlyIHN1cGVyIGNsYXNzIGNvbnN0cnVjdG9ycyBhcyBwcm90b3R5cGVzXG5mdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eShvYmplY3QsIHByb3ApIHtcbiAgcmV0dXJuIG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBvYmplY3RbcHJvcF07XG59XG5cbi8qXG4gKiBSZXR1cm4gbWVyZ2VkIGRlZmF1bHQgcHJvcHMgc3RvcmVkIG9uIGxheWVycyBjb25zdHJ1Y3RvciwgY3JlYXRlIHRoZW0gaWYgbmVlZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMobGF5ZXIpIHtcbiAgY29uc3QgbWVyZ2VkRGVmYXVsdFByb3BzID0gZ2V0T3duUHJvcGVydHkobGF5ZXIuY29uc3RydWN0b3IsICdtZXJnZWREZWZhdWx0UHJvcHMnKTtcbiAgaWYgKG1lcmdlZERlZmF1bHRQcm9wcykge1xuICAgIHJldHVybiBtZXJnZWREZWZhdWx0UHJvcHM7XG4gIH1cbiAgcmV0dXJuIG1lcmdlRGVmYXVsdFByb3BzKGxheWVyKTtcbn1cblxuLypcbiAqIFdhbGsgYSBwcm90b3R5cGUgY2hhaW4gYW5kIG1lcmdlIGFsbCBkZWZhdWx0IHByb3BzIGZyb20gYW55ICdkZWZhdWx0UHJvcHMnIG9iamVjdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGVmYXVsdFByb3BzKG9iamVjdCwgb2JqZWN0TmFtZUtleSA9ICdsYXllck5hbWUnKSB7XG4gIGNvbnN0IHN1YkNsYXNzQ29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIGNvbnN0IG9iamVjdE5hbWUgPSBnZXRPd25Qcm9wZXJ0eShzdWJDbGFzc0NvbnN0cnVjdG9yLCBvYmplY3ROYW1lS2V5KTtcbiAgaWYgKCFvYmplY3ROYW1lKSB7XG4gICAgbG9nLm9uY2UoMCwgYCR7b2JqZWN0LmNvbnN0cnVjdG9yLm5hbWV9IGRvZXMgbm90IHNwZWNpZnkgYSAke29iamVjdE5hbWVLZXl9YCk7XG4gIH1cblxuICAvLyBVc2UgdGhlIG9iamVjdCdzIGNvbnN0cnVjdG9yIG5hbWUgYXMgZGVmYXVsdCBpZCBwcm9wLlxuICAvLyBOb3RlIHRoYXQgY29uc3RydWN0b3IgbmFtZXMgYXJlIHN1YnN0aXR1dGVkIGR1cmluZyBtaW5pZmljYXRpb24gYW5kIG1heSBub3QgYmUgXCJodW1hbiByZWFkYWJsZVwiXG4gIGxldCBtZXJnZWREZWZhdWx0UHJvcHMgPSB7XG4gICAgaWQ6IG9iamVjdE5hbWUgfHwgb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWVcbiAgfTtcblxuICAvLyBSZXZlcnNlIHNoYWRvd2luZ1xuICAvLyBUT0RPIC0gUmV3cml0ZSB0byBzdG9wIHdoZW4gbWVyZ2VkRGVmYXVsdFByb3BzIGlzIGF2YWlsYWJsZSBvbiBwYXJlbnQ/XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBjb25zdCBvYmplY3REZWZhdWx0UHJvcHMgPSBnZXRPd25Qcm9wZXJ0eShvYmplY3QuY29uc3RydWN0b3IsICdkZWZhdWx0UHJvcHMnKTtcbiAgICBPYmplY3QuZnJlZXplKG9iamVjdERlZmF1bHRQcm9wcyk7XG4gICAgaWYgKG9iamVjdERlZmF1bHRQcm9wcykge1xuICAgICAgbWVyZ2VkRGVmYXVsdFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqZWN0RGVmYXVsdFByb3BzLCBtZXJnZWREZWZhdWx0UHJvcHMpO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgfVxuXG4gIE9iamVjdC5mcmVlemUobWVyZ2VkRGVmYXVsdFByb3BzKTtcblxuICAvLyBTdG9yZSBmb3IgcXVpY2sgbG9va3VwXG4gIHN1YkNsYXNzQ29uc3RydWN0b3IubWVyZ2VkRGVmYXVsdFByb3BzID0gbWVyZ2VkRGVmYXVsdFByb3BzO1xuXG4gIGFzc2VydChtZXJnZURlZmF1bHRQcm9wcyk7XG4gIHJldHVybiBtZXJnZWREZWZhdWx0UHJvcHM7XG59XG4iXX0=