'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var _layerManager = require('../lib/layer-manager');

var _layerManager2 = _interopRequireDefault(_layerManager);

var _effectManager = require('../experimental/lib/effect-manager');

var _effectManager2 = _interopRequireDefault(_effectManager);

var _effect = require('../experimental/lib/effect');

var _effect2 = _interopRequireDefault(_effect);

var _webMercatorViewport = require('../viewports/web-mercator-viewport');

var _webMercatorViewport2 = _interopRequireDefault(_webMercatorViewport);

var _mjolnir = require('mjolnir.js');

var _luma = require('luma.gl');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* global document */

function noop() {}

var propTypes = {
  id: _propTypes2.default.string,
  width: _propTypes2.default.number.isRequired,
  height: _propTypes2.default.number.isRequired,
  layers: _propTypes2.default.array.isRequired, // Array can contain falsy values
  viewports: _propTypes2.default.array, // Array can contain falsy values
  effects: _propTypes2.default.arrayOf(_propTypes2.default.instanceOf(_effect2.default)),
  glOptions: _propTypes2.default.object,
  gl: _propTypes2.default.object,
  pickingRadius: _propTypes2.default.number,
  initWebGLParameters: _propTypes2.default.bool,
  onWebGLInitialized: _propTypes2.default.func,
  onBeforeRender: _propTypes2.default.func,
  onAfterRender: _propTypes2.default.func,
  onLayerClick: _propTypes2.default.func,
  onLayerHover: _propTypes2.default.func,
  useDevicePixelRatio: _propTypes2.default.bool,

  // Debug settings
  debug: _propTypes2.default.bool,
  drawPickingColors: _propTypes2.default.bool
};

var defaultProps = {
  id: 'deckgl-overlay',
  pickingRadius: 0,
  glOptions: {},
  gl: null,
  effects: [],
  initWebGLParameters: false, // Will be set to true in next major release
  onWebGLInitialized: noop,
  onBeforeRender: noop,
  onAfterRender: noop,
  onLayerClick: null,
  onLayerHover: null,
  useDevicePixelRatio: false,

  debug: false,
  drawPickingColors: false
};

// TODO - should this class be joined with `LayerManager`?

var DeckGLJS = function () {
  function DeckGLJS(props) {
    var _this = this;

    _classCallCheck(this, DeckGLJS);

    props = Object.assign({}, defaultProps, props);

    this.state = {};
    this.needsRedraw = true;
    this.layerManager = null;
    this.effectManager = null;
    this.viewports = [];

    // Bind methods
    this._onRendererInitialized = this._onRendererInitialized.bind(this);
    this._onRenderFrame = this._onRenderFrame.bind(this);

    this.canvas = this._createCanvas(props);

    var _props = props,
        width = _props.width,
        height = _props.height,
        gl = _props.gl,
        glOptions = _props.glOptions,
        debug = _props.debug;


    this.animationLoop = new _luma.AnimationLoop({
      width: width,
      height: height,
      useDevicePixelRatio: false,
      onCreateContext: function onCreateContext(opts) {
        return gl || (0, _luma.createGLContext)(Object.assign({}, glOptions, { canvas: _this.canvas, debug: debug }));
      },
      onInitialize: this._onRendererInitialized,
      onRender: this._onRenderFrame,
      onBeforeRender: props.onBeforeRender,
      onAfterRender: props.onAfterRender
    });

    this.animationLoop.start();

    this.setProps(props);
  }

  _createClass(DeckGLJS, [{
    key: 'setProps',
    value: function setProps(props) {
      props = Object.assign({}, this.props, props);
      this.props = props;

      if (!this.layerManager) {
        return;
      }

      var _props2 = props,
          pickingRadius = _props2.pickingRadius,
          onLayerClick = _props2.onLayerClick,
          onLayerHover = _props2.onLayerHover,
          useDevicePixelRatio = _props2.useDevicePixelRatio,
          drawPickingColors = _props2.drawPickingColors;

      // If more parameters need to be updated on layerManager add them to this method.

      this.layerManager.setParameters({
        useDevicePixelRatio: useDevicePixelRatio,
        drawPickingColors: drawPickingColors
      });

      this.layerManager.setEventHandlingParameters({
        pickingRadius: pickingRadius,
        onLayerClick: onLayerClick,
        onLayerHover: onLayerHover
      });

      // Update viewports (creating one if not supplied)
      var viewports = props.viewports || props.viewport;
      if (!viewports) {
        var _props3 = props,
            width = _props3.width,
            height = _props3.height,
            latitude = _props3.latitude,
            longitude = _props3.longitude,
            zoom = _props3.zoom,
            pitch = _props3.pitch,
            bearing = _props3.bearing;

        viewports = [new _webMercatorViewport2.default({ width: width, height: height, latitude: latitude, longitude: longitude, zoom: zoom, pitch: pitch, bearing: bearing })];
      }
      this.layerManager.setViewports(viewports);

      // TODO - this is a HACK: UpdateLayers needs one viewport prop set each time
      if (props.layers) {
        this.layerManager.updateLayers({ newLayers: props.layers });
      }
    }
  }, {
    key: 'finalize',
    value: function finalize() {
      this.animationLoop.stop();
      this.animationLoop = null;

      if (this.layerManager) {
        this.layerManager.finalize();
        this.layerManager = null;
      }
    }

    // Public API

  }, {
    key: 'queryObject',
    value: function queryObject(_ref) {
      var x = _ref.x,
          y = _ref.y,
          _ref$radius = _ref.radius,
          radius = _ref$radius === undefined ? 0 : _ref$radius,
          _ref$layerIds = _ref.layerIds,
          layerIds = _ref$layerIds === undefined ? null : _ref$layerIds;

      var selectedInfos = this.layerManager.pickObject({ x: x, y: y, radius: radius, layerIds: layerIds, mode: 'query' });
      return selectedInfos.length ? selectedInfos[0] : null;
    }
  }, {
    key: 'queryVisibleObjects',
    value: function queryVisibleObjects(_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          _ref2$width = _ref2.width,
          width = _ref2$width === undefined ? 1 : _ref2$width,
          _ref2$height = _ref2.height,
          height = _ref2$height === undefined ? 1 : _ref2$height,
          _ref2$layerIds = _ref2.layerIds,
          layerIds = _ref2$layerIds === undefined ? null : _ref2$layerIds;

      return this.layerManager.pickVisibleObjects({ x: x, y: y, width: width, height: height, layerIds: layerIds });
    }
  }, {
    key: 'getViewports',
    value: function getViewports() {
      return this.layerManager ? this.layerManager.getViewports() : [];
    }

    // Experimental

    // Gets actual viewport from a viewport "descriptor" object: viewport || {viewport: ..., ...}

  }, {
    key: '_getViewportFromDescriptor',
    value: function _getViewportFromDescriptor(viewportOrDescriptor) {
      return this.layerManager._getViewportFromDescriptor(viewportOrDescriptor);
    }

    // Private Methods

  }, {
    key: '_createCanvas',
    value: function _createCanvas(props) {
      if (props.canvas) {
        return props.canvas;
      }

      var id = props.id,
          width = props.width,
          height = props.height,
          style = props.style;

      var canvas = document.createElement('canvas');
      canvas.id = id;
      canvas.width = width;
      canvas.height = height;
      canvas.style = style;

      var parent = props.parent || document.body;
      parent.appendChild(canvas);

      return canvas;
    }

    // Callbacks

  }, {
    key: '_onRendererInitialized',
    value: function _onRendererInitialized(_ref3) {
      var gl = _ref3.gl,
          canvas = _ref3.canvas;

      (0, _luma.setParameters)(gl, {
        blend: true,
        blendFunc: [_luma.GL.SRC_ALPHA, _luma.GL.ONE_MINUS_SRC_ALPHA],
        polygonOffsetFill: true
      });

      // TODO - these should be set by default starting from next major release
      if (this.props.initWebGLParameters) {
        (0, _luma.setParameters)(gl, {
          depthTest: true,
          depthFunc: _luma.GL.LEQUAL
        });
      }

      this.props.onWebGLInitialized(gl);

      // Note: avoid React setState due GL animation loop / setState timing issue
      this.layerManager = new _layerManager2.default({ gl: gl });
      this.layerManager.initEventHandling(new _mjolnir.EventManager(canvas));
      this.effectManager = new _effectManager2.default({ gl: gl, layerManager: this.layerManager });

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.props.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var effect = _step.value;

          this.effectManager.addEffect(effect);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.setProps(this.props);
    }
  }, {
    key: '_onRenderFrame',
    value: function _onRenderFrame(_ref4) {
      var gl = _ref4.gl;

      var redraw = this.layerManager.needsRedraw({ clearRedrawFlags: true });
      if (!redraw) {
        return;
      }

      this.props.onBeforeRender({ gl: gl }); // TODO - should be called by AnimationLoop
      this.layerManager.drawLayers({
        pass: 'render to screen',
        // Helps debug layer picking, especially in framebuffer powered layers
        drawPickingColors: this.props.drawPickingColors
      });
      this.props.onAfterRender({ gl: gl }); // TODO - should be called by AnimationLoop
    }
  }]);

  return DeckGLJS;
}();

exports.default = DeckGLJS;


DeckGLJS.propTypes = propTypes;
DeckGLJS.defaultProps = defaultProps;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb3JlL3B1cmUtanMvZGVjay5qcyJdLCJuYW1lcyI6WyJub29wIiwicHJvcFR5cGVzIiwiaWQiLCJzdHJpbmciLCJ3aWR0aCIsIm51bWJlciIsImlzUmVxdWlyZWQiLCJoZWlnaHQiLCJsYXllcnMiLCJhcnJheSIsInZpZXdwb3J0cyIsImVmZmVjdHMiLCJhcnJheU9mIiwiaW5zdGFuY2VPZiIsImdsT3B0aW9ucyIsIm9iamVjdCIsImdsIiwicGlja2luZ1JhZGl1cyIsImluaXRXZWJHTFBhcmFtZXRlcnMiLCJib29sIiwib25XZWJHTEluaXRpYWxpemVkIiwiZnVuYyIsIm9uQmVmb3JlUmVuZGVyIiwib25BZnRlclJlbmRlciIsIm9uTGF5ZXJDbGljayIsIm9uTGF5ZXJIb3ZlciIsInVzZURldmljZVBpeGVsUmF0aW8iLCJkZWJ1ZyIsImRyYXdQaWNraW5nQ29sb3JzIiwiZGVmYXVsdFByb3BzIiwiRGVja0dMSlMiLCJwcm9wcyIsIk9iamVjdCIsImFzc2lnbiIsInN0YXRlIiwibmVlZHNSZWRyYXciLCJsYXllck1hbmFnZXIiLCJlZmZlY3RNYW5hZ2VyIiwiX29uUmVuZGVyZXJJbml0aWFsaXplZCIsImJpbmQiLCJfb25SZW5kZXJGcmFtZSIsImNhbnZhcyIsIl9jcmVhdGVDYW52YXMiLCJhbmltYXRpb25Mb29wIiwib25DcmVhdGVDb250ZXh0Iiwib25Jbml0aWFsaXplIiwib25SZW5kZXIiLCJzdGFydCIsInNldFByb3BzIiwic2V0UGFyYW1ldGVycyIsInNldEV2ZW50SGFuZGxpbmdQYXJhbWV0ZXJzIiwidmlld3BvcnQiLCJsYXRpdHVkZSIsImxvbmdpdHVkZSIsInpvb20iLCJwaXRjaCIsImJlYXJpbmciLCJzZXRWaWV3cG9ydHMiLCJ1cGRhdGVMYXllcnMiLCJuZXdMYXllcnMiLCJzdG9wIiwiZmluYWxpemUiLCJ4IiwieSIsInJhZGl1cyIsImxheWVySWRzIiwic2VsZWN0ZWRJbmZvcyIsInBpY2tPYmplY3QiLCJtb2RlIiwibGVuZ3RoIiwicGlja1Zpc2libGVPYmplY3RzIiwiZ2V0Vmlld3BvcnRzIiwidmlld3BvcnRPckRlc2NyaXB0b3IiLCJfZ2V0Vmlld3BvcnRGcm9tRGVzY3JpcHRvciIsInN0eWxlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwicGFyZW50IiwiYm9keSIsImFwcGVuZENoaWxkIiwiYmxlbmQiLCJibGVuZEZ1bmMiLCJTUkNfQUxQSEEiLCJPTkVfTUlOVVNfU1JDX0FMUEhBIiwicG9seWdvbk9mZnNldEZpbGwiLCJkZXB0aFRlc3QiLCJkZXB0aEZ1bmMiLCJMRVFVQUwiLCJpbml0RXZlbnRIYW5kbGluZyIsImVmZmVjdCIsImFkZEVmZmVjdCIsInJlZHJhdyIsImNsZWFyUmVkcmF3RmxhZ3MiLCJkcmF3TGF5ZXJzIiwicGFzcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O3FqQkFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOztBQUNBOztBQUVBOzs7Ozs7OztBQUVBOztBQUVBLFNBQVNBLElBQVQsR0FBZ0IsQ0FBRTs7QUFFbEIsSUFBTUMsWUFBWTtBQUNoQkMsTUFBSSxvQkFBVUMsTUFERTtBQUVoQkMsU0FBTyxvQkFBVUMsTUFBVixDQUFpQkMsVUFGUjtBQUdoQkMsVUFBUSxvQkFBVUYsTUFBVixDQUFpQkMsVUFIVDtBQUloQkUsVUFBUSxvQkFBVUMsS0FBVixDQUFnQkgsVUFKUixFQUlvQjtBQUNwQ0ksYUFBVyxvQkFBVUQsS0FMTCxFQUtZO0FBQzVCRSxXQUFTLG9CQUFVQyxPQUFWLENBQWtCLG9CQUFVQyxVQUFWLGtCQUFsQixDQU5PO0FBT2hCQyxhQUFXLG9CQUFVQyxNQVBMO0FBUWhCQyxNQUFJLG9CQUFVRCxNQVJFO0FBU2hCRSxpQkFBZSxvQkFBVVosTUFUVDtBQVVoQmEsdUJBQXFCLG9CQUFVQyxJQVZmO0FBV2hCQyxzQkFBb0Isb0JBQVVDLElBWGQ7QUFZaEJDLGtCQUFnQixvQkFBVUQsSUFaVjtBQWFoQkUsaUJBQWUsb0JBQVVGLElBYlQ7QUFjaEJHLGdCQUFjLG9CQUFVSCxJQWRSO0FBZWhCSSxnQkFBYyxvQkFBVUosSUFmUjtBQWdCaEJLLHVCQUFxQixvQkFBVVAsSUFoQmY7O0FBa0JoQjtBQUNBUSxTQUFPLG9CQUFVUixJQW5CRDtBQW9CaEJTLHFCQUFtQixvQkFBVVQ7QUFwQmIsQ0FBbEI7O0FBdUJBLElBQU1VLGVBQWU7QUFDbkIzQixNQUFJLGdCQURlO0FBRW5CZSxpQkFBZSxDQUZJO0FBR25CSCxhQUFXLEVBSFE7QUFJbkJFLE1BQUksSUFKZTtBQUtuQkwsV0FBUyxFQUxVO0FBTW5CTyx1QkFBcUIsS0FORixFQU1TO0FBQzVCRSxzQkFBb0JwQixJQVBEO0FBUW5Cc0Isa0JBQWdCdEIsSUFSRztBQVNuQnVCLGlCQUFldkIsSUFUSTtBQVVuQndCLGdCQUFjLElBVks7QUFXbkJDLGdCQUFjLElBWEs7QUFZbkJDLHVCQUFxQixLQVpGOztBQWNuQkMsU0FBTyxLQWRZO0FBZW5CQyxxQkFBbUI7QUFmQSxDQUFyQjs7QUFrQkE7O0lBQ3FCRSxRO0FBRW5CLG9CQUFZQyxLQUFaLEVBQW1CO0FBQUE7O0FBQUE7O0FBQ2pCQSxZQUFRQyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQkosWUFBbEIsRUFBZ0NFLEtBQWhDLENBQVI7O0FBRUEsU0FBS0csS0FBTCxHQUFhLEVBQWI7QUFDQSxTQUFLQyxXQUFMLEdBQW1CLElBQW5CO0FBQ0EsU0FBS0MsWUFBTCxHQUFvQixJQUFwQjtBQUNBLFNBQUtDLGFBQUwsR0FBcUIsSUFBckI7QUFDQSxTQUFLM0IsU0FBTCxHQUFpQixFQUFqQjs7QUFFQTtBQUNBLFNBQUs0QixzQkFBTCxHQUE4QixLQUFLQSxzQkFBTCxDQUE0QkMsSUFBNUIsQ0FBaUMsSUFBakMsQ0FBOUI7QUFDQSxTQUFLQyxjQUFMLEdBQXNCLEtBQUtBLGNBQUwsQ0FBb0JELElBQXBCLENBQXlCLElBQXpCLENBQXRCOztBQUVBLFNBQUtFLE1BQUwsR0FBYyxLQUFLQyxhQUFMLENBQW1CWCxLQUFuQixDQUFkOztBQWJpQixpQkFlNkJBLEtBZjdCO0FBQUEsUUFlVjNCLEtBZlUsVUFlVkEsS0FmVTtBQUFBLFFBZUhHLE1BZkcsVUFlSEEsTUFmRztBQUFBLFFBZUtTLEVBZkwsVUFlS0EsRUFmTDtBQUFBLFFBZVNGLFNBZlQsVUFlU0EsU0FmVDtBQUFBLFFBZW9CYSxLQWZwQixVQWVvQkEsS0FmcEI7OztBQWlCakIsU0FBS2dCLGFBQUwsR0FBcUIsd0JBQWtCO0FBQ3JDdkMsa0JBRHFDO0FBRXJDRyxvQkFGcUM7QUFHckNtQiwyQkFBcUIsS0FIZ0I7QUFJckNrQix1QkFBaUI7QUFBQSxlQUNmNUIsTUFBTSwyQkFBZ0JnQixPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQm5CLFNBQWxCLEVBQTZCLEVBQUMyQixRQUFRLE1BQUtBLE1BQWQsRUFBc0JkLFlBQXRCLEVBQTdCLENBQWhCLENBRFM7QUFBQSxPQUpvQjtBQU1yQ2tCLG9CQUFjLEtBQUtQLHNCQU5rQjtBQU9yQ1EsZ0JBQVUsS0FBS04sY0FQc0I7QUFRckNsQixzQkFBZ0JTLE1BQU1ULGNBUmU7QUFTckNDLHFCQUFlUSxNQUFNUjtBQVRnQixLQUFsQixDQUFyQjs7QUFZQSxTQUFLb0IsYUFBTCxDQUFtQkksS0FBbkI7O0FBRUEsU0FBS0MsUUFBTCxDQUFjakIsS0FBZDtBQUNEOzs7OzZCQUVRQSxLLEVBQU87QUFDZEEsY0FBUUMsT0FBT0MsTUFBUCxDQUFjLEVBQWQsRUFBa0IsS0FBS0YsS0FBdkIsRUFBOEJBLEtBQTlCLENBQVI7QUFDQSxXQUFLQSxLQUFMLEdBQWFBLEtBQWI7O0FBRUEsVUFBSSxDQUFDLEtBQUtLLFlBQVYsRUFBd0I7QUFDdEI7QUFDRDs7QUFOYSxvQkFjVkwsS0FkVTtBQUFBLFVBU1pkLGFBVFksV0FTWkEsYUFUWTtBQUFBLFVBVVpPLFlBVlksV0FVWkEsWUFWWTtBQUFBLFVBV1pDLFlBWFksV0FXWkEsWUFYWTtBQUFBLFVBWVpDLG1CQVpZLFdBWVpBLG1CQVpZO0FBQUEsVUFhWkUsaUJBYlksV0FhWkEsaUJBYlk7O0FBZ0JkOztBQUNBLFdBQUtRLFlBQUwsQ0FBa0JhLGFBQWxCLENBQWdDO0FBQzlCdkIsZ0RBRDhCO0FBRTlCRTtBQUY4QixPQUFoQzs7QUFLQSxXQUFLUSxZQUFMLENBQWtCYywwQkFBbEIsQ0FBNkM7QUFDM0NqQyxvQ0FEMkM7QUFFM0NPLGtDQUYyQztBQUczQ0M7QUFIMkMsT0FBN0M7O0FBTUE7QUFDQSxVQUFJZixZQUFZcUIsTUFBTXJCLFNBQU4sSUFBbUJxQixNQUFNb0IsUUFBekM7QUFDQSxVQUFJLENBQUN6QyxTQUFMLEVBQWdCO0FBQUEsc0JBQ3FEcUIsS0FEckQ7QUFBQSxZQUNQM0IsS0FETyxXQUNQQSxLQURPO0FBQUEsWUFDQUcsTUFEQSxXQUNBQSxNQURBO0FBQUEsWUFDUTZDLFFBRFIsV0FDUUEsUUFEUjtBQUFBLFlBQ2tCQyxTQURsQixXQUNrQkEsU0FEbEI7QUFBQSxZQUM2QkMsSUFEN0IsV0FDNkJBLElBRDdCO0FBQUEsWUFDbUNDLEtBRG5DLFdBQ21DQSxLQURuQztBQUFBLFlBQzBDQyxPQUQxQyxXQUMwQ0EsT0FEMUM7O0FBRWQ5QyxvQkFBWSxDQUNWLGtDQUF3QixFQUFDTixZQUFELEVBQVFHLGNBQVIsRUFBZ0I2QyxrQkFBaEIsRUFBMEJDLG9CQUExQixFQUFxQ0MsVUFBckMsRUFBMkNDLFlBQTNDLEVBQWtEQyxnQkFBbEQsRUFBeEIsQ0FEVSxDQUFaO0FBR0Q7QUFDRCxXQUFLcEIsWUFBTCxDQUFrQnFCLFlBQWxCLENBQStCL0MsU0FBL0I7O0FBRUE7QUFDQSxVQUFJcUIsTUFBTXZCLE1BQVYsRUFBa0I7QUFDaEIsYUFBSzRCLFlBQUwsQ0FBa0JzQixZQUFsQixDQUErQixFQUFDQyxXQUFXNUIsTUFBTXZCLE1BQWxCLEVBQS9CO0FBQ0Q7QUFDRjs7OytCQUVVO0FBQ1QsV0FBS21DLGFBQUwsQ0FBbUJpQixJQUFuQjtBQUNBLFdBQUtqQixhQUFMLEdBQXFCLElBQXJCOztBQUVBLFVBQUksS0FBS1AsWUFBVCxFQUF1QjtBQUNyQixhQUFLQSxZQUFMLENBQWtCeUIsUUFBbEI7QUFDQSxhQUFLekIsWUFBTCxHQUFvQixJQUFwQjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7c0NBRWlEO0FBQUEsVUFBcEMwQixDQUFvQyxRQUFwQ0EsQ0FBb0M7QUFBQSxVQUFqQ0MsQ0FBaUMsUUFBakNBLENBQWlDO0FBQUEsNkJBQTlCQyxNQUE4QjtBQUFBLFVBQTlCQSxNQUE4QiwrQkFBckIsQ0FBcUI7QUFBQSwrQkFBbEJDLFFBQWtCO0FBQUEsVUFBbEJBLFFBQWtCLGlDQUFQLElBQU87O0FBQy9DLFVBQU1DLGdCQUFnQixLQUFLOUIsWUFBTCxDQUFrQitCLFVBQWxCLENBQTZCLEVBQUNMLElBQUQsRUFBSUMsSUFBSixFQUFPQyxjQUFQLEVBQWVDLGtCQUFmLEVBQXlCRyxNQUFNLE9BQS9CLEVBQTdCLENBQXRCO0FBQ0EsYUFBT0YsY0FBY0csTUFBZCxHQUF1QkgsY0FBYyxDQUFkLENBQXZCLEdBQTBDLElBQWpEO0FBQ0Q7OzsrQ0FFbUU7QUFBQSxVQUEvQ0osQ0FBK0MsU0FBL0NBLENBQStDO0FBQUEsVUFBNUNDLENBQTRDLFNBQTVDQSxDQUE0QztBQUFBLDhCQUF6QzNELEtBQXlDO0FBQUEsVUFBekNBLEtBQXlDLCtCQUFqQyxDQUFpQztBQUFBLCtCQUE5QkcsTUFBOEI7QUFBQSxVQUE5QkEsTUFBOEIsZ0NBQXJCLENBQXFCO0FBQUEsaUNBQWxCMEQsUUFBa0I7QUFBQSxVQUFsQkEsUUFBa0Isa0NBQVAsSUFBTzs7QUFDbEUsYUFBTyxLQUFLN0IsWUFBTCxDQUFrQmtDLGtCQUFsQixDQUFxQyxFQUFDUixJQUFELEVBQUlDLElBQUosRUFBTzNELFlBQVAsRUFBY0csY0FBZCxFQUFzQjBELGtCQUF0QixFQUFyQyxDQUFQO0FBQ0Q7OzttQ0FFYztBQUNiLGFBQU8sS0FBSzdCLFlBQUwsR0FBb0IsS0FBS0EsWUFBTCxDQUFrQm1DLFlBQWxCLEVBQXBCLEdBQXVELEVBQTlEO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7K0NBQzJCQyxvQixFQUFzQjtBQUMvQyxhQUFPLEtBQUtwQyxZQUFMLENBQWtCcUMsMEJBQWxCLENBQTZDRCxvQkFBN0MsQ0FBUDtBQUNEOztBQUVEOzs7O2tDQUVjekMsSyxFQUFPO0FBQ25CLFVBQUlBLE1BQU1VLE1BQVYsRUFBa0I7QUFDaEIsZUFBT1YsTUFBTVUsTUFBYjtBQUNEOztBQUhrQixVQUtadkMsRUFMWSxHQUtnQjZCLEtBTGhCLENBS1o3QixFQUxZO0FBQUEsVUFLUkUsS0FMUSxHQUtnQjJCLEtBTGhCLENBS1IzQixLQUxRO0FBQUEsVUFLREcsTUFMQyxHQUtnQndCLEtBTGhCLENBS0R4QixNQUxDO0FBQUEsVUFLT21FLEtBTFAsR0FLZ0IzQyxLQUxoQixDQUtPMkMsS0FMUDs7QUFNbkIsVUFBTWpDLFNBQVNrQyxTQUFTQyxhQUFULENBQXVCLFFBQXZCLENBQWY7QUFDQW5DLGFBQU92QyxFQUFQLEdBQVlBLEVBQVo7QUFDQXVDLGFBQU9yQyxLQUFQLEdBQWVBLEtBQWY7QUFDQXFDLGFBQU9sQyxNQUFQLEdBQWdCQSxNQUFoQjtBQUNBa0MsYUFBT2lDLEtBQVAsR0FBZUEsS0FBZjs7QUFFQSxVQUFNRyxTQUFTOUMsTUFBTThDLE1BQU4sSUFBZ0JGLFNBQVNHLElBQXhDO0FBQ0FELGFBQU9FLFdBQVAsQ0FBbUJ0QyxNQUFuQjs7QUFFQSxhQUFPQSxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7a0RBRXFDO0FBQUEsVUFBYnpCLEVBQWEsU0FBYkEsRUFBYTtBQUFBLFVBQVR5QixNQUFTLFNBQVRBLE1BQVM7O0FBQ25DLCtCQUFjekIsRUFBZCxFQUFrQjtBQUNoQmdFLGVBQU8sSUFEUztBQUVoQkMsbUJBQVcsQ0FBQyxTQUFHQyxTQUFKLEVBQWUsU0FBR0MsbUJBQWxCLENBRks7QUFHaEJDLDJCQUFtQjtBQUhILE9BQWxCOztBQU1BO0FBQ0EsVUFBSSxLQUFLckQsS0FBTCxDQUFXYixtQkFBZixFQUFvQztBQUNsQyxpQ0FBY0YsRUFBZCxFQUFrQjtBQUNoQnFFLHFCQUFXLElBREs7QUFFaEJDLHFCQUFXLFNBQUdDO0FBRkUsU0FBbEI7QUFJRDs7QUFFRCxXQUFLeEQsS0FBTCxDQUFXWCxrQkFBWCxDQUE4QkosRUFBOUI7O0FBRUE7QUFDQSxXQUFLb0IsWUFBTCxHQUFvQiwyQkFBaUIsRUFBQ3BCLE1BQUQsRUFBakIsQ0FBcEI7QUFDQSxXQUFLb0IsWUFBTCxDQUFrQm9ELGlCQUFsQixDQUFvQywwQkFBaUIvQyxNQUFqQixDQUFwQztBQUNBLFdBQUtKLGFBQUwsR0FBcUIsNEJBQWtCLEVBQUNyQixNQUFELEVBQUtvQixjQUFjLEtBQUtBLFlBQXhCLEVBQWxCLENBQXJCOztBQXBCbUM7QUFBQTtBQUFBOztBQUFBO0FBc0JuQyw2QkFBcUIsS0FBS0wsS0FBTCxDQUFXcEIsT0FBaEMsOEhBQXlDO0FBQUEsY0FBOUI4RSxNQUE4Qjs7QUFDdkMsZUFBS3BELGFBQUwsQ0FBbUJxRCxTQUFuQixDQUE2QkQsTUFBN0I7QUFDRDtBQXhCa0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUEwQm5DLFdBQUt6QyxRQUFMLENBQWMsS0FBS2pCLEtBQW5CO0FBQ0Q7OzswQ0FFb0I7QUFBQSxVQUFMZixFQUFLLFNBQUxBLEVBQUs7O0FBQ25CLFVBQU0yRSxTQUFTLEtBQUt2RCxZQUFMLENBQWtCRCxXQUFsQixDQUE4QixFQUFDeUQsa0JBQWtCLElBQW5CLEVBQTlCLENBQWY7QUFDQSxVQUFJLENBQUNELE1BQUwsRUFBYTtBQUNYO0FBQ0Q7O0FBRUQsV0FBSzVELEtBQUwsQ0FBV1QsY0FBWCxDQUEwQixFQUFDTixNQUFELEVBQTFCLEVBTm1CLENBTWM7QUFDakMsV0FBS29CLFlBQUwsQ0FBa0J5RCxVQUFsQixDQUE2QjtBQUMzQkMsY0FBTSxrQkFEcUI7QUFFM0I7QUFDQWxFLDJCQUFtQixLQUFLRyxLQUFMLENBQVdIO0FBSEgsT0FBN0I7QUFLQSxXQUFLRyxLQUFMLENBQVdSLGFBQVgsQ0FBeUIsRUFBQ1AsTUFBRCxFQUF6QixFQVptQixDQVlhO0FBQ2pDOzs7Ozs7a0JBaExrQmMsUTs7O0FBbUxyQkEsU0FBUzdCLFNBQVQsR0FBcUJBLFNBQXJCO0FBQ0E2QixTQUFTRCxZQUFULEdBQXdCQSxZQUF4QiIsImZpbGUiOiJkZWNrLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE1IC0gMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBMYXllck1hbmFnZXIgZnJvbSAnLi4vbGliL2xheWVyLW1hbmFnZXInO1xuaW1wb3J0IEVmZmVjdE1hbmFnZXIgZnJvbSAnLi4vZXhwZXJpbWVudGFsL2xpYi9lZmZlY3QtbWFuYWdlcic7XG5pbXBvcnQgRWZmZWN0IGZyb20gJy4uL2V4cGVyaW1lbnRhbC9saWIvZWZmZWN0JztcbmltcG9ydCBXZWJNZXJjYXRvclZpZXdwb3J0IGZyb20gJy4uL3ZpZXdwb3J0cy93ZWItbWVyY2F0b3Itdmlld3BvcnQnO1xuXG5pbXBvcnQge0V2ZW50TWFuYWdlcn0gZnJvbSAnbWpvbG5pci5qcyc7XG5pbXBvcnQge0dMLCBBbmltYXRpb25Mb29wLCBjcmVhdGVHTENvbnRleHQsIHNldFBhcmFtZXRlcnN9IGZyb20gJ2x1bWEuZ2wnO1xuXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKiBnbG9iYWwgZG9jdW1lbnQgKi9cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmNvbnN0IHByb3BUeXBlcyA9IHtcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICBsYXllcnM6IFByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkLCAvLyBBcnJheSBjYW4gY29udGFpbiBmYWxzeSB2YWx1ZXNcbiAgdmlld3BvcnRzOiBQcm9wVHlwZXMuYXJyYXksIC8vIEFycmF5IGNhbiBjb250YWluIGZhbHN5IHZhbHVlc1xuICBlZmZlY3RzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuaW5zdGFuY2VPZihFZmZlY3QpKSxcbiAgZ2xPcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0LFxuICBnbDogUHJvcFR5cGVzLm9iamVjdCxcbiAgcGlja2luZ1JhZGl1czogUHJvcFR5cGVzLm51bWJlcixcbiAgaW5pdFdlYkdMUGFyYW1ldGVyczogUHJvcFR5cGVzLmJvb2wsXG4gIG9uV2ViR0xJbml0aWFsaXplZDogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uQmVmb3JlUmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25BZnRlclJlbmRlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTGF5ZXJDbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIG9uTGF5ZXJIb3ZlcjogUHJvcFR5cGVzLmZ1bmMsXG4gIHVzZURldmljZVBpeGVsUmF0aW86IFByb3BUeXBlcy5ib29sLFxuXG4gIC8vIERlYnVnIHNldHRpbmdzXG4gIGRlYnVnOiBQcm9wVHlwZXMuYm9vbCxcbiAgZHJhd1BpY2tpbmdDb2xvcnM6IFByb3BUeXBlcy5ib29sXG59O1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XG4gIGlkOiAnZGVja2dsLW92ZXJsYXknLFxuICBwaWNraW5nUmFkaXVzOiAwLFxuICBnbE9wdGlvbnM6IHt9LFxuICBnbDogbnVsbCxcbiAgZWZmZWN0czogW10sXG4gIGluaXRXZWJHTFBhcmFtZXRlcnM6IGZhbHNlLCAvLyBXaWxsIGJlIHNldCB0byB0cnVlIGluIG5leHQgbWFqb3IgcmVsZWFzZVxuICBvbldlYkdMSW5pdGlhbGl6ZWQ6IG5vb3AsXG4gIG9uQmVmb3JlUmVuZGVyOiBub29wLFxuICBvbkFmdGVyUmVuZGVyOiBub29wLFxuICBvbkxheWVyQ2xpY2s6IG51bGwsXG4gIG9uTGF5ZXJIb3ZlcjogbnVsbCxcbiAgdXNlRGV2aWNlUGl4ZWxSYXRpbzogZmFsc2UsXG5cbiAgZGVidWc6IGZhbHNlLFxuICBkcmF3UGlja2luZ0NvbG9yczogZmFsc2Vcbn07XG5cbi8vIFRPRE8gLSBzaG91bGQgdGhpcyBjbGFzcyBiZSBqb2luZWQgd2l0aCBgTGF5ZXJNYW5hZ2VyYD9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlY2tHTEpTIHtcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFByb3BzLCBwcm9wcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgdGhpcy5sYXllck1hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMuZWZmZWN0TWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy52aWV3cG9ydHMgPSBbXTtcblxuICAgIC8vIEJpbmQgbWV0aG9kc1xuICAgIHRoaXMuX29uUmVuZGVyZXJJbml0aWFsaXplZCA9IHRoaXMuX29uUmVuZGVyZXJJbml0aWFsaXplZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uUmVuZGVyRnJhbWUgPSB0aGlzLl9vblJlbmRlckZyYW1lLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmNhbnZhcyA9IHRoaXMuX2NyZWF0ZUNhbnZhcyhwcm9wcyk7XG5cbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodCwgZ2wsIGdsT3B0aW9ucywgZGVidWd9ID0gcHJvcHM7XG5cbiAgICB0aGlzLmFuaW1hdGlvbkxvb3AgPSBuZXcgQW5pbWF0aW9uTG9vcCh7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHVzZURldmljZVBpeGVsUmF0aW86IGZhbHNlLFxuICAgICAgb25DcmVhdGVDb250ZXh0OiBvcHRzID0+XG4gICAgICAgIGdsIHx8IGNyZWF0ZUdMQ29udGV4dChPYmplY3QuYXNzaWduKHt9LCBnbE9wdGlvbnMsIHtjYW52YXM6IHRoaXMuY2FudmFzLCBkZWJ1Z30pKSxcbiAgICAgIG9uSW5pdGlhbGl6ZTogdGhpcy5fb25SZW5kZXJlckluaXRpYWxpemVkLFxuICAgICAgb25SZW5kZXI6IHRoaXMuX29uUmVuZGVyRnJhbWUsXG4gICAgICBvbkJlZm9yZVJlbmRlcjogcHJvcHMub25CZWZvcmVSZW5kZXIsXG4gICAgICBvbkFmdGVyUmVuZGVyOiBwcm9wcy5vbkFmdGVyUmVuZGVyXG4gICAgfSk7XG5cbiAgICB0aGlzLmFuaW1hdGlvbkxvb3Auc3RhcnQoKTtcblxuICAgIHRoaXMuc2V0UHJvcHMocHJvcHMpO1xuICB9XG5cbiAgc2V0UHJvcHMocHJvcHMpIHtcbiAgICBwcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHByb3BzKTtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG5cbiAgICBpZiAoIXRoaXMubGF5ZXJNYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgcGlja2luZ1JhZGl1cyxcbiAgICAgIG9uTGF5ZXJDbGljayxcbiAgICAgIG9uTGF5ZXJIb3ZlcixcbiAgICAgIHVzZURldmljZVBpeGVsUmF0aW8sXG4gICAgICBkcmF3UGlja2luZ0NvbG9yc1xuICAgIH0gPSBwcm9wcztcblxuICAgIC8vIElmIG1vcmUgcGFyYW1ldGVycyBuZWVkIHRvIGJlIHVwZGF0ZWQgb24gbGF5ZXJNYW5hZ2VyIGFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kLlxuICAgIHRoaXMubGF5ZXJNYW5hZ2VyLnNldFBhcmFtZXRlcnMoe1xuICAgICAgdXNlRGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgIGRyYXdQaWNraW5nQ29sb3JzXG4gICAgfSk7XG5cbiAgICB0aGlzLmxheWVyTWFuYWdlci5zZXRFdmVudEhhbmRsaW5nUGFyYW1ldGVycyh7XG4gICAgICBwaWNraW5nUmFkaXVzLFxuICAgICAgb25MYXllckNsaWNrLFxuICAgICAgb25MYXllckhvdmVyXG4gICAgfSk7XG5cbiAgICAvLyBVcGRhdGUgdmlld3BvcnRzIChjcmVhdGluZyBvbmUgaWYgbm90IHN1cHBsaWVkKVxuICAgIGxldCB2aWV3cG9ydHMgPSBwcm9wcy52aWV3cG9ydHMgfHwgcHJvcHMudmlld3BvcnQ7XG4gICAgaWYgKCF2aWV3cG9ydHMpIHtcbiAgICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBsYXRpdHVkZSwgbG9uZ2l0dWRlLCB6b29tLCBwaXRjaCwgYmVhcmluZ30gPSBwcm9wcztcbiAgICAgIHZpZXdwb3J0cyA9IFtcbiAgICAgICAgbmV3IFdlYk1lcmNhdG9yVmlld3BvcnQoe3dpZHRoLCBoZWlnaHQsIGxhdGl0dWRlLCBsb25naXR1ZGUsIHpvb20sIHBpdGNoLCBiZWFyaW5nfSlcbiAgICAgIF07XG4gICAgfVxuICAgIHRoaXMubGF5ZXJNYW5hZ2VyLnNldFZpZXdwb3J0cyh2aWV3cG9ydHMpO1xuXG4gICAgLy8gVE9ETyAtIHRoaXMgaXMgYSBIQUNLOiBVcGRhdGVMYXllcnMgbmVlZHMgb25lIHZpZXdwb3J0IHByb3Agc2V0IGVhY2ggdGltZVxuICAgIGlmIChwcm9wcy5sYXllcnMpIHtcbiAgICAgIHRoaXMubGF5ZXJNYW5hZ2VyLnVwZGF0ZUxheWVycyh7bmV3TGF5ZXJzOiBwcm9wcy5sYXllcnN9KTtcbiAgICB9XG4gIH1cblxuICBmaW5hbGl6ZSgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkxvb3Auc3RvcCgpO1xuICAgIHRoaXMuYW5pbWF0aW9uTG9vcCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5sYXllck1hbmFnZXIpIHtcbiAgICAgIHRoaXMubGF5ZXJNYW5hZ2VyLmZpbmFsaXplKCk7XG4gICAgICB0aGlzLmxheWVyTWFuYWdlciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gUHVibGljIEFQSVxuXG4gIHF1ZXJ5T2JqZWN0KHt4LCB5LCByYWRpdXMgPSAwLCBsYXllcklkcyA9IG51bGx9KSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRJbmZvcyA9IHRoaXMubGF5ZXJNYW5hZ2VyLnBpY2tPYmplY3Qoe3gsIHksIHJhZGl1cywgbGF5ZXJJZHMsIG1vZGU6ICdxdWVyeSd9KTtcbiAgICByZXR1cm4gc2VsZWN0ZWRJbmZvcy5sZW5ndGggPyBzZWxlY3RlZEluZm9zWzBdIDogbnVsbDtcbiAgfVxuXG4gIHF1ZXJ5VmlzaWJsZU9iamVjdHMoe3gsIHksIHdpZHRoID0gMSwgaGVpZ2h0ID0gMSwgbGF5ZXJJZHMgPSBudWxsfSkge1xuICAgIHJldHVybiB0aGlzLmxheWVyTWFuYWdlci5waWNrVmlzaWJsZU9iamVjdHMoe3gsIHksIHdpZHRoLCBoZWlnaHQsIGxheWVySWRzfSk7XG4gIH1cblxuICBnZXRWaWV3cG9ydHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJNYW5hZ2VyID8gdGhpcy5sYXllck1hbmFnZXIuZ2V0Vmlld3BvcnRzKCkgOiBbXTtcbiAgfVxuXG4gIC8vIEV4cGVyaW1lbnRhbFxuXG4gIC8vIEdldHMgYWN0dWFsIHZpZXdwb3J0IGZyb20gYSB2aWV3cG9ydCBcImRlc2NyaXB0b3JcIiBvYmplY3Q6IHZpZXdwb3J0IHx8IHt2aWV3cG9ydDogLi4uLCAuLi59XG4gIF9nZXRWaWV3cG9ydEZyb21EZXNjcmlwdG9yKHZpZXdwb3J0T3JEZXNjcmlwdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJNYW5hZ2VyLl9nZXRWaWV3cG9ydEZyb21EZXNjcmlwdG9yKHZpZXdwb3J0T3JEZXNjcmlwdG9yKTtcbiAgfVxuXG4gIC8vIFByaXZhdGUgTWV0aG9kc1xuXG4gIF9jcmVhdGVDYW52YXMocHJvcHMpIHtcbiAgICBpZiAocHJvcHMuY2FudmFzKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2FudmFzO1xuICAgIH1cblxuICAgIGNvbnN0IHtpZCwgd2lkdGgsIGhlaWdodCwgc3R5bGV9ID0gcHJvcHM7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLmlkID0gaWQ7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICBjYW52YXMuc3R5bGUgPSBzdHlsZTtcblxuICAgIGNvbnN0IHBhcmVudCA9IHByb3BzLnBhcmVudCB8fCBkb2N1bWVudC5ib2R5O1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChjYW52YXMpO1xuXG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuXG4gIC8vIENhbGxiYWNrc1xuXG4gIF9vblJlbmRlcmVySW5pdGlhbGl6ZWQoe2dsLCBjYW52YXN9KSB7XG4gICAgc2V0UGFyYW1ldGVycyhnbCwge1xuICAgICAgYmxlbmQ6IHRydWUsXG4gICAgICBibGVuZEZ1bmM6IFtHTC5TUkNfQUxQSEEsIEdMLk9ORV9NSU5VU19TUkNfQUxQSEFdLFxuICAgICAgcG9seWdvbk9mZnNldEZpbGw6IHRydWVcbiAgICB9KTtcblxuICAgIC8vIFRPRE8gLSB0aGVzZSBzaG91bGQgYmUgc2V0IGJ5IGRlZmF1bHQgc3RhcnRpbmcgZnJvbSBuZXh0IG1ham9yIHJlbGVhc2VcbiAgICBpZiAodGhpcy5wcm9wcy5pbml0V2ViR0xQYXJhbWV0ZXJzKSB7XG4gICAgICBzZXRQYXJhbWV0ZXJzKGdsLCB7XG4gICAgICAgIGRlcHRoVGVzdDogdHJ1ZSxcbiAgICAgICAgZGVwdGhGdW5jOiBHTC5MRVFVQUxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMucHJvcHMub25XZWJHTEluaXRpYWxpemVkKGdsKTtcblxuICAgIC8vIE5vdGU6IGF2b2lkIFJlYWN0IHNldFN0YXRlIGR1ZSBHTCBhbmltYXRpb24gbG9vcCAvIHNldFN0YXRlIHRpbWluZyBpc3N1ZVxuICAgIHRoaXMubGF5ZXJNYW5hZ2VyID0gbmV3IExheWVyTWFuYWdlcih7Z2x9KTtcbiAgICB0aGlzLmxheWVyTWFuYWdlci5pbml0RXZlbnRIYW5kbGluZyhuZXcgRXZlbnRNYW5hZ2VyKGNhbnZhcykpO1xuICAgIHRoaXMuZWZmZWN0TWFuYWdlciA9IG5ldyBFZmZlY3RNYW5hZ2VyKHtnbCwgbGF5ZXJNYW5hZ2VyOiB0aGlzLmxheWVyTWFuYWdlcn0pO1xuXG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy5wcm9wcy5lZmZlY3RzKSB7XG4gICAgICB0aGlzLmVmZmVjdE1hbmFnZXIuYWRkRWZmZWN0KGVmZmVjdCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRQcm9wcyh0aGlzLnByb3BzKTtcbiAgfVxuXG4gIF9vblJlbmRlckZyYW1lKHtnbH0pIHtcbiAgICBjb25zdCByZWRyYXcgPSB0aGlzLmxheWVyTWFuYWdlci5uZWVkc1JlZHJhdyh7Y2xlYXJSZWRyYXdGbGFnczogdHJ1ZX0pO1xuICAgIGlmICghcmVkcmF3KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wcm9wcy5vbkJlZm9yZVJlbmRlcih7Z2x9KTsgLy8gVE9ETyAtIHNob3VsZCBiZSBjYWxsZWQgYnkgQW5pbWF0aW9uTG9vcFxuICAgIHRoaXMubGF5ZXJNYW5hZ2VyLmRyYXdMYXllcnMoe1xuICAgICAgcGFzczogJ3JlbmRlciB0byBzY3JlZW4nLFxuICAgICAgLy8gSGVscHMgZGVidWcgbGF5ZXIgcGlja2luZywgZXNwZWNpYWxseSBpbiBmcmFtZWJ1ZmZlciBwb3dlcmVkIGxheWVyc1xuICAgICAgZHJhd1BpY2tpbmdDb2xvcnM6IHRoaXMucHJvcHMuZHJhd1BpY2tpbmdDb2xvcnNcbiAgICB9KTtcbiAgICB0aGlzLnByb3BzLm9uQWZ0ZXJSZW5kZXIoe2dsfSk7IC8vIFRPRE8gLSBzaG91bGQgYmUgY2FsbGVkIGJ5IEFuaW1hdGlvbkxvb3BcbiAgfVxufVxuXG5EZWNrR0xKUy5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5EZWNrR0xKUy5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4iXX0=