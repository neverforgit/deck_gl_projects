'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _react = require('react');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _autobind = require('../utils/autobind');

var _autobind2 = _interopRequireDefault(_autobind);

var _staticMap = require('./static-map');

var _staticMap2 = _interopRequireDefault(_staticMap);

var _mapState = require('../utils/map-state');

var _viewportMercatorProject = require('viewport-mercator-project');

var _eventManager = require('../utils/event-manager/event-manager');

var _eventManager2 = _interopRequireDefault(_eventManager);

var _mapControls = require('../utils/map-controls');

var _mapControls2 = _interopRequireDefault(_mapControls);

var _config = require('../config');

var _config2 = _interopRequireDefault(_config);

var _deprecateWarn = require('../utils/deprecate-warn');

var _deprecateWarn2 = _interopRequireDefault(_deprecateWarn);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var propTypes = (0, _assign2.default)({}, _staticMap2.default.propTypes, {
  // Additional props on top of StaticMap

  /** Viewport constraints */
  // Max zoom level
  maxZoom: _propTypes2.default.number,
  // Min zoom level
  minZoom: _propTypes2.default.number,
  // Max pitch in degrees
  maxPitch: _propTypes2.default.number,
  // Min pitch in degrees
  minPitch: _propTypes2.default.number,

  /**
   * `onViewportChange` callback is fired when the user interacted with the
   * map. The object passed to the callback contains viewport properties
   * such as `longitude`, `latitude`, `zoom` etc.
   */
  onViewportChange: _propTypes2.default.func,

  /** Enables control event handling */
  // Scroll to zoom
  scrollZoom: _propTypes2.default.bool,
  // Drag to pan
  dragPan: _propTypes2.default.bool,
  // Drag to rotate
  dragRotate: _propTypes2.default.bool,
  // Double click to zoom
  doubleClickZoom: _propTypes2.default.bool,
  // Pinch to zoom / rotate
  touchZoomRotate: _propTypes2.default.bool,

  /**
     * Called when the map is hovered over.
     * @callback
     * @param {Object} event - The mouse event.
     * @param {[Number, Number]} event.lngLat - The coordinates of the pointer
     * @param {Array} event.features - The features under the pointer, using Mapbox's
     * queryRenderedFeatures API:
     * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures
     * To make a layer interactive, set the `interactive` property in the
     * layer style to `true`. See Mapbox's style spec
     * https://www.mapbox.com/mapbox-gl-style-spec/#layer-interactive
     */
  onHover: _propTypes2.default.func,
  /**
    * Called when the map is clicked.
    * @callback
    * @param {Object} event - The mouse event.
    * @param {[Number, Number]} event.lngLat - The coordinates of the pointer
    * @param {Array} event.features - The features under the pointer, using Mapbox's
    * queryRenderedFeatures API:
    * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures
    * To make a layer interactive, set the `interactive` property in the
    * layer style to `true`. See Mapbox's style spec
    * https://www.mapbox.com/mapbox-gl-style-spec/#layer-interactive
    */
  onClick: _propTypes2.default.func,

  /** Radius to detect features around a clicked point. Defaults to 0. */
  clickRadius: _propTypes2.default.number,

  /** Accessor that returns a cursor style to show interactive state */
  getCursor: _propTypes2.default.func,

  /** Advanced features */
  // Contraints for displaying the map. If not met, then the map is hidden.
  // Experimental! May be changed in minor version updates.
  visibilityConstraints: _propTypes2.default.shape({
    minZoom: _propTypes2.default.number,
    maxZoom: _propTypes2.default.number,
    minPitch: _propTypes2.default.number,
    maxPitch: _propTypes2.default.number
  }),
  // A map control instance to replace the default map controls
  // The object must expose one property: `events` as an array of subscribed
  // event names; and two methods: `setState(state)` and `handle(event)`
  mapControls: _propTypes2.default.shape({
    events: _propTypes2.default.arrayOf(_propTypes2.default.string),
    handleEvent: _propTypes2.default.func
  })
});

var getDefaultCursor = function getDefaultCursor(_ref) {
  var isDragging = _ref.isDragging,
      isHovering = _ref.isHovering;
  return isDragging ? _config2.default.CURSOR.GRABBING : isHovering ? _config2.default.CURSOR.POINTER : _config2.default.CURSOR.GRAB;
};

var defaultProps = (0, _assign2.default)({}, _staticMap2.default.defaultProps, _mapState.MAPBOX_LIMITS, {
  onViewportChange: null,
  onClick: null,
  onHover: null,

  scrollZoom: true,
  dragPan: true,
  dragRotate: true,
  doubleClickZoom: true,
  touchZoomRotate: true,

  clickRadius: 0,
  getCursor: getDefaultCursor,

  visibilityConstraints: _mapState.MAPBOX_LIMITS
});

var childContextTypes = {
  viewport: _propTypes2.default.instanceOf(_viewportMercatorProject.PerspectiveMercatorViewport),
  isDragging: _propTypes2.default.bool
};

var InteractiveMap = function (_PureComponent) {
  (0, _inherits3.default)(InteractiveMap, _PureComponent);
  (0, _createClass3.default)(InteractiveMap, null, [{
    key: 'supported',
    value: function supported() {
      return _staticMap2.default.supported();
    }
  }]);

  function InteractiveMap(props) {
    (0, _classCallCheck3.default)(this, InteractiveMap);

    var _this = (0, _possibleConstructorReturn3.default)(this, (InteractiveMap.__proto__ || (0, _getPrototypeOf2.default)(InteractiveMap)).call(this, props));

    (0, _autobind2.default)(_this);
    // Check for deprecated props
    (0, _deprecateWarn2.default)(props);

    _this.state = {
      // Whether the cursor is down
      isDragging: false,
      // Whether the cursor is over a clickable feature
      isHovering: false
    };

    // If props.mapControls is not provided, fallback to default MapControls instance
    // Cannot use defaultProps here because it needs to be per map instance
    _this._mapControls = props.mapControls || new _mapControls2.default();
    return _this;
  }

  (0, _createClass3.default)(InteractiveMap, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        viewport: new _viewportMercatorProject.PerspectiveMercatorViewport(this.props),
        isDragging: this.state.isDragging
      };
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var eventManager = new _eventManager2.default(this._eventCanvas);

      // Register additional event handlers for click and hover
      eventManager.on('mousemove', this._onMouseMove);
      eventManager.on('click', this._onMouseClick);
      this._eventManager = eventManager;

      this._mapControls.setOptions((0, _assign2.default)({}, this.props, {
        onStateChange: this._onInteractiveStateChange,
        eventManager: eventManager
      }));
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps) {
      this._mapControls.setOptions(nextProps);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this._eventManager) {
        // Must destroy because hammer adds event listeners to window
        this._eventManager.destroy();
      }
    }
  }, {
    key: 'getMap',
    value: function getMap() {
      return this._map.getMap();
    }
  }, {
    key: 'queryRenderedFeatures',
    value: function queryRenderedFeatures(geometry, options) {
      return this._map.queryRenderedFeatures(geometry, options);
    }

    // Checks a visibilityConstraints object to see if the map should be displayed

  }, {
    key: 'checkVisibilityConstraints',
    value: function checkVisibilityConstraints(props) {
      var capitalize = function capitalize(s) {
        return s[0].toUpperCase() + s.slice(1);
      };

      var visibilityConstraints = props.visibilityConstraints;

      for (var propName in props) {
        var capitalizedPropName = capitalize(propName);
        var minPropName = 'min' + capitalizedPropName;
        var maxPropName = 'max' + capitalizedPropName;

        if (minPropName in visibilityConstraints && props[propName] < visibilityConstraints[minPropName]) {
          return false;
        }
        if (maxPropName in visibilityConstraints && props[propName] > visibilityConstraints[maxPropName]) {
          return false;
        }
      }
      return true;
    }
  }, {
    key: '_getFeatures',
    value: function _getFeatures(_ref2) {
      var pos = _ref2.pos,
          radius = _ref2.radius;

      var features = void 0;
      if (radius) {
        // Radius enables point features, like marker symbols, to be clicked.
        var size = radius;
        var bbox = [[pos[0] - size, pos[1] + size], [pos[0] + size, pos[1] - size]];
        features = this._map.queryRenderedFeatures(bbox);
      } else {
        features = this._map.queryRenderedFeatures(pos);
      }
      return features;
    }
  }, {
    key: '_onInteractiveStateChange',
    value: function _onInteractiveStateChange(_ref3) {
      var _ref3$isDragging = _ref3.isDragging,
          isDragging = _ref3$isDragging === undefined ? false : _ref3$isDragging;

      if (isDragging !== this.state.isDragging) {
        this.setState({ isDragging: isDragging });
      }
    }

    // HOVER AND CLICK

  }, {
    key: '_getPos',
    value: function _getPos(event) {
      var _event$offsetCenter = event.offsetCenter,
          x = _event$offsetCenter.x,
          y = _event$offsetCenter.y;

      return [x, y];
    }
  }, {
    key: '_onMouseMove',
    value: function _onMouseMove(event) {
      if (!this.state.isDragging) {
        var pos = this._getPos(event);
        var features = this._getFeatures({ pos: pos, radius: this.props.clickRadius });

        var isHovering = features && features.length > 0;
        if (isHovering !== this.state.isHovering) {
          this.setState({ isHovering: isHovering });
        }

        if (this.props.onHover) {
          var viewport = new _viewportMercatorProject.PerspectiveMercatorViewport(this.props);
          event.lngLat = viewport.unproject(pos);
          event.features = features;

          this.props.onHover(event);
        }
      }
    }
  }, {
    key: '_onMouseClick',
    value: function _onMouseClick(event) {
      if (this.props.onClick) {
        var pos = this._getPos(event);
        var viewport = new _viewportMercatorProject.PerspectiveMercatorViewport(this.props);
        event.lngLat = viewport.unproject(pos);
        event.features = this._getFeatures({ pos: pos, radius: this.props.clickRadius });

        this.props.onClick(event);
      }
    }
  }, {
    key: '_eventCanvasLoaded',
    value: function _eventCanvasLoaded(ref) {
      this._eventCanvas = ref;
    }
  }, {
    key: '_staticMapLoaded',
    value: function _staticMapLoaded(ref) {
      this._map = ref;
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          width = _props.width,
          height = _props.height,
          getCursor = _props.getCursor;


      var eventCanvasStyle = {
        width: width,
        height: height,
        position: 'relative',
        cursor: getCursor(this.state)
      };

      return (0, _react.createElement)('div', {
        key: 'map-controls',
        ref: this._eventCanvasLoaded,
        style: eventCanvasStyle
      }, (0, _react.createElement)(_staticMap2.default, (0, _assign2.default)({}, this.props, {
        visible: this.checkVisibilityConstraints(this.props),
        ref: this._staticMapLoaded
      })));
    }
  }]);
  return InteractiveMap;
}(_react.PureComponent);

exports.default = InteractiveMap;


InteractiveMap.displayName = 'InteractiveMap';
InteractiveMap.propTypes = propTypes;
InteractiveMap.defaultProps = defaultProps;
InteractiveMap.childContextTypes = childContextTypes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21wb25lbnRzL2ludGVyYWN0aXZlLW1hcC5qcyJdLCJuYW1lcyI6WyJwcm9wVHlwZXMiLCJtYXhab29tIiwibnVtYmVyIiwibWluWm9vbSIsIm1heFBpdGNoIiwibWluUGl0Y2giLCJvblZpZXdwb3J0Q2hhbmdlIiwiZnVuYyIsInNjcm9sbFpvb20iLCJib29sIiwiZHJhZ1BhbiIsImRyYWdSb3RhdGUiLCJkb3VibGVDbGlja1pvb20iLCJ0b3VjaFpvb21Sb3RhdGUiLCJvbkhvdmVyIiwib25DbGljayIsImNsaWNrUmFkaXVzIiwiZ2V0Q3Vyc29yIiwidmlzaWJpbGl0eUNvbnN0cmFpbnRzIiwic2hhcGUiLCJtYXBDb250cm9scyIsImV2ZW50cyIsImFycmF5T2YiLCJzdHJpbmciLCJoYW5kbGVFdmVudCIsImdldERlZmF1bHRDdXJzb3IiLCJpc0RyYWdnaW5nIiwiaXNIb3ZlcmluZyIsIkNVUlNPUiIsIkdSQUJCSU5HIiwiUE9JTlRFUiIsIkdSQUIiLCJkZWZhdWx0UHJvcHMiLCJjaGlsZENvbnRleHRUeXBlcyIsInZpZXdwb3J0IiwiaW5zdGFuY2VPZiIsIkludGVyYWN0aXZlTWFwIiwic3VwcG9ydGVkIiwicHJvcHMiLCJzdGF0ZSIsIl9tYXBDb250cm9scyIsImV2ZW50TWFuYWdlciIsIl9ldmVudENhbnZhcyIsIm9uIiwiX29uTW91c2VNb3ZlIiwiX29uTW91c2VDbGljayIsIl9ldmVudE1hbmFnZXIiLCJzZXRPcHRpb25zIiwib25TdGF0ZUNoYW5nZSIsIl9vbkludGVyYWN0aXZlU3RhdGVDaGFuZ2UiLCJuZXh0UHJvcHMiLCJkZXN0cm95IiwiX21hcCIsImdldE1hcCIsImdlb21ldHJ5Iiwib3B0aW9ucyIsInF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyIsImNhcGl0YWxpemUiLCJzIiwidG9VcHBlckNhc2UiLCJzbGljZSIsInByb3BOYW1lIiwiY2FwaXRhbGl6ZWRQcm9wTmFtZSIsIm1pblByb3BOYW1lIiwibWF4UHJvcE5hbWUiLCJwb3MiLCJyYWRpdXMiLCJmZWF0dXJlcyIsInNpemUiLCJiYm94Iiwic2V0U3RhdGUiLCJldmVudCIsIm9mZnNldENlbnRlciIsIngiLCJ5IiwiX2dldFBvcyIsIl9nZXRGZWF0dXJlcyIsImxlbmd0aCIsImxuZ0xhdCIsInVucHJvamVjdCIsInJlZiIsIndpZHRoIiwiaGVpZ2h0IiwiZXZlbnRDYW52YXNTdHlsZSIsInBvc2l0aW9uIiwiY3Vyc29yIiwia2V5IiwiX2V2ZW50Q2FudmFzTG9hZGVkIiwic3R5bGUiLCJ2aXNpYmxlIiwiY2hlY2tWaXNpYmlsaXR5Q29uc3RyYWludHMiLCJfc3RhdGljTWFwTG9hZGVkIiwiZGlzcGxheU5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOztBQUNBOztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFNQSxZQUFZLHNCQUFjLEVBQWQsRUFBa0Isb0JBQVVBLFNBQTVCLEVBQXVDO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQUMsV0FBUyxvQkFBVUMsTUFMb0M7QUFNdkQ7QUFDQUMsV0FBUyxvQkFBVUQsTUFQb0M7QUFRdkQ7QUFDQUUsWUFBVSxvQkFBVUYsTUFUbUM7QUFVdkQ7QUFDQUcsWUFBVSxvQkFBVUgsTUFYbUM7O0FBYXZEOzs7OztBQUtBSSxvQkFBa0Isb0JBQVVDLElBbEIyQjs7QUFvQnZEO0FBQ0E7QUFDQUMsY0FBWSxvQkFBVUMsSUF0QmlDO0FBdUJ2RDtBQUNBQyxXQUFTLG9CQUFVRCxJQXhCb0M7QUF5QnZEO0FBQ0FFLGNBQVksb0JBQVVGLElBMUJpQztBQTJCdkQ7QUFDQUcsbUJBQWlCLG9CQUFVSCxJQTVCNEI7QUE2QnZEO0FBQ0FJLG1CQUFpQixvQkFBVUosSUE5QjRCOztBQWdDeEQ7Ozs7Ozs7Ozs7OztBQVlDSyxXQUFTLG9CQUFVUCxJQTVDb0M7QUE2Q3ZEOzs7Ozs7Ozs7Ozs7QUFZQVEsV0FBUyxvQkFBVVIsSUF6RG9DOztBQTJEdkQ7QUFDQVMsZUFBYSxvQkFBVWQsTUE1RGdDOztBQThEdkQ7QUFDQWUsYUFBVyxvQkFBVVYsSUEvRGtDOztBQWlFdkQ7QUFDQTtBQUNBO0FBQ0FXLHlCQUF1QixvQkFBVUMsS0FBVixDQUFnQjtBQUNyQ2hCLGFBQVMsb0JBQVVELE1BRGtCO0FBRXJDRCxhQUFTLG9CQUFVQyxNQUZrQjtBQUdyQ0csY0FBVSxvQkFBVUgsTUFIaUI7QUFJckNFLGNBQVUsb0JBQVVGO0FBSmlCLEdBQWhCLENBcEVnQztBQTBFdkQ7QUFDQTtBQUNBO0FBQ0FrQixlQUFhLG9CQUFVRCxLQUFWLENBQWdCO0FBQzNCRSxZQUFRLG9CQUFVQyxPQUFWLENBQWtCLG9CQUFVQyxNQUE1QixDQURtQjtBQUUzQkMsaUJBQWEsb0JBQVVqQjtBQUZJLEdBQWhCO0FBN0UwQyxDQUF2QyxDQUFsQjs7QUFtRkEsSUFBTWtCLG1CQUFtQixTQUFuQkEsZ0JBQW1CO0FBQUEsTUFBRUMsVUFBRixRQUFFQSxVQUFGO0FBQUEsTUFBY0MsVUFBZCxRQUFjQSxVQUFkO0FBQUEsU0FBOEJELGFBQ3JELGlCQUFPRSxNQUFQLENBQWNDLFFBRHVDLEdBRXBERixhQUFhLGlCQUFPQyxNQUFQLENBQWNFLE9BQTNCLEdBQXFDLGlCQUFPRixNQUFQLENBQWNHLElBRjdCO0FBQUEsQ0FBekI7O0FBSUEsSUFBTUMsZUFBZSxzQkFBYyxFQUFkLEVBQWtCLG9CQUFVQSxZQUE1QiwyQkFBeUQ7QUFDNUUxQixvQkFBa0IsSUFEMEQ7QUFFNUVTLFdBQVMsSUFGbUU7QUFHNUVELFdBQVMsSUFIbUU7O0FBSzVFTixjQUFZLElBTGdFO0FBTTVFRSxXQUFTLElBTm1FO0FBTzVFQyxjQUFZLElBUGdFO0FBUTVFQyxtQkFBaUIsSUFSMkQ7QUFTNUVDLG1CQUFpQixJQVQyRDs7QUFXNUVHLGVBQWEsQ0FYK0Q7QUFZNUVDLGFBQVdRLGdCQVppRTs7QUFjNUVQO0FBZDRFLENBQXpELENBQXJCOztBQWlCQSxJQUFNZSxvQkFBb0I7QUFDeEJDLFlBQVUsb0JBQVVDLFVBQVYsc0RBRGM7QUFFeEJULGNBQVksb0JBQVVqQjtBQUZFLENBQTFCOztJQUtxQjJCLGM7Ozs7Z0NBRUE7QUFDakIsYUFBTyxvQkFBVUMsU0FBVixFQUFQO0FBQ0Q7OztBQUVELDBCQUFZQyxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsc0pBQ1hBLEtBRFc7O0FBRWpCO0FBQ0E7QUFDQSxpQ0FBY0EsS0FBZDs7QUFFQSxVQUFLQyxLQUFMLEdBQWE7QUFDWDtBQUNBYixrQkFBWSxLQUZEO0FBR1g7QUFDQUMsa0JBQVk7QUFKRCxLQUFiOztBQU9BO0FBQ0E7QUFDQSxVQUFLYSxZQUFMLEdBQW9CRixNQUFNbEIsV0FBTixJQUFxQiwyQkFBekM7QUFmaUI7QUFnQmxCOzs7O3NDQUVpQjtBQUNoQixhQUFPO0FBQ0xjLGtCQUFVLHlEQUFnQyxLQUFLSSxLQUFyQyxDQURMO0FBRUxaLG9CQUFZLEtBQUthLEtBQUwsQ0FBV2I7QUFGbEIsT0FBUDtBQUlEOzs7d0NBRW1CO0FBQ2xCLFVBQU1lLGVBQWUsMkJBQWlCLEtBQUtDLFlBQXRCLENBQXJCOztBQUVBO0FBQ0FELG1CQUFhRSxFQUFiLENBQWdCLFdBQWhCLEVBQTZCLEtBQUtDLFlBQWxDO0FBQ0FILG1CQUFhRSxFQUFiLENBQWdCLE9BQWhCLEVBQXlCLEtBQUtFLGFBQTlCO0FBQ0EsV0FBS0MsYUFBTCxHQUFxQkwsWUFBckI7O0FBRUEsV0FBS0QsWUFBTCxDQUFrQk8sVUFBbEIsQ0FBNkIsc0JBQWMsRUFBZCxFQUFrQixLQUFLVCxLQUF2QixFQUE4QjtBQUN6RFUsdUJBQWUsS0FBS0MseUJBRHFDO0FBRXpEUjtBQUZ5RCxPQUE5QixDQUE3QjtBQUlEOzs7d0NBRW1CUyxTLEVBQVc7QUFDN0IsV0FBS1YsWUFBTCxDQUFrQk8sVUFBbEIsQ0FBNkJHLFNBQTdCO0FBQ0Q7OzsyQ0FFc0I7QUFDckIsVUFBSSxLQUFLSixhQUFULEVBQXdCO0FBQ3RCO0FBQ0EsYUFBS0EsYUFBTCxDQUFtQkssT0FBbkI7QUFDRDtBQUNGOzs7NkJBRVE7QUFDUCxhQUFPLEtBQUtDLElBQUwsQ0FBVUMsTUFBVixFQUFQO0FBQ0Q7OzswQ0FFcUJDLFEsRUFBVUMsTyxFQUFTO0FBQ3ZDLGFBQU8sS0FBS0gsSUFBTCxDQUFVSSxxQkFBVixDQUFnQ0YsUUFBaEMsRUFBMENDLE9BQTFDLENBQVA7QUFDRDs7QUFFRDs7OzsrQ0FDMkJqQixLLEVBQU87QUFDaEMsVUFBTW1CLGFBQWEsU0FBYkEsVUFBYTtBQUFBLGVBQUtDLEVBQUUsQ0FBRixFQUFLQyxXQUFMLEtBQXFCRCxFQUFFRSxLQUFGLENBQVEsQ0FBUixDQUExQjtBQUFBLE9BQW5COztBQURnQyxVQUd6QjFDLHFCQUh5QixHQUdBb0IsS0FIQSxDQUd6QnBCLHFCQUh5Qjs7QUFJaEMsV0FBSyxJQUFNMkMsUUFBWCxJQUF1QnZCLEtBQXZCLEVBQThCO0FBQzVCLFlBQU13QixzQkFBc0JMLFdBQVdJLFFBQVgsQ0FBNUI7QUFDQSxZQUFNRSxzQkFBb0JELG1CQUExQjtBQUNBLFlBQU1FLHNCQUFvQkYsbUJBQTFCOztBQUVBLFlBQUlDLGVBQWU3QyxxQkFBZixJQUNGb0IsTUFBTXVCLFFBQU4sSUFBa0IzQyxzQkFBc0I2QyxXQUF0QixDQURwQixFQUN3RDtBQUN0RCxpQkFBTyxLQUFQO0FBQ0Q7QUFDRCxZQUFJQyxlQUFlOUMscUJBQWYsSUFDRm9CLE1BQU11QixRQUFOLElBQWtCM0Msc0JBQXNCOEMsV0FBdEIsQ0FEcEIsRUFDd0Q7QUFDdEQsaUJBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRCxhQUFPLElBQVA7QUFDRDs7O3dDQUUyQjtBQUFBLFVBQWRDLEdBQWMsU0FBZEEsR0FBYztBQUFBLFVBQVRDLE1BQVMsU0FBVEEsTUFBUzs7QUFDMUIsVUFBSUMsaUJBQUo7QUFDQSxVQUFJRCxNQUFKLEVBQVk7QUFDVjtBQUNBLFlBQU1FLE9BQU9GLE1BQWI7QUFDQSxZQUFNRyxPQUFPLENBQUMsQ0FBQ0osSUFBSSxDQUFKLElBQVNHLElBQVYsRUFBZ0JILElBQUksQ0FBSixJQUFTRyxJQUF6QixDQUFELEVBQWlDLENBQUNILElBQUksQ0FBSixJQUFTRyxJQUFWLEVBQWdCSCxJQUFJLENBQUosSUFBU0csSUFBekIsQ0FBakMsQ0FBYjtBQUNBRCxtQkFBVyxLQUFLZixJQUFMLENBQVVJLHFCQUFWLENBQWdDYSxJQUFoQyxDQUFYO0FBQ0QsT0FMRCxNQUtPO0FBQ0xGLG1CQUFXLEtBQUtmLElBQUwsQ0FBVUkscUJBQVYsQ0FBZ0NTLEdBQWhDLENBQVg7QUFDRDtBQUNELGFBQU9FLFFBQVA7QUFDRDs7O3FEQUUrQztBQUFBLG1DQUFyQnpDLFVBQXFCO0FBQUEsVUFBckJBLFVBQXFCLG9DQUFSLEtBQVE7O0FBQzlDLFVBQUlBLGVBQWUsS0FBS2EsS0FBTCxDQUFXYixVQUE5QixFQUEwQztBQUN4QyxhQUFLNEMsUUFBTCxDQUFjLEVBQUM1QyxzQkFBRCxFQUFkO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs0QkFDUTZDLEssRUFBTztBQUFBLGdDQUNrQkEsS0FEbEIsQ0FDTkMsWUFETTtBQUFBLFVBQ1NDLENBRFQsdUJBQ1NBLENBRFQ7QUFBQSxVQUNZQyxDQURaLHVCQUNZQSxDQURaOztBQUViLGFBQU8sQ0FBQ0QsQ0FBRCxFQUFJQyxDQUFKLENBQVA7QUFDRDs7O2lDQUVZSCxLLEVBQU87QUFDbEIsVUFBSSxDQUFDLEtBQUtoQyxLQUFMLENBQVdiLFVBQWhCLEVBQTRCO0FBQzFCLFlBQU11QyxNQUFNLEtBQUtVLE9BQUwsQ0FBYUosS0FBYixDQUFaO0FBQ0EsWUFBTUosV0FBVyxLQUFLUyxZQUFMLENBQWtCLEVBQUNYLFFBQUQsRUFBTUMsUUFBUSxLQUFLNUIsS0FBTCxDQUFXdEIsV0FBekIsRUFBbEIsQ0FBakI7O0FBRUEsWUFBTVcsYUFBYXdDLFlBQVlBLFNBQVNVLE1BQVQsR0FBa0IsQ0FBakQ7QUFDQSxZQUFJbEQsZUFBZSxLQUFLWSxLQUFMLENBQVdaLFVBQTlCLEVBQTBDO0FBQ3hDLGVBQUsyQyxRQUFMLENBQWMsRUFBQzNDLHNCQUFELEVBQWQ7QUFDRDs7QUFFRCxZQUFJLEtBQUtXLEtBQUwsQ0FBV3hCLE9BQWYsRUFBd0I7QUFDdEIsY0FBTW9CLFdBQVcseURBQWdDLEtBQUtJLEtBQXJDLENBQWpCO0FBQ0FpQyxnQkFBTU8sTUFBTixHQUFlNUMsU0FBUzZDLFNBQVQsQ0FBbUJkLEdBQW5CLENBQWY7QUFDQU0sZ0JBQU1KLFFBQU4sR0FBaUJBLFFBQWpCOztBQUVBLGVBQUs3QixLQUFMLENBQVd4QixPQUFYLENBQW1CeUQsS0FBbkI7QUFDRDtBQUNGO0FBQ0Y7OztrQ0FFYUEsSyxFQUFPO0FBQ25CLFVBQUksS0FBS2pDLEtBQUwsQ0FBV3ZCLE9BQWYsRUFBd0I7QUFDdEIsWUFBTWtELE1BQU0sS0FBS1UsT0FBTCxDQUFhSixLQUFiLENBQVo7QUFDQSxZQUFNckMsV0FBVyx5REFBZ0MsS0FBS0ksS0FBckMsQ0FBakI7QUFDQWlDLGNBQU1PLE1BQU4sR0FBZTVDLFNBQVM2QyxTQUFULENBQW1CZCxHQUFuQixDQUFmO0FBQ0FNLGNBQU1KLFFBQU4sR0FBaUIsS0FBS1MsWUFBTCxDQUFrQixFQUFDWCxRQUFELEVBQU1DLFFBQVEsS0FBSzVCLEtBQUwsQ0FBV3RCLFdBQXpCLEVBQWxCLENBQWpCOztBQUVBLGFBQUtzQixLQUFMLENBQVd2QixPQUFYLENBQW1Cd0QsS0FBbkI7QUFDRDtBQUNGOzs7dUNBRWtCUyxHLEVBQUs7QUFDdEIsV0FBS3RDLFlBQUwsR0FBb0JzQyxHQUFwQjtBQUNEOzs7cUNBRWdCQSxHLEVBQUs7QUFDcEIsV0FBSzVCLElBQUwsR0FBWTRCLEdBQVo7QUFDRDs7OzZCQUVRO0FBQUEsbUJBQzRCLEtBQUsxQyxLQURqQztBQUFBLFVBQ0EyQyxLQURBLFVBQ0FBLEtBREE7QUFBQSxVQUNPQyxNQURQLFVBQ09BLE1BRFA7QUFBQSxVQUNlakUsU0FEZixVQUNlQSxTQURmOzs7QUFHUCxVQUFNa0UsbUJBQW1CO0FBQ3ZCRixvQkFEdUI7QUFFdkJDLHNCQUZ1QjtBQUd2QkUsa0JBQVUsVUFIYTtBQUl2QkMsZ0JBQVFwRSxVQUFVLEtBQUtzQixLQUFmO0FBSmUsT0FBekI7O0FBT0EsYUFDRSwwQkFBYyxLQUFkLEVBQXFCO0FBQ25CK0MsYUFBSyxjQURjO0FBRW5CTixhQUFLLEtBQUtPLGtCQUZTO0FBR25CQyxlQUFPTDtBQUhZLE9BQXJCLEVBS0UsK0NBQXlCLHNCQUFjLEVBQWQsRUFBa0IsS0FBSzdDLEtBQXZCLEVBQThCO0FBQ3JEbUQsaUJBQVMsS0FBS0MsMEJBQUwsQ0FBZ0MsS0FBS3BELEtBQXJDLENBRDRDO0FBRXJEMEMsYUFBSyxLQUFLVztBQUYyQyxPQUE5QixDQUF6QixDQUxGLENBREY7QUFZRDs7Ozs7a0JBNUtrQnZELGM7OztBQStLckJBLGVBQWV3RCxXQUFmLEdBQTZCLGdCQUE3QjtBQUNBeEQsZUFBZXBDLFNBQWYsR0FBMkJBLFNBQTNCO0FBQ0FvQyxlQUFlSixZQUFmLEdBQThCQSxZQUE5QjtBQUNBSSxlQUFlSCxpQkFBZixHQUFtQ0EsaUJBQW5DIiwiZmlsZSI6ImludGVyYWN0aXZlLW1hcC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7UHVyZUNvbXBvbmVudCwgY3JlYXRlRWxlbWVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBhdXRvYmluZCBmcm9tICcuLi91dGlscy9hdXRvYmluZCc7XG5cbmltcG9ydCBTdGF0aWNNYXAgZnJvbSAnLi9zdGF0aWMtbWFwJztcbmltcG9ydCB7TUFQQk9YX0xJTUlUU30gZnJvbSAnLi4vdXRpbHMvbWFwLXN0YXRlJztcbmltcG9ydCB7UGVyc3BlY3RpdmVNZXJjYXRvclZpZXdwb3J0fSBmcm9tICd2aWV3cG9ydC1tZXJjYXRvci1wcm9qZWN0JztcblxuaW1wb3J0IEV2ZW50TWFuYWdlciBmcm9tICcuLi91dGlscy9ldmVudC1tYW5hZ2VyL2V2ZW50LW1hbmFnZXInO1xuaW1wb3J0IE1hcENvbnRyb2xzIGZyb20gJy4uL3V0aWxzL21hcC1jb250cm9scyc7XG5pbXBvcnQgY29uZmlnIGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgZGVwcmVjYXRlV2FybiBmcm9tICcuLi91dGlscy9kZXByZWNhdGUtd2Fybic7XG5cbmNvbnN0IHByb3BUeXBlcyA9IE9iamVjdC5hc3NpZ24oe30sIFN0YXRpY01hcC5wcm9wVHlwZXMsIHtcbiAgLy8gQWRkaXRpb25hbCBwcm9wcyBvbiB0b3Agb2YgU3RhdGljTWFwXG5cbiAgLyoqIFZpZXdwb3J0IGNvbnN0cmFpbnRzICovXG4gIC8vIE1heCB6b29tIGxldmVsXG4gIG1heFpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIE1pbiB6b29tIGxldmVsXG4gIG1pblpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gIC8vIE1heCBwaXRjaCBpbiBkZWdyZWVzXG4gIG1heFBpdGNoOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvLyBNaW4gcGl0Y2ggaW4gZGVncmVlc1xuICBtaW5QaXRjaDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogYG9uVmlld3BvcnRDaGFuZ2VgIGNhbGxiYWNrIGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIHRoZVxuICAgKiBtYXAuIFRoZSBvYmplY3QgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBjb250YWlucyB2aWV3cG9ydCBwcm9wZXJ0aWVzXG4gICAqIHN1Y2ggYXMgYGxvbmdpdHVkZWAsIGBsYXRpdHVkZWAsIGB6b29tYCBldGMuXG4gICAqL1xuICBvblZpZXdwb3J0Q2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKiogRW5hYmxlcyBjb250cm9sIGV2ZW50IGhhbmRsaW5nICovXG4gIC8vIFNjcm9sbCB0byB6b29tXG4gIHNjcm9sbFpvb206IFByb3BUeXBlcy5ib29sLFxuICAvLyBEcmFnIHRvIHBhblxuICBkcmFnUGFuOiBQcm9wVHlwZXMuYm9vbCxcbiAgLy8gRHJhZyB0byByb3RhdGVcbiAgZHJhZ1JvdGF0ZTogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIERvdWJsZSBjbGljayB0byB6b29tXG4gIGRvdWJsZUNsaWNrWm9vbTogUHJvcFR5cGVzLmJvb2wsXG4gIC8vIFBpbmNoIHRvIHpvb20gLyByb3RhdGVcbiAgdG91Y2hab29tUm90YXRlOiBQcm9wVHlwZXMuYm9vbCxcblxuIC8qKlxuICAgICogQ2FsbGVkIHdoZW4gdGhlIG1hcCBpcyBob3ZlcmVkIG92ZXIuXG4gICAgKiBAY2FsbGJhY2tcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBtb3VzZSBldmVudC5cbiAgICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gZXZlbnQubG5nTGF0IC0gVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludGVyXG4gICAgKiBAcGFyYW0ge0FycmF5fSBldmVudC5mZWF0dXJlcyAtIFRoZSBmZWF0dXJlcyB1bmRlciB0aGUgcG9pbnRlciwgdXNpbmcgTWFwYm94J3NcbiAgICAqIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyBBUEk6XG4gICAgKiBodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9hcGkvI01hcCNxdWVyeVJlbmRlcmVkRmVhdHVyZXNcbiAgICAqIFRvIG1ha2UgYSBsYXllciBpbnRlcmFjdGl2ZSwgc2V0IHRoZSBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IGluIHRoZVxuICAgICogbGF5ZXIgc3R5bGUgdG8gYHRydWVgLiBTZWUgTWFwYm94J3Mgc3R5bGUgc3BlY1xuICAgICogaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8jbGF5ZXItaW50ZXJhY3RpdmVcbiAgICAqL1xuICBvbkhvdmVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAgKiBDYWxsZWQgd2hlbiB0aGUgbWFwIGlzIGNsaWNrZWQuXG4gICAgKiBAY2FsbGJhY2tcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBtb3VzZSBldmVudC5cbiAgICAqIEBwYXJhbSB7W051bWJlciwgTnVtYmVyXX0gZXZlbnQubG5nTGF0IC0gVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludGVyXG4gICAgKiBAcGFyYW0ge0FycmF5fSBldmVudC5mZWF0dXJlcyAtIFRoZSBmZWF0dXJlcyB1bmRlciB0aGUgcG9pbnRlciwgdXNpbmcgTWFwYm94J3NcbiAgICAqIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyBBUEk6XG4gICAgKiBodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9hcGkvI01hcCNxdWVyeVJlbmRlcmVkRmVhdHVyZXNcbiAgICAqIFRvIG1ha2UgYSBsYXllciBpbnRlcmFjdGl2ZSwgc2V0IHRoZSBgaW50ZXJhY3RpdmVgIHByb3BlcnR5IGluIHRoZVxuICAgICogbGF5ZXIgc3R5bGUgdG8gYHRydWVgLiBTZWUgTWFwYm94J3Mgc3R5bGUgc3BlY1xuICAgICogaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtc3R5bGUtc3BlYy8jbGF5ZXItaW50ZXJhY3RpdmVcbiAgICAqL1xuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKiogUmFkaXVzIHRvIGRldGVjdCBmZWF0dXJlcyBhcm91bmQgYSBjbGlja2VkIHBvaW50LiBEZWZhdWx0cyB0byAwLiAqL1xuICBjbGlja1JhZGl1czogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKiogQWNjZXNzb3IgdGhhdCByZXR1cm5zIGEgY3Vyc29yIHN0eWxlIHRvIHNob3cgaW50ZXJhY3RpdmUgc3RhdGUgKi9cbiAgZ2V0Q3Vyc29yOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKiogQWR2YW5jZWQgZmVhdHVyZXMgKi9cbiAgLy8gQ29udHJhaW50cyBmb3IgZGlzcGxheWluZyB0aGUgbWFwLiBJZiBub3QgbWV0LCB0aGVuIHRoZSBtYXAgaXMgaGlkZGVuLlxuICAvLyBFeHBlcmltZW50YWwhIE1heSBiZSBjaGFuZ2VkIGluIG1pbm9yIHZlcnNpb24gdXBkYXRlcy5cbiAgdmlzaWJpbGl0eUNvbnN0cmFpbnRzOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIG1pblpvb206IFByb3BUeXBlcy5udW1iZXIsXG4gICAgbWF4Wm9vbTogUHJvcFR5cGVzLm51bWJlcixcbiAgICBtaW5QaXRjaDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBtYXhQaXRjaDogUHJvcFR5cGVzLm51bWJlclxuICB9KSxcbiAgLy8gQSBtYXAgY29udHJvbCBpbnN0YW5jZSB0byByZXBsYWNlIHRoZSBkZWZhdWx0IG1hcCBjb250cm9sc1xuICAvLyBUaGUgb2JqZWN0IG11c3QgZXhwb3NlIG9uZSBwcm9wZXJ0eTogYGV2ZW50c2AgYXMgYW4gYXJyYXkgb2Ygc3Vic2NyaWJlZFxuICAvLyBldmVudCBuYW1lczsgYW5kIHR3byBtZXRob2RzOiBgc2V0U3RhdGUoc3RhdGUpYCBhbmQgYGhhbmRsZShldmVudClgXG4gIG1hcENvbnRyb2xzOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGV2ZW50czogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG4gICAgaGFuZGxlRXZlbnQ6IFByb3BUeXBlcy5mdW5jXG4gIH0pXG59KTtcblxuY29uc3QgZ2V0RGVmYXVsdEN1cnNvciA9ICh7aXNEcmFnZ2luZywgaXNIb3ZlcmluZ30pID0+IGlzRHJhZ2dpbmcgP1xuICBjb25maWcuQ1VSU09SLkdSQUJCSU5HIDpcbiAgKGlzSG92ZXJpbmcgPyBjb25maWcuQ1VSU09SLlBPSU5URVIgOiBjb25maWcuQ1VSU09SLkdSQUIpO1xuXG5jb25zdCBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBTdGF0aWNNYXAuZGVmYXVsdFByb3BzLCBNQVBCT1hfTElNSVRTLCB7XG4gIG9uVmlld3BvcnRDaGFuZ2U6IG51bGwsXG4gIG9uQ2xpY2s6IG51bGwsXG4gIG9uSG92ZXI6IG51bGwsXG5cbiAgc2Nyb2xsWm9vbTogdHJ1ZSxcbiAgZHJhZ1BhbjogdHJ1ZSxcbiAgZHJhZ1JvdGF0ZTogdHJ1ZSxcbiAgZG91YmxlQ2xpY2tab29tOiB0cnVlLFxuICB0b3VjaFpvb21Sb3RhdGU6IHRydWUsXG5cbiAgY2xpY2tSYWRpdXM6IDAsXG4gIGdldEN1cnNvcjogZ2V0RGVmYXVsdEN1cnNvcixcblxuICB2aXNpYmlsaXR5Q29uc3RyYWludHM6IE1BUEJPWF9MSU1JVFNcbn0pO1xuXG5jb25zdCBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgdmlld3BvcnQ6IFByb3BUeXBlcy5pbnN0YW5jZU9mKFBlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydCksXG4gIGlzRHJhZ2dpbmc6IFByb3BUeXBlcy5ib29sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnRlcmFjdGl2ZU1hcCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuXG4gIHN0YXRpYyBzdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIFN0YXRpY01hcC5zdXBwb3J0ZWQoKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIGF1dG9iaW5kKHRoaXMpO1xuICAgIC8vIENoZWNrIGZvciBkZXByZWNhdGVkIHByb3BzXG4gICAgZGVwcmVjYXRlV2Fybihwcm9wcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgLy8gV2hldGhlciB0aGUgY3Vyc29yIGlzIGRvd25cbiAgICAgIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgLy8gV2hldGhlciB0aGUgY3Vyc29yIGlzIG92ZXIgYSBjbGlja2FibGUgZmVhdHVyZVxuICAgICAgaXNIb3ZlcmluZzogZmFsc2VcbiAgICB9O1xuXG4gICAgLy8gSWYgcHJvcHMubWFwQ29udHJvbHMgaXMgbm90IHByb3ZpZGVkLCBmYWxsYmFjayB0byBkZWZhdWx0IE1hcENvbnRyb2xzIGluc3RhbmNlXG4gICAgLy8gQ2Fubm90IHVzZSBkZWZhdWx0UHJvcHMgaGVyZSBiZWNhdXNlIGl0IG5lZWRzIHRvIGJlIHBlciBtYXAgaW5zdGFuY2VcbiAgICB0aGlzLl9tYXBDb250cm9scyA9IHByb3BzLm1hcENvbnRyb2xzIHx8IG5ldyBNYXBDb250cm9scygpO1xuICB9XG5cbiAgZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2aWV3cG9ydDogbmV3IFBlcnNwZWN0aXZlTWVyY2F0b3JWaWV3cG9ydCh0aGlzLnByb3BzKSxcbiAgICAgIGlzRHJhZ2dpbmc6IHRoaXMuc3RhdGUuaXNEcmFnZ2luZ1xuICAgIH07XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCBldmVudE1hbmFnZXIgPSBuZXcgRXZlbnRNYW5hZ2VyKHRoaXMuX2V2ZW50Q2FudmFzKTtcblxuICAgIC8vIFJlZ2lzdGVyIGFkZGl0aW9uYWwgZXZlbnQgaGFuZGxlcnMgZm9yIGNsaWNrIGFuZCBob3ZlclxuICAgIGV2ZW50TWFuYWdlci5vbignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUpO1xuICAgIGV2ZW50TWFuYWdlci5vbignY2xpY2snLCB0aGlzLl9vbk1vdXNlQ2xpY2spO1xuICAgIHRoaXMuX2V2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcblxuICAgIHRoaXMuX21hcENvbnRyb2xzLnNldE9wdGlvbnMoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcywge1xuICAgICAgb25TdGF0ZUNoYW5nZTogdGhpcy5fb25JbnRlcmFjdGl2ZVN0YXRlQ2hhbmdlLFxuICAgICAgZXZlbnRNYW5hZ2VyXG4gICAgfSkpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMpIHtcbiAgICB0aGlzLl9tYXBDb250cm9scy5zZXRPcHRpb25zKG5leHRQcm9wcyk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5fZXZlbnRNYW5hZ2VyKSB7XG4gICAgICAvLyBNdXN0IGRlc3Ryb3kgYmVjYXVzZSBoYW1tZXIgYWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gd2luZG93XG4gICAgICB0aGlzLl9ldmVudE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldE1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmdldE1hcCgpO1xuICB9XG5cbiAgcXVlcnlSZW5kZXJlZEZlYXR1cmVzKGdlb21ldHJ5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoZ2VvbWV0cnksIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gQ2hlY2tzIGEgdmlzaWJpbGl0eUNvbnN0cmFpbnRzIG9iamVjdCB0byBzZWUgaWYgdGhlIG1hcCBzaG91bGQgYmUgZGlzcGxheWVkXG4gIGNoZWNrVmlzaWJpbGl0eUNvbnN0cmFpbnRzKHByb3BzKSB7XG4gICAgY29uc3QgY2FwaXRhbGl6ZSA9IHMgPT4gc1swXS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKTtcblxuICAgIGNvbnN0IHt2aXNpYmlsaXR5Q29uc3RyYWludHN9ID0gcHJvcHM7XG4gICAgZm9yIChjb25zdCBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgY29uc3QgY2FwaXRhbGl6ZWRQcm9wTmFtZSA9IGNhcGl0YWxpemUocHJvcE5hbWUpO1xuICAgICAgY29uc3QgbWluUHJvcE5hbWUgPSBgbWluJHtjYXBpdGFsaXplZFByb3BOYW1lfWA7XG4gICAgICBjb25zdCBtYXhQcm9wTmFtZSA9IGBtYXgke2NhcGl0YWxpemVkUHJvcE5hbWV9YDtcblxuICAgICAgaWYgKG1pblByb3BOYW1lIGluIHZpc2liaWxpdHlDb25zdHJhaW50cyAmJlxuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPCB2aXNpYmlsaXR5Q29uc3RyYWludHNbbWluUHJvcE5hbWVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhQcm9wTmFtZSBpbiB2aXNpYmlsaXR5Q29uc3RyYWludHMgJiZcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID4gdmlzaWJpbGl0eUNvbnN0cmFpbnRzW21heFByb3BOYW1lXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX2dldEZlYXR1cmVzKHtwb3MsIHJhZGl1c30pIHtcbiAgICBsZXQgZmVhdHVyZXM7XG4gICAgaWYgKHJhZGl1cykge1xuICAgICAgLy8gUmFkaXVzIGVuYWJsZXMgcG9pbnQgZmVhdHVyZXMsIGxpa2UgbWFya2VyIHN5bWJvbHMsIHRvIGJlIGNsaWNrZWQuXG4gICAgICBjb25zdCBzaXplID0gcmFkaXVzO1xuICAgICAgY29uc3QgYmJveCA9IFtbcG9zWzBdIC0gc2l6ZSwgcG9zWzFdICsgc2l6ZV0sIFtwb3NbMF0gKyBzaXplLCBwb3NbMV0gLSBzaXplXV07XG4gICAgICBmZWF0dXJlcyA9IHRoaXMuX21hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoYmJveCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZlYXR1cmVzID0gdGhpcy5fbWFwLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhwb3MpO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH1cblxuICBfb25JbnRlcmFjdGl2ZVN0YXRlQ2hhbmdlKHtpc0RyYWdnaW5nID0gZmFsc2V9KSB7XG4gICAgaWYgKGlzRHJhZ2dpbmcgIT09IHRoaXMuc3RhdGUuaXNEcmFnZ2luZykge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7aXNEcmFnZ2luZ30pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhPVkVSIEFORCBDTElDS1xuICBfZ2V0UG9zKGV2ZW50KSB7XG4gICAgY29uc3Qge29mZnNldENlbnRlcjoge3gsIHl9fSA9IGV2ZW50O1xuICAgIHJldHVybiBbeCwgeV07XG4gIH1cblxuICBfb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNEcmFnZ2luZykge1xuICAgICAgY29uc3QgcG9zID0gdGhpcy5fZ2V0UG9zKGV2ZW50KTtcbiAgICAgIGNvbnN0IGZlYXR1cmVzID0gdGhpcy5fZ2V0RmVhdHVyZXMoe3BvcywgcmFkaXVzOiB0aGlzLnByb3BzLmNsaWNrUmFkaXVzfSk7XG5cbiAgICAgIGNvbnN0IGlzSG92ZXJpbmcgPSBmZWF0dXJlcyAmJiBmZWF0dXJlcy5sZW5ndGggPiAwO1xuICAgICAgaWYgKGlzSG92ZXJpbmcgIT09IHRoaXMuc3RhdGUuaXNIb3ZlcmluZykge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtpc0hvdmVyaW5nfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLm9uSG92ZXIpIHtcbiAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBuZXcgUGVyc3BlY3RpdmVNZXJjYXRvclZpZXdwb3J0KHRoaXMucHJvcHMpO1xuICAgICAgICBldmVudC5sbmdMYXQgPSB2aWV3cG9ydC51bnByb2plY3QocG9zKTtcbiAgICAgICAgZXZlbnQuZmVhdHVyZXMgPSBmZWF0dXJlcztcblxuICAgICAgICB0aGlzLnByb3BzLm9uSG92ZXIoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9vbk1vdXNlQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkNsaWNrKSB7XG4gICAgICBjb25zdCBwb3MgPSB0aGlzLl9nZXRQb3MoZXZlbnQpO1xuICAgICAgY29uc3Qgdmlld3BvcnQgPSBuZXcgUGVyc3BlY3RpdmVNZXJjYXRvclZpZXdwb3J0KHRoaXMucHJvcHMpO1xuICAgICAgZXZlbnQubG5nTGF0ID0gdmlld3BvcnQudW5wcm9qZWN0KHBvcyk7XG4gICAgICBldmVudC5mZWF0dXJlcyA9IHRoaXMuX2dldEZlYXR1cmVzKHtwb3MsIHJhZGl1czogdGhpcy5wcm9wcy5jbGlja1JhZGl1c30pO1xuXG4gICAgICB0aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIF9ldmVudENhbnZhc0xvYWRlZChyZWYpIHtcbiAgICB0aGlzLl9ldmVudENhbnZhcyA9IHJlZjtcbiAgfVxuXG4gIF9zdGF0aWNNYXBMb2FkZWQocmVmKSB7XG4gICAgdGhpcy5fbWFwID0gcmVmO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBnZXRDdXJzb3J9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGV2ZW50Q2FudmFzU3R5bGUgPSB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgY3Vyc29yOiBnZXRDdXJzb3IodGhpcy5zdGF0ZSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAga2V5OiAnbWFwLWNvbnRyb2xzJyxcbiAgICAgICAgcmVmOiB0aGlzLl9ldmVudENhbnZhc0xvYWRlZCxcbiAgICAgICAgc3R5bGU6IGV2ZW50Q2FudmFzU3R5bGVcbiAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoU3RhdGljTWFwLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICAgICAgdmlzaWJsZTogdGhpcy5jaGVja1Zpc2liaWxpdHlDb25zdHJhaW50cyh0aGlzLnByb3BzKSxcbiAgICAgICAgICByZWY6IHRoaXMuX3N0YXRpY01hcExvYWRlZFxuICAgICAgICB9KSlcbiAgICAgIClcbiAgICApO1xuICB9XG59XG5cbkludGVyYWN0aXZlTWFwLmRpc3BsYXlOYW1lID0gJ0ludGVyYWN0aXZlTWFwJztcbkludGVyYWN0aXZlTWFwLnByb3BUeXBlcyA9IHByb3BUeXBlcztcbkludGVyYWN0aXZlTWFwLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbkludGVyYWN0aXZlTWFwLmNoaWxkQ29udGV4dFR5cGVzID0gY2hpbGRDb250ZXh0VHlwZXM7XG4iXX0=